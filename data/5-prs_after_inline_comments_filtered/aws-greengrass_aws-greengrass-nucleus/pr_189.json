{"pr_number": 189, "pr_title": "consolidate break/continue in lifecycle whileLoop", "pr_createdAt": "2020-04-16T23:59:47Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMTA3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409921071", "bodyText": "This can just be a lambda, can't it?", "author": "MikeDombo", "createdAt": "2020-04-17T00:16:59Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -509,6 +527,33 @@ private void serviceTerminatedMoveToDesiredState(@Nonnull State desiredState) {\n         }\n     }\n \n+    private TimerTask timeoutTask;\n+    private Timer timer = new Timer();\n+\n+    private void setTimeoutAction(Runnable timeoutAction, long timeout) {\n+        synchronized (timer) {\n+            if (timeoutTask != null) {\n+                timeoutTask.cancel();\n+            }\n+\n+            timeoutTask = new TimerTask() {\n+                @Override\n+                public void run() {\n+                    timeoutAction.run();\n+                }\n+            };", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMTgzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409921836", "bodyText": "should be final.", "author": "MikeDombo", "createdAt": "2020-04-17T00:19:35Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -509,6 +527,33 @@ private void serviceTerminatedMoveToDesiredState(@Nonnull State desiredState) {\n         }\n     }\n \n+    private TimerTask timeoutTask;\n+    private Timer timer = new Timer();", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMjExMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409922113", "bodyText": "instead of null, can we we use an AtomicReference<Predicate>? Which we get() and set()?", "author": "MikeDombo", "createdAt": "2020-04-17T00:20:42Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -213,57 +203,76 @@ void startStateTransition() throws InterruptedException {\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n+            // A state event can either be a report state transition event or a desired state updated event.\n+            Object stateEvent = stateEventQueue.poll();\n+\n+            // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+            // drain them until a \"State\" event is encountered.\n+            while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                stateEvent = stateEventQueue.poll();\n             }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+\n+            // if there are no events in the queue, block until one is available.\n+            if (stateEvent == null) {\n+                stateEvent = stateEventQueue.take();\n             }\n+\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    // ignore same state reported twice\n+                    if (newState != current) {\n+                        canFinish = true;\n+                        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n+                        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+                        // across different services.\n+                        synchronized (State.class) {\n+                            prevState = current;\n+                            stateTopic.withValue(newState);\n+                            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                        }\n+                    }\n+                }\n+                if (asyncFinishActionCheck == null || asyncFinishActionCheck.test(stateEvent)) {", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NTY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410365674", "bodyText": "Sure", "author": "ShirleyZheng92", "createdAt": "2020-04-17T17:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MDIxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409970215", "bodyText": "I'd really really prefer if we only have 1 place in this thread that we block.", "author": "MikeDombo", "createdAt": "2020-04-17T03:22:50Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -213,57 +203,76 @@ void startStateTransition() throws InterruptedException {\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n+            // A state event can either be a report state transition event or a desired state updated event.\n+            Object stateEvent = stateEventQueue.poll();\n+\n+            // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+            // drain them until a \"State\" event is encountered.\n+            while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                stateEvent = stateEventQueue.poll();\n             }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+\n+            // if there are no events in the queue, block until one is available.\n+            if (stateEvent == null) {\n+                stateEvent = stateEventQueue.take();\n             }\n+\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    // ignore same state reported twice\n+                    if (newState != current) {\n+                        canFinish = true;\n+                        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n+                        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+                        // across different services.\n+                        synchronized (State.class) {\n+                            prevState = current;\n+                            stateTopic.withValue(newState);\n+                            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                        }\n+                    }\n+                }\n+                if (asyncFinishActionCheck == null || asyncFinishActionCheck.test(stateEvent)) {\n+                    canFinish = true;\n+                }\n+\n+                if (canFinish) {\n+                    break;\n+                } else {\n+                    stateEvent = stateEventQueue.take();", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjAxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410352013", "bodyText": "Agree", "author": "fengwang666", "createdAt": "2020-04-17T16:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MDIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMjQwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410412404", "bodyText": "I tried that way and find out it can't handle some use cases.\nEg. when the service is in INSTALLED state and starting, there is a new requestStart() call comes in and trigger a \"desiredStateUpdate\" event. In this case we don't want to cancel the current starting thread.", "author": "ShirleyZheng92", "createdAt": "2020-04-17T18:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MDIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxNDAxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410414018", "bodyText": "Can't we de-dupe? Like we know we're already trying to get to RUNNING, so there's nothing different that we need to do.", "author": "MikeDombo", "createdAt": "2020-04-17T19:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MDIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTQyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409995424", "bodyText": "Probably log at debug level.", "author": "fengwang666", "createdAt": "2020-04-17T05:09:01Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {\n+         logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1Njc5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410356793", "bodyText": "Personally I like having this at info since our state transitions are some of the most important things that happen to services.", "author": "MikeDombo", "createdAt": "2020-04-17T17:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTc0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409995746", "bodyText": "Probably logging at warn level is more appropriate. Error should be reserved for something with negative impact. I'm not sure if that's the case here.", "author": "fengwang666", "createdAt": "2020-04-17T05:10:24Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {\n+         logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"newState\", newState).log(\"Invalid reported state\");", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409995996", "bodyText": "synchronized is not needed here.", "author": "fengwang666", "createdAt": "2020-04-17T05:11:30Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NjMyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409996321", "bodyText": "Move this above together with other instance variables.", "author": "fengwang666", "createdAt": "2020-04-17T05:12:55Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {\n+         logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"newState\", newState).log(\"Invalid reported state\");\n         }\n+        // TODO: Add more validations\n \n-        // TODO: Add validation\n-\n-        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n-        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n-        // across different services.\n-        synchronized (State.class) {\n-            prevState = currentState;\n-            stateTopic.withValue(newState);\n-            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n-        }\n+        internalReportState(newState);\n     }\n \n+    private AtomicBoolean errorReported = new AtomicBoolean(false);", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAwNjAwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410006009", "bodyText": "Not sure if this is better than the previous way. Personally I find it more difficult to read. setTimeoutAction() also takes an extra thread.", "author": "fengwang666", "createdAt": "2020-04-17T05:52:27Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -369,43 +380,50 @@ private void handleStateTransitionInstalledToRunning(AtomicReference<Future> tri\n                     Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n                             : (Integer) timeOutTopic.getOnce();\n \n-\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                if (!State.RUNNING.equals(evergreenService.getState())) {\n-                                    logger.atWarn(\"service-startup-timed-out\")\n-                                            .kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n+                    setTimeoutAction(() -> {\n+                        logger.error(\"Timeout starting service\");\n+                        reportState(State.ERRORED);\n+                    }, timeout * 1000);", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjM0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410356347", "bodyText": "While I do like this syntax better, I'm not sure about the threads. The previous implementation relied on the scheduled thread pool, so while running it obviously uses 1 thread, but when it isn't running, that thread pool is free to do other stuff. I'm not too sure about the Timer's thread usage. I'd certainly want more info on that before accepting this change.", "author": "MikeDombo", "createdAt": "2020-04-17T17:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAwNjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMzY4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410413685", "bodyText": "From Timer document: \"Corresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks, sequentially. \"\nhttps://docs.oracle.com/javase/7/docs/api/java/util/Timer.html\nI don't have a strong preference. Using Timer() makes the code look a little cleaner to me, but I'm ok with executor as well.", "author": "ShirleyZheng92", "createdAt": "2020-04-17T18:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAwNjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTg0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410349849", "bodyText": "What does canFinish mean?", "author": "fengwang666", "createdAt": "2020-04-17T16:55:49Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -213,57 +203,76 @@ void startStateTransition() throws InterruptedException {\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n+            // A state event can either be a report state transition event or a desired state updated event.\n+            Object stateEvent = stateEventQueue.poll();\n+\n+            // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+            // drain them until a \"State\" event is encountered.\n+            while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                stateEvent = stateEventQueue.poll();\n             }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+\n+            // if there are no events in the queue, block until one is available.\n+            if (stateEvent == null) {\n+                stateEvent = stateEventQueue.take();\n             }\n+\n+            boolean canFinish = false;", "originalCommit": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxNzYxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410417618", "bodyText": "When handleCurrentStateX() is async, it need to check the next coming stateEvent to decide whether the current state handle is finished.\nThe check is Predicate asyncFinishActionCheck . One example is in handleStateTransitionInstalledToRunningAsync()", "author": "ShirleyZheng92", "createdAt": "2020-04-17T19:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTg0OQ=="}], "type": "inlineReview"}, {"oid": "eba133a1c621966c07f8c8b2ea11c1db2f9021e3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eba133a1c621966c07f8c8b2ea11c1db2f9021e3", "message": "address comments and add unit test", "committedDate": "2020-04-24T19:28:48Z", "type": "forcePushed"}, {"oid": "dab78db3c13a8923f952e9180ae4e2a8a8ac6799", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dab78db3c13a8923f952e9180ae4e2a8a8ac6799", "message": "address comments and add unit test", "committedDate": "2020-04-27T20:36:49Z", "type": "forcePushed"}, {"oid": "b87348bb1d19f3c2b81bfba8f5bd900e949c8c18", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b87348bb1d19f3c2b81bfba8f5bd900e949c8c18", "message": "[Draft]consolidate break/continue in lifecycle whileLoop", "committedDate": "2020-04-27T20:37:57Z", "type": "forcePushed"}, {"oid": "3d7e68c8fbae52f509179949629ab754b5a300e5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3d7e68c8fbae52f509179949629ab754b5a300e5", "message": "Consolidate break/continue in lifecycle whileLoop", "committedDate": "2020-04-27T22:47:09Z", "type": "forcePushed"}, {"oid": "08d296e59cb004d47039856aeb0fb6bae49ef24c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08d296e59cb004d47039856aeb0fb6bae49ef24c", "message": "Consolidate break/continue in lifecycle whileLoop", "committedDate": "2020-04-27T23:23:34Z", "type": "forcePushed"}, {"oid": "2cf8530442fb914c220e41659ee8e3a79c2d3fd2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2cf8530442fb914c220e41659ee8e3a79c2d3fd2", "message": "Consolidate break/continue in lifecycle whileLoop", "committedDate": "2020-04-28T00:35:43Z", "type": "forcePushed"}, {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4e07375c85dca0fcd65f3432d199de680de390a4", "message": "Add Starting state", "committedDate": "2020-04-28T20:49:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMTkwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416921904", "bodyText": "not needed, the default is console.", "author": "MikeDombo", "createdAt": "2020-04-28T21:05:24Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjA2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416922068", "bodyText": "context needs to be closed in the after and the executors need to be shutdown too, otherwise you're leaking a lot of threads.", "author": "MikeDombo", "createdAt": "2020-04-28T21:05:42Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjc2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416922763", "bodyText": "this isn't needed, you can just let this method throw.", "author": "MikeDombo", "createdAt": "2020-04-28T21:06:48Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDIwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416924203", "bodyText": "no sleeping, just use verify(<x>, timeout(<some time>)", "author": "MikeDombo", "createdAt": "2020-04-28T21:09:24Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDY5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416924691", "bodyText": "switch the order here, it should be expected, actual.", "author": "MikeDombo", "createdAt": "2020-04-28T21:10:17Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDk2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416924963", "bodyText": "please no sleeping", "author": "MikeDombo", "createdAt": "2020-04-28T21:10:50Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_install_timeout_THEN_service_errored() throws InterruptedException {\n+        //GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        AtomicBoolean installInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MTc1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416961753", "bodyText": "This is the sleep in mock install() method. The test is verify that when install() times out, it's properly interrupted.", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NDE4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416964180", "bodyText": "How long is the timeout though? These unit tests should be very very fast to run; at the very most 1 second each.", "author": "MikeDombo", "createdAt": "2020-04-28T22:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMjk2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r417012960", "bodyText": "Timeout is parsed from config, I can set to 1 second.", "author": "ShirleyZheng92", "createdAt": "2020-04-29T01:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTIyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416925227", "bodyText": "these are unit tests, 10 seconds is far too long for a unit test. Each one should take a couple milliseconds.", "author": "MikeDombo", "createdAt": "2020-04-28T21:11:18Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_install_timeout_THEN_service_errored() throws InterruptedException {\n+        //GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        AtomicBoolean installInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                installInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).install();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean errorHandled = errorHandleLatch.await(10, TimeUnit.SECONDS);", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MTgxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416961810", "bodyText": "Sure", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTkzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416925934", "bodyText": "Understand what you're doing, but why?", "author": "MikeDombo", "createdAt": "2020-04-28T21:12:30Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_install_timeout_THEN_service_errored() throws InterruptedException {\n+        //GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        AtomicBoolean installInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                installInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).install();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean errorHandled = errorHandleLatch.await(10, TimeUnit.SECONDS);\n+\n+        // THEN\n+        assertTrue(errorHandled);\n+        // sleep to let error handle finished\n+        Thread.sleep(100);\n+        assertTrue(installInterrupted.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_installed_WHEN_startup_timeout_THEN_service_errored() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        CountDownLatch shutdownHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            if (errorHandleLatch.getCount() == 0) {\n+                shutdownHandleLatch.countDown();\n+            }\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean shutdownCalled = shutdownHandleLatch.await(10, TimeUnit.SECONDS);\n+\n+        // THEN\n+        assertTrue(shutdownCalled);\n+        // sleep to let shutdown finished\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_running_WHEN_requestStop_THEN_shutdown_called() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            lifecycle.reportState(State.RUNNING);\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+\n+        CountDownLatch shutdownCalledLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            shutdownCalledLatch.countDown();\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        assertEquals(State.RUNNING, lifecycle.getState());\n+\n+        // WHEN\n+        lifecycle.requestStop();\n+        shutdownCalledLatch.await(1, TimeUnit.SECONDS);\n+\n+        // THEN\n+        Mockito.verify(evergreenService).startup();\n+        Mockito.verify(evergreenService).shutdown();\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+        assertEquals(State.FINISHED, lifecycle.getState());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_install_WHEN_requestStop_THEN_shutdown_called() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            // not report RUNNING here\n+            lifecycle.requestStop();\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+        CountDownLatch shutdownCalledLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            shutdownCalledLatch.countDown();\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        // THEN\n+        shutdownCalledLatch.await(1, TimeUnit.SECONDS);\n+        Mockito.verify(evergreenService).startup();\n+        Mockito.verify(evergreenService).shutdown();\n+\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+        assertEquals(State.FINISHED, lifecycle.getState());\n+    }\n+\n+    @Test\n+    void GIVEN_a_service_WHEN_reportState_THEN_all_state_changes_are_notified() throws InterruptedException {\n+        // set lifecycle thread with min priority", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjE3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416926171", "bodyText": "Also, this executor will need to be shutdown.", "author": "MikeDombo", "createdAt": "2020-04-28T21:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MjE2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416962162", "bodyText": "I moved the test from EvergreenServiceTest. This is to make sure that all reportState are processed even when lifecycle thread is in lowest priority.", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzA3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416927071", "bodyText": "Why do these need getters? If they need getters, can we keep them private or package-private?", "author": "MikeDombo", "createdAt": "2020-04-28T21:14:32Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -36,17 +36,18 @@\n import static com.aws.iot.evergreen.util.Utils.getUltimateCause;\n \n public class EvergreenService implements InjectionActions {\n-    public static final String STATE_TOPIC_NAME = \"_State\";\n     public static final String SERVICES_NAMESPACE_TOPIC = \"services\";\n     public static final String SERVICE_LIFECYCLE_NAMESPACE_TOPIC = \"lifecycle\";\n     public static final String SERVICE_NAME_KEY = \"serviceName\";\n \n     private static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n \n+    @Getter", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxNzY2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r417017663", "bodyText": "use Getter for easier mocking. currently context is accessed in many places. I can add a TODO comment to make it private.", "author": "ShirleyZheng92", "createdAt": "2020-04-29T01:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDI2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416930262", "bodyText": "This seems very specific, can this be generalized more, ie apply it to all the reported-current state pairs that don't make sense.", "author": "MikeDombo", "createdAt": "2020-04-28T21:20:51Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -89,44 +97,36 @@\n     // We only need to track the ERROR for the state transition starting from NEW, INSTALLED and RUNNING because\n     // these states impact whether the service can function as expected.\n     private static final Set<State> STATES_TO_ERRORED =\n-            new HashSet<>(Arrays.asList(State.NEW, State.INSTALLED, State.RUNNING));\n-    private Pair<State, State> currentStateTransition = null;\n+            new HashSet<>(Arrays.asList(State.NEW, State.STARTING, State.RUNNING));\n \n     /**\n      * Constructor for lifecycle.\n      *\n      * @param evergreenService service that this is the lifecycle for\n-     * @param state            service's state topic\n      * @param logger           service's logger\n      */\n-    public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger) {\n+    public Lifecycle(EvergreenService evergreenService, Logger logger) {\n         this.evergreenService = evergreenService;\n         this.prevState = State.NEW;\n-        this.stateTopic = state;\n+        this.stateTopic = initStateTopic(evergreenService.getConfig());\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n+    void reportState(State newState) {\n+        logger.atInfo(\"service-report-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atWarn(INVALID_STATE_ERROR_EVENT).kv(NEW_STATE_METRIC_NAME, newState).log(\"Invalid reported state\");\n             return;\n         }\n \n-        // TODO: Add validation\n-\n-        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n-        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n-        // across different services.\n-        synchronized (State.class) {\n-            currentStateTransition = null; //NOPMD\n-            if (State.INSTALLED.equals(newState)) {\n-                stateGeneration.incrementAndGet();\n-            }\n-            prevState = currentState;\n-            stateTopic.withValue(newState);\n-            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+        if (newState.equals(State.RUNNING) && !currentOrReportedStateIs(State.STARTING)) {\n+            logger.atWarn(INVALID_STATE_ERROR_EVENT).kv(NEW_STATE_METRIC_NAME, newState)\n+                    .log(\"Service cannot report running when in the process of shutdown\");\n+            return;", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTUwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416931505", "bodyText": "The last reported state also needs to be reset once the reported state has been processed because after that point, it is invalid.", "author": "MikeDombo", "createdAt": "2020-04-28T21:23:08Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -164,30 +160,51 @@ synchronized void reportState(State newState) {\n         }\n     }\n \n-    private Optional<State> getReportState() {\n-        Object top = stateEventQueue.poll();\n-        while (top != null && !(top instanceof State)) {\n-            top = stateEventQueue.poll();\n+    /**\n+     * Returns true if either the current or the very last reported state (if any)\n+     * is equal to the provided state.\n+     *\n+     * @param state state to check against\n+     */\n+    public boolean currentOrReportedStateIs(State state) {\n+        if (state.equals(getState())) {\n+            return true;\n         }\n+        return state.equals(lastReportedState.get());", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1OTUyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416959528", "bodyText": "I feel it's unnecessary to reset this field. In this PR, all state are reported through state queue so the lastReportedState will eventually be the same as current state.", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMzkyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416933924", "bodyText": "is current at this point accurate? Can't the handleX methods change what state it is in?", "author": "MikeDombo", "createdAt": "2020-04-28T21:27:21Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +245,111 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1OTgwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416959801", "bodyText": "the PR update handleX method to not change state directly, but through internalReportState()", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MzAzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416963030", "bodyText": "Yes, exactly. The current here is wrong at this point, because a new state has been reported.", "author": "MikeDombo", "createdAt": "2020-04-28T22:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxOTI1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r417019253", "bodyText": "\"a new state has been reported.\" - the new state is captured in 'newState' variable , 'current' is the processed state. in this way the reported states are processed in strict order.", "author": "ShirleyZheng92", "createdAt": "2020-04-29T01:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNTI3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416935270", "bodyText": "this needs logging now since it is called directly in the lifecycle thread.", "author": "MikeDombo", "createdAt": "2020-04-28T21:29:56Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -135,19 +135,15 @@ private void updateStateAndBroadcast(State newState) {\n      * @param newState reported state from the service which should eventually be set as the service's\n      *                 actual state\n      */\n-    synchronized void reportState(State newState) {\n-        logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();\n-        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n-            logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"newState\", newState).log(\"Invalid reported state\");\n-        }\n-        // TODO: Add more validations\n+    private synchronized void internalReportState(State newState) {", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNjg5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416936898", "bodyText": "Let's check the generation here too.", "author": "MikeDombo", "createdAt": "2020-04-28T21:32:55Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +245,111 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {\n+                        continue;\n+                    }\n+\n+                    canFinish = true;\n+                    logger.atInfo(\"service-set-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+                    // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged\n+                    // are consistent across different services.\n+                    synchronized (State.class) {\n+                        prevState = current;\n+                        stateTopic.withValue(newState);\n+                        evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                    }\n+                }\n+                if (asyncFinishAction.get().test(stateEvent)) {\n+                    canFinish = true;\n+                }\n             }\n+            asyncFinishAction.set((stateEvent) -> true);\n         }\n     }\n \n-    private boolean handleCurrentStateBroken(Optional<State> desiredState) {\n+    private void handleCurrentStateBroken(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n         // Having State.NEW as the desired state indicates the service is requested to reinstall, so here\n         // we'll transition out of BROKEN state to give it a new chance.\n         if (State.NEW.equals(desiredState.get())) {\n-            updateStateAndBroadcast(State.NEW);\n+            internalReportState(State.NEW);\n         } else {\n             logger.atError(\"service-broken\").log(\"service is broken. Deployment is needed\");\n-            return true;\n         }\n-        return false;\n     }\n \n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private boolean handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n+    private void handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n         // if no desired state is set, don't do anything.\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        CountDownLatch installLatch = new CountDownLatch(1);\n         setBackingTask(() -> {\n-            if (!State.NEW.equals(evergreenService.getState())) {\n+            if (!State.NEW.equals(getState())) {", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDA1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416960056", "bodyText": "Sure. should we increment generation in every state then? Currently it's only incremented when INSTALLED", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNjg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MzY5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416963699", "bodyText": "No. That can work if you're asserting that the state has not changed since you last checked, but it does not work in the case that you want the state to have changed; just not restarted the whole service.", "author": "MikeDombo", "createdAt": "2020-04-28T22:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNjg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzYxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416937612", "bodyText": "Let's use serviceErrored since that provides a standardized way of logging errors which result in the service moving to errored.", "author": "MikeDombo", "createdAt": "2020-04-28T21:34:24Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -328,101 +360,90 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (Throwable t) {\n                 reportState(State.ERRORED);\n                 logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            logger.error(\"error in install\", ee);\n+            internalReportState(State.ERRORED);\n+        } catch (TimeoutException te) {\n+            logger.error(\"Timeout in install\");", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDU0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416960544", "bodyText": "Sure", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzODc4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416938781", "bodyText": "use current or reported?", "author": "MikeDombo", "createdAt": "2020-04-28T21:36:36Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -328,101 +360,90 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (Throwable t) {\n                 reportState(State.ERRORED);\n                 logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDUxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416960517", "bodyText": "lastReported because the current state isn't updated yet", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzODc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDE4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416940185", "bodyText": "use current or last?", "author": "MikeDombo", "createdAt": "2020-04-28T21:39:22Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -455,37 +493,36 @@ private void handleCurrentStateStopping() throws InterruptedException {\n             } catch (Throwable t) {\n                 reportState(State.ERRORED);\n                 logger.atError(\"service-shutdown-error\", t).log();\n-            } finally {\n-                stopping.countDown();\n             }\n         });\n \n-        boolean stopSucceed = stopping.await(15, TimeUnit.SECONDS);\n-\n-        stopBackingTask();\n-        if (State.ERRORED.equals(getReportState().orElse(null)) || !stopSucceed) {\n-            if (!stopSucceed) {\n-                logger.atError(\"service-shutdown-error\").log(\"Service stop timed out\");\n-            }\n-            updateStateAndBroadcast(State.ERRORED);\n-            // If the thread is still running, then kill it\n-            if (!shutdownFuture.isDone()) {\n-                shutdownFuture.cancel(true);\n+        try {\n+            Integer timeout = getTimeoutConfigValue(\n+                        LIFECYCLE_SHUTDOWN_NAMESPACE_TOPIC, DEFAULT_SHUTDOWN_STAGE_TIMEOUT_IN_SEC);\n+            shutdownFuture.get(timeout, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDcyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416960725", "bodyText": "ditto. use lastReported because current isn't updated yet.", "author": "ShirleyZheng92", "createdAt": "2020-04-28T22:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDk2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416940963", "bodyText": "these lines do the same thing.", "author": "MikeDombo", "createdAt": "2020-04-28T21:40:57Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -589,13 +634,17 @@ void initLifecycleThread() {\n                             .log(\"Service lifecycle thread interrupted. Thread will exit now\");\n                     return;\n                 } catch (Throwable e) {\n-                    logger.atError(\"service-state-transition-error\", e).log();\n+                    logger.atError(\"service-state-transition-error\").setCause(e).log();", "originalCommit": "4e07375c85dca0fcd65f3432d199de680de390a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "94b8051a1139e717722215eb9dd4aba8152b85b5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/94b8051a1139e717722215eb9dd4aba8152b85b5", "message": "Add Starting state", "committedDate": "2020-04-28T21:30:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNTAzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418315031", "bodyText": "Is it ok to discard \"DesiredStateUpdated\"? If yes, why do we even add those to the queue?", "author": "hui-yang", "createdAt": "2020-04-30T22:03:53Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +255,112 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4ODMxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419588311", "bodyText": "Yes, because the \"DesiredStateUpdated\" just serves as a notification to notify lifecycle loop about the update. We add the events anyways to avoid race conditions", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNTAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNDM5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418324392", "bodyText": "nit: update the comments", "author": "hui-yang", "createdAt": "2020-04-30T22:27:12Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -80,53 +89,53 @@\n     // Eg. Start a service will need DesiredStateList to be <RUNNING>\n     // ReInstall a service will set DesiredStateList to <FINISHED->NEW->RUNNING>\n     private final List<State> desiredStateList = new CopyOnWriteArrayList<>();\n-    private static final Set<State> ALLOWED_STATES_FOR_REPORTING =\n-            new HashSet<>(Arrays.asList(State.RUNNING, State.ERRORED, State.FINISHED));\n     private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+    private static final Map<State, Collection<State>> ALLOWED_STATE_TRANSITION_FOR_REPORTING = new HashMap<>();\n     // The number of continual occurrences from a state to ERRORED.\n     // This is not thread safe and should only be used inside reportState().\n     private final Map<State, Integer> stateToErroredCount = new HashMap<>();\n     // We only need to track the ERROR for the state transition starting from NEW, INSTALLED and RUNNING because", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyODc0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418328743", "bodyText": "Not sure if I understand. Is asyncFinishAction used to block until the backing task inhandleXAsync actually finishes? The default value (stateEvent) -> true (in both init ln259 and reset below ln337) is only needed so that the loop exists properly for handleX sync methods?", "author": "hui-yang", "createdAt": "2020-04-30T22:39:02Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +255,112 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {\n+                        continue;\n+                    }\n+\n+                    canFinish = true;\n+                    logger.atInfo(\"service-set-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+                    // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged\n+                    // are consistent across different services.\n+                    synchronized (State.class) {\n+                        prevState = current;\n+                        stateTopic.withValue(newState);\n+                        evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                    }\n+                }\n+                if (asyncFinishAction.get().test(stateEvent)) {\n+                    canFinish = true;", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4OTk4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419589989", "bodyText": "no. 'asyncFinishAction' blocks until a new state event arrives . a stateEvent is either a new state or a 'desiredStateUpdated' notification. One example is lifecycle while loop starts the service by calling service startup() , and wait until service report RUNNING", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyODc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyOTgyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418329827", "bodyText": "Update comments about what stateGeneration is intended for?", "author": "hui-yang", "createdAt": "2020-04-30T22:42:16Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -66,12 +74,13 @@\n     @Getter(AccessLevel.PACKAGE)\n     private final AtomicLong stateGeneration = new AtomicLong();", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5MDEwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419590103", "bodyText": "Sure", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyOTgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzNTI3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418335279", "bodyText": "Is it implicit that backingTask won't be changed again after setBackingTask, since handleX is actually executed synchronously? nit but in this case, we don't need atomic reference of backingTask?", "author": "hui-yang", "createdAt": "2020-04-30T22:58:21Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5MTU3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419591579", "bodyText": "SetBackingTask will only be called in the main lifecycle thread. I'd assume it's safe to remove atomic reference. Let me recheck", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzNTI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzODUxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418338517", "bodyText": "Why stopBackingTask here?", "author": "hui-yang", "createdAt": "2020-04-30T23:08:17Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5Mzc1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419593759", "bodyText": "We want to stop the thread of waiting dependency ready, and process the updated state/desiredstate in next while loop", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzODUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzOTA3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418339070", "bodyText": "Why do we have another way to timeout different from install timeout?", "author": "hui-yang", "createdAt": "2020-04-30T23:10:01Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5NDY2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419594662", "bodyText": "Install timeout is to measure install() invocation time, but startup() timeout is to measure the time between calling startup() to reportState(RUNNING)", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzOTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0MDA2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418340066", "bodyText": "What are the possible current tasks?", "author": "hui-yang", "createdAt": "2020-04-30T23:13:03Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5NTQ0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419595446", "bodyText": "A previous startup() invocation.", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0MDA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyNjkzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418726935", "bodyText": "This is the only case that the async action returns false. Why is this the only case?", "author": "MikeDombo", "createdAt": "2020-05-01T20:37:03Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;\n+            }\n+\n+            // else if desiredState is updated\n+            Optional<State> nextDesiredState = peekOrRemoveFirstDesiredState(State.INSTALLED);\n+            // Don't finish the state handling if the new desiredState is still RUNNING\n+            if (nextDesiredState.isPresent() && nextDesiredState.get().equals(State.RUNNING)) {", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5Njc0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419596746", "bodyText": "If the new stateEvent is a different state, then we need to go to the next loop to process the new state. If the new stateEvent is desiredStateUpdated, and the new desiredState isn't running, then the service need to stop first.", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyNjkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MjE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418742140", "bodyText": "make this a long instead of Long.", "author": "MikeDombo", "createdAt": "2020-05-01T21:18:11Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +255,112 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {\n+                        continue;\n+                    }\n+\n+                    canFinish = true;\n+                    logger.atInfo(\"service-set-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+                    // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged\n+                    // are consistent across different services.\n+                    synchronized (State.class) {\n+                        prevState = current;\n+                        stateTopic.withValue(newState);\n+                        evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                    }\n+                }\n+                if (asyncFinishAction.get().test(stateEvent)) {\n+                    canFinish = true;\n+                }\n             }\n+            asyncFinishAction.set((stateEvent) -> true);\n         }\n     }\n \n-    private boolean handleCurrentStateBroken(Optional<State> desiredState) {\n+    private void handleCurrentStateBroken(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n         // Having State.NEW as the desired state indicates the service is requested to reinstall, so here\n         // we'll transition out of BROKEN state to give it a new chance.\n         if (State.NEW.equals(desiredState.get())) {\n-            updateStateAndBroadcast(State.NEW);\n+            internalReportState(State.NEW);\n         } else {\n             logger.atError(\"service-broken\").log(\"service is broken. Deployment is needed\");\n-            return true;\n         }\n-        return false;\n     }\n \n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private boolean handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n+    private void handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n         // if no desired state is set, don't do anything.\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        CountDownLatch installLatch = new CountDownLatch(1);\n+        Long currentStateGeneration = stateGeneration.incrementAndGet();", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzY3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418743673", "bodyText": "Report stopping doesn't seem right. Shouldn't we request a stop here?", "author": "MikeDombo", "createdAt": "2020-05-01T21:22:21Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5NzkzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419597932", "bodyText": "Inside the lifecycle thread, requestStop only sets next desiredState to FINISHED. reportStopping in here is to implement the state transition of STARTING->STOPPING.", "author": "ShirleyZheng92", "createdAt": "2020-05-04T17:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYwMjM2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419602367", "bodyText": "But it isn't stopping here. If this did requestStop, then the state machine should handle the transition from STARTING->STOPPING.", "author": "MikeDombo", "createdAt": "2020-05-04T17:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0NDAzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418744034", "bodyText": "Shouldn't this re-check that the dependencies are ready, since this is happening async to when we last know that the dependencies were ready?", "author": "MikeDombo", "createdAt": "2020-05-01T21:23:26Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMzk0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419803941", "bodyText": "Added", "author": "ShirleyZheng92", "createdAt": "2020-05-05T00:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0NDAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0NTA1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418745050", "bodyText": "This log should be redundant, right? We already log in internalReportState.", "author": "MikeDombo", "createdAt": "2020-05-01T21:26:25Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;\n+            }\n+\n+            // else if desiredState is updated\n+            Optional<State> nextDesiredState = peekOrRemoveFirstDesiredState(State.INSTALLED);\n+            // Don't finish the state handling if the new desiredState is still RUNNING\n+            if (nextDesiredState.isPresent() && nextDesiredState.get().equals(State.RUNNING)) {\n+                return false;\n+            }\n+\n+            schedule.cancel(true);\n+            return true;\n+        });\n     }\n \n-    private boolean handleCurrentStateRunning(Optional<State> desiredState) {\n+\n+    private void handleCurrentStateRunning(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n         // desired state is different, let's transition to stopping state first.\n-        updateStateAndBroadcast(State.STOPPING);\n-        return false;\n+        internalReportState(State.STOPPING);\n     }\n \n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n     private void handleCurrentStateStopping() throws InterruptedException {\n         // does not handle desiredState in STOPPING because we must stop first.\n         // does not use setBackingTask because it will cancel the existing task.\n-        CountDownLatch stopping = new CountDownLatch(1);\n         Future<?> shutdownFuture = evergreenService.getContext().get(ExecutorService.class).submit(() -> {\n             try {\n                 evergreenService.shutdown();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-shutdown-interrupted\").log(\"Service interrupted while running shutdown\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-shutdown-error\", t).log();\n-            } finally {\n-                stopping.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         });\n \n-        boolean stopSucceed = stopping.await(15, TimeUnit.SECONDS);\n-\n-        stopBackingTask();\n-        if (State.ERRORED.equals(getReportState().orElse(null)) || !stopSucceed) {\n-            if (!stopSucceed) {\n-                logger.atError(\"service-shutdown-error\").log(\"Service stop timed out\");\n-            }\n-            updateStateAndBroadcast(State.ERRORED);\n-            // If the thread is still running, then kill it\n-            if (!shutdownFuture.isDone()) {\n-                shutdownFuture.cancel(true);\n+        try {\n+            Integer timeout = getTimeoutConfigValue(\n+                        LIFECYCLE_SHUTDOWN_NAMESPACE_TOPIC, DEFAULT_SHUTDOWN_STAGE_TIMEOUT_IN_SEC);\n+            shutdownFuture.get(timeout, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                Optional<State> desiredState = peekOrRemoveFirstDesiredState(State.FINISHED);\n+                serviceTerminatedMoveToDesiredState(desiredState.orElse(State.FINISHED));\n             }\n-        } else {\n-            Optional<State> desiredState = peekOrRemoveFirstDesiredState(State.FINISHED);\n-            serviceTerminatedMoveToDesiredState(desiredState.orElse(State.FINISHED));\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            shutdownFuture.cancel(true);\n+            evergreenService.serviceErrored(\"Timeout shutdown\");\n+        } finally {\n+            stopBackingTask();\n         }\n     }\n \n-    private boolean handleCurrentStateFinished(Optional<State> desiredState) {\n+    private void handleCurrentStateFinished(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n         logger.atInfo(\"service-state-transition\").kv(\"desiredState\", desiredState).log();", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "49ca8da27510405a163eaa0840f4599fd9d05d64", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/49ca8da27510405a163eaa0840f4599fd9d05d64", "message": "AddressComments", "committedDate": "2020-05-04T21:13:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY5OTA4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419699087", "bodyText": "Do we need to check if this state is RUNNING?", "author": "hui-yang", "createdAt": "2020-05-04T20:12:35Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMzY4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419803686", "bodyText": "whether it's RUNNING or not, it should cancel the timer, go to next while loop to process the new state.", "author": "ShirleyZheng92", "createdAt": "2020-05-05T00:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY5OTA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcwMTA0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419701048", "bodyText": "Why do we pass in INSTALLED here? The side effect seems to be removing INSTALLED from desired list if exists. Does this mean if reinstall is called during the starting->running transition, we will drop it?", "author": "hui-yang", "createdAt": "2020-05-04T20:16:08Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;\n+            }\n+\n+            // else if desiredState is updated\n+            Optional<State> nextDesiredState = peekOrRemoveFirstDesiredState(State.INSTALLED);", "originalCommit": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMzQ3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419803475", "bodyText": "I changed it to STARTING .", "author": "ShirleyZheng92", "createdAt": "2020-05-05T00:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcwMTA0OA=="}], "type": "inlineReview"}, {"oid": "d29330f245d6e62b33d2c0758cabd50a83a805a7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d29330f245d6e62b33d2c0758cabd50a83a805a7", "message": "AddressComments", "committedDate": "2020-05-04T21:20:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MTUyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419741526", "bodyText": "Add some comments about when to use lastReportedState, prevState and stateEventQueue?", "author": "hui-yang", "createdAt": "2020-05-04T21:31:44Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -66,67 +74,68 @@\n     @Getter(AccessLevel.PACKAGE)\n     private final AtomicLong stateGeneration = new AtomicLong();\n     private final EvergreenService evergreenService;\n+    private final AtomicReference<State> lastReportedState = new AtomicReference<>();", "originalCommit": "d29330f245d6e62b33d2c0758cabd50a83a805a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MTYyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419741629", "bodyText": "Add comments?", "author": "hui-yang", "createdAt": "2020-05-04T21:31:58Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/State.java", "diffHunk": "@@ -25,6 +25,7 @@\n      */\n     INSTALLED(true, false, false),\n \n+    STARTING(true, false, false),", "originalCommit": "d29330f245d6e62b33d2c0758cabd50a83a805a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c29da1e7afb3e45b915383bd08d8f0c06ba3ca77", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c29da1e7afb3e45b915383bd08d8f0c06ba3ca77", "message": "Consolidate break/continue in lifecycle whileLoop", "committedDate": "2020-05-04T23:26:11Z", "type": "commit"}, {"oid": "172b8ee8dafd3adbc2511cca2f8ecd8ccc564aa9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/172b8ee8dafd3adbc2511cca2f8ecd8ccc564aa9", "message": "AddressComments", "committedDate": "2020-05-04T23:26:13Z", "type": "commit"}, {"oid": "10295e1c460ccb0583fd6f5d15ab2ab1795d71c5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/10295e1c460ccb0583fd6f5d15ab2ab1795d71c5", "message": "Add Starting state", "committedDate": "2020-05-04T23:26:13Z", "type": "commit"}, {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/594451043077c64d3708687d1d3f0c7c5c1d670b", "message": "AddressComments", "committedDate": "2020-05-04T23:57:23Z", "type": "forcePushed"}, {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/594451043077c64d3708687d1d3f0c7c5c1d670b", "message": "AddressComments", "committedDate": "2020-05-04T23:57:23Z", "type": "commit"}, {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/594451043077c64d3708687d1d3f0c7c5c1d670b", "message": "AddressComments", "committedDate": "2020-05-04T23:57:23Z", "type": "forcePushed"}]}