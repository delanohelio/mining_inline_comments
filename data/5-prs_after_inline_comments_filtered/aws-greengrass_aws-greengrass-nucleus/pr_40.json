{"pr_number": 40, "pr_title": "POC implementation of service discovery. Implement auth for IPC connnections", "pr_createdAt": "2020-01-23T21:32:22Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40", "timeline": [{"oid": "078e20f1747edb93b267e7b8175036910719cddd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/078e20f1747edb93b267e7b8175036910719cddd", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-23T21:29:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370408534", "bodyText": "Why do we need an atomic reference here?", "author": "fahadmohammed01", "createdAt": "2020-01-23T23:27:43Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,56 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public RequestContext doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n-        }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        AtomicReference<String> serviceName = new AtomicReference<>();", "originalCommit": "078e20f1747edb93b267e7b8175036910719cddd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409096", "bodyText": "It is needed so that I can set the serviceName inside the lambda that I have in the deepForEach", "author": "MikeDombo", "createdAt": "2020-01-23T23:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4ODQ2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370488467", "bodyText": "There should be an inline comment explaining why having a atomic reference", "author": "fengwang666", "createdAt": "2020-01-24T06:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MzIxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370493215", "bodyText": "Alright, can do. I would expect to see this pattern a lot in our code going forward since so much of it is lambda/callback based.", "author": "MikeDombo", "createdAt": "2020-01-24T06:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409046", "bodyText": "Can we store the token in a different map so the lookup during auth is not a linear search", "author": "fahadmohammed01", "createdAt": "2020-01-23T23:29:24Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -24,6 +24,10 @@ public GenericExternalService(Topics c) {\n                 setState(child.childOf(\"install\") ? State.Installing : State.AwaitingStartup);\n             }\n         });\n+\n+        // Set a unique ID used for IPC Auth\n+        Topic uid = c.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "originalCommit": "078e20f1747edb93b267e7b8175036910719cddd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTMwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409304", "bodyText": "Potentially, but that means that we need to duplicate the value so we have both A->B and B->A.", "author": "MikeDombo", "createdAt": "2020-01-23T23:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NTk2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370485961", "bodyText": "I'll see what I can do for this tomorrow.", "author": "MikeDombo", "createdAt": "2020-01-24T06:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409140", "bodyText": "add TODO: for synchronization between requests?", "author": "fahadmohammed01", "createdAt": "2020-01-23T23:29:40Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {", "originalCommit": "078e20f1747edb93b267e7b8175036910719cddd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQxMDAwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370410003", "bodyText": "It is synchronized", "author": "MikeDombo", "createdAt": "2020-01-23T23:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTE0MA=="}], "type": "inlineReview"}, {"oid": "205381a05a894f1d27be5eec952afbb35281e7fa", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/205381a05a894f1d27be5eec952afbb35281e7fa", "message": "Merge branch 'master' into service_discovery", "committedDate": "2020-01-23T23:35:17Z", "type": "commit"}, {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/524fc3ad38ad170d9ba5215e51f1fe48459a4225", "message": "Make IPC Auth have a response", "committedDate": "2020-01-24T00:56:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2ODg0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370468841", "bodyText": "What's the reason of having SDAResource instead of directly using Resource class?", "author": "fengwang666", "createdAt": "2020-01-24T04:22:45Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {", "originalCommit": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MjU3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370492579", "bodyText": "Just to store information not in the resource, but about the resource. Such as the owning service and if it is published to DNS-SD.", "author": "MikeDombo", "createdAt": "2020-01-24T06:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2ODg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469024", "bodyText": "I would add a comment explaining why this method is synchronized. Also, java doc?", "author": "fengwang666", "createdAt": "2020-01-24T04:24:03Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {", "originalCommit": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MzM0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370493340", "bodyText": "Sure thing", "author": "MikeDombo", "createdAt": "2020-01-24T06:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDczODIzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370738238", "bodyText": "Do we need more finer level of synchronization?", "author": "fahadmohammed01", "createdAt": "2020-01-24T16:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MzQwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370743409", "bodyText": "Added javadoc and switch from using synchronized to using a ReentrantReadWriteLock. I can't really go any finer because we're storing the data in the config store.", "author": "MikeDombo", "createdAt": "2020-01-24T17:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTE2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469167", "bodyText": "Create a SIM and add a link to the SIM here.", "author": "fengwang666", "createdAt": "2020-01-24T04:25:12Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation", "originalCommit": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTMwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469307", "bodyText": "Unnecessary comment", "author": "fengwang666", "createdAt": "2020-01-24T04:26:05Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+            response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+            return response;\n+        }\n+\n+        // Save resource", "originalCommit": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjU2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370486566", "bodyText": "nonnull?", "author": "fengwang666", "createdAt": "2020-01-24T06:13:58Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {\n+    private Resource resource;\n+    private boolean publishedToDNSSD;\n+    private String owningService;", "originalCommit": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MjcxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370492715", "bodyText": "This isn't user input, so validations aren't really necessary. Though of course I could mark these all as nonnull.", "author": "MikeDombo", "createdAt": "2020-01-24T06:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370486704", "bodyText": "Unnecessary comment", "author": "fengwang666", "createdAt": "2020-01-24T06:14:48Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+            response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = SDAResource.builder()\n+                .resource(request.getResource())\n+                .publishedToDNSSD(request.isPublishToDNSSD())\n+                .owningService(serviceName).build();\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        response.setError(ServiceDiscoveryResponseStatus.Success);\n+        response.setResponse(request.getResource());\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public synchronized GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+            response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.getOwningService().equals(serviceName)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.getResource().setTxtRecords(request.getResource().getTxtRecords());\n+        resource.getResource().setUri(request.getResource().getUri());\n+        resource.setPublishedToDNSSD(request.isPublishToDNSSD());\n+\n+        response.setError(ServiceDiscoveryResponseStatus.Success);\n+        return response;\n+    }\n+\n+    public synchronized GeneralResponse<Void, ServiceDiscoveryResponseStatus> removeResource(RemoveResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+            response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.getOwningService().equals(serviceName)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to remove %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        // Remove from master list", "originalCommit": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NzkxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370487913", "bodyText": "Extract the address to a constant?", "author": "fengwang666", "createdAt": "2020-01-24T06:21:52Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/common/Server.java", "diffHunk": "@@ -36,7 +36,7 @@ public void startup() throws IPCException {\n             serverSocket = new ServerSocket();\n             // specifying port 0 causes  the system to pick an ephemeral port and a valid local address to bind the socket\n             serverSocket.bind(new InetSocketAddress(0));\n-            String serverUri = \"tcp://\" + serverSocket.getInetAddress().getHostAddress() + \":\" + serverSocket.getLocalPort();\n+            String serverUri = \"tcp://127.0.0.1:\" + serverSocket.getLocalPort();", "originalCommit": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NjExNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370756117", "bodyText": "The try...finally can be replaced by a LockScope object we used in stream manager: https://code.amazon.com/packages/AWSGreengrassGreenlake/blobs/mainline/--/src/com/amazonaws/iot/greengrass/streammanager/utils/LockScope.java", "author": "fengwang666", "createdAt": "2020-01-24T17:38:03Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to handle the business logic for Service Discovery including CRUD operations.\n+ */\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    /**\n+     * Register a resource with Service Discovery. Will throw if the resource is already registered.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+                response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource sdaResource = SDAResource.builder()\n+                    .resource(request.getResource())\n+                    .publishedToDNSSD(request.isPublishToDNSSD())\n+                    .owningService(serviceName).build();\n+            config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            response.setResponse(request.getResource());\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Update an already existing resource. The update will only update the URI, TXT Records, and whether\n+     * it is published to DNS-SD or not.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (!isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+                response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+            if (!resource.getOwningService().equals(serviceName)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+                response.setErrorMessage(String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath));\n+                return response;\n+            }\n+\n+            // update resource (only some fields are updatable)\n+            resource.getResource().setTxtRecords(request.getResource().getTxtRecords());\n+            resource.getResource().setUri(request.getResource().getUri());\n+            resource.setPublishedToDNSSD(request.isPublishToDNSSD());\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }", "originalCommit": "7febfd634fa1666594b67ae2708c6cd195516168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODE4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370758188", "bodyText": "I know, I just didn't necessarily want to start copying utilities over from there. But I can if you think that's a good thing to do.", "author": "MikeDombo", "createdAt": "2020-01-24T17:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NjExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1Njg0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370756848", "bodyText": "remove empty line", "author": "fengwang666", "createdAt": "2020-01-24T17:39:40Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to handle the business logic for Service Discovery including CRUD operations.\n+ */\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    /**\n+     * Register a resource with Service Discovery. Will throw if the resource is already registered.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+", "originalCommit": "7febfd634fa1666594b67ae2708c6cd195516168", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "800277a58091d443e6b9010306e1843d93f307c0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/800277a58091d443e6b9010306e1843d93f307c0", "message": "Address PR comments", "committedDate": "2020-01-24T17:50:15Z", "type": "commit"}, {"oid": "800277a58091d443e6b9010306e1843d93f307c0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/800277a58091d443e6b9010306e1843d93f307c0", "message": "Address PR comments", "committedDate": "2020-01-24T17:50:15Z", "type": "forcePushed"}]}