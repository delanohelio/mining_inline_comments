{"pr_number": 346, "pr_title": "Config store IPC APIs - updates read, subscribe and adds write, validate", "pr_createdAt": "2020-08-03T07:18:24Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346", "timeline": [{"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "message": "Remove runtime config handling", "committedDate": "2020-08-04T23:10:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NzcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465867704", "bodyText": "update this comment, what is this a map of now?", "author": "MikeDombo", "createdAt": "2020-08-05T16:53:31Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -40,17 +49,13 @@\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n     // Map from connection --> Function to call when service config changes", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2OTY5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465869695", "bodyText": "I don't think you need the contains check, I'm pretty sure you can just do remove", "author": "MikeDombo", "createdAt": "2020-08-05T16:56:40Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n         });\n \n-        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDk2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465870967", "bodyText": "[nit]\ncombine this string", "author": "MikeDombo", "createdAt": "2020-08-05T16:58:37Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2OTgxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466769819", "bodyText": "Are we not taking key (to subscribe to) as an input in the request as desribed in API design doc?", "author": "abanthiy", "createdAt": "2020-08-07T01:24:35Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMzk1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466803950", "bodyText": "I'm waiting for Fahad to respond to a question about two conflicting suggestions in the doc https://quip-amazon.com/mbN5ATEk6Db6/IPC-SDK-API-Design#GcZ9CAnF4nL If there is one subscription for all config then we do not need keyname, however I want to know his thought process", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2OTgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MTI5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466771299", "bodyText": "To me the name does not seem to fit. Don;t have great suggestions but maybe actionsByContext or methodToInvokeByContext", "author": "abanthiy", "createdAt": "2020-08-07T01:30:14Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -40,17 +49,13 @@\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n     // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n+            new ConcurrentHashMap<>();\n+    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners = new ConcurrentHashMap<>();", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NzIwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466777204", "bodyText": "Currently context represents one client and you can receive more than one subscriptions from one client. I think in that case this will not work. We probably need configUpdateListeners to be Map<Context, BiConsumer<String, String>>\nBiConsumer to consume keychanged and serviceName, and send that serviceName to the client. Let me know what you think.\nAlso, it is not implemented yet but I think the meaning of context will change when we use the new IPC, since that will have streamIds. A context object will represent a particular stream for a particular client. So when that happens this code will work. We can see if we can write something that works for both and we do not have to change much with new IPC.", "author": "abanthiy", "createdAt": "2020-08-07T01:53:25Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNDYxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466804618", "bodyText": "This is based on the idea that there are no per key subscription one subscription for all config of a component, so component A can register 1 subscription for component B's config, one for component C's config etc, and this will work for that", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NzIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxOTAyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r468219028", "bodyText": "If I understand correctly - When componentA subscribes for componentB, the configUpdateListeners map will have entry for contextForComponentA with service name as componentB. When A subscribes for componentC, that time you won't update the entry in configUpdateListeners map and when you want to send the event to componentA corresponding to change in componentC's config, you would send the service name as componentB.", "author": "abanthiy", "createdAt": "2020-08-10T22:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NzIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3OTY2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466779667", "bodyText": "Is the key still called parameters? Or is it now called configuration?\nAlso, just making sure, event for the same service we allow only this part of config to be read?", "author": "abanthiy", "createdAt": "2020-08-07T02:03:04Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -134,27 +166,28 @@ public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n \n     /**\n      * Read specified key from the service's dynamic config.\n-     * @param readRequest read request\n+     *\n+     * @param request request\n      * @param context client context\n      * @return response data\n      */\n-    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n-        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n-                ConfigStoreReadValueResponse.builder();\n+    public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n+        String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        Topics configTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n-        if (configTopics == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.NoDynamicConfig)\n-                    .errorMessage(\"Service has no dynamic config\").build();\n+        Topics componentConfigurationTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNDk3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466804975", "bodyText": "It's still called parameters, we haven't done renaming of package->component or parameter->configuration terminology yet. Yes there is no need for a service to read any other config even if it's self", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3OTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466780585", "bodyText": "So when the device SDK team provides us the server code, I imagine we will get some POJOS for requests, responses and errors. Let see how we can reduce the changes we need to do when we want to move to using those POJOS. So putting all send error responses into a helper method would help. In that helper we can pass the error type and send the response accordingly and when we move to using SDK POJOS we just need to change that helper method. You can refer to ConfigStore APIs error messages at https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L259", "author": "abanthiy", "createdAt": "2020-08-07T02:06:44Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -134,27 +166,28 @@ public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n \n     /**\n      * Read specified key from the service's dynamic config.\n-     * @param readRequest read request\n+     *\n+     * @param request request\n      * @param context client context\n      * @return response data\n      */\n-    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n-        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n-                ConfigStoreReadValueResponse.builder();\n+    public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n+        String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDg1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466780858", "bodyText": "Also, if we need other error messages then we can add to the Smithy model as well.", "author": "abanthiy", "createdAt": "2020-08-07T02:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNTU1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466805553", "bodyText": "I'm okay with making a refactor into the current IPC server side code to align with the smithy model but I will prefer to do that as part of a separate PR which will allow doing it for all existing IPC APIs i.e. lifecycle, pubsub and config store. I want to get this particular PR out sooner since stream manager folks are waiting for read write and subscribe APIs which was the original scope for this for last sprint", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MjcxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466782716", "bodyText": "If we do not allow this then we should remove componentName from the request. We can add when we start supporting it. Let me know what is the decision, the API doc says we are. We need to update both Smithy model and doc to reflect the decision.", "author": "abanthiy", "createdAt": "2020-08-07T02:14:44Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNTczNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466805735", "bodyText": "Why is the smithy model different from the definitions in the API design doc?", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MjcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4NzY5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466787698", "bodyText": "I am thinking about how we can minimize the changes we need to do with new IPC. So putting this creation of application message and sending can be put in helper method (which takes the opcode and others as parameters). This helper can be used by the sendStoreUpdateToListener method as well.\nThis is just something I want to put out there so as you code you can keep it in mind and wherever possible we can attempt to do it.", "author": "abanthiy", "createdAt": "2020-08-07T02:34:43Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNjA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466806041", "bodyText": "I will try to see if I can refactor with minimal changes for this PR otherwise create a task to do initial refactoring for the long term IPC changes like I said in my other comment", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4NzY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4OTYxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466789616", "bodyText": "Add handle in the method name?", "author": "abanthiy", "createdAt": "2020-08-07T02:42:37Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466790539", "bodyText": "Most of the APIs for Config store does not send response. You can refer here : https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L76\nEven the Subscribe APIs do not send any initial response. The acknowledgement of the message at protocol level should be taken care by new IPC. So for now you may want to add TODO to remove these sent responses when new IPC is used.", "author": "abanthiy", "createdAt": "2020-08-07T02:46:26Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -70,13 +73,28 @@ public void postInject() {\n             ConfigStoreClientOpCodes opCode = ConfigStoreClientOpCodes.values()[applicationMessage.getOpCode()];\n             ConfigStoreGenericResponse configStoreGenericResponse = new ConfigStoreGenericResponse();\n             switch (opCode) {\n-                case SUBSCRIBE_ALL:\n-                    configStoreGenericResponse = agent.subscribe(context);\n+                case SUBSCRIBE_TO_ALL_CONFIG_UPDATES:\n+                    SubscribeToConfigurationUpdateRequest subscribeToConfigUpdateRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), SubscribeToConfigurationUpdateRequest.class);\n+                    configStoreGenericResponse = agent.subscribeToConfigUpdate(subscribeToConfigUpdateRequest, context);\n                     break;\n-                case READ_KEY:\n-                    ConfigStoreReadValueRequest readRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), ConfigStoreReadValueRequest.class);\n-                    configStoreGenericResponse = agent.read(readRequest, context);\n+                case GET_CONFIG:\n+                    GetConfigurationRequest getConfigRequest =\n+                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), GetConfigurationRequest.class);\n+                    configStoreGenericResponse = agent.getConfig(getConfigRequest, context);\n+                    break;\n+                case UPDATE_CONFIG:\n+                    UpdateConfigurationRequest updateConfigRequest =\n+                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), UpdateConfigurationRequest.class);\n+                    configStoreGenericResponse = agent.updateConfig(updateConfigRequest, context);\n+                    break;\n+                case SUBSCRIBE_TO_CONFIG_VALIDATION:\n+                    configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n+                    break;\n+                case REPORT_CONFIG_VALIDITY:\n+                    ReportConfigurationValidityRequest reportConfigValidityRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), ReportConfigurationValidityRequest.class);\n+                    configStoreGenericResponse = agent.reportConfigValidity(reportConfigValidityRequest, context);\n                     break;\n                 default:\n                     configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNjc3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466806777", "bodyText": "I see empty response object in the API design doc SubscribeToConfigurationUpdateResponse https://quip-amazon.com/mbN5ATEk6Db6/IPC-SDK-API-Design, again how is the doc and the model different?", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNzEzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466807132", "bodyText": "Current IPC implementation requires a response, so this is fine.", "author": "MikeDombo", "createdAt": "2020-08-07T03:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMDgzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r468220836", "bodyText": "Doc an model are different because\n\nSome changes were made during model review as we learnt about Smithy and they are not reflected in the doc.\nSome decisions are taken after smithy model was written", "author": "abanthiy", "createdAt": "2020-08-10T22:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDY0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466790646", "bodyText": "Similar comment about helper for sending errors. This will be treated as ServiceError since this is not a clients mistake.", "author": "abanthiy", "createdAt": "2020-08-07T02:46:52Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n+                                                                    ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n+                ReportConfigurationValidityResponse.builder();\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNzI5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466807298", "bodyText": "I'll change message for this", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDY0Ng=="}], "type": "inlineReview"}, {"oid": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81ecc7100d8d18e21d85048a661cf47a0d12726e", "message": "Enhancements", "committedDate": "2020-08-07T04:31:29Z", "type": "forcePushed"}, {"oid": "dac25eeeea15629ed8f335290415076ea691bc22", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dac25eeeea15629ed8f335290415076ea691bc22", "message": "Enhancements", "committedDate": "2020-08-07T04:34:31Z", "type": "forcePushed"}, {"oid": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85c8fa46d71692a43e5f4e3dfcf080bf38694230", "message": "Enhancements", "committedDate": "2020-08-07T04:42:58Z", "type": "forcePushed"}, {"oid": "35798fd73576d2dcc4a06ba500c23f7aec2ecc18", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/35798fd73576d2dcc4a06ba500c23f7aec2ecc18", "message": "Enhancements", "committedDate": "2020-08-07T04:52:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTU5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331591", "bodyText": "should this be in a finally so that it is always removed even if the test fails?", "author": "MikeDombo", "createdAt": "2020-08-07T23:55:15Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -222,17 +225,80 @@ void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_key_sent_when_changed() throws\n             }\n         }, 2);\n \n-        c.subscribe(p.getRight());\n-        custom.createLeafChild(\"abc\").withValue(\"ABC\");\n-        custom.createLeafChild(\"DDF\").withValue(\"ddf\");\n+        c.subscribeToConfigurationUpdate(\"ServiceName\", p.getRight());\n+        configuration.createLeafChild(\"abc\").withValue(\"ABC\");\n+        configuration.createLeafChild(\"DDF\").withValue(\"ddf\");\n \n         try {\n-            p.getLeft().get(1, TimeUnit.SECONDS);\n+            p.getLeft().get(10, TimeUnit.SECONDS);\n         } finally {\n-            custom.remove();\n+            configuration.remove();\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTgwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331806", "bodyText": "this assertion won't do anything (except cause the CDL to not be counted down). I'd recommend using: https://github.com/aws/aws-greengrass-kernel/blob/708b5de9daf62f941429a6131523aaae3c448380/src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java#L60", "author": "MikeDombo", "createdAt": "2020-08-07T23:56:25Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -222,17 +225,80 @@ void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_key_sent_when_changed() throws\n             }\n         }, 2);\n \n-        c.subscribe(p.getRight());\n-        custom.createLeafChild(\"abc\").withValue(\"ABC\");\n-        custom.createLeafChild(\"DDF\").withValue(\"ddf\");\n+        c.subscribeToConfigurationUpdate(\"ServiceName\", p.getRight());\n+        configuration.createLeafChild(\"abc\").withValue(\"ABC\");\n+        configuration.createLeafChild(\"DDF\").withValue(\"ddf\");\n \n         try {\n-            p.getLeft().get(1, TimeUnit.SECONDS);\n+            p.getLeft().get(10, TimeUnit.SECONDS);\n         } finally {\n-            custom.remove();\n+            configuration.remove();\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTk3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331971", "bodyText": "this is changed now due to my recent merge. You'll need to rebase.", "author": "MikeDombo", "createdAt": "2020-08-07T23:57:26Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -62,19 +91,30 @@\n         }\n \n         List<String> nodePath = node.path();\n-        // The path should have at least 5 items: null (root), services, serviceName, custom, <someKey>\n+        // The path should have at least 5 items: null (root), services, serviceName, parameters, <someKey>\n         if (nodePath.size() < 5) {", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjM5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467332396", "bodyText": "should this be moved into our SDK package?", "author": "MikeDombo", "createdAt": "2020-08-07T23:59:57Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -165,10 +217,179 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n         } else if (node instanceof Topics) {\n             response.value(((Topics) node).toPOJO());\n         } else {\n-            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            response.responseStatus(ConfigStoreResponseStatus.ServiceError).errorMessage(\"Node has an unknown type\");\n             log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n         }\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's configuration.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n+            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n+        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n+                SendConfigurationValidityReportResponse.builder();\n+        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n+        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n+        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Validation request either timed out or was never made\").build();\n+        }\n+\n+        CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                configValidationReportFutures.get(context.getServiceName());\n+        if (!reportFuture.isCancelled()) {\n+            reportFuture.complete(\n+                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n+                            .build());\n+        }\n+        configValidationReportFutures.remove(context.getServiceName());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Trigger a validate event to service/component, typically used during deployments.\n+     *\n+     * @param componentName service/component to send validate event to\n+     * @param configuration new component configuration to validate\n+     * @param reportFuture  future to track validation report in response to the event\n+     * @return true if the service has registered a validator, false if not\n+     * @throws UnsupportedOperationException throws when triggering requested validation event is not allowed\n+     */\n+    public boolean validateConfiguration(String componentName, Map<String, Object> configuration,\n+                                         CompletableFuture<ConfigurationValidityReport> reportFuture)\n+            throws UnsupportedOperationException {\n+        // TODO : Consider handling a collection of components to abstract validation for the whole deployment\n+        if (configValidationReportFutures.containsKey(componentName)) {\n+            throw new UnsupportedOperationException(\n+                    \"A validation request to this component is already waiting for response\");\n+        }\n+\n+        for (Map.Entry<ConnectionContext, Consumer<Map<String, Object>>> e : configValidationListeners.entrySet()) {\n+            if (e.getKey().getServiceName().equals(componentName)) {\n+                configValidationReportFutures.put(componentName, reportFuture);\n+                e.getValue().accept(configuration);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Abandon tracking for report of configuration validation event. Can be used by the caller in the case of timeouts\n+     * or other errors.\n+     *\n+     * @param componentName component name to abandon validation for\n+     * @param reportFuture  tracking future for validation report to abandon\n+     * @return true if abandon request was successful\n+     */\n+    public boolean discardValidationReportTracker(String componentName,\n+                                                  CompletableFuture<ConfigurationValidityReport> reportFuture) {\n+        return configValidationReportFutures.remove(componentName, reportFuture);\n+    }\n+\n+    // TODO: If it adds value, add this to the SendConfigurationValidityReportRequest in smithy model\n+    @Builder\n+    @Getter\n+    public static class ConfigurationValidityReport {", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzMjU3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467632573", "bodyText": "will update smithy model with\n\nConfigurationValidityStatus status;\nString message;\nfor SendConfigurationValidityReportRequest", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjYwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467332608", "bodyText": "close context in aftereach", "author": "MikeDombo", "createdAt": "2020-08-08T00:00:49Z", "path": "src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class ConfigStoreIPCAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private ExecutorService executor;\n+\n+    @Mock\n+    private ConnectionContext componentAContext;\n+\n+    @Mock\n+    private ConnectionContext componentBContext;\n+\n+    private ConfigStoreIPCAgent agent;\n+\n+    private Configuration configuration;\n+\n+    @BeforeEach\n+    void setup() {\n+        agent = new ConfigStoreIPCAgent(kernel, executor);\n+\n+        configuration = new Configuration(new Context());", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0eada4e4c5d2644f516058f34a4f43a9472fbc58", "message": "Simplified version with per key and nested key subscriptions", "committedDate": "2020-08-09T03:45:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjUyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467532527", "bodyText": "I changed this but forgot to remove this comment", "author": "shaguptashaikh", "createdAt": "2020-08-09T03:56:32Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,177 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        // Sends an event immediately after", "originalCommit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjM1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467532357", "bodyText": "pass in the version too", "author": "MikeDombo", "createdAt": "2020-08-09T03:53:48Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)", "originalCommit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21d36db9c58cff65320dc91184a2dab2b057cc32", "message": "Simplified version with per key and nested key subscriptions", "committedDate": "2020-08-09T04:04:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYyOTUyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467629529", "bodyText": "Nice, this can be used by all ipc components\ndo the server push also with the executor thread? Since this will run by the publish thread, we should avoid doing IO. Also can we return the future so called can handle if the sendEvent failed. The caller might not use it always but is a nice to have", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:14:28Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)\n+                            .payload(IPCUtil.encode(serviceEvent)).build();\n+            // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+            Future<FrameReader.Message> fut = connectionContext", "originalCommit": "21d36db9c58cff65320dc91184a2dab2b057cc32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYyOTk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467629996", "bodyText": "This is leaking info about what components are present, from a security stand point we should always return key not found. Same goes for \"Requested component does not have any configuration\". Not sure how relevant this is right now, but changing it now might help in the future", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:19:33Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,176 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,", "originalCommit": "21d36db9c58cff65320dc91184a2dab2b057cc32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzMTA3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467631074", "bodyText": "+1 for string arrays.", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:31:32Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,176 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {", "originalCommit": "21d36db9c58cff65320dc91184a2dab2b057cc32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "06ea9776f2584626db3feffbab6dbb09ff463b69", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/06ea9776f2584626db3feffbab6dbb09ff463b69", "message": "Address comments add more open questions as TODOs", "committedDate": "2020-08-10T16:42:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjQwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470166408", "bodyText": "withNewerValue() will not change the value if the request timestamp is less than the topics last modified timestamp. We should return that information back to the callee rather than report success.", "author": "fahadmohammed01", "createdAt": "2020-08-13T18:38:16Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -170,4 +238,154 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's configuration.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n+        }\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());", "originalCommit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0NjIxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470246213", "bodyText": "It may or may not be needed. Basically withNewerValue() abstract the timestamp comparison and doesn't throw any exception if the update didn't take effect due to an older proposed timestamp. We can still explicitly compare if after the call the node has the proposed value and modtime, it can be done later if we think it is needed", "author": "shaguptashaikh", "createdAt": "2020-08-13T21:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3NTE1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470375155", "bodyText": "Update - Incorporated this change while adding compare with swap update", "author": "shaguptashaikh", "createdAt": "2020-08-14T02:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjQwOA=="}], "type": "inlineReview"}, {"oid": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "message": "Implemented TODOs for previously open/now resolved questions", "committedDate": "2020-08-13T20:46:32Z", "type": "forcePushed"}, {"oid": "647576c1f224d6603cec83e06225b81e8738162e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/647576c1f224d6603cec83e06225b81e8738162e", "message": "Support compare and swap update", "committedDate": "2020-08-14T02:23:16Z", "type": "forcePushed"}, {"oid": "96005264f317b738b3a10e836112b85cc4ad0a6b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/96005264f317b738b3a10e836112b85cc4ad0a6b", "message": "Make checkstyle and pmd happy", "committedDate": "2020-08-14T05:41:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNjg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470836865", "bodyText": "Initialize to null? as you are doing a null check where it is being called.", "author": "abanthiy", "createdAt": "2020-08-14T19:53:58Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +53,164 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String CONTEXT_LOGGING_KEY = \"context\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n+        Node subscribeTo = configurationTopics;", "originalCommit": "4053d8d291511f5087460f3ea17fd05dd88045f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MTU2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470881569", "bodyText": "This call configurationTopics.findNode(keyPath.toArray(new String[0])); on line 122 below can return null and change a non null value to null which is why I did it this way", "author": "shaguptashaikh", "createdAt": "2020-08-14T21:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNjg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MzQ1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470883453", "bodyText": "oh right and you want to setup the subscription for the whole config if key path is not specified. Looks good then", "author": "abanthiy", "createdAt": "2020-08-14T22:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNjg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzODgyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470838820", "bodyText": "Dead code? If not needed, may remove the check watcher.isPresent() in the calling method.", "author": "abanthiy", "createdAt": "2020-08-14T19:58:36Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +53,164 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String CONTEXT_LOGGING_KEY = \"context\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n+        Node subscribeTo = configurationTopics;\n+        if (keyPath != null && !keyPath.isEmpty()) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n+        }\n+        return subscribeTo;\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n \n-        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();", "originalCommit": "4053d8d291511f5087460f3ea17fd05dd88045f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MDg3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470880871", "bodyText": "It's logically dead code because we will never have a situation where a node is neither a Topic instance nor a Topics instance, but theoretically it's possible for this piece of code because of which the compiler complains if I remove this return statement", "author": "shaguptashaikh", "createdAt": "2020-08-14T21:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzODgyMA=="}], "type": "inlineReview"}, {"oid": "a197e2f42f728d7d18772483a5b9069198b6c816", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a197e2f42f728d7d18772483a5b9069198b6c816", "message": "Config store APIs - updates read, subscribe for supporting shared config, adds write and validate", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8bf751c899bf489deab8fae35f87a339e2d4ca18", "message": "Remove runtime config handling", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "message": "Enhancements", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "message": "Unit and integ tests", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a9ade7d386a806aa6a0b7287151d4c385ab552ab", "message": "Simplified version with per key and nested key subscriptions", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "message": "Address comments add more open questions as TODOs", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "a80552617929885383367fa73312d0463252df98", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a80552617929885383367fa73312d0463252df98", "message": "Implemented TODOs for previously open/now resolved questions", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "2fcea893248454e36733ab3403d7b3f9c9f63657", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2fcea893248454e36733ab3403d7b3f9c9f63657", "message": "Support compare and swap update", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "message": "Make checkstyle and pmd happy", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "af1db22427c77a4b6d617ebd503c6eb878b08f21", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af1db22427c77a4b6d617ebd503c6eb878b08f21", "message": "Fix integ test", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "151638416620da7204def0d2fc975075be6363d7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/151638416620da7204def0d2fc975075be6363d7", "message": "Fix flakiness in subscribe to config update tests", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "151638416620da7204def0d2fc975075be6363d7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/151638416620da7204def0d2fc975075be6363d7", "message": "Fix flakiness in subscribe to config update tests", "committedDate": "2020-08-14T23:36:42Z", "type": "forcePushed"}, {"oid": "9cc694b3d02b1f6abc2bae044415818f638cc1c6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9cc694b3d02b1f6abc2bae044415818f638cc1c6", "message": "Fix another flake in integ test", "committedDate": "2020-08-15T00:57:45Z", "type": "commit"}, {"oid": "02bedd38a3acab477dda371b3d7eb2ae50c68f2e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/02bedd38a3acab477dda371b3d7eb2ae50c68f2e", "message": "Merge branch 'master' into shared-config", "committedDate": "2020-08-18T15:59:00Z", "type": "commit"}, {"oid": "3cf93b4af6ecaf3649e133e46de6918204f297c2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cf93b4af6ecaf3649e133e46de6918204f297c2", "message": "Merge branch 'master' into shared-config", "committedDate": "2020-08-18T17:28:55Z", "type": "commit"}]}