{"pr_number": 277, "pr_title": "New MQTT client with automatic scaling based on subscriptions", "pr_createdAt": "2020-06-09T21:58:46Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277", "timeline": [{"oid": "7617445d9803d14d094b62a33cd62f48233d3321", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7617445d9803d14d094b62a33cd62f48233d3321", "message": "New MQTT client", "committedDate": "2020-06-09T22:36:25Z", "type": "forcePushed"}, {"oid": "7177432d30d880b8664f4313b4c9949c755fbdc8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7177432d30d880b8664f4313b4c9949c755fbdc8", "message": "New MQTT client", "committedDate": "2020-06-09T23:47:49Z", "type": "forcePushed"}, {"oid": "c21c59c5f19066b25eb00c5fe0f3ef6941db0314", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c21c59c5f19066b25eb00c5fe0f3ef6941db0314", "message": "New MQTT client", "committedDate": "2020-06-10T19:17:10Z", "type": "forcePushed"}, {"oid": "dfb1f7137a94505ae1889e11768c6b5f8731d184", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dfb1f7137a94505ae1889e11768c6b5f8731d184", "message": "New MQTT client", "committedDate": "2020-06-10T19:26:43Z", "type": "forcePushed"}, {"oid": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "message": "New MQTT client", "committedDate": "2020-06-10T19:58:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNDE3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438334174", "bodyText": "This was captured as a feedback in Mqtt discussions. I don't think this is an immediate requirement. But I was under the impression that we will figure out less costlier ways to identify connection loss when we design separate mqtt client. This comment here is not right place for it I think. We need to determine connection loss outside of this method and then trigger the onConnectionInterrupted.", "author": "abanthiy", "createdAt": "2020-06-10T18:41:29Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available", "originalCommit": "7177432d30d880b8664f4313b4c9949c755fbdc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NzY0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438387641", "bodyText": "Why would we trigger this? It is a callback that the SDK should be calling, right?", "author": "MikeDombo", "createdAt": "2020-06-10T20:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNDE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4OTgwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438389806", "bodyText": "That is correct. But if we want to identify connection loss separately, then we do not want duplicate notification, so we may have to increase the mqtt ping timeout. And we can have a separate indication of connection loss (which is not this method).", "author": "abanthiy", "createdAt": "2020-06-10T20:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNDE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5ODg3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438398874", "bodyText": "This sounds like something which may happen at a later point, and so I don't want to make any change now without knowing what that entails. For now, the SDK will just let us know when it disconnects and when it reconnects.", "author": "MikeDombo", "createdAt": "2020-06-10T20:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNDE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1NTk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438355996", "bodyText": "Do you need the locking if only thing happening in the try block is setting the Atomic variable?", "author": "abanthiy", "createdAt": "2020-06-10T19:23:07Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }", "originalCommit": "c21c59c5f19066b25eb00c5fe0f3ef6941db0314", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4ODM1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438388354", "bodyText": "Not exactly, no, but the idea is that the write lock is used when changing the connection state, and in this location that's what we're doing, so we want to block any readers until it is updated.", "author": "MikeDombo", "createdAt": "2020-06-10T20:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1NTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1OTI3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438359275", "bodyText": "Add timeout?\nAdd exception handling? It should throw checked exceptions which the calling client can use to put appropriate handling.", "author": "abanthiy", "createdAt": "2020-06-10T19:29:40Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final AtomicInteger subscriptionCount = new AtomicInteger(0);\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(\"topic\", topic).kv(\"qos\", qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionCount.incrementAndGet();\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(\"topic\", topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionCount.decrementAndGet();\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(\"topic\", message.getTopic()).kv(\"qos\", qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            connect();\n+        }\n+    }\n+\n+    private void connect() throws ExecutionException, InterruptedException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                connection.connect().get();", "originalCommit": "dfb1f7137a94505ae1889e11768c6b5f8731d184", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5ODAxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438398019", "bodyText": "I can add a configurable timeout definitely. As for exceptions though, the SDK doesn't provide checked exceptions, so I really don't have any idea what might go wrong and how to best handle it yet. This needs much more testing with the cloud and under various network environments.", "author": "MikeDombo", "createdAt": "2020-06-10T20:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1OTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MDg1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438360853", "bodyText": "Do we need MqttClientConnectionEvents as well? Or a method which will be invoked as part of that?\nAnyone using this client wants to define what happens when connection is resumed/interrupted?", "author": "abanthiy", "createdAt": "2020-06-10T19:32:47Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final AtomicInteger subscriptionCount = new AtomicInteger(0);\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;", "originalCommit": "dfb1f7137a94505ae1889e11768c6b5f8731d184", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5NzA1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438397052", "bodyText": "No, clients don't get to decide what happens, this is all handled internally to our client.", "author": "MikeDombo", "createdAt": "2020-06-10T20:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MDg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyMDU5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438420591", "bodyText": "So for IotJobsHelper , it needs to resubscribe to the certain Jobs topics (Event Notifications and NextPendingJobDescription topics) when a connection is resumed. How do you see this being communicated back to JobsHelper or take care of it in this client (or the MqttClient)?", "author": "abanthiy", "createdAt": "2020-06-10T21:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MDg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyMjg2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438422864", "bodyText": "This client will need to handle that. By setting cleanSession to false, the client should automatically resubscribe, this is handled by the SDK.", "author": "MikeDombo", "createdAt": "2020-06-10T21:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MDg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MTEyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438441121", "bodyText": "I see. Thanks", "author": "abanthiy", "createdAt": "2020-06-10T22:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MDg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0NjIwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438446208", "bodyText": "I think I'll add subscriptions to the IndividualMqttClient also and manually call resubscribe when it reconnects, just as another fallback because I don't think that the cleanSession is guaranteed to stay around forever.", "author": "MikeDombo", "createdAt": "2020-06-10T22:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MDg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NzgyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438367821", "bodyText": "Do we need this for all config changes? If anything changes that kills the connection then any reconnect attempt should read the latest config. If cert path changes and the old one still exists then we probably need to establish a new connection.\nWe should not try to reconnect everytime anything in Device config changes, since it costs. For eg. a change in credential endpoint alone does not require Mqtt connection to be restablished? So I am thinking maybe define more specifically when to attempt to reconnect?", "author": "abanthiy", "createdAt": "2020-06-10T19:46:04Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {", "originalCommit": "dfb1f7137a94505ae1889e11768c6b5f8731d184", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwMzcyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438403722", "bodyText": "We can scope it down to the specific keys we care about by inspecting the node.", "author": "MikeDombo", "createdAt": "2020-06-10T20:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NzgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzMzY1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438433656", "bodyText": "Changed it to list the specific nodes that we care about (which is almost all of them right now).", "author": "MikeDombo", "createdAt": "2020-06-10T22:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NzgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3NjQ4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438376487", "bodyText": "Why do we need WriteLockScope?\nLockScope.lock(connectionLock.writeLock()) won't work?", "author": "abanthiy", "createdAt": "2020-06-10T20:02:23Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what)) {\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {", "originalCommit": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4OTM4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438389388", "bodyText": "Because you can't upgrade a read lock to a write lock, but the WriteLockScope I provide does allow that behavior.\nWithout it, it will deadlock waiting for the readlocks to be released.", "author": "MikeDombo", "createdAt": "2020-06-10T20:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3NjQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3OTI0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438379245", "bodyText": "why do you need to do this again? Isn't it happening in L190?", "author": "abanthiy", "createdAt": "2020-06-10T20:08:09Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what)) {\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     */\n+    public void unsubscribe(UnsubscribeRequest request) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIncludes(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || connections.stream().noneMatch(IndividualMqttClient::canAddNewSubscription)\n+                && forSubscription) {\n+            connections.add(getNewMqttClient());\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<IndividualMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (IndividualMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // If this connection is to add a new subscription, then don't provide a connection\n+        // which is already maxed out on subscriptions\n+        if (forSubscription) {\n+            return connections.stream().filter(IndividualMqttClient::canAddNewSubscription).findAny().orElseGet(() -> {\n+                IndividualMqttClient client = getNewMqttClient();\n+                connections.add(client);\n+                return client;", "originalCommit": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5NjQ0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438396445", "bodyText": "It made unit testing easier, but I can remove it.", "author": "MikeDombo", "createdAt": "2020-06-10T20:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3OTI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438384762", "bodyText": "Should the callback be made optional in the unsubscribe request?", "author": "abanthiy", "createdAt": "2020-06-10T20:19:33Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what)) {\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     */\n+    public void unsubscribe(UnsubscribeRequest request) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));", "originalCommit": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4OTg1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438389857", "bodyText": "No, it can't be optional because otherwise we don't know who to unsubscribe. We can have many subscribers on the same topic, each with their own callbacks.", "author": "MikeDombo", "createdAt": "2020-06-10T20:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNjM4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438426384", "bodyText": "I don't see callback tied to subscriptions very intuitive. If I want to cancel a subscription to a topic, I should just need to topic name. And if so then we should cancel all subscribers to that topic. If I want to cancel a particular subscriber that is when I can provide a callback to you for matching.", "author": "abanthiy", "createdAt": "2020-06-10T21:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyOTk4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438429988", "bodyText": "If we have 2 pieces of code which both subscribe to \"A/B/C\" and then one of them wants to stop receiving callbacks, what do you want it to do?\nIn this implementation we can have as many internal subscribers as we want, associated with a smaller number of cloud subscriptions. And subscribers can unsubscribe at any time as they please.", "author": "MikeDombo", "createdAt": "2020-06-10T21:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzNDk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438434991", "bodyText": "In the described scenario, in an unsubscribe call,  I can provide the callback  which I intend to stop receiving the messages.\nMaking callback optional in unsubscribe does not take away the functionality you mention.\nIn another case, if I want to cancel all the subscribers for a topic, in this implementation I need to keep track of all callbacks.", "author": "abanthiy", "createdAt": "2020-06-10T22:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzODAyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438438022", "bodyText": "But one piece of code should not have the ability to unsubscribe someone else just because they didn't know what their callback was.", "author": "MikeDombo", "createdAt": "2020-06-10T22:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0NTEyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438445121", "bodyText": "Ya that's fair.", "author": "abanthiy", "createdAt": "2020-06-10T22:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NjIzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438386236", "bodyText": "seems less readable to me.", "author": "abanthiy", "createdAt": "2020-06-10T20:22:24Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -231,15 +231,15 @@ void GIVEN_kernel_WHEN_shutdown_THEN_shutsdown_services_in_order(ExtensionContex\n         CountDownLatch seenErrors = new CountDownLatch(2);\n         Pair<CompletableFuture<Void>, Consumer<EvergreenStructuredLogMessage>> listener =\n                 TestUtils.asyncAssertOnConsumer((m) -> {\n-            if(m.getEventType().equals(\"service-shutdown-error\")) {\n+            if(\"service-shutdown-error\".equals(m.getEventType())) {", "originalCommit": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5MDExMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438390112", "bodyText": "This is needed because the event type can be null, so the .equals() causes a NPE. Flipping it is preferred because it avoids this possibility.", "author": "MikeDombo", "createdAt": "2020-06-10T20:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NjIzNg=="}], "type": "inlineReview"}, {"oid": "0a9411a11ce04892dbce6284c53bf9ccfe8da38d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0a9411a11ce04892dbce6284c53bf9ccfe8da38d", "message": "Address PR comments", "committedDate": "2020-06-10T21:11:52Z", "type": "forcePushed"}, {"oid": "75c04df5a44bcb96105bbbd1086711d8e8b2dd65", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/75c04df5a44bcb96105bbbd1086711d8e8b2dd65", "message": "Address PR comments", "committedDate": "2020-06-10T21:31:23Z", "type": "forcePushed"}, {"oid": "b79328651316a9c14efce20498d04199dc7abfeb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b79328651316a9c14efce20498d04199dc7abfeb", "message": "Address PR comments", "committedDate": "2020-06-10T21:40:40Z", "type": "forcePushed"}, {"oid": "313e7152dcb48c9cb8213ed69051e1b78c5487f0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/313e7152dcb48c9cb8213ed69051e1b78c5487f0", "message": "Address PR comments", "committedDate": "2020-06-10T23:17:20Z", "type": "forcePushed"}, {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/32c4839f0e51279ed73d6309d7e10e758667b829", "message": "Fix topic superset test", "committedDate": "2020-06-11T21:13:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyMDM3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439120370", "bodyText": "Curious why you need to create a new class here instead of just implementing the logic?", "author": "ShirleyZheng92", "createdAt": "2020-06-11T23:14:38Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttTopic.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class MqttTopic {\n+    private static final String SINGLE_LEVEL_WILDCARD = \"+\";\n+    private static final String MULTILEVEL_WILDCARD = \"#\";\n+    private static final String TOPIC_PATH_SEPARATOR = \"/\";\n+\n+    private final String topic;\n+    private final List<String> subscriptionParts;\n+\n+    public MqttTopic(String topic) {\n+        this.topic = topic;\n+        subscriptionParts = Arrays.asList(topic.split(TOPIC_PATH_SEPARATOR));\n+    }\n+\n+    /**\n+     * Returns true if the topic that is the current instance is a superset (includes) or equals the provided topic\n+     * string. For example, A/B and A/B would be true because they are equal. A/+ and A/B would also work because of the\n+     * wildcard, as would A/# and A/B/C/# because the first one's wildcard includes all of the second.\n+     *\n+     * @param testTopic topic to compare against\n+     * @return true if this instance equals or contains the testTopic\n+     */\n+    public boolean includes(String testTopic) {\n+        if (this.topic.equals(testTopic)) {\n+            return true;\n+        }\n+\n+        MqttTopic tester = new MqttTopic(testTopic);\n+\n+        int i;\n+        for (i = 0; i < Math.min(subscriptionParts.size(), tester.subscriptionParts.size()); i++) {\n+            if (MULTILEVEL_WILDCARD.equals(subscriptionParts.get(i))) {\n+                return true;\n+            }\n+            if (SINGLE_LEVEL_WILDCARD.equals(subscriptionParts.get(i))) {\n+                continue; // single wildcard, continue to match on the rest of the topic\n+            }\n+            String testStr = tester.subscriptionParts.get(i);\n+            if (!subscriptionParts.get(i).equals(testStr)) {\n+                return false;\n+            }\n+        }\n+        // If we didn't make it to the end of either topic, then it doesn't match\n+        return i >= tester.subscriptionParts.size() && i >= subscriptionParts.size();\n+    }\n+\n+    public static boolean topicIncludes(String topic, String testTopic) {\n+        return new MqttTopic(topic).includes(testTopic);", "originalCommit": "32c4839f0e51279ed73d6309d7e10e758667b829", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MzMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439153306", "bodyText": "Because creating it gives me access to the subscriptionParts.", "author": "MikeDombo", "createdAt": "2020-06-12T01:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyMDM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyOTgyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439129825", "bodyText": "NIT: DEVICE_MQTT_NAMESPACE is duplicated here.\nI'd prefer in this way:\nCONFIG_TO_CHECK = Arrays.asList(DEVICE_PARAM_THING_NAME, DEVICE_PARAM...)\nif (node.childOf(DEVICE_MQTT_NAMESPACE) || CONFIG_TO_CHECK.contians(node.getName())) {\n}\n\nor even make these configs checks in DeviceConfiguration static class", "author": "ShirleyZheng92", "createdAt": "2020-06-11T23:48:00Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {", "originalCommit": "32c4839f0e51279ed73d6309d7e10e758667b829", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzMDIzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439130238", "bodyText": "topic subscriber is global blocking. Will this reconnect() be blocking?", "author": "ShirleyZheng92", "createdAt": "2020-06-11T23:49:39Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {\n+                    return;\n+                }\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();", "originalCommit": "32c4839f0e51279ed73d6309d7e10e758667b829", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0NjM3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439146371", "bodyText": "I'm confused between sessionPresent and currentlyConnected. What are the diffence between them?", "author": "ShirleyZheng92", "createdAt": "2020-06-12T00:33:49Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                boolean sessionPresent = connection.connect()\n+                        .get(Coerce.toInt(\n+                                mqttTopics.findOrDefault(DEFAULT_MQTT_CONNECT_TIMEOUT, MQTT_CONNECT_TIMEOUT_KEY)),\n+                        TimeUnit.MILLISECONDS);\n+                currentlyConnected.set(true);\n+                logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n+                return sessionPresent;", "originalCommit": "32c4839f0e51279ed73d6309d7e10e758667b829", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MzYzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439153631", "bodyText": "sessionPresent is a MQTT protocol thing it means that the server remembered us and automatically resubscribed us to topics we had before. And currentlyConnected is as it sounds a flag to know if we're connected or not.", "author": "MikeDombo", "createdAt": "2020-06-12T01:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0NjM3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDMyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439944326", "bodyText": "Then maybe connected() can return sessionPresent instead of the flag value?", "author": "ShirleyZheng92", "createdAt": "2020-06-15T05:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0NjM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0Nzc2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439147768", "bodyText": "disconnect clear all subscriptionTopics. Is this desired behavior?", "author": "ShirleyZheng92", "createdAt": "2020-06-12T00:39:37Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();", "originalCommit": "32c4839f0e51279ed73d6309d7e10e758667b829", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MzkyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439153923", "bodyText": "Not really. Fixed.", "author": "MikeDombo", "createdAt": "2020-06-12T01:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0Nzc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0OTA0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439149045", "bodyText": "why not return the new mqtt client here directly?", "author": "ShirleyZheng92", "createdAt": "2020-06-12T00:44:53Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {\n+                    return;\n+                }\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIncludes(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(IndividualMqttClient::canAddNewSubscription)) {\n+            connections.add(getNewMqttClient());", "originalCommit": "32c4839f0e51279ed73d6309d7e10e758667b829", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTk1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439151950", "bodyText": "can getConnection return null?", "author": "ShirleyZheng92", "createdAt": "2020-06-12T00:55:55Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {\n+                    return;\n+                }\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);", "originalCommit": "32c4839f0e51279ed73d6309d7e10e758667b829", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NDg4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439154881", "bodyText": "no", "author": "MikeDombo", "createdAt": "2020-06-12T01:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTk1MA=="}], "type": "inlineReview"}, {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "message": "Rename", "committedDate": "2020-06-12T07:16:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE2ODg5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439168896", "bodyText": "I am not sure what is meaning of \"node.childOf(*)\". Seems like it should only be true is the node is not the child of any other nodes. Under what situation, it may happen?", "author": "awszztt", "createdAt": "2020-06-12T02:06:57Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -114,18 +119,20 @@ protected MqttClient(DeviceConfiguration deviceConfiguration,\n                 // List of configuration nodes that we need to reconfigure for if they change\n                 if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node", "originalCommit": "0dc461742b4757ec8c38ee477ca2f0fd53bff5be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MDg1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439540851", "bodyText": "childOf(x) means that the node that we run this function on either is named x or exists under a tree containing the node named x.\nThis is checking if we should reconfigure the connection which only needs to happen when we change one or more of a specific set of keys in the config. If any MQTT things change, then we need to reconfigure. Likewise if the certificate or endpoint changes we also need to reconfigure.", "author": "MikeDombo", "createdAt": "2020-06-12T17:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE2ODg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1Njc4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439956784", "bodyText": "If forSubscription == true, You still need to check canAddNewSubscription() here", "author": "ShirleyZheng92", "createdAt": "2020-06-15T06:34:37Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIsSupersetOf(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(IndividualMqttClient::canAddNewSubscription)) {\n+            IndividualMqttClient conn = getNewMqttClient();\n+            connections.add(conn);\n+            return conn;\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<IndividualMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (IndividualMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // Get a somewhat random, somewhat round robin connection\n+        return connections.get(connectionRoundRobin.getAndIncrement() % connections.size());", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwODY0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440408648", "bodyText": "I had this check before, but removed it. I will add it back.", "author": "MikeDombo", "createdAt": "2020-06-15T19:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1Njc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1OTY5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439959694", "bodyText": "NIT: Maybe use MqttTopic for the Pair.left?", "author": "ShirleyZheng92", "createdAt": "2020-06-15T06:42:32Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1OTk3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439959972", "bodyText": "NIT: this seems inefficient as it takes N^2 time. Maybe set subscriptions to Map<MqttTopic, List> ?", "author": "ShirleyZheng92", "createdAt": "2020-06-15T06:43:15Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5ODk3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440298975", "bodyText": "What's n^2 about this, we're just going through the subscription list twice, so 2n==n.", "author": "MikeDombo", "createdAt": "2020-06-15T16:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1OTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2MTU4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439961581", "bodyText": "Do we guarantee mutual exclusive in subscription?\nSay, we subscribe to /foo/bar first, then fill up the 50 subscriptions. Then we subscribe to /foo next, which will create another mqtt client. Both will have a message handler. When a message comes to 'foo/bar', both connection message handler will be invoked, cause the message to be delivered twice.", "author": "ShirleyZheng92", "createdAt": "2020-06-15T06:47:30Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5OTI4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440299281", "bodyText": "Good call, I'll need to check the handling to make sure we do it correctly.", "author": "MikeDombo", "createdAt": "2020-06-15T16:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2MTU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwNzE1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440407152", "bodyText": "Made a fix to determine the closest match for each subscription and then check to see that the client matches. This will ensure that each subscriber is only called once, even if a subscription which includes the topic exists in multiple clients (only one of those clients will have the closest match for the subscription topic).", "author": "MikeDombo", "createdAt": "2020-06-15T19:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2MTU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI1Nzg0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440257843", "bodyText": "Do we need this to move readwrite lock from read lock to write lock and back ? Can we just lock/unlock the write lock  using try/finally ?", "author": "fahadmohammed01", "createdAt": "2020-06-15T15:25:21Z", "path": "src/main/java/com/aws/iot/evergreen/util/WriteLockScope.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.util;\n+\n+import java.util.concurrent.locks.ReadWriteLock;\n+\n+public final class WriteLockScope implements AutoCloseable {", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5Njk4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440296984", "bodyText": "Yes, this needs to do that. It can't just take the write lock because the read lock is already held and must be released first. This is used when called from methods which may or may not be holding the read lock, so this can actually check if it is held or not.", "author": "MikeDombo", "createdAt": "2020-06-15T16:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI1Nzg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTcyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440285725", "bodyText": "What are the acceptable values? Add a comment?", "author": "fengwang666", "createdAt": "2020-06-15T16:06:27Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/PublishRequest.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+@Builder\n+@Value\n+public class PublishRequest {\n+    @NonNull String topic;\n+    @Builder.Default\n+    @NonNull QualityOfService qos = QualityOfService.AT_LEAST_ONCE;", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMDM1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440410355", "bodyText": "Why add a comment? It is an enum so the acceptable values are in the enum.\nThis type (QualityOfService) is in the AWS Device SDK.", "author": "MikeDombo", "createdAt": "2020-06-15T19:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTk4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440285981", "bodyText": "What is retain? Add a comment?", "author": "fengwang666", "createdAt": "2020-06-15T16:06:49Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/PublishRequest.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+@Builder\n+@Value\n+public class PublishRequest {\n+    @NonNull String topic;\n+    @Builder.Default\n+    @NonNull QualityOfService qos = QualityOfService.AT_LEAST_ONCE;\n+    boolean retain;", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMDYxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440410615", "bodyText": "Part of MQTT protocol. I will add a comment, but this is all just standard MQTT.", "author": "MikeDombo", "createdAt": "2020-06-15T19:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5Mjk3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440292978", "bodyText": "Add doc?\nAlso is \"AwsIoTMqttClient\" a better name?", "author": "fengwang666", "createdAt": "2020-06-15T16:17:58Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5MDk3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440390979", "bodyText": "Sure.", "author": "MikeDombo", "createdAt": "2020-06-15T19:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5Mjk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NjY1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440296655", "bodyText": "Should we use random uuid? I think the client id should include thing name at least for easier debugging. I wouldn't mind the first connection use the thing name, the second uses \"thingname-1\", and go on, .... This way at least the first connection can use IoT thing policy variable", "author": "fengwang666", "createdAt": "2020-06-15T16:23:50Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIsSupersetOf(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(IndividualMqttClient::canAddNewSubscription)) {\n+            IndividualMqttClient conn = getNewMqttClient();\n+            connections.add(conn);\n+            return conn;\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<IndividualMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (IndividualMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // Get a somewhat random, somewhat round robin connection\n+        return connections.get(connectionRoundRobin.getAndIncrement() % connections.size());\n+    }\n+\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    Consumer<MqttMessage> getMessageHandlerForClient(String clientId) {\n+        return (message) -> {\n+            logger.atTrace().kv(CLIENT_ID_KEY, clientId).kv(\"topic\", message.getTopic()).log(\"Received MQTT message\");\n+            Set<SubscribeRequest> subs =\n+                    subscriptions.stream().filter(s -> MqttTopic.topicIsSupersetOf(s.getTopic(), message.getTopic()))\n+                            .collect(Collectors.toSet());\n+            if (subs.isEmpty()) {\n+                logger.atError().kv(\"topic\", message.getTopic()).kv(CLIENT_ID_KEY, clientId)\n+                        .log(\"Somehow got message from topic that no one subscribed to\");\n+                return;\n+            }\n+            subs.forEach((h) -> {\n+                try {\n+                    h.getCallback().accept(message);\n+                } catch (Throwable t) {\n+                    logger.atError().kv(\"message\", message).kv(CLIENT_ID_KEY, clientId)\n+                            .log(\"Unhandled error in MQTT message callback\", t);\n+                }\n+            });\n+        };\n+    }\n+\n+    protected IndividualMqttClient getNewMqttClient() {\n+        String clientId = UUID.randomUUID().toString();", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwOTUxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440409515", "bodyText": "OK, done.", "author": "MikeDombo", "createdAt": "2020-06-15T19:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5OTA4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440299089", "bodyText": "Why do you need to lock here?", "author": "fengwang666", "createdAt": "2020-06-15T16:27:51Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5MTI0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440391243", "bodyText": "Removed lock to rely just on synchronized", "author": "MikeDombo", "createdAt": "2020-06-15T19:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5OTA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNDg5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440324891", "bodyText": "debug level?", "author": "fengwang666", "createdAt": "2020-06-15T17:12:58Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNDUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440334530", "bodyText": "Remove TimeoutException?", "author": "fengwang666", "createdAt": "2020-06-15T17:30:14Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5NjkzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440396933", "bodyText": "Not possible because the connect call can timeout (unless we want to wrap the exception with something else of course). All exception handling needs to be rethought, especially once we add spooling.", "author": "MikeDombo", "createdAt": "2020-06-15T19:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNDUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNDY5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440334696", "bodyText": "Do we need to add a timeout in get()?", "author": "fengwang666", "createdAt": "2020-06-15T17:30:31Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MDkyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440350925", "bodyText": "It's worth adding a comment explaining why we're add handler on the onMessage() method.", "author": "fengwang666", "createdAt": "2020-06-15T18:00:24Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MTQ3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440351475", "bodyText": "debug level?", "author": "fengwang666", "createdAt": "2020-06-15T18:01:25Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MTU4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440351580", "bodyText": "debug level?", "author": "fengwang666", "createdAt": "2020-06-15T18:01:38Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                boolean sessionPresent = connection.connect()\n+                        .get(Coerce.toInt(\n+                                mqttTopics.findOrDefault(DEFAULT_MQTT_CONNECT_TIMEOUT, MQTT_CONNECT_TIMEOUT_KEY)),\n+                        TimeUnit.MILLISECONDS);\n+                currentlyConnected.set(true);\n+                logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2Mjk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440362996", "bodyText": "We probably shouldn't populate ExecutionException, InterruptedException, TimeoutException up to the caller. We should handle the exception here and throw more meaningful exception back to the caller. The same applies to the other public methods in this class.", "author": "fengwang666", "createdAt": "2020-06-15T18:23:20Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIsSupersetOf(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5MDUzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441690535", "bodyText": "I don't see reply on this comment.", "author": "fengwang666", "createdAt": "2020-06-17T16:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2Mjk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NzY5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441697691", "bodyText": "I'm going to rework the exception handling when working on spooling, that's why I didn't change any error handling yet.", "author": "MikeDombo", "createdAt": "2020-06-17T17:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2Mjk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDM2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440370363", "bodyText": "There is potentially a race condition with getMessageHandlerForClient() method. If a subscribe() fails after line 158, the subscribeRequest is added into subscriptions, even though the customer thought the subscribe() call failed. If next time the customer successfully subscribed to the same topic with a different handler, then the message hanlder in the previously failed subscribeRequest will also be triggered by a message to the topic.\nSimilar to the other comment, we should handle the exceptions of connection.subscribe() here and remove the request from subscriptions if the call fails.", "author": "fengwang666", "createdAt": "2020-06-15T18:36:44Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwNjUyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440406524", "bodyText": "You're absolutely right. I have added a handler to the subscribe call to remove the subscription if it fails.", "author": "MikeDombo", "createdAt": "2020-06-15T19:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjI1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440372252", "bodyText": "why lock?", "author": "fengwang666", "createdAt": "2020-06-15T18:40:20Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                boolean sessionPresent = connection.connect()\n+                        .get(Coerce.toInt(\n+                                mqttTopics.findOrDefault(DEFAULT_MQTT_CONNECT_TIMEOUT, MQTT_CONNECT_TIMEOUT_KEY)),\n+                        TimeUnit.MILLISECONDS);\n+                currentlyConnected.set(true);\n+                logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n+                return sessionPresent;\n+            }\n+        }\n+    }\n+\n+    private void resubscribe() {\n+        subscriptionTopics.forEach(s -> {\n+            try {\n+                subscribe(s.getLeft(), s.getRight());\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                logger.atError().kv(TOPIC_KEY, s.getLeft()).kv(QOS_KEY, s.getRight().name())\n+                        .log(\"Unable to resubscribe to topic\");\n+            }\n+        });\n+    }\n+\n+    boolean canAddNewSubscription() {\n+        return subscriptionTopics.size() < MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+    }\n+\n+    int subscriptionCount() {\n+        return subscriptionTopics.size();\n+    }\n+\n+    boolean connected() {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3OTk1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440379951", "bodyText": "Is it true that, if tryLock() return false, then someone must be holding the readLock? What if another thread is holding the writeLock?  In that case when close() is called, readLock() is acquired, which is wrong.", "author": "fengwang666", "createdAt": "2020-06-15T18:54:48Z", "path": "src/main/java/com/aws/iot/evergreen/util/WriteLockScope.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.util;\n+\n+import java.util.concurrent.locks.ReadWriteLock;\n+\n+public final class WriteLockScope implements AutoCloseable {\n+    private final ReadWriteLock ref;\n+    private boolean heldRead = false;\n+\n+    private WriteLockScope(ReadWriteLock ref) {\n+        this.ref = ref;\n+        if (!ref.writeLock().tryLock()) {\n+            ref.readLock().unlock();", "originalCommit": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c6942454ad79ebb344baff77851b3aa2b83c470a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c6942454ad79ebb344baff77851b3aa2b83c470a", "message": "Address PR comments", "committedDate": "2020-06-15T19:56:05Z", "type": "forcePushed"}, {"oid": "50b315aa6919888363153d5c5c8e522713779504", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/50b315aa6919888363153d5c5c8e522713779504", "message": "Address PR comments", "committedDate": "2020-06-15T20:06:27Z", "type": "forcePushed"}, {"oid": "242f517a37a483348bcf76165f98f7207c83c65d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/242f517a37a483348bcf76165f98f7207c83c65d", "message": "Address PR comments", "committedDate": "2020-06-15T20:15:39Z", "type": "forcePushed"}, {"oid": "33fcd6f5f2638bcf8f6684a8ff7b0577021c534d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33fcd6f5f2638bcf8f6684a8ff7b0577021c534d", "message": "Address PR comments", "committedDate": "2020-06-15T20:40:23Z", "type": "forcePushed"}, {"oid": "ddcb664dbcc93b9163340cb6a93a13dc294b9639", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ddcb664dbcc93b9163340cb6a93a13dc294b9639", "message": "Address PR comments", "committedDate": "2020-06-15T20:54:06Z", "type": "forcePushed"}, {"oid": "5156dff59d8ff76794be4b4308b09d2b64f8b892", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5156dff59d8ff76794be4b4308b09d2b64f8b892", "message": "New MQTT client", "committedDate": "2020-06-17T01:50:57Z", "type": "commit"}, {"oid": "3d068d0605afb7f4c6128db84519bc1c6f92c773", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3d068d0605afb7f4c6128db84519bc1c6f92c773", "message": "Address PR comments", "committedDate": "2020-06-17T01:50:57Z", "type": "commit"}, {"oid": "28d0e2a5faaa97b6ac664d72a998c064e5573f9d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/28d0e2a5faaa97b6ac664d72a998c064e5573f9d", "message": "Fix topic superset test", "committedDate": "2020-06-17T01:50:57Z", "type": "commit"}, {"oid": "3b9cdb5fa409fd4bbb5fbc47d2f8d8b78ebe476b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b9cdb5fa409fd4bbb5fbc47d2f8d8b78ebe476b", "message": "Address PR comments", "committedDate": "2020-06-17T01:50:57Z", "type": "commit"}, {"oid": "23d33f224e6783f147d5c36f2754f3d601496123", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/23d33f224e6783f147d5c36f2754f3d601496123", "message": "Rename", "committedDate": "2020-06-17T01:50:57Z", "type": "commit"}, {"oid": "f71f4f64f52456064eb656ea72c123584858b414", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f71f4f64f52456064eb656ea72c123584858b414", "message": "Deduplicate messages in callback", "committedDate": "2020-06-17T01:50:57Z", "type": "commit"}, {"oid": "d2f8b8181ed88b157b512601938fa1e3491023da", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d2f8b8181ed88b157b512601938fa1e3491023da", "message": "Address PR comments", "committedDate": "2020-06-17T01:50:57Z", "type": "commit"}, {"oid": "f023a3250d7438b53ceed241b9f5be696a332d42", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f023a3250d7438b53ceed241b9f5be696a332d42", "message": "Precompute client for each subscription topic", "committedDate": "2020-06-17T01:50:57Z", "type": "forcePushed"}, {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3add4b37c76c904cae81efa70659f68ed7da9a69", "message": "Precompute client for each subscription topic", "committedDate": "2020-06-17T01:53:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NTYzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441675637", "bodyText": "Is synchronized necessary here?", "author": "fengwang666", "createdAt": "2020-06-17T16:31:47Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/AwsIotMqttClient.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_OPERATION_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_OPERATION_TIMEOUT_KEY;\n+\n+/**\n+ * Wrapper for a single AWS IoT MQTT client connection.\n+ * Do not use except through {@link MqttClient}.\n+ */\n+class AwsIotMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(AwsIotMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    @SuppressFBWarnings(\"IS2_INCONSISTENT_SYNC\")\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            currentlyConnected.set(false);\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            currentlyConnected.set(true);\n+            // If we didn't reconnect using the same session, then resubscribe to all the topics\n+            if (!sessionPresent) {\n+                resubscribe();\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, QualityOfService> subscriptionTopics = new ConcurrentHashMap<>();\n+\n+    AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n+                     Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n+                     String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+        this.messageHandler = messageHandler.apply(this);\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+        connection.subscribe(topic, qos).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.put(topic, qos);\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+        connection.unsubscribe(topic).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.remove(topic);\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                .log(\"Publishing message\");\n+        connection.publish(message, qos, retain).get(getTimeout(), TimeUnit.MILLISECONDS);\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        // Synchronize here instead of method signature to make mockito work without deadlocking\n+        synchronized (this) {", "originalCommit": "3add4b37c76c904cae81efa70659f68ed7da9a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5ODk4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441698985", "bodyText": "I only want 1 thing to be reconnecting at a time, so even though it is only called from one place, I want to be extra sure that we don't do anything silly during the reconnection and especially the resubscription.", "author": "MikeDombo", "createdAt": "2020-06-17T17:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NzI1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441677259", "bodyText": "Does this need to be public? Can it be package level like the other methods?", "author": "fengwang666", "createdAt": "2020-06-17T16:34:39Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/AwsIotMqttClient.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_OPERATION_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_OPERATION_TIMEOUT_KEY;\n+\n+/**\n+ * Wrapper for a single AWS IoT MQTT client connection.\n+ * Do not use except through {@link MqttClient}.\n+ */\n+class AwsIotMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(AwsIotMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    @SuppressFBWarnings(\"IS2_INCONSISTENT_SYNC\")\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            currentlyConnected.set(false);\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            currentlyConnected.set(true);\n+            // If we didn't reconnect using the same session, then resubscribe to all the topics\n+            if (!sessionPresent) {\n+                resubscribe();\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, QualityOfService> subscriptionTopics = new ConcurrentHashMap<>();\n+\n+    AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n+                     Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n+                     String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+        this.messageHandler = messageHandler.apply(this);\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+        connection.subscribe(topic, qos).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.put(topic, qos);\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+        connection.unsubscribe(topic).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.remove(topic);\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                .log(\"Publishing message\");\n+        connection.publish(message, qos, retain).get(getTimeout(), TimeUnit.MILLISECONDS);\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        // Synchronize here instead of method signature to make mockito work without deadlocking\n+        synchronized (this) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private synchronized boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        if (connected()) {\n+            return true;\n+        }\n+\n+        // Always use the builder provider here so that the builder is updated with whatever\n+        // the latest device config is\n+        try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+            builder.withConnectionEventCallbacks(connectionEventCallback);\n+            builder.withClientId(clientId);\n+\n+            connection = builder.build();\n+            // Set message handler for this connection to be our global message handler.\n+            // The handler will then send out the message to all subscribers.\n+            connection.onMessage(messageHandler);\n+            logger.atDebug().log(\"Connecting to AWS IoT Core\");\n+            boolean sessionPresent = connection.connect().get(getTimeout(), TimeUnit.MILLISECONDS);\n+            currentlyConnected.set(true);\n+            logger.atDebug().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n+            return sessionPresent;\n+        }\n+    }\n+\n+    private int getTimeout() {\n+        return Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_OPERATION_TIMEOUT, MQTT_OPERATION_TIMEOUT_KEY));\n+    }\n+\n+    private void resubscribe() {\n+        subscriptionTopics.forEach((key, value) -> {\n+            try {\n+                subscribe(key, value);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                logger.atError().kv(TOPIC_KEY, key).kv(QOS_KEY, value.name()).log(\"Unable to resubscribe to topic\");\n+            }\n+        });\n+    }\n+\n+    boolean canAddNewSubscription() {\n+        return subscriptionTopics.size() < MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+    }\n+\n+    int subscriptionCount() {\n+        return subscriptionTopics.size();\n+    }\n+\n+    boolean connected() {\n+        return connection != null && currentlyConnected.get();\n+    }\n+\n+    private synchronized void disconnect() {\n+        try {\n+            currentlyConnected.set(false);\n+            if (connection != null) {\n+                logger.atDebug().log(\"Disconnecting from AWS IoT Core\");\n+                try {\n+                    connection.disconnect().get(getTimeout(), TimeUnit.MILLISECONDS);\n+                } finally {\n+                    connection.close();\n+                }\n+                logger.atDebug().log(\"Successfully disconnected from AWS IoT Core\");\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.atError().log(\"Error while disconnecting the MQTT client\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {", "originalCommit": "3add4b37c76c904cae81efa70659f68ed7da9a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5OTk2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441699966", "bodyText": "Yes, to implement Closable it must be public.", "author": "MikeDombo", "createdAt": "2020-06-17T17:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3OTQ5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441679499", "bodyText": "Is this the right error handling?", "author": "fengwang666", "createdAt": "2020-06-17T16:38:18Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_OPERATION_TIMEOUT_KEY = \"operationTimeoutMs\";\n+    static final int DEFAULT_MQTT_OPERATION_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<AwsIotMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n+    private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService     executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (AwsIotMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");", "originalCommit": "3add4b37c76c904cae81efa70659f68ed7da9a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcwNDI5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441704291", "bodyText": "Adding a todo to reinvestigate the error handling here. Again, this PR is already quite large and I want to get it merged and then iterate on it.", "author": "MikeDombo", "createdAt": "2020-06-17T17:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3OTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcxNDQwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441714400", "bodyText": "Updated handling.", "author": "MikeDombo", "createdAt": "2020-06-17T17:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3OTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4Mjg1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441682857", "bodyText": "I think this comment misses the key point that MqttClient handles topic filtering and triggers the message handler corresponding to each subscription.", "author": "fengwang666", "createdAt": "2020-06-17T16:43:33Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/AwsIotMqttClient.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_OPERATION_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_OPERATION_TIMEOUT_KEY;\n+\n+/**\n+ * Wrapper for a single AWS IoT MQTT client connection.\n+ * Do not use except through {@link MqttClient}.\n+ */\n+class AwsIotMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(AwsIotMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    @SuppressFBWarnings(\"IS2_INCONSISTENT_SYNC\")\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            currentlyConnected.set(false);\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            currentlyConnected.set(true);\n+            // If we didn't reconnect using the same session, then resubscribe to all the topics\n+            if (!sessionPresent) {\n+                resubscribe();\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, QualityOfService> subscriptionTopics = new ConcurrentHashMap<>();\n+\n+    AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n+                     Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n+                     String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+        this.messageHandler = messageHandler.apply(this);\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+        connection.subscribe(topic, qos).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.put(topic, qos);\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+        connection.unsubscribe(topic).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.remove(topic);\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                .log(\"Publishing message\");\n+        connection.publish(message, qos, retain).get(getTimeout(), TimeUnit.MILLISECONDS);\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        // Synchronize here instead of method signature to make mockito work without deadlocking\n+        synchronized (this) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private synchronized boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        if (connected()) {\n+            return true;\n+        }\n+\n+        // Always use the builder provider here so that the builder is updated with whatever\n+        // the latest device config is\n+        try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+            builder.withConnectionEventCallbacks(connectionEventCallback);\n+            builder.withClientId(clientId);\n+\n+            connection = builder.build();\n+            // Set message handler for this connection to be our global message handler.\n+            // The handler will then send out the message to all subscribers.", "originalCommit": "3add4b37c76c904cae81efa70659f68ed7da9a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5OTA2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441699063", "bodyText": "OK, will update.", "author": "MikeDombo", "createdAt": "2020-06-17T17:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4Mjg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4OTg4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441689888", "bodyText": "Both unsubscribe and subscribe are synchronized, do you still the lock?", "author": "fengwang666", "createdAt": "2020-06-17T16:54:47Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_OPERATION_TIMEOUT_KEY = \"operationTimeoutMs\";\n+    static final int DEFAULT_MQTT_OPERATION_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<AwsIotMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n+    private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService     executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (AwsIotMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public synchronized void subscribe(SubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try {\n+            AwsIotMqttClient connection = null;\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> existingConnection =\n+                        findExistingSubscriberForTopic(request.getTopic());\n+                if (existingConnection.isPresent()) {\n+                    subscriptions.put(request, existingConnection.get().getValue());\n+                } else {\n+                    connection = getConnection(true);\n+                    subscriptions.put(request, connection);\n+                }\n+            }\n+\n+            try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+                // Connection isn't null, so we should subscribe to the topic\n+                if (connection != null) {\n+                    connection.subscribe(request.getTopic(), request.getQos());\n+                    subscriptionTopics.put(new MqttTopic(request.getTopic()), connection);\n+                }\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+            // If subscribing failed, then clean up the failed subscription callback\n+            subscriptions.remove(request);\n+            throw e;\n+        }\n+    }\n+\n+    private Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> findExistingSubscriberForTopic(String topic) {\n+        return subscriptionTopics.entrySet().stream().filter(s -> s.getKey().isSupersetOf(new MqttTopic(topic)))\n+                .findAny();\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public synchronized void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+        try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {", "originalCommit": "3add4b37c76c904cae81efa70659f68ed7da9a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcwNDYxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441704610", "bodyText": "Yes, the lock is used in the message handler when it sends out the subscription notifications.", "author": "MikeDombo", "createdAt": "2020-06-17T17:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4OTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5MjMzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441692331", "bodyText": "Shouldn't this method be synchronized as well?", "author": "fengwang666", "createdAt": "2020-06-17T16:58:32Z", "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_OPERATION_TIMEOUT_KEY = \"operationTimeoutMs\";\n+    static final int DEFAULT_MQTT_OPERATION_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<AwsIotMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n+    private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService     executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (AwsIotMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public synchronized void subscribe(SubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try {\n+            AwsIotMqttClient connection = null;\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> existingConnection =\n+                        findExistingSubscriberForTopic(request.getTopic());\n+                if (existingConnection.isPresent()) {\n+                    subscriptions.put(request, existingConnection.get().getValue());\n+                } else {\n+                    connection = getConnection(true);\n+                    subscriptions.put(request, connection);\n+                }\n+            }\n+\n+            try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+                // Connection isn't null, so we should subscribe to the topic\n+                if (connection != null) {\n+                    connection.subscribe(request.getTopic(), request.getQos());\n+                    subscriptionTopics.put(new MqttTopic(request.getTopic()), connection);\n+                }\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+            // If subscribing failed, then clean up the failed subscription callback\n+            subscriptions.remove(request);\n+            throw e;\n+        }\n+    }\n+\n+    private Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> findExistingSubscriberForTopic(String topic) {\n+        return subscriptionTopics.entrySet().stream().filter(s -> s.getKey().isSupersetOf(new MqttTopic(topic)))\n+                .findAny();\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public synchronized void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+        try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+            Set<Map.Entry<MqttTopic, AwsIotMqttClient>> deadSubscriptionTopics;\n+            for (Map.Entry<SubscribeRequest, AwsIotMqttClient> sub : subscriptions.entrySet()) {\n+                if (sub.getKey().getCallback() == request.getCallback() && sub.getKey().getTopic()\n+                        .equals(request.getTopic())) {\n+                    subscriptions.remove(sub.getKey());\n+                }\n+\n+            }\n+            // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+            deadSubscriptionTopics = subscriptionTopics.entrySet().stream().filter(s -> subscriptions.keySet().stream()\n+                    .noneMatch(sub -> s.getKey().isSupersetOf(new MqttTopic(sub.getTopic()))))\n+                    .collect(Collectors.toSet());\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Map.Entry<MqttTopic, AwsIotMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getValue().unsubscribe(sub.getKey().getTopic());\n+                    subscriptionTopics.remove(sub.getKey());\n+\n+                    // Since we changed the cloud subscriptions, we need to recalculate the client to use for each\n+                    // subscription, since it may have changed\n+                    subscriptions.entrySet().stream()\n+                            // if the cloud clients are the same, and the removed topic covered the topic\n+                            // that we're looking at, then recalculate that topic's client\n+                            .filter(s -> s.getValue() == sub.getValue() && sub.getKey()\n+                                    .isSupersetOf(new MqttTopic(s.getKey().getTopic()))).forEach(e -> {\n+                        // recalculate and replace the client\n+                        Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> subscriberForTopic =\n+                                findExistingSubscriberForTopic(e.getKey().getTopic());\n+                        if (subscriberForTopic.isPresent()) {\n+                            subscriptions.put(e.getKey(), subscriberForTopic.get().getValue());\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized AwsIotMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(AwsIotMqttClient::canAddNewSubscription)) {\n+            AwsIotMqttClient conn = getNewMqttClient();\n+            connections.add(conn);\n+            return conn;\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<AwsIotMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (AwsIotMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // If this connection is to add a new subscription, then don't provide a connection\n+        // which is already maxed out on subscriptions\n+        if (forSubscription) {\n+            return connections.stream().filter(AwsIotMqttClient::canAddNewSubscription).findAny().get();\n+        }\n+\n+        // Get a somewhat random, somewhat round robin connection\n+        return connections.get(connectionRoundRobin.getAndIncrement() % connections.size());\n+    }\n+\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    Consumer<MqttMessage> getMessageHandlerForClient(AwsIotMqttClient client) {\n+        return (message) -> {\n+            logger.atTrace().kv(CLIENT_ID_KEY, client.getClientId()).kv(\"topic\", message.getTopic())\n+                    .log(\"Received MQTT message\");\n+\n+            // Each subscription is associated with a single AWSIotMqttClient even if this\n+            // on-device subscription did not cause the cloud connection to be made.\n+            // By checking that the client matches the client for the subscription, we will\n+            // prevent duplicate messages occurring due to overlapping subscriptions between\n+            // multiple clients such as A/B and A/#. Without this, an update to A/B would\n+            // trigger twice if those 2 subscriptions were in different clients because\n+            // both will receive the message from the cloud and call this handler.\n+            Set<SubscribeRequest> subs = subscriptions.entrySet().stream()\n+                    .filter(s -> s.getValue() == client && MqttTopic\n+                            .topicIsSupersetOf(s.getKey().getTopic(), message.getTopic())).map(Map.Entry::getKey)\n+                    .collect(Collectors.toSet());\n+            if (subs.isEmpty()) {\n+                logger.atError().kv(\"topic\", message.getTopic()).kv(CLIENT_ID_KEY, client.getClientId())\n+                        .log(\"Somehow got message from topic that no one subscribed to\");\n+                return;\n+            }\n+            subs.forEach((h) -> {\n+                try {\n+                    h.getCallback().accept(message);\n+                } catch (Throwable t) {\n+                    logger.atError().kv(\"message\", message).kv(CLIENT_ID_KEY, client.getClientId())\n+                            .log(\"Unhandled error in MQTT message callback\", t);\n+                }\n+            });\n+        };\n+    }\n+\n+    protected AwsIotMqttClient getNewMqttClient() {\n+        // Name client by thingName-<number> except for the first connection which will just be thingName\n+        String clientId = Coerce.toString(deviceConfiguration.getThingName()) + (connections.isEmpty() ? \"\"\n+                : \"-\" + connections.size() + 1);\n+        return new AwsIotMqttClient(() -> builderProvider.apply(clientBootstrap), this::getMessageHandlerForClient,\n+                clientId, mqttTopics);\n+    }\n+\n+    public boolean connected() {\n+        return !connections.isEmpty() && connections.stream().anyMatch(AwsIotMqttClient::connected);\n+    }\n+\n+    @Override\n+    public void close() {", "originalCommit": "3add4b37c76c904cae81efa70659f68ed7da9a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcwNTEzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441705133", "bodyText": "I don't think it matters if this is called multiple times or from multiple threads, so not really. Also, it will only be called by the Context during shutdown, so it will only be called by a single thread anyway.", "author": "MikeDombo", "createdAt": "2020-06-17T17:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5MjMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcwODQ0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441708448", "bodyText": "I was thinking to synchronize close() with \"subscribe()\" and \"unsubscribe() so the close() is more graceful.", "author": "fengwang666", "createdAt": "2020-06-17T17:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5MjMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcxMzM1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441713350", "bodyText": "Sure, good idea. Done.", "author": "MikeDombo", "createdAt": "2020-06-17T17:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5MjMzMQ=="}], "type": "inlineReview"}, {"oid": "43a319390b81d3d67382661c41b75e99feeb8c39", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/43a319390b81d3d67382661c41b75e99feeb8c39", "message": "Precompute client for each subscription topic", "committedDate": "2020-06-17T17:21:14Z", "type": "commit"}, {"oid": "43a319390b81d3d67382661c41b75e99feeb8c39", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/43a319390b81d3d67382661c41b75e99feeb8c39", "message": "Precompute client for each subscription topic", "committedDate": "2020-06-17T17:21:14Z", "type": "forcePushed"}, {"oid": "ff1afb701ce9e3e4ea9642cc33ad38bca481b441", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ff1afb701ce9e3e4ea9642cc33ad38bca481b441", "message": "Address PR Comments", "committedDate": "2020-06-17T17:34:04Z", "type": "commit"}, {"oid": "19eb4e0596c7b44dc2570eb6c749e02e070684ea", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/19eb4e0596c7b44dc2570eb6c749e02e070684ea", "message": "Merge branch 'master' into mqtt", "committedDate": "2020-06-17T21:38:24Z", "type": "commit"}]}