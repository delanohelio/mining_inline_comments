{"pr_number": 101, "pr_title": "Config resolver with parameter interpolation", "pr_createdAt": "2020-03-07T00:04:50Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzM4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389203381", "bodyText": "All these gets should take a timeout, and that timeout should probably come from the caller of this deployment task, or something like that.", "author": "MikeDombo", "createdAt": "2020-03-07T00:22:33Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentTask.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.DependencyResolver;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.packagemanager.PackageCache;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+@AllArgsConstructor\n+public class DeploymentTask implements Callable<Void> {\n+    private final DependencyResolver dependencyResolver;\n+    private final PackageCache packageCache;\n+    private final KernelConfigResolver kernelConfigResolver;\n+    private final Kernel kernel;\n+    private final DeploymentDocument document;\n+\n+    @Override\n+    public Void call() throws Exception {\n+        List<PackageIdentifier> desiredPackages = dependencyResolver.resolveDependencies(document);\n+        packageCache.preparePackages(desiredPackages).get();", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNjUyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389206524", "bodyText": "Sure, I copied it as it is from Feng's PR, I think it will be taken care of when deployment code is cleaned up", "author": "shaguptashaikh", "createdAt": "2020-03-07T00:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzE4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389207186", "bodyText": "Sounds good.", "author": "MikeDombo", "createdAt": "2020-03-07T00:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzc0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389203748", "bodyText": "Seems like since this is the KernelConfigResolver that it should be the bridge between DA and Kernel. In that way, DA should not tell it what packages to remove, but I think that this class itself should determine what packages to remove.", "author": "MikeDombo", "createdAt": "2020-03-07T00:24:46Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNjk5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389206998", "bodyText": "This will be derived from the local map we will have in the device for fleet -> top level packages, at the moment I'm assuming deployment agent will have that information and so it can pass it on to the config resolver. Config resolver as it is will not be capable of finding out what to remove because that information is not in the deployment document", "author": "shaguptashaikh", "createdAt": "2020-03-07T00:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzg3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391833870", "bodyText": "Maybe add a TODO in DeploymentTask or somewhere else, that we need to find out this information rootPackagesToRemove.", "author": "hui-yang", "createdAt": "2020-03-12T19:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1MjU1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391852558", "bodyText": "Yeah added a TODO in DeploymentTask", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDA4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389204087", "bodyText": "[nit]\nUse method reference instead of lambda: EvergreenService::getName", "author": "MikeDombo", "createdAt": "2020-03-07T00:26:19Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Object childLifecycleKey : childLifecycleMap.keySet()) {\n+                interpolate(childLifecycleKey, childLifecycleMap, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment.\n+     *\n+     * @return main service with updated dependencies\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<String> rootPackagesToRemove, DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzAyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389207022", "bodyText": "Sure", "author": "shaguptashaikh", "createdAt": "2020-03-07T00:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDQ0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389204443", "bodyText": "Instead of null, why not just return the Optional?", "author": "MikeDombo", "createdAt": "2020-03-07T00:28:19Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Object childLifecycleKey : childLifecycleMap.keySet()) {\n+                interpolate(childLifecycleKey, childLifecycleMap, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment.\n+     *\n+     * @return main service with updated dependencies\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<String> rootPackagesToRemove, DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(rootPackagesToRemove);\n+        kernelDependencies.addAll(getRootPackagesToAdd(document).stream().map(PackageIdentifier::getName)\n+                .collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addConfigForServiceDependencies(mainLifecycleMap, kernelDependencies);\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    void addConfigForServiceDependencies(Map<Object, Object> lifecycle, final Set<String> dependencies) {\n+        lifecycle.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencies));\n+    }\n+\n+    boolean packageExistsInDeployment(DeploymentDocument document, PackageIdentifier packageIdentifier) {\n+        return getMatchingPackageConfigFromDeployment(document, packageIdentifier.getName(),\n+                packageIdentifier.getVersion().toString()) != null;\n+    }\n+\n+    DeploymentPackageConfiguration getMatchingPackageConfigFromDeployment(DeploymentDocument document,\n+                                                                          String packageName, String packageVersion) {\n+        return document.getDeploymentPackageConfigurationList().stream()\n+                .filter(packageConfig -> packageName.equals(packageConfig.getPackageName()) && packageVersion.toString()\n+                        .equals(packageConfig.getResolvedVersion())).findAny().orElse(null);", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzE3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389207172", "bodyText": "Sure, I have to clean up and optimize this code still, for now let's identify major conflicts with everyone's understanding on what this class should do", "author": "shaguptashaikh", "createdAt": "2020-03-07T00:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDc4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389204785", "bodyText": "I'm not too sure about the pojos we have right now, but this seems to be unnecessarily copying data by making a new PackageIdentifier. Is it possible to just use the existing package POJO that is in the getDeploymentPackageConfigurationList?", "author": "MikeDombo", "createdAt": "2020-03-07T00:30:11Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Object childLifecycleKey : childLifecycleMap.keySet()) {\n+                interpolate(childLifecycleKey, childLifecycleMap, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment.\n+     *\n+     * @return main service with updated dependencies\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<String> rootPackagesToRemove, DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(rootPackagesToRemove);\n+        kernelDependencies.addAll(getRootPackagesToAdd(document).stream().map(PackageIdentifier::getName)\n+                .collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addConfigForServiceDependencies(mainLifecycleMap, kernelDependencies);\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    void addConfigForServiceDependencies(Map<Object, Object> lifecycle, final Set<String> dependencies) {\n+        lifecycle.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencies));\n+    }\n+\n+    boolean packageExistsInDeployment(DeploymentDocument document, PackageIdentifier packageIdentifier) {\n+        return getMatchingPackageConfigFromDeployment(document, packageIdentifier.getName(),\n+                packageIdentifier.getVersion().toString()) != null;\n+    }\n+\n+    DeploymentPackageConfiguration getMatchingPackageConfigFromDeployment(DeploymentDocument document,\n+                                                                          String packageName, String packageVersion) {\n+        return document.getDeploymentPackageConfigurationList().stream()\n+                .filter(packageConfig -> packageName.equals(packageConfig.getPackageName()) && packageVersion.toString()\n+                        .equals(packageConfig.getResolvedVersion())).findAny().orElse(null);\n+    }\n+\n+    Set<PackageParameter> resolveParameterValuesToUse(Package pkg, DeploymentDocument document) {\n+        // If values for parameters were set in deployment they should be used\n+        Set<PackageParameter> resolvedParams = new HashSet<>(getParametersFromDeployment(document, pkg));\n+\n+        // Use defaults for parameters for which no values were set in deployment\n+        resolvedParams.addAll(pkg.getPackageParameters());\n+        return resolvedParams;\n+    }\n+\n+    Set<PackageParameter> getParametersFromDeployment(DeploymentDocument document, Package pkg) {\n+        return getMatchingPackageConfigFromDeployment(document, pkg.getPackageName(), pkg.getVersion().toString())\n+                .getParameters();\n+    }\n+\n+    /*\n+     * Deployment document has a flat list of packages, we need to identify those that are the root\n+     * packages that customer added so that they can be added as the top level dependencies of the main service.\n+     */\n+    Set<PackageIdentifier> getRootPackagesToAdd(DeploymentDocument document) {\n+        Set<PackageIdentifier> rootPackages = document.getDeploymentPackageConfigurationList().stream()\n+                .map(pkg -> new PackageIdentifier(pkg.getPackageName(),\n+                        new Semver(pkg.getResolvedVersion(), Semver.SemverType.NPM))).collect(Collectors.toSet());", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzc3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389207773", "bodyText": "I'm not sure if the document will have dependency information in deployment doc after refactoring, and even with the current modeling it does not have this information readily available in the form of package name - version. If this turns out to be redundant I'll optimize", "author": "shaguptashaikh", "createdAt": "2020-03-07T00:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTY4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389209680", "bodyText": "Isn't listOfPackagesToDeploy in the deploymentDocument the top level packages to be deploy?  We can modify it to include version information too.", "author": "fengwang666", "createdAt": "2020-03-07T01:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzMDE4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389230180", "bodyText": "Right, I didn't know this was readily available in the deployment document, fixed it", "author": "shaguptashaikh", "createdAt": "2020-03-07T05:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMjU4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389202585", "bodyText": "How is rootPackagesToRemove derived from? Can it be included in the document?", "author": "fengwang666", "createdAt": "2020-03-07T00:18:33Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzMDExNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389230114", "bodyText": "It cannot be included in deployment document because deployment document is limited to a single fleet while a package even if removed in deployment for one fleet may be still needed by other fleets the device belongs to. As discussed a few days ago, there will be a mapping of fleets <-> packages maintained at the device which will handle deployments for multiple fleets. This can be used to find out what top level packages are no longer needed by any fleet and need to be removed from Kernel config. Logically DA will manage that fleets <-> packages mapping which is why I'm expecting it to pass the to be removed packages to the config resolver", "author": "shaguptashaikh", "createdAt": "2020-03-07T05:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389208661", "bodyText": "How do we know it must be a map? Can it be a list?", "author": "fengwang666", "createdAt": "2020-03-07T00:54:10Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzMDI0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389230249", "bodyText": "As of today there are no lists/sets, but I'll talk to the Kernel folks to see if there is a possibility of seeing anything other than plain strings and nested config maps here", "author": "shaguptashaikh", "createdAt": "2020-03-07T05:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUxNDU2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r390514560", "bodyText": "Talked to @ShirleyZheng92 and turns out this can be a list, in that case I will need to add another condition here to handle lists, I'll do that in the next update", "author": "shaguptashaikh", "createdAt": "2020-03-10T18:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTE5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389209199", "bodyText": "Ideally I would prefer not to mutate the object passed into a method. Can we change to return the value instead?", "author": "fengwang666", "createdAt": "2020-03-07T00:57:33Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzMDI1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389230259", "bodyText": "Changed it", "author": "shaguptashaikh", "createdAt": "2020-03-07T05:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMDU0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389210546", "bodyText": "Same here. Let's not return value through parameter. This can be changed to\nprivate Object generateConfig(PackageIdentifier packageIdentifier, DeploymentDocument document)\n\nIn the caller code line52:\npackageIdentifiers.stream().collect(Collectors.toMap(PackageIdentifier::getName, p -> generateConfig(p, document));", "author": "fengwang666", "createdAt": "2020-03-07T01:06:35Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,", "originalCommit": "48457ace2e8873fcd3ff8cf165876729b97659d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzMDI2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389230266", "bodyText": "Changed", "author": "shaguptashaikh", "createdAt": "2020-03-07T05:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMDU0Ng=="}], "type": "inlineReview"}, {"oid": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "message": "Address comments and clean up", "committedDate": "2020-03-07T06:34:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0OTI3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r390049274", "bodyText": "This assumption may not be true if the job document has multiple versions of a package. It might be better to check with kernel instead.", "author": "hui-yang", "createdAt": "2020-03-10T01:36:48Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each packaage and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen during\n+        // dependency resolution over the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {", "originalCommit": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUxMzMxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r390513316", "bodyText": "I'm not very clear about how version info in the document is changing, so far when there was going to be one proposed version in the doc and dependency resolution locally could decide to resolve to the running version if it satisfies version constraint, in such a case parameter handling becomes difficult, because the chosen version after local dependency resolution may not be present in the job document so we wouldn't find the right parameters in the document. With your changes, will the job document always have the version that gets picked? If not, how do we find parameters for the package in it? since parameters can be different for different versions of the same package", "author": "shaguptashaikh", "createdAt": "2020-03-10T18:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0OTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MTgzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r390051833", "bodyText": "We might also want to put the version constraints of each deployment fleet.", "author": "hui-yang", "createdAt": "2020-03-10T01:47:29Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each packaage and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen during\n+        // dependency resolution over the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return Collections.EMPTY_MAP;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax, then change the following code accordingly\n+\n+        // Generate dependencies\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());", "originalCommit": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUxMDI4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r390510286", "bodyText": "Could you elaborate a little on how this information is supposed to be stored, when you say each fleet? do you mean there should be multiple config key value pairs for fleet - package version constraint? what happens when a package is not in all fleets?", "author": "shaguptashaikh", "createdAt": "2020-03-10T18:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MTgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyMTkzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391821932", "bodyText": "I'm fine with your current implementation, but we might need some more discussions later about how to store this version constraint information.", "author": "hui-yang", "createdAt": "2020-03-12T18:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MTgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1MTk2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391851964", "bodyText": "yeah, as discussed in the backlog meeting, we need a discussion but currently I'm storing the info you send as it is in kernel config", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MTgzMw=="}], "type": "inlineReview"}, {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "message": "Config resolver with parameter interpolation", "committedDate": "2020-03-11T20:54:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyMjg2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391322862", "bodyText": "Could you use PlatformResolver.resolvePlatform() to get platform-specific lifecycle?", "author": "hui-yang", "createdAt": "2020-03-11T23:16:04Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,179 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     resolved packages to deploy\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {", "originalCommit": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQyMDgzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391420835", "bodyText": "Kernel already does that when merging new config https://github.com/aws/aws-greengrass-kernel/blob/master/src/main/java/com/aws/iot/evergreen/config/Configuration.java#L145 Doing that here will need changes in merge API definition and will be redundant anyway, we can let config resolver not worry about platform for now, we do need platform for generating service dependencies but package recipe should support it first so there is a TODO in this class corresponding to that", "author": "shaguptashaikh", "createdAt": "2020-03-12T06:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyMjg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMjI1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391802257", "bodyText": "Got it.", "author": "hui-yang", "createdAt": "2020-03-12T18:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyMjg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMTU4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391401584", "bodyText": "This is a map, can you add information on what the map represents.", "author": "abanthiy", "createdAt": "2020-03-12T04:57:44Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,179 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     resolved packages to deploy", "originalCommit": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQxOTExMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391419111", "bodyText": "Sure, will update", "author": "shaguptashaikh", "createdAt": "2020-03-12T06:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMTU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNzk1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391817958", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-03-12T18:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwNTY5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391405696", "bodyText": "To be future proof and consistent we can use Set to represent rootPackagesToRemove.\nYou can simply pull the PackageName from it for now.", "author": "abanthiy", "createdAt": "2020-03-12T05:16:50Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,179 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     resolved packages to deploy\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) throws InterruptedException {", "originalCommit": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQxOTAyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391419024", "bodyText": "rootPackagesToRemove is already a set, could you elaborate what you mean? a set of something else than String?", "author": "shaguptashaikh", "createdAt": "2020-03-12T06:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwNTY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5ODUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391798519", "bodyText": "I missed the main point, I meant Set", "author": "abanthiy", "createdAt": "2020-03-12T18:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwNTY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5ODg2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391798861", "bodyText": "ok so somehow this parses angular brackets differently. I meant Set of PackageIdentifier", "author": "abanthiy", "createdAt": "2020-03-12T18:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwNTY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNzg4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391817885", "bodyText": "Got it now, updated it", "author": "shaguptashaikh", "createdAt": "2020-03-12T18:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwNTY5Ng=="}], "type": "inlineReview"}, {"oid": "b6c0e1330923f33df76e52f23c89c583b93b2b69", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6c0e1330923f33df76e52f23c89c583b93b2b69", "message": "Config resolver with parameter interpolation", "committedDate": "2020-03-12T18:02:37Z", "type": "forcePushed"}, {"oid": "748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "message": "Config resolver with parameter interpolation", "committedDate": "2020-03-12T18:14:08Z", "type": "forcePushed"}, {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aa72910b4a55e3dae36d31b770fe1b2247614c04", "message": "Config resolver with parameter interpolation", "committedDate": "2020-03-12T18:32:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTMzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391805339", "bodyText": "I'm going to mark this as deprecated because job document does not have this information based on the latest changes. When do you need this list?", "author": "hui-yang", "createdAt": "2020-03-12T18:14:25Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -32,6 +35,6 @@\n     Set<PackageParameter> parameters;\n \n     @JsonProperty(\"Dependencies\")\n-    List<NameVersionPair> listOfDependentPackages;\n+    List<PackageIdentifier> listOfDependencies;", "originalCommit": "b6c0e1330923f33df76e52f23c89c583b93b2b69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0NTY4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391845682", "bodyText": "Yes, we won't need that once deployment service starts using  deployment task", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjgyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391806821", "bodyText": "Besides naming changes, do you need this function in parameter resolution?", "author": "hui-yang", "createdAt": "2020-03-12T18:17:01Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/ParseAndValidateState.java", "diffHunk": "@@ -69,12 +69,12 @@ public void proceed() throws DeploymentFailureException {\n             PackageMetadata currentPackageMetdata = entry.getValue();\n             if (nameToPackageConfig.containsKey(packageName)) {\n                 DeploymentPackageConfiguration deploymentPackageConfiguration = nameToPackageConfig.get(packageName);\n-                if (deploymentPackageConfiguration.getListOfDependentPackages() != null) {\n-                    for (NameVersionPair dependencyNameVersion : deploymentPackageConfiguration\n-                            .getListOfDependentPackages()) {\n-                        if (nameToPackageMetadata.containsKey(dependencyNameVersion.getPackageName())) {\n+                if (deploymentPackageConfiguration.getListOfDependencies() != null) {", "originalCommit": "748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0NTk0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391845949", "bodyText": "No I do not need this, left it there so the existing state machine code at least builds while we refactor", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNDM0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391814340", "bodyText": "I'm assuming the \"dependencies\" has platform-specific definitions https://github.com/aws/aws-greengrass-kernel/blob/73a8bec3a4d64c4b1499bded048a6523279dcfaf/src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java#L232-L238\nDoes kernel config resolve the platform as well when merging?", "author": "hui-yang", "createdAt": "2020-03-12T18:30:54Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,182 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));", "originalCommit": "748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0NjcxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391846719", "bodyText": "There is a TODO for this, config resolver has to pick platform specific dependencies but the package recipe and hence package POJO needs to support that first, Kernel won't be able to distinguish between those since we're giving it a plain list, we can do the platform specific work next sprint if I recall correctly from yesterday's standup", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNDM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNzE4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391827187", "bodyText": "Just to confirm, parameters are only allowed for \"lifecycle\"?", "author": "hui-yang", "createdAt": "2020-03-12T18:55:05Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,184 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<PackageIdentifier> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        resolvedServiceConfig.put(VERSION_CONSTRAINT_CONFIG_KEY, versionConstraint);\n+        return resolvedServiceConfig;\n+    }\n+\n+    /*\n+     * For each lifecycle key-value pair of a package, substitute parameter values.\n+     */\n+    private Object interpolate(Object configValue, Set<PackageParameter> packageParameters) {", "originalCommit": "aa72910b4a55e3dae36d31b770fe1b2247614c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMDUzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391830536", "bodyText": "Maybe I'm underestimating things, why don't we flatten the config to String, run a replaceAll, and reconstruct the config tree?", "author": "hui-yang", "createdAt": "2020-03-12T19:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNzE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0ODExNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391848116", "bodyText": "Parameters should be allowed for anything that goes as it is to the service's kernel config. Although package recipe calls all of that 'lifecycle' and Kernel calls only part of that lifecycle, there's another TODO to bring recipe format into alignment with Kernel config and we need to make changed to this code accordingly. For converting to string and doing replaceall, I wanted to avoid that to avoid serialzing - deserializing over and over, and I'm not sure if the YAML string format will be retained, but I can make a note of this and give it a shot", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMjQxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391832411", "bodyText": "Currently this packageVersion.toString().equals(packageConfig.getResolvedVersion()) is always true, but let's keep the check here just in case any logic changes in dependency resolver.", "author": "hui-yang", "createdAt": "2020-03-12T19:05:20Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,184 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<PackageIdentifier> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        resolvedServiceConfig.put(VERSION_CONSTRAINT_CONFIG_KEY, versionConstraint);\n+        return resolvedServiceConfig;\n+    }\n+\n+    /*\n+     * For each lifecycle key-value pair of a package, substitute parameter values.\n+     */\n+    private Object interpolate(Object configValue, Set<PackageParameter> packageParameters) {\n+\n+        Object result = configValue;\n+        if (configValue instanceof String) {\n+            String value = (String) configValue;\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            result = value;\n+\n+            // TODO : Handle system parameters\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<Object, Object> resolvedChildConfig = new HashMap<>();\n+            for (Map.Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig\n+                        .put(childLifecycle.getKey(), interpolate(childLifecycle.getValue(), packageParameters));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+        // TODO : Do we want to support other config types than map of\n+        // string k,v pairs? e.g. how should lists be handled?\n+        return result;\n     }\n+\n+\n+    /*\n+     * Recompute main service dependencies for deployment.\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<PackageIdentifier> rootPackagesToRemove,\n+                                                     DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(EvergreenService::getName)\n+                        .collect(Collectors.toSet());\n+        kernelDependencies\n+                .removeAll(rootPackagesToRemove.stream().map(PackageIdentifier::getName).collect(Collectors.toSet()));\n+        kernelDependencies.addAll(document.getRootPackages());\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        mainLifecycleMap.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", kernelDependencies));\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    /*\n+     * Get configuration for a package-version combination from deployment document.\n+     */\n+    private Optional<DeploymentPackageConfiguration> getMatchingPackageConfigFromDeployment(DeploymentDocument document,\n+                                                                                            String packageName,\n+                                                                                            String packageVersion) {\n+        return document.getDeploymentPackageConfigurationList().stream()\n+                .filter(packageConfig -> packageName.equals(packageConfig.getPackageName()) && packageVersion.toString()\n+                        .equals(packageConfig.getResolvedVersion())).findAny();", "originalCommit": "aa72910b4a55e3dae36d31b770fe1b2247614c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0ODQ0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391848447", "bodyText": "Yes, I'll leave the check as it is here", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMjQxMQ=="}], "type": "inlineReview"}, {"oid": "42b0ffe7591f294d8e4d67f9fc893bca872279b6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/42b0ffe7591f294d8e4d67f9fc893bca872279b6", "message": "Config resolver with parameter interpolation", "committedDate": "2020-03-12T20:19:45Z", "type": "commit"}, {"oid": "42b0ffe7591f294d8e4d67f9fc893bca872279b6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/42b0ffe7591f294d8e4d67f9fc893bca872279b6", "message": "Config resolver with parameter interpolation", "committedDate": "2020-03-12T20:19:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3Nzk4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391877984", "bodyText": "According to yesterday's discussion, we don't need the versionConstraint since it can be derived from the recipe file for each package. It can also lead to error cases, for example:\nDeployment 1: Group A: pkgA-1.0 -> pkgD-2.0 (constraint: pkgD < 3.0) => resolved constraint: pkgD: < 3.0\nDeployment 2: Group B: pkgB-1.0 -> pkgD-2.0 (constraint: pkgD > 1.0) => resolved constraint: pkgD: >1.0 && < 3.0\nDeployment 3: Group A: pkgA-1.0 -> pkgD-3.0 (constraint: pkgD > 3.0) => constraint conflict!\n\nIn this case Deployment 3 will fail because the constraint brought by it conflicts with the existing constraint on device. However, in this case it shouldn't fail.", "author": "fengwang666", "createdAt": "2020-03-12T20:31:17Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,184 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<PackageIdentifier> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        resolvedServiceConfig.put(VERSION_CONSTRAINT_CONFIG_KEY, versionConstraint);", "originalCommit": "42b0ffe7591f294d8e4d67f9fc893bca872279b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MzE0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391883148", "bodyText": "Let me speak with Hui and do that in a new PR, will need to change the interface back to the old one too", "author": "shaguptashaikh", "createdAt": "2020-03-12T20:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3Nzk4NA=="}], "type": "inlineReview"}]}