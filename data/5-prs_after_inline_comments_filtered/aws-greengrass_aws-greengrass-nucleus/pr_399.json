{"pr_number": 399, "pr_title": "Refactored authorization to take in a parameterized JSON ACL", "pr_createdAt": "2020-08-28T05:32:42Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NzIzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479457230", "bodyText": "I am not sure what would happen if the ACL parameter key itself is removed, like when author deploys a new recipe and removes the parameter config altogether and then deploys. That case is skipped here, right?", "author": "prateek-y", "createdAt": "2020-08-28T18:01:53Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)\n+                            || !newv.getName().equals(ACCESS_CONTROL_NAMESPACE_TOPIC)) {", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585585", "bodyText": "refactored and added integ test for this", "author": "avipinku", "createdAt": "2020-08-29T00:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NzIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1ODY3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479458675", "bodyText": "Is it a common pattern to pass logger as part of method? Isnt it usually class member?", "author": "prateek-y", "createdAt": "2020-08-28T18:05:10Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -88,11 +91,13 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                     }\n                     Topic updatedTopic = (Topic) newv;\n                     String componentName = findServiceForNode(updatedTopic);\n-                    //If there is a change in a node, reload that one component's ACL\n-                    List<AuthorizationPolicy> updatedComponentPolicies = policyParser\n-                            .parseAuthorizationPolicyList(componentName, updatedTopic, logger);\n-                    this.loadAuthorizationPolicies(updatedTopic.getName(), updatedComponentPolicies, true);\n-\n+                    Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = policyParser\n+                           .parseAllPoliciesForComponent(updatedTopic, componentName, logger);", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585548", "bodyText": "yep, fixed", "author": "avipinku", "createdAt": "2020-08-29T00:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1ODY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MDg1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479460857", "bodyText": "This is not a warn, and as auth we dont care about it really. lets make it info, same for below.", "author": "prateek-y", "createdAt": "2020-08-28T18:09:58Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585603", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-29T00:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MDg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjU5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479462598", "bodyText": "You dont need to do getOnce(), coerce does that. right?", "author": "prateek-y", "createdAt": "2020-08-28T18:13:46Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzg1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479517855", "bodyText": "It does", "author": "MikeDombo", "createdAt": "2020-08-28T20:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585610", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-29T00:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2NDMzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479464338", "bodyText": "Being empty is not invalid, that should not be warn.", "author": "prateek-y", "createdAt": "2020-08-28T18:17:27Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());\n+            Object accessControlTopicObject = accessControlType.getValue();\n+\n+            if (!(accessControlTopicObject instanceof List)\n+                    || Utils.isEmpty((List) accessControlTopicObject)", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585614", "bodyText": "changed to info", "author": "avipinku", "createdAt": "2020-08-29T00:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2NDMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjI4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479462282", "bodyText": "Have you tested if \"parameters\" or \"accessControl\" node is removed? Will that fall into this if statement?", "author": "youtuyy", "createdAt": "2020-08-28T18:13:03Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585589", "bodyText": "added integ tests for both of these cases", "author": "avipinku", "createdAt": "2020-08-29T00:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479517781", "bodyText": "why?", "author": "MikeDombo", "createdAt": "2020-08-28T20:22:44Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585545", "bodyText": "this gives the following error otherwise:\n        \n[ERROR] Unchecked/unconfirmed cast from com.fasterxml.jackson.databind.ObjectMapper to com.fasterxml.jackson.databind.json.JsonMapper of return value in com.aws.iot.evergreen.auth.AuthorizationPolicyParser.<static initializer for AuthorizationPolicyParser>() [com.aws.iot.evergreen.auth.AuthorizationPolicyParser] At AuthorizationPolicyParser.java:[line 32] BC_UNCONFIRMED_CAST_OF_RETURN_VALUE", "author": "avipinku", "createdAt": "2020-08-29T00:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NjA1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479586054", "bodyText": "Just make the field an objectmapper instead", "author": "MikeDombo", "createdAt": "2020-08-29T00:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxODA2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479518064", "bodyText": "put this in a try-finally, and remove the listener in the finally", "author": "MikeDombo", "createdAt": "2020-08-28T20:23:31Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -158,8 +176,15 @@ public void GIVEN_invalid_pubsub_yaml_file_with_invalid_fields_WHEN_auth_parsing\n             assertNotNull(inputStream);\n             config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n \n-            //TODO: this no longer throws an exception; we need to parse the log to check the behavior\n+            logReceived = new CountDownLatch(1);\n+            logListener = m -> {\n+                if (\"load-authorization-config-unknown-policy-key\".equals(m.getEventType())) {\n+                    logReceived.countDown();\n+                }\n+            };\n+            Slf4jLogAdapter.addGlobalListener(logListener);", "originalCommit": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585626", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-29T00:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxODA2NA=="}], "type": "inlineReview"}, {"oid": "645f32f6407553d6b0b8c875d0c6c76d7c77aa8a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/645f32f6407553d6b0b8c875d0c6c76d7c77aa8a", "message": "Responded to feedback", "committedDate": "2020-08-29T00:44:11Z", "type": "forcePushed"}, {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "message": "Responded to feedback", "committedDate": "2020-08-29T00:57:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480287968", "bodyText": "why are we logging the exception? It should probably only be returned to the user, maybe with a warning or info as well.", "author": "MikeDombo", "createdAt": "2020-08-31T17:47:14Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "originalCommit": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjMxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480376310", "bodyText": "I think this is part of how the PubSubImpl is implemented. We can talk about changing that and I can fix it in another PR for the SDK.", "author": "avipinku", "createdAt": "2020-08-31T20:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3Nzc5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480377797", "bodyText": "Nonono. That exception is correct. I'm talking about AuthorizationException", "author": "MikeDombo", "createdAt": "2020-08-31T20:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwOTkzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481309930", "bodyText": "that exception is thrown by the  PubSubIPCService in order to set the response as PubSubResponseStatus.Unauthorized\nhttps://github.com/aws/aws-greengrass-kernel/blob/master/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java#L133\nDo we want to handle that differently?", "author": "avipinku", "createdAt": "2020-09-01T17:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxNTA4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481315083", "bodyText": "Maybe log only when it isn't an auth exception, since we understand what that's about. Do log that authorization was denied, but you don't need to log out the whole exception.", "author": "MikeDombo", "createdAt": "2020-09-01T17:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU4ODM0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481588345", "bodyText": "changed", "author": "avipinku", "createdAt": "2020-09-02T03:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTgwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481751804", "bodyText": "Since you changed it, you should be able to remove the ignore now.", "author": "MikeDombo", "createdAt": "2020-09-02T05:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODA5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480288091", "bodyText": "this won't do anything; you've already ignored it on L157.", "author": "MikeDombo", "createdAt": "2020-08-31T17:47:31Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);", "originalCommit": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjI3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480376274", "bodyText": "whoops, removed", "author": "avipinku", "createdAt": "2020-08-31T20:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480288140", "bodyText": "same", "author": "MikeDombo", "createdAt": "2020-08-31T17:47:37Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_parameters_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        if (parameters != null) {\n+            parameters.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);", "originalCommit": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4OTM4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480289380", "bodyText": "this isn't possible", "author": "MikeDombo", "createdAt": "2020-08-31T17:49:53Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,35 +24,145 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atInfo(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }", "originalCommit": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjE4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480376184", "bodyText": "removed the check", "author": "avipinku", "createdAt": "2020-08-31T20:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4OTM4MA=="}], "type": "inlineReview"}, {"oid": "ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4", "message": "Minor cleanup", "committedDate": "2020-08-31T20:18:32Z", "type": "forcePushed"}, {"oid": "d253092d449a841b242526f9537068ddcca48547", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d253092d449a841b242526f9537068ddcca48547", "message": "Responded to feedback", "committedDate": "2020-09-01T21:54:22Z", "type": "forcePushed"}, {"oid": "7765270bfa21f1fb5ee1e92f92d3e86749d6fd2e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7765270bfa21f1fb5ee1e92f92d3e86749d6fd2e", "message": "Removed pub/sub support for unsubscribe operation", "committedDate": "2020-09-01T22:09:16Z", "type": "forcePushed"}, {"oid": "b9ee6ffbbd6d4a5de952e547d5bced5cc237bb7b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b9ee6ffbbd6d4a5de952e547d5bced5cc237bb7b", "message": "Integration test fix", "committedDate": "2020-09-01T22:49:49Z", "type": "forcePushed"}, {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "message": "Refactored authorization to take in a parameterized JSON ACL", "committedDate": "2020-09-02T02:02:36Z", "type": "commit"}, {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "message": "Refactored authorization to take in a parameterized JSON ACL", "committedDate": "2020-09-02T02:02:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481751334", "bodyText": "can we get rid of the sleep? Random sleeps are incredibly suspect", "author": "MikeDombo", "createdAt": "2020-09-02T05:56:53Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MTk5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482261999", "bodyText": "There needs to be some delay here for the changes in the ACL to propagate. If this is removed, it fails.", "author": "avipinku", "createdAt": "2020-09-02T17:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MzYzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482263630", "bodyText": "That sounds like a bug!", "author": "MikeDombo", "createdAt": "2020-09-02T18:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDM1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482264350", "bodyText": "I thought kernel config read is asynchronous?", "author": "prateek-y", "createdAt": "2020-09-02T18:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482264996", "bodyText": "You may need to use kernel.getContext().runOnPublishQueueAndWait(() -> {}); which will block until all the events have completed.", "author": "MikeDombo", "createdAt": "2020-09-02T18:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyNzg2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482327862", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-09-02T19:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzUyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481753526", "bodyText": "do not log", "author": "MikeDombo", "createdAt": "2020-09-02T05:58:58Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjAxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262018", "bodyText": "removed", "author": "avipinku", "createdAt": "2020-09-02T17:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzY1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481753655", "bodyText": "do not log", "author": "MikeDombo", "createdAt": "2020-09-02T05:59:06Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjA4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262080", "bodyText": "removed", "author": "avipinku", "createdAt": "2020-09-02T17:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NDQwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481754406", "bodyText": "use Kernel.findServiceForNode instead of getting the name like that. Just in case.", "author": "MikeDombo", "createdAt": "2020-09-02T05:59:51Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjA2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262063", "bodyText": "done", "author": "avipinku", "createdAt": "2020-09-02T17:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NDQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NTIzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481755230", "bodyText": "simplify to serviceConfig.find(PARAMETERS_CONFIG_KEY, ACCESS_CONTROL_NAMESPACE_TOPIC) which will return null if either is null", "author": "MikeDombo", "createdAt": "2020-09-02T06:00:37Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjE3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262172", "bodyText": "done", "author": "avipinku", "createdAt": "2020-09-02T18:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NTIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NzEyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481757124", "bodyText": "Provide the generics: Map.Entry<String, Object>", "author": "MikeDombo", "createdAt": "2020-09-02T06:02:34Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjI2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262262", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-09-02T18:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NzEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1Nzg3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481757879", "bodyText": "you don't need to coerce to string, it is already a string. This will be fixed if you use the generic as I suggest above.", "author": "MikeDombo", "createdAt": "2020-09-02T06:03:21Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjIyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262221", "bodyText": "done", "author": "avipinku", "createdAt": "2020-09-02T18:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1Nzg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTA4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481759085", "bodyText": "don't bother with the cause, we know what causes authz exceptions. You can just log the exception message. (e.getmessage()I mean)", "author": "MikeDombo", "createdAt": "2020-09-02T06:04:33Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -126,21 +127,30 @@ public void postInject() {\n             ApplicationMessage responseMessage = ApplicationMessage.builder().version(applicationMessage.getVersion())\n                     .payload(CBOR_MAPPER.writeValueAsBytes(pubSubGenericResponse)).build();\n             fut.complete(new Message(responseMessage.toByteArray()));\n+        } catch (AuthorizationException e) {\n+            logger.atWarn().setEventType(\"pubsub-authorization-error\").setCause(e).log(\"Unauthorized request\");", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262308", "bodyText": "done", "author": "avipinku", "createdAt": "2020-09-02T18:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MDQwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481760405", "bodyText": "try (InputStream inputStream = getClass().getResourceAsStream(filename)) { ... }", "author": "MikeDombo", "createdAt": "2020-09-02T06:05:46Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjM3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262379", "bodyText": "done", "author": "avipinku", "createdAt": "2020-09-02T18:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MDQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MTkzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481761935", "bodyText": "not needed. You already do this with @Mock", "author": "MikeDombo", "createdAt": "2020-09-02T06:07:23Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);\n+        Topics allServices = mock(Topics.class);\n+        it = mock(Iterator.class);", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjQxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262417", "bodyText": "removed", "author": "avipinku", "createdAt": "2020-09-02T18:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481762939", "bodyText": "You have both real and mocked configs?", "author": "MikeDombo", "createdAt": "2020-09-02T06:08:22Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);", "originalCommit": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjQ1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262452", "bodyText": "Yes, instead of having to mock each and every function called on the Topics config/ trying to construct a mock with the parameters we want, we can just mock the iterator and use it to return real Nodes that get loaded into realConfig. We don't care about the kernel.getConfig call.", "author": "avipinku", "createdAt": "2020-09-02T18:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482264706", "bodyText": "Then why have a mock at all? Why not just use the real config for everything?", "author": "MikeDombo", "createdAt": "2020-09-02T18:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3Mzg5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482273891", "bodyText": "Oh thats right. We can just pass the read config as part of kernel.getConfig() ?", "author": "prateek-y", "createdAt": "2020-09-02T18:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyNzc5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482327791", "bodyText": "yeah, refactored to just use the real config for everything", "author": "avipinku", "createdAt": "2020-09-02T19:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}], "type": "inlineReview"}, {"oid": "b04ba917f0dd346057454e07dc06fe95ff4f3856", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b04ba917f0dd346057454e07dc06fe95ff4f3856", "message": "Cleaned up according to feedback", "committedDate": "2020-09-02T19:17:38Z", "type": "forcePushed"}, {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eb841218b544be7d0d65ce0e6a9479742039d5dc", "message": "Responded to feedback", "committedDate": "2020-09-02T19:53:01Z", "type": "commit"}, {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eb841218b544be7d0d65ce0e6a9479742039d5dc", "message": "Responded to feedback", "committedDate": "2020-09-02T19:53:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0NjQxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482446416", "bodyText": "technically, the nullcheck is included here, so you can remove L59", "author": "MikeDombo", "createdAt": "2020-09-02T20:48:59Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,165 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {", "originalCommit": "eb841218b544be7d0d65ce0e6a9479742039d5dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}