{"pr_number": 486, "pr_title": "Device deployment", "pr_createdAt": "2020-09-29T06:50:54Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486", "timeline": [{"oid": "7896b8dc93505b9968fde382b0f8bd77bc0cf467", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7896b8dc93505b9968fde382b0f8bd77bc0cf467", "message": "shadow deployment", "committedDate": "2020-09-29T06:48:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ1NzY2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r496457664", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem: InterruptedException is ignored. This can delay thread shutdown and clear the thread\u2019s interrupt status. Only code that implements a thread\u2019s interruption policy can swallow an interruption request.\nFix: Rethrow the InterruptedException or reinterrupt the current thread using Thread.currentThread().interrupt() so that higher-level interrupt handlers can function correctly.\nIf you are wrapping the InterruptedException inside a RuntimeException, call Thread.currentThread().interrupt() before throwing the RuntimeException.\nLearn more about interrupts and dealing with InterruptedException", "author": "MikeDombo", "createdAt": "2020-09-29T06:53:52Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        subscribeToShadowTopics();\n+        // Get the shadow state when kernel starts up by publishing to get topic\n+        publishToGetDeviceShadowTopic();\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);\n+        Pair<Integer, Map<String, Object>> configurationCountPair = configArnToDesiredStateMap.get(configurationArn);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(configurationCountPair.getRight());\n+\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                return true;\n+            } catch (InterruptedException e) {", "originalCommit": "7896b8dc93505b9968fde382b0f8bd77bc0cf467", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e06a16b506873d37447e9aa9608afc68914d92c0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e06a16b506873d37447e9aa9608afc68914d92c0", "message": "shadow deployment", "committedDate": "2020-09-29T06:59:16Z", "type": "commit"}, {"oid": "4ecf9319b50e7a07453d0242a5b8694519ce79c1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4ecf9319b50e7a07453d0242a5b8694519ce79c1", "message": "merged from master", "committedDate": "2020-09-29T07:01:55Z", "type": "commit"}, {"oid": "55df8e97d68f76a13a693d62348446f8f2f3ac77", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/55df8e97d68f76a13a693d62348446f8f2f3ac77", "message": "Merge branch 'master' into device_deployment", "committedDate": "2020-09-29T18:03:58Z", "type": "commit"}, {"oid": "6b4413f4df99c46dbb246db8801cddfe230b0cc9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6b4413f4df99c46dbb246db8801cddfe230b0cc9", "message": "fixed pmd violations", "committedDate": "2020-09-29T18:49:44Z", "type": "commit"}, {"oid": "fd86d313163a98488e17c9908b303239d8d87b9a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fd86d313163a98488e17c9908b303239d8d87b9a", "message": "fixed pmd violations", "committedDate": "2020-09-29T19:04:01Z", "type": "commit"}, {"oid": "7dc0b98f0c5a15ea0020b5cc9dbd89c92ee20b8a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7dc0b98f0c5a15ea0020b5cc9dbd89c92ee20b8a", "message": "Merge branch 'master' into device_deployment", "committedDate": "2020-09-29T20:19:17Z", "type": "commit"}, {"oid": "e17b447e17338ce13fe7c6d6b9c26fa617473ea6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e17b447e17338ce13fe7c6d6b9c26fa617473ea6", "message": "moved subscribe to a separate thread", "committedDate": "2020-09-30T00:09:45Z", "type": "commit"}, {"oid": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "message": "Merge branch 'master' into device_deployment", "committedDate": "2020-09-30T00:10:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE3NjE2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497176160", "bodyText": "With CLI over IPC we should not be needing LocalDeploymentListener. If its not too much, remove this class in this PR.", "author": "abanthiy", "createdAt": "2020-09-30T00:23:57Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -150,10 +150,11 @@ public DeploymentService(Topics topics) {\n     @Override\n     public void postInject() {\n         super.postInject();\n-        // Informing kernel about IotJobsHelper and LocalDeploymentListener so kernel can instantiate,\n-        // inject dependencies and call post inject.\n+        // Informing kernel about IotJobsHelper ShadowDeploymentListener and LocalDeploymentListener,\n+        // so kernel can instantiate,inject dependencies and call post inject.\n         // This is required because both the classes are independent and not Greengrass services\n         context.get(IotJobsHelper.class);\n+        context.get(ShadowDeploymentListener.class);\n         context.get(LocalDeploymentListener.class);", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5Mjk2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498592969", "bodyText": "Removed", "author": "fahadmohammed01", "createdAt": "2020-10-02T02:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE3NjE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MDk1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497190950", "bodyText": "Is empty deployment doc valid?", "author": "abanthiy", "createdAt": "2020-09-30T01:18:14Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -395,16 +408,16 @@ private DefaultDeploymentTask createDefaultNewDeployment(Deployment deployment)\n     }\n \n     private DeploymentDocument parseAndValidateJobDocument(Deployment deployment) throws InvalidRequestException {\n-        String jobDocumentString = deployment.getDeploymentDocument();\n-        if (Utils.isEmpty(jobDocumentString)) {\n+\n+        if (deployment.getDeploymentDocument() == null) {", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MTM1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497191356", "bodyText": "Deserialize?", "author": "abanthiy", "createdAt": "2020-09-30T01:20:03Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -422,14 +435,18 @@ private DeploymentDocument parseAndValidateJobDocument(Deployment deployment) th\n                             }\n                         });\n                     }\n-\n                     document = DeploymentDocumentConverter\n                             .convertFromLocalOverrideRequestAndRoot(localOverrideRequest, rootComponents);\n                     break;\n                 case IOT_JOBS:\n-                    FleetConfiguration config = OBJECT_MAPPER.readValue(jobDocumentString, FleetConfiguration.class);\n+                    FleetConfiguration config = OBJECT_MAPPER.readValue((String) deployment.getDeploymentDocument(),\n+                            FleetConfiguration.class);\n                     document = DeploymentDocumentConverter.convertFromFleetConfiguration(config);\n                     break;\n+                case SHADOW:\n+                    document = DeploymentDocumentConverter.convertFromFleetConfiguration(", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5NzExMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497197113", "bodyText": "We need to check if the exception qualifies for being retryable. https://github.com/aws/aws-greengrass-kernel/blob/master/src/main/java/com/aws/greengrass/deployment/IotJobsHelper.java#L460 - Similar TODO needs to be added here.", "author": "abanthiy", "createdAt": "2020-09-30T01:43:36Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5Nzg5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497197897", "bodyText": "This TODO should be in FleetStatusService, not here.", "author": "abanthiy", "createdAt": "2020-09-30T01:46:45Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4ODE3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498588170", "bodyText": "Updated FleetStatusService", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5Nzg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5ODIxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497198217", "bodyText": "Should be called CONFIGURATION_ARN not DEPLOYMENT_ARN", "author": "abanthiy", "createdAt": "2020-09-30T01:48:04Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5OTc3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497199770", "bodyText": "If version 3 was cancelled then the version coming in the deployment be version 2 or version 4?\nIf it will be 2 then this will not provide desired cancellation behavior.", "author": "abanthiy", "createdAt": "2020-09-30T01:54:15Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);\n+        Pair<Integer, Map<String, Object>> configurationCountPair = configArnToDesiredStateMap.get(configurationArn);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(configurationCountPair.getRight());\n+\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                return true;\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while publishing reported state\");\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while publishing reported state\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Publish reported state timed out, will retry shortly\");\n+            }\n+            return false;\n+        }\n+        if (DeploymentStatus.SUCCEEDED.equals(status) || DeploymentStatus.FAILED.equals(status)) {\n+            configurationCountPair.setLeft(configurationCountPair.getLeft() - 1);\n+            if (configurationCountPair.getLeft() == 0) {\n+                configArnToDesiredStateMap.remove(configurationArn);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    protected void shadowUpdated(Map<String, Object> configuration, Integer version) {\n+        if (configuration == null || configuration.isEmpty()) {\n+            logger.debug(\"Empty desired state, no device deployments created yet\");\n+            return;\n+        }\n+        FleetConfiguration fleetConfiguration = OBJECT_MAPPER.convertValue(configuration, FleetConfiguration.class);\n+        synchronized (ShadowDeploymentListener.class) {\n+            if (lastVersion != null && lastVersion > version) {", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzOTYxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497639614", "bodyText": "version 4, during cancellation the shadow is updates causing the version to be bumped up.", "author": "fahadmohammed01", "createdAt": "2020-09-30T16:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5OTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTA0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497201045", "bodyText": "Why is this needed? This is not safe. The document from any source should be json and then DeploymentService parses it depending on the deploymentType.", "author": "abanthiy", "createdAt": "2020-09-30T01:59:19Z", "path": "src/main/java/com/aws/greengrass/deployment/model/Deployment.java", "diffHunk": "@@ -41,7 +41,7 @@\n      * @param deploymentType deployment type\n      * @param id deployment id\n      */\n-    public Deployment(String deploymentDocument, DeploymentType deploymentType, String id) {\n+    public Deployment(Object deploymentDocument, DeploymentType deploymentType, String id) {", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTMwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497201307", "bodyText": "You don't need this conversion here. Just pull put the configuration arn from the map. This conversion should happen in DeploymentService. Keeping it here just makes it confusing in the DeploymentService and now I know why you do not deserialize over there. But I would prefer deserializing there, unless there is some other reason for this. You can just serialize it here.", "author": "abanthiy", "createdAt": "2020-09-30T02:00:24Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);\n+        Pair<Integer, Map<String, Object>> configurationCountPair = configArnToDesiredStateMap.get(configurationArn);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(configurationCountPair.getRight());\n+\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                return true;\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while publishing reported state\");\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while publishing reported state\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Publish reported state timed out, will retry shortly\");\n+            }\n+            return false;\n+        }\n+        if (DeploymentStatus.SUCCEEDED.equals(status) || DeploymentStatus.FAILED.equals(status)) {\n+            configurationCountPair.setLeft(configurationCountPair.getLeft() - 1);\n+            if (configurationCountPair.getLeft() == 0) {\n+                configArnToDesiredStateMap.remove(configurationArn);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    protected void shadowUpdated(Map<String, Object> configuration, Integer version) {\n+        if (configuration == null || configuration.isEmpty()) {\n+            logger.debug(\"Empty desired state, no device deployments created yet\");\n+            return;\n+        }\n+        FleetConfiguration fleetConfiguration = OBJECT_MAPPER.convertValue(configuration, FleetConfiguration.class);", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4ODA5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498588095", "bodyText": "removed", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTk4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497201988", "bodyText": "I don't understand this reasoning. Why do we need to persist data for rollback here?\nIn my mind a desired state corresponds to a config arn, so we should not be deploying a config arn multiple times.", "author": "abanthiy", "createdAt": "2020-09-30T02:03:31Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4Njc2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497786765", "bodyText": "In case of failure and rollback, is it ok to not update the reported state? Or do we need to update reported state with a newer timestamp?", "author": "hui-yang", "createdAt": "2020-09-30T20:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNDQ3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497814478", "bodyText": "we only update the reported state when the device moves to a new configuration. Failures are reported via FSS.", "author": "fahadmohammed01", "createdAt": "2020-09-30T21:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkwNTI0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497905247", "bodyText": "Doesn't rollback happen as part of the deployment execution, or is this rollback referring to the kernel update deployment rollback? I'm confused why there will be two different status entries with same config arn like this comment says", "author": "shaguptashaikh", "createdAt": "2020-10-01T01:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4ODA1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498588050", "bodyText": "reverted this piece of logic", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMjYwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497202606", "bodyText": "Change the name to CONFIGURATION_ARN", "author": "abanthiy", "createdAt": "2020-09-30T02:06:12Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);\n+        Pair<Integer, Map<String, Object>> configurationCountPair = configArnToDesiredStateMap.get(configurationArn);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(configurationCountPair.getRight());\n+\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                return true;\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while publishing reported state\");\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while publishing reported state\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Publish reported state timed out, will retry shortly\");\n+            }\n+            return false;\n+        }\n+        if (DeploymentStatus.SUCCEEDED.equals(status) || DeploymentStatus.FAILED.equals(status)) {\n+            configurationCountPair.setLeft(configurationCountPair.getLeft() - 1);\n+            if (configurationCountPair.getLeft() == 0) {\n+                configArnToDesiredStateMap.remove(configurationArn);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    protected void shadowUpdated(Map<String, Object> configuration, Integer version) {\n+        if (configuration == null || configuration.isEmpty()) {\n+            logger.debug(\"Empty desired state, no device deployments created yet\");\n+            return;\n+        }\n+        FleetConfiguration fleetConfiguration = OBJECT_MAPPER.convertValue(configuration, FleetConfiguration.class);\n+        synchronized (ShadowDeploymentListener.class) {\n+            if (lastVersion != null && lastVersion > version) {\n+                logger.atInfo().kv(\"CONFIGURATION_ARN\", fleetConfiguration.getConfigurationArn())\n+                        .kv(\"SHADOW_VERSION\", version)\n+                        .log(\"Old deployment notification, Ignoring...\");\n+                return;\n+            }\n+            if (lastConfigurationArn != null && lastConfigurationArn.equals(fleetConfiguration.getConfigurationArn())) {\n+                logger.atInfo().kv(\"CONFIGURATION_ARN\", fleetConfiguration.getConfigurationArn())\n+                        .log(\"Duplicate deployment notification, Ignoring...\");\n+                return;\n+            }\n+            lastConfigurationArn = fleetConfiguration.getConfigurationArn();\n+            lastVersion = version;\n+        }\n+        configArnToDesiredStateMap.compute(fleetConfiguration.getConfigurationArn(), (arn, pair) -> {\n+            if (pair == null) {\n+                pair = new Pair(1, configuration);\n+            } else {\n+                pair.setLeft(pair.getLeft() + 1);\n+            }\n+            return pair;\n+        });\n+        Deployment deployment =\n+                new Deployment(fleetConfiguration, DeploymentType.SHADOW, fleetConfiguration.getConfigurationArn());\n+        deploymentsQueue.add(deployment);\n+    }\n+\n+\n+    private MqttClientConnection getMqttClientConnection() {\n+        return new WrapperMqttClientConnection(mqttClient);\n+    }\n+\n+    @Data\n+    @SuppressWarnings(\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\")\n+    @SuppressFBWarnings\n+    public static class DeviceDeploymentDetails {\n+        @JsonProperty(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN)", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4Nzk3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498587976", "bodyText": "not using DeviceDeploymentDetails anymore", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3OTEzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497679130", "bodyText": "I would not call it JOB status as that refers to Iot Jobs. Would prefer DEPLOYMENT_STATUS", "author": "abanthiy", "createdAt": "2020-09-30T17:23:02Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);\n+        Pair<Integer, Map<String, Object>> configurationCountPair = configArnToDesiredStateMap.get(configurationArn);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(configurationCountPair.getRight());\n+\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                return true;\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while publishing reported state\");\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while publishing reported state\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Publish reported state timed out, will retry shortly\");\n+            }\n+            return false;\n+        }\n+        if (DeploymentStatus.SUCCEEDED.equals(status) || DeploymentStatus.FAILED.equals(status)) {\n+            configurationCountPair.setLeft(configurationCountPair.getLeft() - 1);\n+            if (configurationCountPair.getLeft() == 0) {\n+                configArnToDesiredStateMap.remove(configurationArn);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    protected void shadowUpdated(Map<String, Object> configuration, Integer version) {\n+        if (configuration == null || configuration.isEmpty()) {\n+            logger.debug(\"Empty desired state, no device deployments created yet\");\n+            return;\n+        }\n+        FleetConfiguration fleetConfiguration = OBJECT_MAPPER.convertValue(configuration, FleetConfiguration.class);\n+        synchronized (ShadowDeploymentListener.class) {\n+            if (lastVersion != null && lastVersion > version) {\n+                logger.atInfo().kv(\"CONFIGURATION_ARN\", fleetConfiguration.getConfigurationArn())\n+                        .kv(\"SHADOW_VERSION\", version)\n+                        .log(\"Old deployment notification, Ignoring...\");\n+                return;\n+            }\n+            if (lastConfigurationArn != null && lastConfigurationArn.equals(fleetConfiguration.getConfigurationArn())) {\n+                logger.atInfo().kv(\"CONFIGURATION_ARN\", fleetConfiguration.getConfigurationArn())\n+                        .log(\"Duplicate deployment notification, Ignoring...\");\n+                return;\n+            }\n+            lastConfigurationArn = fleetConfiguration.getConfigurationArn();\n+            lastVersion = version;\n+        }\n+        configArnToDesiredStateMap.compute(fleetConfiguration.getConfigurationArn(), (arn, pair) -> {\n+            if (pair == null) {\n+                pair = new Pair(1, configuration);\n+            } else {\n+                pair.setLeft(pair.getLeft() + 1);\n+            }\n+            return pair;\n+        });\n+        Deployment deployment =\n+                new Deployment(fleetConfiguration, DeploymentType.SHADOW, fleetConfiguration.getConfigurationArn());\n+        deploymentsQueue.add(deployment);\n+    }\n+\n+\n+    private MqttClientConnection getMqttClientConnection() {\n+        return new WrapperMqttClientConnection(mqttClient);\n+    }\n+\n+    @Data\n+    @SuppressWarnings(\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\")\n+    @SuppressFBWarnings\n+    public static class DeviceDeploymentDetails {\n+        @JsonProperty(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN)\n+        private String configurationArn;\n+        @JsonProperty(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS)", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4Nzk0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498587944", "bodyText": "No using DeviceDeploymentDetails anymore", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3OTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTIyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497081220", "bodyText": "nit: IotJobsHelper, ShadowDeploymentListener and instantiate, inject", "author": "hui-yang", "createdAt": "2020-09-29T21:50:12Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -150,10 +150,11 @@ public DeploymentService(Topics topics) {\n     @Override\n     public void postInject() {\n         super.postInject();\n-        // Informing kernel about IotJobsHelper and LocalDeploymentListener so kernel can instantiate,\n-        // inject dependencies and call post inject.\n+        // Informing kernel about IotJobsHelper ShadowDeploymentListener and LocalDeploymentListener,\n+        // so kernel can instantiate,inject dependencies and call post inject.", "originalCommit": "7dc0b98f0c5a15ea0020b5cc9dbd89c92ee20b8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4Nzg4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498587884", "bodyText": "Updated", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjE1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497082153", "bodyText": "Do we need to compare the id of current deployment and new shadow deployment here?", "author": "hui-yang", "createdAt": "2020-09-29T21:52:19Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -180,11 +181,21 @@ protected void startup() throws InterruptedException {\n                 if (currentDeploymentTaskMetadata != null && currentDeploymentTaskMetadata.getDeploymentType()\n                         .equals(deployment.getDeploymentType()) && deployment.isCancelled()\n                         && currentDeploymentTaskMetadata.isCancellable()) {\n-                    logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n+                    logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n                             .log(\"Canceling current deployment\");\n                     // Assuming cancel will either cancel the current deployment or wait till it finishes\n                     cancelCurrentDeployment();\n                 }\n+                // A new device deployment invalidates the previous deployment, cancel the ongoing device deployment\n+                // and wait till the new device deployment can be picked up.\n+                if (deployment.getDeploymentType() == Deployment.DeploymentType.SHADOW\n+                        && currentDeploymentTaskMetadata != null\n+                        && currentDeploymentTaskMetadata.getDeploymentType() == Deployment.DeploymentType.SHADOW) {", "originalCommit": "7dc0b98f0c5a15ea0020b5cc9dbd89c92ee20b8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMjM3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497812372", "bodyText": "no, any new shadow deployment invalidates the previous one. Here we try to cancel an ongoing shadow deployment if a new one arrives.", "author": "fahadmohammed01", "createdAt": "2020-09-30T21:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgyMDQ1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497820452", "bodyText": "what about before and after kernel restart? will we get notified of the same shadow version?", "author": "hui-yang", "createdAt": "2020-09-30T21:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4Nzg2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498587861", "bodyText": "Stored the last deployed configuration arn in Deployment service topics and de-dupe shadow deployments using that to avoid processing the same device deployment in the before and after kernel restart scenerio", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQ4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497082485", "bodyText": "Is this deployment Id basically fleet config arn?", "author": "hui-yang", "createdAt": "2020-09-29T21:53:05Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -180,11 +181,21 @@ protected void startup() throws InterruptedException {\n                 if (currentDeploymentTaskMetadata != null && currentDeploymentTaskMetadata.getDeploymentType()\n                         .equals(deployment.getDeploymentType()) && deployment.isCancelled()\n                         && currentDeploymentTaskMetadata.isCancellable()) {\n-                    logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n+                    logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())", "originalCommit": "7dc0b98f0c5a15ea0020b5cc9dbd89c92ee20b8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMTg0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497811845", "bodyText": "Here it will be Iot job's Id.", "author": "fahadmohammed01", "createdAt": "2020-09-30T21:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4NDcxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497784718", "bodyText": "Can we reuse util.SerializerFactory if possible?", "author": "hui-yang", "createdAt": "2020-09-30T20:36:06Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMjU2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497812562", "bodyText": "Updated", "author": "fahadmohammed01", "createdAt": "2020-09-30T21:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4NDcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4NzYyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497787627", "bodyText": "Do we support updating device info in runtime? If yes, how can we start these listeners if device info is added to config?", "author": "hui-yang", "createdAt": "2020-09-30T20:41:54Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5OTMwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498599303", "bodyText": "I dont think we handle updating device info in runtime yet. There is a bunch of places we need to update if need to do it", "author": "fahadmohammed01", "createdAt": "2020-10-02T02:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4NzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4OTY1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497789654", "bodyText": "Not sure if I understand what this code is doing. What is count used for?", "author": "hui-yang", "createdAt": "2020-09-30T20:45:55Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);\n+        Pair<Integer, Map<String, Object>> configurationCountPair = configArnToDesiredStateMap.get(configurationArn);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(configurationCountPair.getRight());\n+\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                return true;\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while publishing reported state\");\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while publishing reported state\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Publish reported state timed out, will retry shortly\");\n+            }\n+            return false;\n+        }\n+        if (DeploymentStatus.SUCCEEDED.equals(status) || DeploymentStatus.FAILED.equals(status)) {\n+            configurationCountPair.setLeft(configurationCountPair.getLeft() - 1);\n+            if (configurationCountPair.getLeft() == 0) {\n+                configArnToDesiredStateMap.remove(configurationArn);\n+            }\n+        }", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4NzUwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498587509", "bodyText": "reverted this logic", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4OTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTc3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497791770", "bodyText": "Why do we need 3 different classes of deploymentDetails for each type?", "author": "hui-yang", "createdAt": "2020-09-30T20:49:50Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        //TODO: publish status via FSS\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS));\n+\n+        String configurationArn = (String)\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEVICE_DEPLOYMENT_ARN);\n+        Pair<Integer, Map<String, Object>> configurationCountPair = configArnToDesiredStateMap.get(configurationArn);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(configurationCountPair.getRight());\n+\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                return true;\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while publishing reported state\");\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while publishing reported state\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Publish reported state timed out, will retry shortly\");\n+            }\n+            return false;\n+        }\n+        if (DeploymentStatus.SUCCEEDED.equals(status) || DeploymentStatus.FAILED.equals(status)) {\n+            configurationCountPair.setLeft(configurationCountPair.getLeft() - 1);\n+            if (configurationCountPair.getLeft() == 0) {\n+                configArnToDesiredStateMap.remove(configurationArn);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    protected void shadowUpdated(Map<String, Object> configuration, Integer version) {\n+        if (configuration == null || configuration.isEmpty()) {\n+            logger.debug(\"Empty desired state, no device deployments created yet\");\n+            return;\n+        }\n+        FleetConfiguration fleetConfiguration = OBJECT_MAPPER.convertValue(configuration, FleetConfiguration.class);\n+        synchronized (ShadowDeploymentListener.class) {\n+            if (lastVersion != null && lastVersion > version) {\n+                logger.atInfo().kv(\"CONFIGURATION_ARN\", fleetConfiguration.getConfigurationArn())\n+                        .kv(\"SHADOW_VERSION\", version)\n+                        .log(\"Old deployment notification, Ignoring...\");\n+                return;\n+            }\n+            if (lastConfigurationArn != null && lastConfigurationArn.equals(fleetConfiguration.getConfigurationArn())) {\n+                logger.atInfo().kv(\"CONFIGURATION_ARN\", fleetConfiguration.getConfigurationArn())\n+                        .log(\"Duplicate deployment notification, Ignoring...\");\n+                return;\n+            }\n+            lastConfigurationArn = fleetConfiguration.getConfigurationArn();\n+            lastVersion = version;\n+        }\n+        configArnToDesiredStateMap.compute(fleetConfiguration.getConfigurationArn(), (arn, pair) -> {\n+            if (pair == null) {\n+                pair = new Pair(1, configuration);\n+            } else {\n+                pair.setLeft(pair.getLeft() + 1);\n+            }\n+            return pair;\n+        });\n+        Deployment deployment =\n+                new Deployment(fleetConfiguration, DeploymentType.SHADOW, fleetConfiguration.getConfigurationArn());\n+        deploymentsQueue.add(deployment);\n+    }\n+\n+\n+    private MqttClientConnection getMqttClientConnection() {\n+        return new WrapperMqttClientConnection(mqttClient);\n+    }\n+\n+    @Data\n+    @SuppressWarnings(\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\")\n+    @SuppressFBWarnings\n+    public static class DeviceDeploymentDetails {", "originalCommit": "3eeb2e97f28a4fff64ff537ea8bd747646a4efa2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwNjM4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497806381", "bodyText": "Not really, that clean up needs to happen. Didn't want to introduce a lot of changes to this PR", "author": "fahadmohammed01", "createdAt": "2020-09-30T21:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxOTg2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497819869", "bodyText": "\ud83d\udc4d  maybe in this PR, we can start with reusing IotJobsHelper.DeploymentDetailsIotJobs instead of adding DeviceDeploymentDetails?", "author": "hui-yang", "createdAt": "2020-09-30T21:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxMDUyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497910526", "bodyText": "+1, will be nice if we could clean up a bit", "author": "shaguptashaikh", "createdAt": "2020-10-01T01:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4NzQ5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498587490", "bodyText": "Removed 2 of the deployment details classes, LocalDeploymentDetails used in CLIServiceAgent for persistence. But it is not used in Deployment status keeper", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTc3MA=="}], "type": "inlineReview"}, {"oid": "da370faf1b864c8d6731f962fa970a027e0ce7d3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/da370faf1b864c8d6731f962fa970a027e0ce7d3", "message": "publish status via FSS", "committedDate": "2020-09-30T21:06:17Z", "type": "commit"}, {"oid": "83c02c0db1fc599a8231284b5db7e06d6ce2e33f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/83c02c0db1fc599a8231284b5db7e06d6ce2e33f", "message": "Merge branch 'device_deployment' of github.com:aws/aws-greengrass-kernel into device_deployment", "committedDate": "2020-09-30T21:06:44Z", "type": "commit"}, {"oid": "e89b2a4026ee8e5b5d85cc738d181d89620d6083", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e89b2a4026ee8e5b5d85cc738d181d89620d6083", "message": "addressed comments", "committedDate": "2020-09-30T21:38:13Z", "type": "commit"}, {"oid": "aab71c93314932918e891461b29ad80edfc5777d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aab71c93314932918e891461b29ad80edfc5777d", "message": "Merge branch 'master' into device_deployment", "committedDate": "2020-09-30T22:01:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg5NzQ5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497897498", "bodyText": "nit - equals", "author": "shaguptashaikh", "createdAt": "2020-10-01T01:00:23Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -180,11 +181,21 @@ protected void startup() throws InterruptedException {\n                 if (currentDeploymentTaskMetadata != null && currentDeploymentTaskMetadata.getDeploymentType()\n                         .equals(deployment.getDeploymentType()) && deployment.isCancelled()\n                         && currentDeploymentTaskMetadata.isCancellable()) {\n-                    logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n+                    logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n                             .log(\"Canceling current deployment\");\n                     // Assuming cancel will either cancel the current deployment or wait till it finishes\n                     cancelCurrentDeployment();\n                 }\n+                // A new device deployment invalidates the previous deployment, cancel the ongoing device deployment\n+                // and wait till the new device deployment can be picked up.\n+                if (deployment.getDeploymentType() == Deployment.DeploymentType.SHADOW\n+                        && currentDeploymentTaskMetadata != null\n+                        && currentDeploymentTaskMetadata.getDeploymentType() == Deployment.DeploymentType.SHADOW) {", "originalCommit": "aab71c93314932918e891461b29ad80edfc5777d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4Njg4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498586887", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg5NzQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkwMDE5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497900196", "bodyText": "Why switching from empty to null check?", "author": "shaguptashaikh", "createdAt": "2020-10-01T01:04:45Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -395,16 +408,16 @@ private DefaultDeploymentTask createDefaultNewDeployment(Deployment deployment)\n     }\n \n     private DeploymentDocument parseAndValidateJobDocument(Deployment deployment) throws InvalidRequestException {\n-        String jobDocumentString = deployment.getDeploymentDocument();\n-        if (Utils.isEmpty(jobDocumentString)) {", "originalCommit": "aab71c93314932918e891461b29ad80edfc5777d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4Njg2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498586868", "bodyText": "reverted this", "author": "fahadmohammed01", "createdAt": "2020-10-02T01:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkwMDE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkwNjAzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497906037", "bodyText": "Why not use isDeviceConfiguredToTalkToCloud() here?", "author": "shaguptashaikh", "createdAt": "2020-10-01T01:13:44Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.FleetConfiguration;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.SerializerFactory;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_CONFIGURATION_ARN;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_STATUS;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_TYPE;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    @Inject\n+    @Named(DEPLOYMENTS_QUEUE)\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+\n+    @Setter\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    //Once deployment succeeds, the reported state of the shadow needs to be synced with the desired state.\n+    //This map keeps track of configArn to desired state mapping. During rollback, the same configArn will be present\n+    // multiple deployments so a pair is used to keep track of the count of deployments with the same config arn.\n+    // The count is used for clean up purposes.\n+    private final Map<String, Pair<Integer, Map<String, Object>>> configArnToDesiredStateMap = new HashMap<>();\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        try {\n+            deviceConfiguration.validate();\n+        } catch (DeviceConfigurationException e) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }", "originalCommit": "aab71c93314932918e891461b29ad80edfc5777d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5MjIwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498592201", "bodyText": "Added isDeviceConfiguredToTalkToCloud after making this change, updated", "author": "fahadmohammed01", "createdAt": "2020-10-02T02:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkwNjAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxMDA4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r497910084", "bodyText": "This else block doesn't seem to be doing anything too different from the if block for jobs above, can we unify them?", "author": "shaguptashaikh", "createdAt": "2020-10-01T01:19:54Z", "path": "src/main/java/com/aws/greengrass/status/FleetStatusService.java", "diffHunk": "@@ -235,6 +242,16 @@ private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n                     deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID));\n             isDeploymentInProgress.set(false);\n             updateEventTriggeredFleetStatusData();\n+        } else if (type == SHADOW) {\n+            String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_DEPLOYMENT_STATUS).toString();\n+            if (DeploymentStatus.IN_PROGRESS.toString().equals(status)) {\n+                isDeploymentInProgress.set(true);\n+                return true;\n+            }\n+            logger.atDebug().log(\"Updating Fleet Status service for shadow deployment with Configuration: {}\",\n+                    deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_CONFIGURATION_ARN));\n+            isDeploymentInProgress.set(false);\n+            updateEventTriggeredFleetStatusData();", "originalCommit": "aab71c93314932918e891461b29ad80edfc5777d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5Nzc2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498597766", "bodyText": "refactored", "author": "fahadmohammed01", "createdAt": "2020-10-02T02:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxMDA4NA=="}], "type": "inlineReview"}, {"oid": "82a10983edcbaebdbb49ddfb280f4d18626efb78", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/82a10983edcbaebdbb49ddfb280f4d18626efb78", "message": "Merge branch 'master' into device_deployment", "committedDate": "2020-10-02T01:42:55Z", "type": "commit"}, {"oid": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "message": "addressed comments", "committedDate": "2020-10-02T02:08:40Z", "type": "commit"}, {"oid": "cbbe4c0f41f0b40fa8e5bb778434ce481839a953", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbbe4c0f41f0b40fa8e5bb778434ce481839a953", "message": "addressed comments", "committedDate": "2020-10-02T02:42:37Z", "type": "commit"}, {"oid": "a4280c1382d684d45eade0413abfa3c177e021fd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a4280c1382d684d45eade0413abfa3c177e021fd", "message": "added more comments", "committedDate": "2020-10-02T02:50:02Z", "type": "commit"}, {"oid": "963130c63aff7f3dcd83517673e37682388d2140", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/963130c63aff7f3dcd83517673e37682388d2140", "message": "minor bug fix", "committedDate": "2020-10-02T04:24:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYxNDAzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498614036", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentLinkedQueue, but your usage of peek(), null check, and remove() may not be thread-safe at lines: 176, 179, 184, and 198. If the ConcurrentLinkedQueue contains only one element and two threads perform this same check at the same time , the second thread's call to remove() will throw NoSuchElementException.\nFix\nConsider using poll() (does not throw an exception, but it may return null, which you can check for) or handling the exception.", "author": "MikeDombo", "createdAt": "2020-10-02T04:27:10Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.SerializerFactory;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    public static final String CONFIGURATION_ARN_LOG_KEY_NAME = \"CONFIGURATION_ARN\";\n+    private final Queue<Pair<String, Map<String, Object>>> desiredStateQueue = new ConcurrentLinkedQueue<>();\n+    @Inject\n+    private DeploymentQueue deploymentQueue;\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+    @Inject\n+    private MqttClient mqttClient;\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    @Setter\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        if (!deviceConfiguration.isDeviceConfiguredToTalkToCloud()) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof MqttException || cause instanceof TimeoutException) {\n+                    //TODO: If network is not available then it will throw MqttException\n+                    // If there is any other problem like thingName is not specified in the request then also\n+                    // it throws Mqtt exception. This can be identified based on error code. Currently error code is not\n+                    // exposed. Will make required change in CRT package to expose the error code and then update this\n+                    logger.atWarn().setCause(cause).log(\"Caught exception while subscribing to shadow topics, \"\n+                            + \"will retry shortly\");\n+                }\n+                if (cause instanceof InterruptedException) {\n+                    logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                    return;\n+                }\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    @SuppressFBWarnings\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(DEPLOYMENT_STATUS_KEY_NAME));\n+\n+        String configurationArn = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+\n+            Pair<String, Map<String, Object>> desired = desiredStateQueue.peek();\n+            // discard configurations that might have got added to the queue but the deployment\n+            // got discarded before being processed due to a new shadow deployment\n+            while (desired != null && !desired.getLeft().equals(configurationArn)) {\n+                desiredStateQueue.poll();\n+                desired = desiredStateQueue.peek();\n+            }\n+\n+            if (desired == null) {\n+                logger.atError().kv(CONFIGURATION_ARN_LOG_KEY_NAME, configurationArn)\n+                        .log(\"Unable to update shadow for deployment\");\n+                return true;\n+            }\n+\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(desired.getRight());\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                desiredStateQueue.remove();", "originalCommit": "963130c63aff7f3dcd83517673e37682388d2140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYxNDAzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498614037", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentLinkedQueue, but your usage of peek(), null check, and remove() may not be thread-safe at lines: 181, 184, 198, and 179. If the ConcurrentLinkedQueue contains only one element and two threads perform this same check at the same time , the second thread's call to remove() will throw NoSuchElementException.\nFix\nConsider using poll() (does not throw an exception, but it may return null, which you can check for) or handling the exception.", "author": "MikeDombo", "createdAt": "2020-10-02T04:27:11Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.SerializerFactory;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    public static final String CONFIGURATION_ARN_LOG_KEY_NAME = \"CONFIGURATION_ARN\";\n+    private final Queue<Pair<String, Map<String, Object>>> desiredStateQueue = new ConcurrentLinkedQueue<>();\n+    @Inject\n+    private DeploymentQueue deploymentQueue;\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+    @Inject\n+    private MqttClient mqttClient;\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    @Setter\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        if (!deviceConfiguration.isDeviceConfiguredToTalkToCloud()) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof MqttException || cause instanceof TimeoutException) {\n+                    //TODO: If network is not available then it will throw MqttException\n+                    // If there is any other problem like thingName is not specified in the request then also\n+                    // it throws Mqtt exception. This can be identified based on error code. Currently error code is not\n+                    // exposed. Will make required change in CRT package to expose the error code and then update this\n+                    logger.atWarn().setCause(cause).log(\"Caught exception while subscribing to shadow topics, \"\n+                            + \"will retry shortly\");\n+                }\n+                if (cause instanceof InterruptedException) {\n+                    logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                    return;\n+                }\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    @SuppressFBWarnings\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(DEPLOYMENT_STATUS_KEY_NAME));\n+\n+        String configurationArn = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+\n+            Pair<String, Map<String, Object>> desired = desiredStateQueue.peek();\n+            // discard configurations that might have got added to the queue but the deployment\n+            // got discarded before being processed due to a new shadow deployment\n+            while (desired != null && !desired.getLeft().equals(configurationArn)) {\n+                desiredStateQueue.poll();\n+                desired = desiredStateQueue.peek();\n+            }\n+\n+            if (desired == null) {\n+                logger.atError().kv(CONFIGURATION_ARN_LOG_KEY_NAME, configurationArn)\n+                        .log(\"Unable to update shadow for deployment\");\n+                return true;\n+            }\n+\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(desired.getRight());\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                desiredStateQueue.remove();", "originalCommit": "963130c63aff7f3dcd83517673e37682388d2140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYxNDAzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498614039", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentLinkedQueue, but your usage of peek() and peek() may not be thread-safe at lines: 176, 179, and 181. If the ConcurrentLinkedQueue contains only one element and another thread removes that element, this thread's call to peek() will get null. This null may be used at lines: 179 and 184. The removes that can remove the element are at lines: 198 and 180.\nFix\nConsider calling peek(), checking instead of your current check if the returned object is null, and only then using that object.", "author": "MikeDombo", "createdAt": "2020-10-02T04:27:11Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.SerializerFactory;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    public static final String CONFIGURATION_ARN_LOG_KEY_NAME = \"CONFIGURATION_ARN\";\n+    private final Queue<Pair<String, Map<String, Object>>> desiredStateQueue = new ConcurrentLinkedQueue<>();\n+    @Inject\n+    private DeploymentQueue deploymentQueue;\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+    @Inject\n+    private MqttClient mqttClient;\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    @Setter\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        if (!deviceConfiguration.isDeviceConfiguredToTalkToCloud()) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof MqttException || cause instanceof TimeoutException) {\n+                    //TODO: If network is not available then it will throw MqttException\n+                    // If there is any other problem like thingName is not specified in the request then also\n+                    // it throws Mqtt exception. This can be identified based on error code. Currently error code is not\n+                    // exposed. Will make required change in CRT package to expose the error code and then update this\n+                    logger.atWarn().setCause(cause).log(\"Caught exception while subscribing to shadow topics, \"\n+                            + \"will retry shortly\");\n+                }\n+                if (cause instanceof InterruptedException) {\n+                    logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                    return;\n+                }\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    @SuppressFBWarnings\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(DEPLOYMENT_STATUS_KEY_NAME));\n+\n+        String configurationArn = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+\n+            Pair<String, Map<String, Object>> desired = desiredStateQueue.peek();\n+            // discard configurations that might have got added to the queue but the deployment\n+            // got discarded before being processed due to a new shadow deployment\n+            while (desired != null && !desired.getLeft().equals(configurationArn)) {\n+                desiredStateQueue.poll();\n+                desired = desiredStateQueue.peek();", "originalCommit": "963130c63aff7f3dcd83517673e37682388d2140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTgxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498981810", "bodyText": "Why do we need this iteration? How about keeping a reference to the last shadow deployment, and in offer(), directly remove the previous reference from queue on a new shadow deployment", "author": "hui-yang", "createdAt": "2020-10-02T18:23:26Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentQueue.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+public class DeploymentQueue {\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentQueue.class);\n+    private final ConcurrentLinkedQueue<Deployment> deploymentsQueue = new ConcurrentLinkedQueue();\n+\n+    /**\n+     * Add a deployment to the queue.\n+     *\n+     * @param deployment deployment\n+     */\n+    public synchronized boolean offer(Deployment deployment) {\n+        //For shadow deployment when desired state is reverted, it can result in scheduling a deployment which is\n+        // same as\n+        if (!deployment.getDeploymentType().equals(DeploymentType.SHADOW) && deploymentsQueue.contains(deployment)) {\n+            return false;\n+        }\n+        return deploymentsQueue.offer(deployment);\n+    }\n+\n+    /**\n+     * Get the next deployment to be deployed.\n+     *\n+     * @return deployment\n+     */\n+    public synchronized Deployment peekNextDeployment() {\n+        Deployment deployment = deploymentsQueue.peek();\n+        // Discarding is not at schedule time because the deployment service does not remove the deployments atomically\n+        // Deployment service first peeks and determine if the next deployment is actionable.\n+        while (deployment != null && canDeploymentBeDiscarded(deployment)) {\n+            logger.atInfo().kv(\"DEPLOYMENT_ID\", deployment.getId())\n+                    .kv(\"DEPLOYMENT_TYPE\", deployment.getDeploymentType())\n+                    .log(\"Discarding device deployment\");\n+            deploymentsQueue.remove();\n+            deployment = deploymentsQueue.peek();\n+        }\n+        return deployment;\n+    }\n+\n+    /**\n+     * Removed the deployment from the head of the queue.\n+     */\n+    public synchronized void remove() {\n+        deploymentsQueue.remove();\n+    }\n+\n+    public boolean isEmpty() {\n+        return deploymentsQueue.isEmpty();\n+    }\n+\n+    private boolean canDeploymentBeDiscarded(Deployment selectedDeployment) {\n+        // If the selected deployment is of type shadow and there is another deployment in the queue\n+        // the selected deployment can be discarded. ShadowDeploymentListener ensures that shadow deployments are\n+        // queued based on the order in which they are created in the cloud.\n+        if (selectedDeployment.getDeploymentType().equals(DeploymentType.SHADOW)) {\n+            Iterator<Deployment> iterator = deploymentsQueue.iterator();\n+            while (iterator.hasNext()) {", "originalCommit": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5ODkyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498998926", "bodyText": "I have updated the method with comments, you are looking at a previous version. The reason discard is not done at schedule time because the DeploymentService does not remove the deployments from the queue atomically DeploymentService first peeks and executes some logic, then removes it from the queue. Deleting the deployment after the peek and before the remove can break assumptions the deployment service made.", "author": "fahadmohammed01", "createdAt": "2020-10-02T18:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MjYwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498982608", "bodyText": "nit: we can still keep peek as method name", "author": "hui-yang", "createdAt": "2020-10-02T18:25:01Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentQueue.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+public class DeploymentQueue {\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentQueue.class);\n+    private final ConcurrentLinkedQueue<Deployment> deploymentsQueue = new ConcurrentLinkedQueue();\n+\n+    /**\n+     * Add a deployment to the queue.\n+     *\n+     * @param deployment deployment\n+     */\n+    public synchronized boolean offer(Deployment deployment) {\n+        //For shadow deployment when desired state is reverted, it can result in scheduling a deployment which is\n+        // same as\n+        if (!deployment.getDeploymentType().equals(DeploymentType.SHADOW) && deploymentsQueue.contains(deployment)) {\n+            return false;\n+        }\n+        return deploymentsQueue.offer(deployment);\n+    }\n+\n+    /**\n+     * Get the next deployment to be deployed.\n+     *\n+     * @return deployment\n+     */\n+    public synchronized Deployment peekNextDeployment() {", "originalCommit": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMTE5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499001193", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-10-02T19:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MjYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDY4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498984683", "bodyText": "Do we still cancel the deployment if config arn is the same?", "author": "hui-yang", "createdAt": "2020-10-02T18:29:04Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -186,28 +179,36 @@ protected void startup() throws InterruptedException {\n                     // Assuming cancel will either cancel the current deployment or wait till it finishes\n                     cancelCurrentDeployment();\n                 }\n-                // A new device deployment invalidates the previous deployment, cancel the ongoing device deployment\n-                // and wait till the new device deployment can be picked up.\n-                if (deployment.getDeploymentType() == Deployment.DeploymentType.SHADOW\n-                        && currentDeploymentTaskMetadata != null\n-                        && currentDeploymentTaskMetadata.getDeploymentType() == Deployment.DeploymentType.SHADOW) {\n-                    logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n-                            .log(\"Canceling current device deployment\");\n-                    cancelCurrentDeployment();\n-                    continue;\n-                }\n                 if (currentDeploymentTaskMetadata != null && deployment.getId()\n                         .equals(currentDeploymentTaskMetadata.getDeploymentId()) && deployment.getDeploymentType()\n                         .equals(currentDeploymentTaskMetadata.getDeploymentType())) {\n                     // Duplicate message and already processing this deployment so nothing is needed\n-                    deploymentsQueue.remove();\n+                    deploymentQueue.remove();\n                     continue;\n                 }\n+                if (deployment.getDeploymentType().equals(DeploymentType.SHADOW)) {\n+                    // A new device deployment invalidates the previous deployment, cancel the ongoing device deployment\n+                    // and wait till the new device deployment can be picked up.\n+                    if (currentDeploymentTaskMetadata != null\n+                            && currentDeploymentTaskMetadata.getDeploymentType().equals(DeploymentType.SHADOW)) {\n+                        logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n+                                .log(\"Canceling current device deployment\");\n+                        cancelCurrentDeployment();", "originalCommit": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NDc3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498994771", "bodyText": "Shadow deployment listener will not schedule duplicate deployments for the same config arn, except for kernel restart scenarios. In case of kernel restart scenario, the last deployed config arn is stored in LAST_SUCCESSFUL_DEPLOYMENT_ID_TOPIC and is used to prevent an already processed deployment from happening again.", "author": "fahadmohammed01", "createdAt": "2020-10-02T18:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTMxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498985318", "bodyText": "How does LAST_SUCCESSFUL_DEPLOYMENT_ID_TOPIC work? Is it not for shadow deployment only?", "author": "hui-yang", "createdAt": "2020-10-02T18:30:13Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -241,6 +242,8 @@ private void finishCurrentDeployment() throws InterruptedException {\n                     Topics deploymentGroupTopics = config.lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS,\n                             deploymentDocument.getGroupName());\n \n+                    config.lookup(LAST_SUCCESSFUL_DEPLOYMENT_ID_TOPIC)\n+                            .withValue(currentDeploymentTaskMetadata.getDeploymentId());", "originalCommit": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NDg3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498994877", "bodyText": "Answered above.", "author": "fahadmohammed01", "createdAt": "2020-10-02T18:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTMxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMTg5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499011893", "bodyText": "Yeah it makes sense to me. Only question I have is seems LAST_SUCCESSFUL_DEPLOYMENT_ID_TOPIC can be updated to other types of deployments as well. I thought we only want last shadow deployment?", "author": "hui-yang", "createdAt": "2020-10-02T19:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NjQzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498986433", "bodyText": "Cool.", "author": "hui-yang", "createdAt": "2020-10-02T18:32:34Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -73,40 +63,13 @@ public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentTyp\n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            // TODO: Consider making DeploymentDetailsIotJobs and LocalDeploymentDetails inherit from the same base\n-            //  class with deployment type as common parameter and store those objects directly instead of Map\n-            Map<String, Object> deploymentDetails = null;\n-\n-            switch (deploymentType) {\n-                case IOT_JOBS:\n-                    IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n-                            new IotJobsHelper.DeploymentDetailsIotJobs();\n-                    deploymentDetailsIotJobs.setJobId(deploymentId);\n-                    deploymentDetailsIotJobs.setJobStatus(JobStatus.valueOf(status));\n-                    deploymentDetailsIotJobs.setStatusDetails(statusDetails);\n-                    deploymentDetailsIotJobs.setDeploymentType(DeploymentType.IOT_JOBS);\n-                    deploymentDetails = deploymentDetailsIotJobs.convertToMapOfObjects();\n-                    break;\n-                case LOCAL:\n-                    CLIServiceAgent.LocalDeploymentDetails localDeploymentDetails =\n-                            new CLIServiceAgent.LocalDeploymentDetails();\n-                    localDeploymentDetails.setDeploymentId(deploymentId);\n-                    localDeploymentDetails.setDeploymentType(DeploymentType.LOCAL);\n-                    localDeploymentDetails.setStatus(DeploymentStatus.valueOf(status));\n-                    deploymentDetails = localDeploymentDetails.convertToMapOfObject();\n-                    break;\n-                case SHADOW:\n-                    DeviceDeploymentDetails deviceDeploymentDetails = new DeviceDeploymentDetails();\n-                    deviceDeploymentDetails.setConfigurationArn(deploymentId);\n-                    deviceDeploymentDetails.setStatus(DeploymentStatus.valueOf(status));\n-                    deviceDeploymentDetails.setDeploymentType(DeploymentType.SHADOW);\n-                    deploymentDetails = deviceDeploymentDetails.convertToMapOfObjects();\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unexpected deploymentType: \" + deploymentType);\n-            }\n-\n+            logger.atDebug().kv(DEPLOYMENT_ID_KEY_NAME, deploymentId).kv(DEPLOYMENT_STATUS_KEY_NAME, status)\n+                    .log(\"Storing deployment status\");\n+            Map<String, Object> deploymentDetails = new HashMap<>();", "originalCommit": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzI2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498987266", "bodyText": "Seems LocalDeploymentListener is removed and ShadowDeploymentListener added", "author": "hui-yang", "createdAt": "2020-10-02T18:34:15Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -150,16 +143,16 @@ public DeploymentService(Topics topics) {\n     @Override\n     public void postInject() {\n         super.postInject();\n-        // Informing kernel about IotJobsHelper ShadowDeploymentListener and LocalDeploymentListener,\n-        // so kernel can instantiate,inject dependencies and call post inject.\n+        // Informing kernel about IotJobsHelper and LocalDeploymentListener,", "originalCommit": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5MDAwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498990003", "bodyText": "Yes, LocalDeploymentListener is no longer needed", "author": "fahadmohammed01", "createdAt": "2020-10-02T18:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNTEwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499015107", "bodyText": "need to update comment", "author": "hui-yang", "createdAt": "2020-10-02T19:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxODgyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499018826", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-10-02T19:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4ODI2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r498988265", "bodyText": "Add javadoc for desiredState?", "author": "hui-yang", "createdAt": "2020-10-02T18:36:18Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -52,21 +46,17 @@\n     private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n     private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n     private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    private final Queue<Pair<String, Map<String, Object>>> desiredState = new ConcurrentLinkedQueue<>();", "originalCommit": "93125aa91fc311cbeda4e63564092d4cc7ff6ccb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMTI1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499001257", "bodyText": "added", "author": "fahadmohammed01", "createdAt": "2020-10-02T19:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4ODI2NQ=="}], "type": "inlineReview"}, {"oid": "2b92f4e4fdbad97df7b9253bd5052af6f3489320", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2b92f4e4fdbad97df7b9253bd5052af6f3489320", "message": "added comments", "committedDate": "2020-10-02T19:05:07Z", "type": "commit"}, {"oid": "3986cdad197ccbb7759fbe548d92583e0368d77d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3986cdad197ccbb7759fbe548d92583e0368d77d", "message": "Merge branch 'master' into device_deployment", "committedDate": "2020-10-02T19:06:07Z", "type": "commit"}, {"oid": "f6c96af29d22ab1f36037dd9e06abdf7145629af", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f6c96af29d22ab1f36037dd9e06abdf7145629af", "message": "addressed comments", "committedDate": "2020-10-02T19:46:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MjAzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499042039", "bodyText": "Nit - just say Get next deployment?", "author": "shaguptashaikh", "createdAt": "2020-10-02T20:44:39Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentQueue.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+public class DeploymentQueue {\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentQueue.class);\n+    private final ConcurrentLinkedQueue<Deployment> deploymentsQueue = new ConcurrentLinkedQueue();\n+\n+    /**\n+     * Add a deployment to the queue.\n+     *\n+     * @param deployment deployment\n+     */\n+    public synchronized boolean offer(Deployment deployment) {\n+        //For shadow deployment when desired state is reverted, it can result in scheduling a deployment which is\n+        // same as\n+        if (!DeploymentType.SHADOW.equals(deployment.getDeploymentType()) && deploymentsQueue.contains(deployment)) {\n+            return false;\n+        }\n+        return deploymentsQueue.offer(deployment);\n+    }\n+\n+    /**\n+     * Get the next deployment to be deployed.", "originalCommit": "f6c96af29d22ab1f36037dd9e06abdf7145629af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MTQ1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499051452", "bodyText": "How do we handle effective cancellations? We should be removing (synchronized with DeploymentService) from deployment queue if possible right?", "author": "abanthiy", "createdAt": "2020-10-02T21:09:04Z", "path": "src/main/java/com/aws/greengrass/deployment/ShadowDeploymentListener.java", "diffHunk": "@@ -0,0 +1,258 @@\n+package com.aws.greengrass.deployment;\n+\n+import com.aws.greengrass.dependency.InjectionActions;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.WrapperMqttClientConnection;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.SerializerFactory;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotshadow.IotShadowClient;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.GetShadowSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.ShadowState;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowRequest;\n+import software.amazon.awssdk.iot.iotshadow.model.UpdateShadowSubscriptionRequest;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.model.Deployment.DeploymentType;\n+\n+public class ShadowDeploymentListener implements InjectionActions {\n+\n+    private static final long TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS = Duration.ofMinutes(1).getSeconds();\n+    private static final long WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS = Duration.ofMinutes(2).toMillis();\n+    private static final Logger logger = LogManager.getLogger(ShadowDeploymentListener.class);\n+    public static final String CONFIGURATION_ARN_LOG_KEY_NAME = \"CONFIGURATION_ARN\";\n+    //Keeps track of the deployment config-arn and the desired state, in the order in which deployments\n+    //were received.\n+    private final Queue<Pair<String, Map<String, Object>>> desiredStateQueue = new ConcurrentLinkedQueue<>();\n+    @Inject\n+    private DeploymentQueue deploymentQueue;\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+    @Inject\n+    private MqttClient mqttClient;\n+    @Inject\n+    private ExecutorService executorService;\n+    @Inject\n+    private DeviceConfiguration deviceConfiguration;\n+    @Setter\n+    private IotShadowClient iotShadowClient;\n+    private String thingName;\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            executorService.execute(() -> {\n+                // Get the shadow state when connection is re-established by publishing to get topic\n+                publishToGetDeviceShadowTopic();\n+                deploymentStatusKeeper.publishPersistedStatusUpdates(DeploymentType.SHADOW);\n+            });\n+        }\n+    };\n+    private String lastConfigurationArn;\n+    private Integer lastVersion;\n+\n+    @Override\n+    public void postInject() {\n+\n+        if (!deviceConfiguration.isDeviceConfiguredToTalkToCloud()) {\n+            logger.atWarn().log(\"Device not configured to talk to AWS Iot cloud. Device will run in offline mode\");\n+            return;\n+        }\n+\n+        this.thingName = Coerce.toString(deviceConfiguration.getThingName());\n+        this.iotShadowClient = new IotShadowClient(getMqttClientConnection());\n+        mqttClient.addToCallbackEvents(callbacks);\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.SHADOW,\n+                this::deploymentStatusChanged, ShadowDeploymentListener.class.getName());\n+        executorService.execute(() -> {\n+            subscribeToShadowTopics();\n+            // Get the shadow state when kernel starts up by publishing to get topic\n+            publishToGetDeviceShadowTopic();\n+        });\n+    }\n+\n+\n+    /*\n+        Subscribe to \"$aws/things/{thingName}/shadow/update/accepted\" topic to get notified when shadow is updated\n+        Subscribe to \"$aws/things/{thingName}/shadow/get/accepted\" topic to retrieve shadow by publishing to get topic\n+     */\n+    private void subscribeToShadowTopics() {\n+        while (true) {\n+            try {\n+                UpdateShadowSubscriptionRequest updateShadowSubscriptionRequest = new UpdateShadowSubscriptionRequest();\n+                updateShadowSubscriptionRequest.thingName = thingName;\n+                iotShadowClient.SubscribeToUpdateShadowAccepted(updateShadowSubscriptionRequest,\n+                        QualityOfService.AT_LEAST_ONCE, updateShadowResponse ->\n+                                shadowUpdated(updateShadowResponse.state.desired, updateShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing updateShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                GetShadowSubscriptionRequest request = new GetShadowSubscriptionRequest();\n+                request.thingName = thingName;\n+                logger.info(\"Subscribed to update device shadow topics\" + thingName);\n+                iotShadowClient.SubscribeToGetShadowAccepted(request, QualityOfService.AT_MOST_ONCE,\n+                        getShadowResponse -> shadowUpdated(getShadowResponse.state.desired, getShadowResponse.version),\n+                        (e) -> logger.atError().log(\"Error processing getShadowResponse\", e))\n+                        .get(TIMEOUT_FOR_SUBSCRIBING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                logger.info(\"Subscribed to get device shadow topics\" + thingName);\n+                return;\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof MqttException || cause instanceof TimeoutException) {\n+                    //TODO: If network is not available then it will throw MqttException\n+                    // If there is any other problem like thingName is not specified in the request then also\n+                    // it throws Mqtt exception. This can be identified based on error code. Currently error code is not\n+                    // exposed. Will make required change in CRT package to expose the error code and then update this\n+                    logger.atWarn().setCause(cause).log(\"Caught exception while subscribing to shadow topics, \"\n+                            + \"will retry shortly\");\n+                }\n+                if (cause instanceof InterruptedException) {\n+                    logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                    return;\n+                }\n+                logger.atError().setCause(e).log(\"Caught exception while subscribing to shadow topics, \"\n+                        + \"will retry shortly\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Subscribe to shadow topics timed out, will retry shortly\");\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while subscribing to shadow topics\");\n+                return;\n+            }\n+            try {\n+                // Wait for sometime and then try to subscribe again\n+                Random jitter = new Random();\n+                Thread.sleep(WAIT_TIME_TO_SUBSCRIBE_AGAIN_IN_MS + jitter.nextInt(10_000));\n+            } catch (InterruptedException interruptedException) {\n+                logger.atWarn().log(\"Interrupted while subscribing to device shadow topics\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void publishToGetDeviceShadowTopic() {\n+        GetShadowRequest getShadowRequest = new GetShadowRequest();\n+        getShadowRequest.thingName = thingName;\n+        iotShadowClient.PublishGetShadow(getShadowRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    @SuppressFBWarnings\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        DeploymentStatus status = DeploymentStatus.valueOf((String)\n+                deploymentDetails.get(DEPLOYMENT_STATUS_KEY_NAME));\n+\n+        String configurationArn = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        // only update reported state when the deployment succeeds.\n+        if (DeploymentStatus.SUCCEEDED.equals(status)) {\n+\n+            Pair<String, Map<String, Object>> desired = desiredStateQueue.peek();\n+            // discard configurations that might have got added to the queue but the deployment\n+            // got discarded before being processed due to a new shadow deployment\n+            while (desired != null && !desired.getLeft().equals(configurationArn)) {\n+                desiredStateQueue.poll();\n+                desired = desiredStateQueue.peek();\n+            }\n+\n+            if (desired == null) {\n+                logger.atError().kv(CONFIGURATION_ARN_LOG_KEY_NAME, configurationArn)\n+                        .log(\"Unable to update shadow for deployment\");\n+                return true;\n+            }\n+\n+            try {\n+                ShadowState shadowState = new ShadowState();\n+                shadowState.reported = new HashMap<>(desired.getRight());\n+                UpdateShadowRequest updateShadowRequest = new UpdateShadowRequest();\n+                updateShadowRequest.thingName = thingName;\n+                updateShadowRequest.state = shadowState;\n+                iotShadowClient.PublishUpdateShadow(updateShadowRequest, QualityOfService.AT_LEAST_ONCE)\n+                        .get(TIMEOUT_FOR_PUBLISHING_TO_TOPICS_SECONDS, TimeUnit.SECONDS);\n+                desiredStateQueue.remove();\n+                logger.atInfo().kv(CONFIGURATION_ARN_LOG_KEY_NAME, configurationArn)\n+                        .log(\"Updated reported state for deployment\");\n+                return true;\n+            } catch (InterruptedException e) {\n+                //Since this method can run as runnable cannot throw exception so handling exceptions here\n+                logger.atWarn().log(\"Interrupted while publishing reported state\");\n+            } catch (ExecutionException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while publishing reported state\");\n+            } catch (TimeoutException e) {\n+                logger.atWarn().setCause(e).log(\"Publish reported state timed out, will retry shortly\");\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected void shadowUpdated(Map<String, Object> configuration, Integer version) {\n+        if (configuration == null || configuration.isEmpty()) {\n+            logger.debug(\"Empty desired state, no device deployments created yet\");\n+            return;\n+        }\n+        String configurationArn = (String) configuration.get(\"configurationArn\");\n+        synchronized (ShadowDeploymentListener.class) {\n+            if (lastVersion != null && lastVersion > version) {\n+                logger.atInfo().kv(CONFIGURATION_ARN_LOG_KEY_NAME, configurationArn)\n+                        .kv(\"SHADOW_VERSION\", version)\n+                        .log(\"Old deployment notification, Ignoring...\");\n+                return;\n+            }\n+            if (lastConfigurationArn != null && lastConfigurationArn.equals(configurationArn)) {\n+                logger.atInfo().kv(CONFIGURATION_ARN_LOG_KEY_NAME, configurationArn)\n+                        .log(\"Duplicate deployment notification, Ignoring...\");\n+                return;\n+            }", "originalCommit": "f6c96af29d22ab1f36037dd9e06abdf7145629af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3MTUzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/486#discussion_r499071537", "bodyText": "I am doing this in the DeploymentQueue class", "author": "fahadmohammed01", "createdAt": "2020-10-02T22:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MTQ1Mg=="}], "type": "inlineReview"}]}