{"pr_number": 32, "pr_title": "Making multiple coordinated updates to the system config.", "pr_createdAt": "2020-01-11T21:57:59Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32", "timeline": [{"oid": "120413a8b8bc316145b133b14ebcf62567f461b7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/120413a8b8bc316145b133b14ebcf62567f461b7", "message": "Making multiple coordinated updates to the system config.  It enables\ncode fragments like:\n\n    kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(\"test\", \n        ()->kernel.readMerge(Kernel.class.getResource(\"delta.yaml\"), false));\n\nThe readMerge() call reads the deltas in the file \"delta.yaml\", which can\nalso be in JSON or TLog format.  addUpdateAction() causes it to happen when\nthe system is in a safe state.", "committedDate": "2020-01-11T21:25:22Z", "type": "commit"}, {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "message": "Merge branch 'master' into CompoundChanges", "committedDate": "2020-01-11T22:00:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTQ4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365545486", "bodyText": "[nit]\nMaybe useSourceTimestamp or sourceTimestampAvailable.", "author": "MikeDombo", "createdAt": "2020-01-11T22:31:33Z", "path": "src/main/java/com/aws/iot/evergreen/config/Configuration.java", "diffHunk": "@@ -99,12 +97,13 @@ public void deepForEachTopic(Consumer<Topic> f) {\n         root.deepForEachTopic(f);\n     }\n     public Configuration read(String s) throws IOException {\n-        return s.contains(\":/\") ? read(new URL(s)) : read(Paths.get(s));\n+        return s.contains(\":/\") ? read(new URL(s), false) : read(Paths.get(s));\n     }\n-    public Configuration read(URL url) throws IOException {\n+    public Configuration read(URL url, boolean sourceTimestamp) throws IOException {", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk1MDA5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365950093", "bodyText": "Fixed", "author": "JamesGosling", "createdAt": "2020-01-13T18:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTU4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365545583", "bodyText": "Could this be made AutoCloseable?", "author": "MikeDombo", "createdAt": "2020-01-11T22:34:29Z", "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationWriter.java", "diffHunk": "@@ -12,10 +12,12 @@\n public class ConfigurationWriter implements Closeable, Subscriber {\n     private final Writer out;\n     private final Configuration conf;\n+    private  boolean flushImmediately;\n     public static void dump(Configuration c, Path file) {\n         try (CommitableWriter out = CommitableWriter.abandonOnClose(file);\n                 ConfigurationWriter cs = new ConfigurationWriter(c, out)) {\n             cs.writeAll();\n+            cs.close();", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0NjYwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365646605", "bodyText": "It could be, but it's already Closeable (from BufferedWriter), which is a subclass of AutoCloseable.", "author": "JamesGosling", "createdAt": "2020-01-13T04:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0Njg3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365646874", "bodyText": "Ah, in that case, can't the call to close be omitted here?", "author": "MikeDombo", "createdAt": "2020-01-13T04:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0OTQ1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365949457", "bodyText": "It's worse: the close() should have been a commit()", "author": "JamesGosling", "createdAt": "2020-01-13T18:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTczMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365545731", "bodyText": "[nit]\nMaybe something like bubbleUpChanges = true or even simply notifyParentOfChanges =true  instead of transparency. Transparency to me sounds a bit like the change is only ever bubbled up and not handled at all at this node.", "author": "MikeDombo", "createdAt": "2020-01-11T22:38:37Z", "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -20,6 +20,7 @@ protected Node(Context c, String n, Topics p) {\n     public final Context context;\n     public final String name;\n     public final Topics parent;\n+    private boolean transParent; // parent doesn't get notified of changes to this node", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYyNjQ0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365626442", "bodyText": "You're right, it's a dumb name.  I'll pick a better one.", "author": "JamesGosling", "createdAt": "2020-01-13T01:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjIzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365546230", "bodyText": "I see you're returning the lower 8 bits of the exit code, but why is this needed? Shouldn't it just return the exit code as-is?", "author": "MikeDombo", "createdAt": "2020-01-11T22:52:23Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -40,31 +48,57 @@ public void startup() {\n     }\n     @Override\n     public void run() {\n-//        log().significant(\"running\", this);\n         if (run(\"run\", exit -> {\n-            if (exit == 0) {\n-                setState(State.Finished);\n-                context.getLog().significant(\"Finished\", getName());\n-            } else {\n-                setState(State.Errored);\n-                context.getLog().error(\"Failed\", getName(), exit);\n-            }\n+            currentScript = null;\n+            if(!inShutdown)\n+                if (exit == 0) {\n+                    setState(State.Finished);\n+                    context.getLog().significant(getName(), \"Finished\");\n+                } else {\n+                    setState(State.Errored);\n+                    context.getLog().error(getName(), \"Failed\", exit2String(exit));\n+                }\n         })==RunStatus.NothingDone) {\n-            context.getLog().significant(\"run: NothingDone\", getName());\n+            context.getLog().significant(getName(), \"run: NothingDone\");\n             setState(State.Finished);\n         }\n     }\n-\n+    static final String[] sigCodes = {\n+        \"SIGHUP\", \"SIGINT\", \"SIGQUIT\", \"SIGILL\", \"SIGTRAP\", \"SIGIOT\", \"SIGBUS\", \"SIGFPE\",\n+        \"SIGKILL\", \"SIGUSR1\", \"SIGSEGV\", \"SIGUSR2\", \"SIGPIPE\", \"SIGALRM\", \"SIGTERM\",\n+        \"SIGSTKFLT\", \"SIGCHLD\", \"SIGCONT\", \"SIGSTOP\", \"SIGTSTP\", \"SIGTTIN\", \"SIGTTOU\",\n+        \"SIGURG\", \"SIGXCPU\", \"SIGXFSZ\", \"SIGVTALRM\", \"SIGPROF\", \"SIGWINCH\", \"SIGIO\",\n+        \"SIGPWR\", \"SIGSYS\",\n+    };\n+    public static String exit2String(int exitCode) {\n+        return exitCode>128 && exitCode<129+sigCodes.length\n+            ? sigCodes[exitCode-129]\n+            : \"exit(\"+((exitCode<<24)>>24)+\")\";", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYyNzcwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365627702", "bodyText": "Well...  The posix standard does specify that the exit code is unsigned.  But, historically, lots of code does exit(-1), or even exit(-n) for errors.  Standard practice is a mess, but I just find that exit(-1) is less confusing than exit(255), even though they're exactly the same.  It's easy enough to revert.", "author": "JamesGosling", "createdAt": "2020-01-13T01:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjY2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365546668", "bodyText": "Should the return type be a Duration or a date? Otherwise it is difficult to know (just from the interface) that the long in the return represents time in milliseconds.", "author": "MikeDombo", "createdAt": "2020-01-11T23:04:04Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.add(d);\n+    }\n+    public void removeDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.remove(d);\n+    }\n+    /**\n+     * \n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disrutableChecks) c.disruptableCheck(false); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();\n+            long maxt = now;\n+\n+            log.note(getName(), \"updates pending:\", pendingActions.size());\n+            for (DisruptableCheck c : disrutableChecks) {\n+                long ct = c.disruptableCheck(true);\n+                if (ct > maxt) maxt = ct;\n+            }\n+            if (maxt > now) try {\n+                log.note(getName(), \"Holding for\", maxt - now, \"millis\u00cf\");\n+                Thread.sleep(maxt - now);\n+            } catch (InterruptedException ex) {\n+            }\n+            else {\n+                log.note(getName(), \"Queueing update actions\");\n+                context.runOnPublishQueueAndWait(() -> {\n+                    log.note(getName(), \"Starting safe-time update\");\n+                    runUpdateActions();\n+                    log.note(getName(), \"Finished read-phase of safe-time update\");\n+                });\n+                log.note(getName(), \"Back on run Q safe-time update\");\n+            }\n+        }\n+        super.run();\n+    }\n+\n+    public static interface DisruptableCheck {\n+        /**\n+         * \n+         * @param disruptionPending true iff a disruption is pending.  After a disruption,\n+         *      disruptableCheck is called with this being false to signal to the handler\n+         *      that it's OK to start activity\n+         * @return Estimated time that this handler will be willing to be disrupted. If\n+         *      the returned value is less than now (System.currentTimeMillis()) the handler\n+         *      is granting permission to be disrupted.  Otherwise, it will be asked again\n+         *      sometime later.\n+         */\n+        public long disruptableCheck(boolean disruptionPending);", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYyODAzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365628038", "bodyText": "I'll make it clearer.  Duration and Date don't add much other than heap churn.", "author": "JamesGosling", "createdAt": "2020-01-13T01:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MDk2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365660960", "bodyText": "I'm not sure how this function would be implemented, but since the return value only applies when disruptionPending is true, is it worth splitting this into two functions?", "author": "rbattle", "createdAt": "2020-01-13T06:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk1NDYwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365954603", "bodyText": "Funny you should ask....  Yes.  I almost did it that way.  The semantics would be cleaner.  The nice thing about interfaces with one method is that you can create instances with the lambda syntax.  With more than one you have to use the clunkier inner class syntax.  So it was a choice between clean semantics or clean syntax.  When I say it that way, it's clear I should have leaned the other way.", "author": "JamesGosling", "createdAt": "2020-01-13T18:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA5MjY5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366092696", "bodyText": "Fixed", "author": "JamesGosling", "createdAt": "2020-01-14T00:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjY2OA=="}], "type": "inlineReview"}, {"oid": "4f2a6c54543bae2b363dd6e49a8f4818b2392b98", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4f2a6c54543bae2b363dd6e49a8f4818b2392b98", "message": "Making multiple coordinated updates to the system config.  It enables\ncode fragments like:\n\n    kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(\"test\", \n        ()->kernel.readMerge(Kernel.class.getResource(\"delta.yaml\"), false));\n\nThe readMerge() call reads the deltas in the file \"delta.yaml\", which can\nalso be in JSON or TLog format.  addUpdateAction() causes it to happen when\nthe system is in a safe state.", "committedDate": "2020-01-12T01:09:23Z", "type": "commit"}, {"oid": "f3f7c8f67268edee3cd878ae177c00e638716231", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f3f7c8f67268edee3cd878ae177c00e638716231", "message": "Trivial change to trigger build", "committedDate": "2020-01-12T01:09:23Z", "type": "commit"}, {"oid": "82fd928d9aeba34eda9c8ab3c9248dfd30ca8334", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/82fd928d9aeba34eda9c8ab3c9248dfd30ca8334", "message": "Merge origin/CompoundChanges into CompoundChanges\n\nConflicts:\n\tsrc/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "committedDate": "2020-01-12T01:46:50Z", "type": "commit"}, {"oid": "0b4523d342493751826c6852ba2c3aebea9b2422", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b4523d342493751826c6852ba2c3aebea9b2422", "message": "Respond to PR comments.", "committedDate": "2020-01-13T04:37:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0OTgxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365549819", "bodyText": "nit: disruptableChecks", "author": "rbattle", "createdAt": "2020-01-12T00:37:30Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0OTgzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365549835", "bodyText": "nit: addDisruptableCheck", "author": "rbattle", "createdAt": "2020-01-12T00:37:50Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisrutableCheck(DisruptableCheck d) {", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0OTgzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365549839", "bodyText": "nit: removeDisruptableCheck", "author": "rbattle", "createdAt": "2020-01-12T00:38:02Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.add(d);\n+    }\n+    public void removeDisrutableCheck(DisruptableCheck d) {", "originalCommit": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MzYyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365963629", "bodyText": "If I were a superhero, my nemesis would be spelling.   :-)", "author": "JamesGosling", "createdAt": "2020-01-13T18:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0OTgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY1OTkyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365659921", "bodyText": "nit: can you add a todo for these timeouts? Presumably we want them to be configurable in the future", "author": "rbattle", "createdAt": "2020-01-13T06:37:04Z", "path": "src/main/java/com/aws/iot/evergreen/util/Exec.java", "diffHunk": "@@ -208,17 +206,57 @@ public void run() {\n                         break;\n                 }\n             } catch (Throwable t) {\n-                appendStackTrace(t, out);\n+                // nothing that can go wrong here worries us, they're\n+                // all EOFs\n+                // appendStackTrace(t, out);\n             }\n             if (whenDone != null && numberOfCopiers.decrementAndGet() <= 0)\n                 try {\n-                    process.waitFor(10, TimeUnit.SECONDS);\n-                    whenDone.accept(process.exitValue());\n+                    process.waitFor(10, TimeUnit.SECONDS); // be graceful\n+                    setClosed();\n                 } catch (Throwable t) {\n                     t.printStackTrace(System.out);\n                 }\n         }\n     }\n+    synchronized void setClosed() {\n+        if(!closed) {\n+            IntConsumer wd = whenDone;\n+            int exit = process!=null ? process.exitValue() : -1;\n+            closed = true;\n+            process = null;\n+            stderrc = null;\n+            stdoutc = null;\n+            whenDone = null;\n+            if(wd!=null) wd.accept(exit);\n+            notifyAll();\n+        }\n+    }\n+    public boolean isRunning() { return !closed; }\n+    public synchronized boolean waitClosed(int timeout) {\n+        if(!closed) try {\n+            wait(timeout);\n+        } catch(InterruptedException ie){}\n+        return closed;\n+    }\n+    @Override\n+    public synchronized void close() throws IOException {\n+        if(!closed) {\n+            Process p = process;\n+            if(p!=null) {\n+                p.destroy();\n+                if(!waitClosed(2000)) {", "originalCommit": "0b4523d342493751826c6852ba2c3aebea9b2422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA5MjMyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366092328", "bodyText": "Sure.", "author": "JamesGosling", "createdAt": "2020-01-14T00:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY1OTkyMQ=="}], "type": "inlineReview"}, {"oid": "094079a156977e8274233eab8b7673fd18aa16f5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/094079a156977e8274233eab8b7673fd18aa16f5", "message": "Respond to PR comments.", "committedDate": "2020-01-14T00:28:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzMjg3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366132876", "bodyText": "Any reason why these are removed? I think Shirley's doc on states still has Unstable in it.", "author": "MikeDombo", "createdAt": "2020-01-14T02:59:17Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/State.java", "diffHunk": "@@ -34,20 +34,20 @@\n      * ever take a significant amount of time to run.\n      */\n     Running(true, true, true),\n-    /**\n-     * Running, but experiencing problems that the service is attempting to\n-     * repair itself\n-     */\n-    Unstable(false, true, false),\n+//    /**\n+//     * Running, but experiencing problems that the service is attempting to\n+//     * repair itself\n+//     */\n+//    Unstable(false, true, false),", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzODQ1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366138456", "bodyText": "It's certainly a topic ripe for debate.  They are two states that were never used in any real way and I had originally put them in partly as thought experiments.  The more I think about Unstable the less I think it's the right way to approach the situation.  I think it's better to have services that are experiencing instability to instead indicate the instability in their outputs.  For example:\nif(sensor.state==Running) { v = sensor.getValue(); ... }\n\nhas the problem that check-then-fetch has a race hazard.  But\nv = sensor.getValue();\nif (i!sNan(v)) [ ... ]\n\ndoes not.\nHaving low-value states needlessly complicates the state machine.", "author": "JamesGosling", "createdAt": "2020-01-14T03:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzMjg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MTc5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366451790", "bodyText": "nit: looks like a weird character \"\u00cf\" got added to the end of millis", "author": "rbattle", "createdAt": "2020-01-14T16:47:50Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disruptableChecks) c.disruptionCompleted(); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();\n+            long maxt = now;\n+\n+            log.note(getName(), \"updates pending:\", pendingActions.size());\n+            for (DisruptableCheck c : disruptableChecks) {\n+                long ct = c.whenIsDisruptionOK();\n+                if (ct > maxt) maxt = ct;\n+            }\n+            if (maxt > now) try {\n+                log.note(getName(), \"Holding for\", maxt - now, \"millis\u00cf\");", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366469855", "bodyText": "How weird.  Fixed.", "author": "JamesGosling", "createdAt": "2020-01-14T17:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MTc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MjMyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366452327", "bodyText": "you used to have a clock that could be injected. Is that still available?", "author": "rbattle", "createdAt": "2020-01-14T16:48:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disruptableChecks) c.disruptionCompleted(); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MTcxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366471712", "bodyText": "Yes, I put it in to enable running a device in \"simulation\" mode where the system clock could run faster than realtime.  But it was never religiously used, so it would have taken a while to make it all work properly.  I pulled it because the code was a mess and cleaning it up properly meant finishing off simulation support, which I didn't feel up to.  It should go on the TODO list.", "author": "JamesGosling", "createdAt": "2020-01-14T17:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MjMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MzA3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366473074", "bodyText": "I've done it in previous projects and it's seriously useful; it's also a serious pain in the ass to nail all the details (eg. timeouts).", "author": "JamesGosling", "createdAt": "2020-01-14T17:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MjMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNDM0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366604346", "bodyText": "I'm fine with it going in a TODO :-) I remember you talking about it before and how useful it was", "author": "rbattle", "createdAt": "2020-01-14T22:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MjMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1Mjc2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366452760", "bodyText": "what does the boolean signify here?", "author": "rbattle", "createdAt": "2020-01-14T16:49:31Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disruptableChecks) c.disruptionCompleted(); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();\n+            long maxt = now;\n+\n+            log.note(getName(), \"updates pending:\", pendingActions.size());\n+            for (DisruptableCheck c : disruptableChecks) {\n+                long ct = c.whenIsDisruptionOK();\n+                if (ct > maxt) maxt = ct;\n+            }\n+            if (maxt > now) try {\n+                log.note(getName(), \"Holding for\", maxt - now, \"millis\u00cf\");\n+                Thread.sleep(maxt - now);\n+            } catch (InterruptedException ex) {\n+            }\n+            else {\n+                log.note(getName(), \"Queueing update actions\");\n+                context.runOnPublishQueueAndWait(() -> {\n+                    log.note(getName(), \"Starting safe-time update\");\n+                    runUpdateActions();\n+                    log.note(getName(), \"Finished read-phase of safe-time update\");\n+                });\n+                log.note(getName(), \"Back on run Q safe-time update\");\n+            }\n+        }\n+        super.run();\n+    }\n+\n+    public static interface DisruptableCheck {\n+        /**\n+         * Inform a listener that a disruption is pending to find out when a disruption\n+         * is acceptable.\n+         * @return Estimated time when this handler will be willing to be disrupted,\n+         *      expressed as milliseconds since the epoch. If\n+         *      the returned value is less than now (System.currentTimeMillis()) the handler\n+         *      is granting permission to be disrupted.  Otherwise, it will be asked again\n+         *      sometime later.\n+         */\n+        public long whenIsDisruptionOK();\n+        /** After a disruption, this is called to signal to the handler that the\n+         * disruption is over and it's OK to start activity */\n+        public boolean disruptionCompleted();", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MzM1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366473354", "bodyText": "Nothing.  It's a leftover turd.  Fixed.", "author": "JamesGosling", "createdAt": "2020-01-14T17:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1Mjc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzMDU1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366630556", "bodyText": "Yeah I noticed this bug as well. Have a temporary check in #30", "author": "ShirleyZheng92", "createdAt": "2020-01-14T23:41:26Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/ShellRunner.java", "diffHunk": "@@ -21,16 +21,18 @@\n         @Override\n         public synchronized Exec setup(String note, String command, EvergreenService onBehalfOf) {\n             if (!isEmpty(command) && onBehalfOf != null) {\n-                if (!isEmpty(note))\n+                if (!isEmpty(note) && log!=null /* !!?!! */)", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzMjgxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366632811", "bodyText": "Will this result in run() being called multiple times?", "author": "ShirleyZheng92", "createdAt": "2020-01-14T23:49:55Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxOTY2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r367019663", "bodyText": "Simultaneously: no.  setState(Running) does nothing if the service is already running.  The update service normally sits in Finished state doing nothing.   If it's periodic, it will get started whenever it's period next comes around.  Otherwise it get's started immediatly whenever there is some action pending.  It then checks for all services that care about disruptions to give their permission, when permission is granted by everyone, the disruption happens.", "author": "JamesGosling", "createdAt": "2020-01-15T17:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzMjgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzODc1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366638750", "bodyText": "So basically if the 'install' part of a configuration file changed, the service will automatically re-install , if any other parts changed, service will restart. Should we skip child.childOf(\"shutdown\") ?", "author": "ShirleyZheng92", "createdAt": "2020-01-15T00:12:36Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -18,6 +18,14 @@\n public class GenericExternalService extends EvergreenService {\n     public GenericExternalService(Topics c) {\n         super(c);\n+        c.subscribe((what,child)->{\n+            if(c.parentNeedsToKnow()) {\n+                context.getLog().warn(getName(),\"responding to change to\",child);\n+                if(child.childOf(\"install\"))", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMTkzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r367021936", "bodyText": "Good point.", "author": "JamesGosling", "createdAt": "2020-01-15T17:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzODc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzOTczMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366639733", "bodyText": "Should run(\"shutdown\") be before closing the Exec or after?", "author": "ShirleyZheng92", "createdAt": "2020-01-15T00:16:04Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -40,34 +48,56 @@ public void startup() {\n     }\n     @Override\n     public void run() {\n-//        log().significant(\"running\", this);\n         if (run(\"run\", exit -> {\n-            if (exit == 0) {\n-                setState(State.Finished);\n-                context.getLog().significant(\"Finished\", getName());\n-            } else {\n-                setState(State.Errored);\n-                context.getLog().error(\"Failed\", getName(), exit);\n-            }\n+            currentScript = null;\n+            if(!inShutdown)\n+                if (exit == 0) {\n+                    setState(State.Finished);\n+                    context.getLog().significant(getName(), \"Finished\");\n+                } else {\n+                    setState(State.Errored);\n+                    context.getLog().error(getName(), \"Failed\", exit2String(exit));\n+                }\n         })==RunStatus.NothingDone) {\n-            context.getLog().significant(\"run: NothingDone\", getName());\n+            context.getLog().significant(getName(), \"run: NothingDone\");\n             setState(State.Finished);\n         }\n     }\n-\n+    static final String[] sigCodes = {\n+        \"SIGHUP\", \"SIGINT\", \"SIGQUIT\", \"SIGILL\", \"SIGTRAP\", \"SIGIOT\", \"SIGBUS\", \"SIGFPE\",\n+        \"SIGKILL\", \"SIGUSR1\", \"SIGSEGV\", \"SIGUSR2\", \"SIGPIPE\", \"SIGALRM\", \"SIGTERM\",\n+        \"SIGSTKFLT\", \"SIGCHLD\", \"SIGCONT\", \"SIGSTOP\", \"SIGTSTP\", \"SIGTTIN\", \"SIGTTOU\",\n+        \"SIGURG\", \"SIGXCPU\", \"SIGXFSZ\", \"SIGVTALRM\", \"SIGPROF\", \"SIGWINCH\", \"SIGIO\",\n+        \"SIGPWR\", \"SIGSYS\",\n+    };\n+    public static String exit2String(int exitCode) {\n+        return exitCode>128 && exitCode<129+sigCodes.length\n+            ? sigCodes[exitCode-129]\n+            : \"exit(\"+((exitCode<<24)>>24)+\")\";\n+    }\n+    private boolean inShutdown;\n     @Override\n     public void shutdown() {\n+        inShutdown = true;\n+//        context.getLog().significant(this,\"starting shutdown\");\n+        Exec e = currentScript;\n+        if(e!=null && e.isRunning()) try {\n+            context.getLog().significant(getName(),\"shutting down\",e);\n+            e.close();\n+            e.waitClosed(1000);\n+//            new Throwable().printStackTrace();\n+        } catch(IOException ioe) {\n+            context.getLog().error(\n+                    this,\"shutdown failure\",Utils.getUltimateMessage(ioe));\n+        }\n //        context.getLog().significant(\"shutdown\", this);\n         run(\"shutdown\", null);", "originalCommit": "094079a156977e8274233eab8b7673fd18aa16f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4ODMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r367188306", "bodyText": "That is a very good question.  If shutdown does nothing, it doesn't matter.  If shutdown does something, it'll probably expect the service that it's shutting down is still around.  It's probably going to try something more graceful than just firing a SIG* at it, which is what the preceeding code does.  \"Before\" is clearly the right answer.  I'll fix it.", "author": "JamesGosling", "createdAt": "2020-01-16T01:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzOTczMw=="}], "type": "inlineReview"}, {"oid": "0756605816cba277be1d7324a5a8b0bd231cbb97", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0756605816cba277be1d7324a5a8b0bd231cbb97", "message": "Respond to PR comments.", "committedDate": "2020-01-16T17:51:28Z", "type": "commit"}, {"oid": "c29f15fd7f298a8c6b6eaee480ce15ea27781ffa", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c29f15fd7f298a8c6b6eaee480ce15ea27781ffa", "message": "Merge branch 'master' into CompoundChanges", "committedDate": "2020-01-16T18:11:15Z", "type": "commit"}, {"oid": "c6d3379b80873ea9b2951d946f24a53b956e7681", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c6d3379b80873ea9b2951d946f24a53b956e7681", "message": "Making multiple coordinated updates to the system config.  It enables\ncode fragments like:\n\n    kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(\"test\", \n        ()->kernel.readMerge(Kernel.class.getResource(\"delta.yaml\"), false));\n\nThe readMerge() call reads the deltas in the file \"delta.yaml\", which can\nalso be in JSON or TLog format.  addUpdateAction() causes it to happen when\nthe system is in a safe state.", "committedDate": "2020-01-16T18:21:33Z", "type": "commit"}, {"oid": "65439889bdd454a93cc120931c3de14d47798d25", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65439889bdd454a93cc120931c3de14d47798d25", "message": "Respond to PR comments.", "committedDate": "2020-01-16T18:22:49Z", "type": "commit"}, {"oid": "db71c0a641fac9a3f4d324b414164226478e6477", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/db71c0a641fac9a3f4d324b414164226478e6477", "message": "Respond to PR comments.", "committedDate": "2020-01-16T18:23:39Z", "type": "commit"}, {"oid": "8137eea97fa759b46fd181ed019d55fdeea19ab0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8137eea97fa759b46fd181ed019d55fdeea19ab0", "message": "Respond to PR comments.", "committedDate": "2020-01-16T18:23:39Z", "type": "commit"}, {"oid": "0ac287c3cc9d62d5f54853ab047a3a60e7178da0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0ac287c3cc9d62d5f54853ab047a3a60e7178da0", "message": "\"Unstable\" eliminated -- right or wrong?", "committedDate": "2020-01-16T18:24:46Z", "type": "commit"}]}