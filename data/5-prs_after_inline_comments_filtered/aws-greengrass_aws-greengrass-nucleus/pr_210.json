{"pr_number": 210, "pr_title": "Encapsulate recipe CRUD in PackageStore", "pr_createdAt": "2020-04-23T17:41:55Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210", "timeline": [{"oid": "f6b64107d006490c129b8d8df9d88ec7740b4df3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f6b64107d006490c129b8d8df9d88ec7740b4df3", "message": "Implement PackageStore", "committedDate": "2020-04-23T17:14:51Z", "type": "commit"}, {"oid": "fa96f07584959ae6429866b5b27b6c2c179578af", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fa96f07584959ae6429866b5b27b6c2c179578af", "message": "Implement PackageStore", "committedDate": "2020-04-23T17:25:32Z", "type": "commit"}, {"oid": "3baa86269b0ee9fcddcb13839c27738ace8ee2bf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3baa86269b0ee9fcddcb13839c27738ace8ee2bf", "message": "Implement PackageStore", "committedDate": "2020-04-23T17:32:46Z", "type": "commit"}, {"oid": "091066d97955d68b49c8cf7334958eda6fae157e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/091066d97955d68b49c8cf7334958eda6fae157e", "message": "small typo", "committedDate": "2020-04-23T17:43:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5ODM4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r413998388", "bodyText": "rename: savePackageRecipe. I'd expect that create would return me a PackageRecipe.", "author": "MikeDombo", "createdAt": "2020-04-23T17:45:42Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {", "originalCommit": "091066d97955d68b49c8cf7334958eda6fae157e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MDcxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414090712", "bodyText": "or storePackageRecipe", "author": "abanthiy", "createdAt": "2020-04-23T20:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5ODM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxNDc4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414214785", "bodyText": "Discussed offline. I wanted to differentiate create and update. For now, we only need save, which creates if not exists, and override otherwise. We could add create and update, or SaveOption.OVERRIDE in the future when needed.", "author": "leaf94", "createdAt": "2020-04-24T00:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5ODM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAwNjYwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414006606", "bodyText": "we have .yaml in many places throughout the codebase, can we extract that out to a shared const please?", "author": "MikeDombo", "createdAt": "2020-04-23T17:57:40Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(final String packageName, Requirement requirement)\n+            throws PackagingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File recipeFile : recipeFiles) {\n+            String recipePackageName = parsePackageNameFromFileName(recipeFile.getName());\n+            // Only check the recipes for the package that we're looking for\n+            if (!recipePackageName.equalsIgnoreCase(packageName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                packageMetadataList.add(getPackageMetadata(new PackageIdentifier(packageName, version)));\n+            }\n+        }\n+\n+        return packageMetadataList;\n+    }\n+\n+\n+    /**\n+     * Resolve the artifact directory path for a target package id.\n+     *\n+     * @param packageIdentifier packageIdentifier\n+     * @return the artifact directory path for target package.\n+     */\n+    Path resolveArtifactDirectoryPath(PackageIdentifier packageIdentifier) {\n+        return artifactDirectory.resolve(packageIdentifier.getName())\n+                .resolve(packageIdentifier.getVersion().getValue());\n+    }\n+\n+    private Path resolveRecipePath(String packageName, Semver packageVersion) {\n+        return recipeDirectory.resolve(String.format(RECIPE_FILE_NAME_FORMAT, packageName, packageVersion.getValue()));\n+    }\n+\n+    private static String parsePackageNameFromFileName(String filename) {\n+        // TODO validate filename\n+\n+        // MonitoringService-1.0.0.yaml\n+        String suffix = \".yaml\";", "originalCommit": "091066d97955d68b49c8cf7334958eda6fae157e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxOTA5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414219094", "bodyText": "Extracted it to evergreen/constants/FileSuffix and used it as FileSuffix.YAML_SUFFIX", "author": "leaf94", "createdAt": "2020-04-24T00:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAwNjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxMzgxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414013818", "bodyText": "nit\nblank line at end.", "author": "MikeDombo", "createdAt": "2020-04-23T18:08:23Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.collection.IsIterableWithSize.iterableWithSize;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.hamcrest.io.FileMatchers.anExistingDirectory;\n+import static org.hamcrest.io.FileMatchers.anExistingFile;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Every test in PackageStoreTest start with a new and clean package store by creating a temp folder. It pre loads\n+ * files from its test resource folder if it needs to mock some recipe/artifact. It doesn't and shouldn't use or assume\n+ * any static folder directly as package store. The package store folder is deleted after each test.\n+ */\n+@ExtendWith({EGExtension.class})\n+class PackageStoreTest {\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private static final String MONITORING_SERVICE_PKG_NAME = \"MonitoringService\";\n+    private static final Semver MONITORING_SERVICE_PKG_VERSION = new Semver(\"1.0.0\", Semver.SemverType.NPM);\n+    private static final PackageIdentifier MONITORING_SERVICE_PKG_ID =\n+            new PackageIdentifier(MONITORING_SERVICE_PKG_NAME, MONITORING_SERVICE_PKG_VERSION);\n+\n+\n+    private static final Path RECIPE_RESOURCE_PATH = Paths.get(PackageStoreTest.class.getResource(\"recipe\").getPath());\n+\n+    private PackageStore packageStore;\n+\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @TempDir\n+    Path packageStoreRootPath;\n+\n+    @BeforeEach\n+    void beforeEach() throws PackagingException {\n+        packageStore = new PackageStore(packageStoreRootPath.toAbsolutePath());\n+        recipeDirectory = packageStoreRootPath.resolve(\"recipe\");\n+        artifactDirectory = packageStoreRootPath.resolve(\"artifact\");\n+    }\n+\n+    @Test\n+    void WHEN_PackageStore_is_initialized_THEN_recipe_and_artifact_folders_created() {\n+        assertThat(recipeDirectory.toFile(), anExistingDirectory());\n+        assertThat(artifactDirectory.toFile(), anExistingDirectory());\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_not_exists_when_createPackageRecipe_THEN_recipe_file_created()\n+            throws IOException, PackageLoadingException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+        PackageRecipe recipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+\n+\n+        File expectedRecipeFile = recipeDirectory.resolve(fileName).toFile();\n+        assertThat(expectedRecipeFile, not(anExistingFile()));\n+\n+        // WHEN\n+        packageStore.createPackageRecipe(recipe);\n+\n+        // THEN\n+        assertThat(expectedRecipeFile, anExistingFile());\n+        String fileContent = new String(Files.readAllBytes(expectedRecipeFile.toPath()));\n+        assertThat(fileContent, is(equalTo(RECIPE_SERIALIZER.writeValueAsString(recipe))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_findPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertTrue(optionalPackageRecipe.isPresent());\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(optionalPackageRecipe.get(), equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_findPackageRecipe_THEN_empty_is_returned() throws Exception {\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertFalse(optionalPackageRecipe.isPresent());\n+    }\n+\n+    @Test\n+    void GIVEN_an_invalid_recipe_exists_WHEN_findPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        // GIVEN\n+        String fileName = \"InvalidRecipe-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        // THEN\n+        assertThrows(PackageLoadingException.class,\n+                () -> packageStore.findPackageRecipe(new PackageIdentifier(\"InvalidRecipe\", new Semver(\"1.0.0\"))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageRecipe packageRecipe = packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(packageRecipe, equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_getPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        assertThrows(PackageLoadingException.class, () -> packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageMetadata_then_return_it() throws PackagingException, IOException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageMetadata packageMetadata = packageStore.getPackageMetadata(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertThat(packageMetadata.getPackageIdentifier(), is(MONITORING_SERVICE_PKG_ID));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(MONITORING_SERVICE_PKG_VERSION)));\n+    }\n+\n+    @Test\n+    void GIVEN_pre_loaded_package_versions_WHEN_listAvailablePackageMetadata_THEN_return_satisfiedVersion()\n+            throws IOException, PackagingException {\n+        // GIVEN\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.1.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-2.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-3.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"Log-1.0.0.yaml\");\n+\n+        // WHEN\n+        Requirement requirement = Requirement.buildNPM(\">=1.0.0 <2.0.0\");\n+        List<PackageMetadata> packageMetadataList =\n+                packageStore.listAvailablePackageMetadata(MONITORING_SERVICE_PKG_NAME, requirement);\n+\n+        // THEN\n+        // expected return: MonitoringService 1.0.0 and 1.1.0\n+        assertThat(packageMetadataList, iterableWithSize(2));\n+\n+        // 1.0.0\n+        PackageMetadata packageMetadata = packageMetadataList.get(0);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.0.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.0.0\"))));\n+\n+        // 1.1.0\n+        packageMetadata = packageMetadataList.get(1);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.1.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.1.0\"))));\n+    }\n+\n+    private void preloadRecipeFileFromTestResource(String fileName) throws IOException {\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        Path destinationRecipe = recipeDirectory.resolve(fileName);\n+\n+        Files.copy(sourceRecipe, destinationRecipe);\n+    }\n+\n+    @Test\n+    void resolveArtifactDirectoryPath() {\n+        Path artifactPath = packageStore.resolveArtifactDirectoryPath(MONITORING_SERVICE_PKG_ID);\n+\n+        Path expectedArtifactPath = artifactDirectory.resolve(MONITORING_SERVICE_PKG_ID.getName())\n+                .resolve(MONITORING_SERVICE_PKG_ID.getVersion().getValue());\n+        assertThat(artifactPath.toAbsolutePath(), is(equalTo(expectedArtifactPath)));\n+\n+    }\n+\n+    private static Map<String, String> getExpectedDependencies(Semver version) {\n+        return new HashMap<String, String>() {{\n+            put(\"Log\", version.toString());\n+            put(\"Cool-Database\", version.toString());\n+        }};\n+    }\n+\n+}", "originalCommit": "091066d97955d68b49c8cf7334958eda6fae157e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxMzgyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414213828", "bodyText": "Done.", "author": "leaf94", "createdAt": "2020-04-24T00:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxMzgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxNDUwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414014500", "bodyText": "test for create when it already exists?", "author": "MikeDombo", "createdAt": "2020-04-23T18:09:22Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.collection.IsIterableWithSize.iterableWithSize;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.hamcrest.io.FileMatchers.anExistingDirectory;\n+import static org.hamcrest.io.FileMatchers.anExistingFile;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Every test in PackageStoreTest start with a new and clean package store by creating a temp folder. It pre loads\n+ * files from its test resource folder if it needs to mock some recipe/artifact. It doesn't and shouldn't use or assume\n+ * any static folder directly as package store. The package store folder is deleted after each test.\n+ */\n+@ExtendWith({EGExtension.class})\n+class PackageStoreTest {\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private static final String MONITORING_SERVICE_PKG_NAME = \"MonitoringService\";\n+    private static final Semver MONITORING_SERVICE_PKG_VERSION = new Semver(\"1.0.0\", Semver.SemverType.NPM);\n+    private static final PackageIdentifier MONITORING_SERVICE_PKG_ID =\n+            new PackageIdentifier(MONITORING_SERVICE_PKG_NAME, MONITORING_SERVICE_PKG_VERSION);\n+\n+\n+    private static final Path RECIPE_RESOURCE_PATH = Paths.get(PackageStoreTest.class.getResource(\"recipe\").getPath());\n+\n+    private PackageStore packageStore;\n+\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @TempDir\n+    Path packageStoreRootPath;\n+\n+    @BeforeEach\n+    void beforeEach() throws PackagingException {\n+        packageStore = new PackageStore(packageStoreRootPath.toAbsolutePath());\n+        recipeDirectory = packageStoreRootPath.resolve(\"recipe\");\n+        artifactDirectory = packageStoreRootPath.resolve(\"artifact\");\n+    }\n+\n+    @Test\n+    void WHEN_PackageStore_is_initialized_THEN_recipe_and_artifact_folders_created() {\n+        assertThat(recipeDirectory.toFile(), anExistingDirectory());\n+        assertThat(artifactDirectory.toFile(), anExistingDirectory());\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_not_exists_when_createPackageRecipe_THEN_recipe_file_created()\n+            throws IOException, PackageLoadingException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+        PackageRecipe recipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+\n+\n+        File expectedRecipeFile = recipeDirectory.resolve(fileName).toFile();\n+        assertThat(expectedRecipeFile, not(anExistingFile()));\n+\n+        // WHEN\n+        packageStore.createPackageRecipe(recipe);\n+\n+        // THEN\n+        assertThat(expectedRecipeFile, anExistingFile());\n+        String fileContent = new String(Files.readAllBytes(expectedRecipeFile.toPath()));\n+        assertThat(fileContent, is(equalTo(RECIPE_SERIALIZER.writeValueAsString(recipe))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_findPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertTrue(optionalPackageRecipe.isPresent());\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(optionalPackageRecipe.get(), equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_findPackageRecipe_THEN_empty_is_returned() throws Exception {\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertFalse(optionalPackageRecipe.isPresent());\n+    }\n+\n+    @Test\n+    void GIVEN_an_invalid_recipe_exists_WHEN_findPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        // GIVEN\n+        String fileName = \"InvalidRecipe-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        // THEN\n+        assertThrows(PackageLoadingException.class,\n+                () -> packageStore.findPackageRecipe(new PackageIdentifier(\"InvalidRecipe\", new Semver(\"1.0.0\"))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageRecipe packageRecipe = packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(packageRecipe, equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_getPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        assertThrows(PackageLoadingException.class, () -> packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageMetadata_then_return_it() throws PackagingException, IOException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageMetadata packageMetadata = packageStore.getPackageMetadata(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertThat(packageMetadata.getPackageIdentifier(), is(MONITORING_SERVICE_PKG_ID));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(MONITORING_SERVICE_PKG_VERSION)));\n+    }\n+\n+    @Test\n+    void GIVEN_pre_loaded_package_versions_WHEN_listAvailablePackageMetadata_THEN_return_satisfiedVersion()\n+            throws IOException, PackagingException {\n+        // GIVEN\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.1.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-2.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-3.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"Log-1.0.0.yaml\");\n+\n+        // WHEN\n+        Requirement requirement = Requirement.buildNPM(\">=1.0.0 <2.0.0\");\n+        List<PackageMetadata> packageMetadataList =\n+                packageStore.listAvailablePackageMetadata(MONITORING_SERVICE_PKG_NAME, requirement);\n+\n+        // THEN\n+        // expected return: MonitoringService 1.0.0 and 1.1.0\n+        assertThat(packageMetadataList, iterableWithSize(2));\n+\n+        // 1.0.0\n+        PackageMetadata packageMetadata = packageMetadataList.get(0);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.0.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.0.0\"))));\n+\n+        // 1.1.0\n+        packageMetadata = packageMetadataList.get(1);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.1.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.1.0\"))));\n+    }\n+\n+    private void preloadRecipeFileFromTestResource(String fileName) throws IOException {\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        Path destinationRecipe = recipeDirectory.resolve(fileName);\n+\n+        Files.copy(sourceRecipe, destinationRecipe);\n+    }\n+\n+    @Test\n+    void resolveArtifactDirectoryPath() {\n+        Path artifactPath = packageStore.resolveArtifactDirectoryPath(MONITORING_SERVICE_PKG_ID);\n+\n+        Path expectedArtifactPath = artifactDirectory.resolve(MONITORING_SERVICE_PKG_ID.getName())\n+                .resolve(MONITORING_SERVICE_PKG_ID.getVersion().getValue());\n+        assertThat(artifactPath.toAbsolutePath(), is(equalTo(expectedArtifactPath)));\n+\n+    }\n+", "originalCommit": "091066d97955d68b49c8cf7334958eda6fae157e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIyNzc1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414227753", "bodyText": "Added a test GIVEN_a_recipe_exists_when_savePackageRecipe_THEN_recipe_file_is_updated", "author": "leaf94", "createdAt": "2020-04-24T01:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxNDUwMA=="}], "type": "inlineReview"}, {"oid": "69fadd6379276c19dc05aaa9a29b82e67916f1e0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/69fadd6379276c19dc05aaa9a29b82e67916f1e0", "message": "rename to save", "committedDate": "2020-04-23T20:14:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5Mzc5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414093795", "bodyText": "Why not reuse the pkgId?", "author": "abanthiy", "createdAt": "2020-04-23T20:15:24Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),", "originalCommit": "091066d97955d68b49c8cf7334958eda6fae157e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxMzc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414213783", "bodyText": "It should the same ideally - but there is a chance theoretically that we retrieved wrong one... So I'm returning the retrieved one to be sure. Adding a validation is probably better...", "author": "leaf94", "createdAt": "2020-04-24T00:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5Mzc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2NzI5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414767291", "bodyText": "If getPackageRecipe then that is a bigger problem. So I don't see how we can retrieve wrong Ids when we are passing the same as argument. My concern was only to not allocae unncessary memory. Even though GC may collect the unused pkgId but its an overhead?", "author": "abanthiy", "createdAt": "2020-04-24T18:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5Mzc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MDk1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414790953", "bodyText": "It is... Right now if we have a bug and we are retrieving a totally wrong version, we don't fail anywhere. By having the encapsulation, I also want PackageStore to be more protective by validating this.\nBut I agree with you that the validation should probably be added in the getPackageRecipe instead of there. Will change it to use the input~", "author": "leaf94", "createdAt": "2020-04-24T18:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5Mzc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NDQxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414094418", "bodyText": "you mean version constraints?", "author": "abanthiy", "createdAt": "2020-04-23T20:16:22Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement", "originalCommit": "091066d97955d68b49c8cf7334958eda6fae157e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxMzM0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414213346", "bodyText": "Yeah... They means the same thing. I named it after Semver's \"Requirement\" object.", "author": "leaf94", "createdAt": "2020-04-24T00:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwODY4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414108683", "bodyText": "Where do we need this method? This seems to be a high computation method.", "author": "abanthiy", "createdAt": "2020-04-23T20:40:16Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(final String packageName, Requirement requirement)", "originalCommit": "69fadd6379276c19dc05aaa9a29b82e67916f1e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxMzAyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414213022", "bodyText": "Yes it is. PackageManager::listAvailablePackageMetadata, and it was further used in the DependencyResolver to explore available versions.\nBut I have the idea to make this return an iterator and do lazy iteration. It is definitely required if we have many recipe files.", "author": "leaf94", "createdAt": "2020-04-24T00:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwODY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwOTYxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414109618", "bodyText": "Null check for packageRecipe?", "author": "abanthiy", "createdAt": "2020-04-23T20:41:48Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {", "originalCommit": "69fadd6379276c19dc05aaa9a29b82e67916f1e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxOTI2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414219266", "bodyText": "Good point! Adding it...", "author": "leaf94", "createdAt": "2020-04-24T00:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwOTYxOA=="}], "type": "inlineReview"}, {"oid": "e4500144066c67a1df724d10f538b4b2a2153d2d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e4500144066c67a1df724d10f538b4b2a2153d2d", "message": "Merge branch 'master' into package_store_new", "committedDate": "2020-04-23T22:52:09Z", "type": "commit"}, {"oid": "bf80c657f73b52c7498c84626684b05f4ea924fe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bf80c657f73b52c7498c84626684b05f4ea924fe", "message": "Address PR comments", "committedDate": "2020-04-24T01:12:22Z", "type": "commit"}, {"oid": "476d379a99fc59ea7292f925bbb43bd0893c00e5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/476d379a99fc59ea7292f925bbb43bd0893c00e5", "message": "Merge branch 'master' into package_store_new", "committedDate": "2020-04-24T17:00:59Z", "type": "commit"}, {"oid": "db01f686abbd30babbc2eff03828e3a4f9c891bd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/db01f686abbd30babbc2eff03828e3a4f9c891bd", "message": "Merge branch 'master' into package_store_new", "committedDate": "2020-04-24T17:27:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczNzgzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414737834", "bodyText": "nit: use plural?", "author": "fengwang666", "createdAt": "2020-04-24T17:20:53Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";", "originalCommit": "476d379a99fc59ea7292f925bbb43bd0893c00e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3NzY2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414777667", "bodyText": "hahah. Big ask! I will do a renaming after the demo :)", "author": "leaf94", "createdAt": "2020-04-24T18:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczNzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTc5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414739796", "bodyText": "Why is it called PackageLoadingException? It has nothing to do with \"load package\". Maybe have a generic PackageIOException?", "author": "fengwang666", "createdAt": "2020-04-24T17:23:55Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {", "originalCommit": "476d379a99fc59ea7292f925bbb43bd0893c00e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3Mzk0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414773944", "bodyText": "... Yeah. The exceptions were from the initial version and next step is to refine them.\nI also had the same thought while reviewing Rahul's #191. We were having LoadingException even while downloading a recipe, which doesn't make sense.\nPackageIOException or PackageParsingException would be more appropriate.", "author": "leaf94", "createdAt": "2020-04-24T18:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTMzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414901336", "bodyText": "Added a TODO for refactoring PackageLoadingException.", "author": "leaf94", "createdAt": "2020-04-24T22:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MDgyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414740825", "bodyText": "Why need both getPackageRecipe and findPackageRecipe?", "author": "fengwang666", "createdAt": "2020-04-24T17:25:34Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {", "originalCommit": "476d379a99fc59ea7292f925bbb43bd0893c00e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3NzE4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414777189", "bodyText": "This is more a useful naming convention (if we agree as a team \ud83d\ude1b). I added this as \"Team's ask\" in our coding practice doc so maybe we could have an agreement...\nCallers use get if it expect it to exist, and should handle PackageLoadingException.\nOn the other hand, callers use find if it doesn't expect one to exist and use the 'Optional' returned to do branching logic, instead of branching on an PackageLoadingException, because it is not an exception.", "author": "leaf94", "createdAt": "2020-04-24T18:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MDgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NDcwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414744708", "bodyText": "Why sort?", "author": "fengwang666", "createdAt": "2020-04-24T17:31:44Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(@NonNull PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(@NonNull String packageName, @NonNull Requirement requirement)\n+            throws PackagingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        Arrays.sort(recipeFiles);", "originalCommit": "db01f686abbd30babbc2eff03828e3a4f9c891bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MjIzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414772239", "bodyText": "Because the File::listFiles does not guarantee the order. The intention was to return a sorted list... i.e. [\"pkg-1.0.0\", \"pkg-2.0.0\"]...", "author": "leaf94", "createdAt": "2020-04-24T18:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3NjMyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414776329", "bodyText": "That's not going to give you the right order once versions (or minor or patch) is greater than 9. If we need it to be ordered by version I think we need a custom comparator.", "author": "MikeDombo", "createdAt": "2020-04-24T18:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4Mzc2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414783760", "bodyText": "Good catch. I didn't pay enough attention when copying this logic. Will do.", "author": "leaf94", "createdAt": "2020-04-24T18:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTcwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414901701", "bodyText": "I will do this after we changed the recipe folder structure per Feng's comment below, because the filename will only contain the version. Should be easier.", "author": "leaf94", "createdAt": "2020-04-24T22:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NTc0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414745749", "bodyText": "This method does a o(n) lookup, do we have to have this method? The other way is to organize the recipe files as\nrecipes/Foo/1.0.recipe", "author": "fengwang666", "createdAt": "2020-04-24T17:33:35Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(@NonNull PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(@NonNull String packageName, @NonNull Requirement requirement)", "originalCommit": "db01f686abbd30babbc2eff03828e3a4f9c891bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MDU4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414770587", "bodyText": "lol. I was thinking about the exact same thing. We should probably change the folder structure from the original design. Because it doesn't make sense to go through the entire package store's recipes to find versions for one package.\nThis method is a good interface to query/list satisfying package versions locally.", "author": "leaf94", "createdAt": "2020-04-24T18:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NTc0OQ=="}], "type": "inlineReview"}, {"oid": "008832328b2daad2885d054dd0a4c0c896b0ba9e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/008832328b2daad2885d054dd0a4c0c896b0ba9e", "message": "Merge branch 'master' into package_store_new", "committedDate": "2020-04-24T18:36:24Z", "type": "commit"}, {"oid": "4afb3340e06e1820025c67bb6fd1c236e5807b85", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4afb3340e06e1820025c67bb6fd1c236e5807b85", "message": "Merge branch 'master' into package_store_new", "committedDate": "2020-04-24T22:45:39Z", "type": "commit"}, {"oid": "59ee87c30d4ad373a3625df8ea8e6cb6ba21bb6f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/59ee87c30d4ad373a3625df8ea8e6cb6ba21bb6f", "message": "Address PR comments", "committedDate": "2020-04-24T22:46:03Z", "type": "commit"}, {"oid": "1b6f1d2614ea4427f5def264c1cc22d1f3fe6ba7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1b6f1d2614ea4427f5def264c1cc22d1f3fe6ba7", "message": "Small fix for DeploymentCloudServiceIntegTest", "committedDate": "2020-04-27T18:54:37Z", "type": "commit"}, {"oid": "aaa0cded7046a1864e65008788cc46e95c85d5b2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aaa0cded7046a1864e65008788cc46e95c85d5b2", "message": "Small fix for DeploymentCloudServiceIntegTest", "committedDate": "2020-04-27T19:21:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4NjQzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r416086438", "bodyText": "nit\nuse your const for .yaml.", "author": "MikeDombo", "createdAt": "2020-04-27T19:24:30Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipes\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifacts\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";", "originalCommit": "aaa0cded7046a1864e65008788cc46e95c85d5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}