{"pr_number": 111, "pr_title": "Refactor dependency resolution for packages", "pr_createdAt": "2020-03-12T07:18:47Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5MTI0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391791247", "bodyText": "Make this final?", "author": "MikeDombo", "createdAt": "2020-03-12T17:49:00Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -1,19 +1,47 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.PlatformResolver;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.io.IOException;\n+import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static Logger logger = LogManager.getLogger(DependencyResolver.class);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzA3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391803073", "bodyText": "typo, find found?", "author": "MikeDombo", "createdAt": "2020-03-12T18:10:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzg3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391803870", "bodyText": "Even though this is private, it is important and complicated, so please add javadoc to explain inputs and outputs.", "author": "MikeDombo", "createdAt": "2020-03-12T18:11:34Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NTE3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391885176", "bodyText": "Agree. maybe also add a readme explaining how the algorithm works.", "author": "fengwang666", "createdAt": "2020-03-12T20:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNDcwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391804700", "bodyText": "here too, please add javadoc.", "author": "MikeDombo", "createdAt": "2020-03-12T18:13:11Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTMwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391805307", "bodyText": "typo: should be semver not semvar", "author": "MikeDombo", "createdAt": "2020-03-12T18:14:21Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjA3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391806076", "bodyText": "Maybe make this an Optional instead?", "author": "MikeDombo", "createdAt": "2020-03-12T18:15:44Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3NzA4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391877087", "bodyText": "Will do.", "author": "hui-yang", "createdAt": "2020-03-12T20:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjQyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391806425", "bodyText": "Why empty string here instead of null?", "author": "MikeDombo", "createdAt": "2020-03-12T18:16:20Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {\n+        EvergreenService service = null;\n+        try {\n+            service = EvergreenService.locate(context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atWarn().setCause(e).addKeyValue(\"packageName\", packageName).log(\"Fail to load package\");\n+            return \"\";", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyMjY0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391822645", "bodyText": "Nit - Semver", "author": "shaguptashaikh", "createdAt": "2020-03-12T18:46:20Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1NTkwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391855901", "bodyText": "I'm not sure this will do anything since we don't have a way for customers to specify platform specific dependencies in the recipe. The map of String,String here actually stands for packagename,version, there is no platform specification in it, you can leave it as it is if you want though and we can revisit after the recipe has a way to support platform in dependencies as well as artifacts sections", "author": "shaguptashaikh", "createdAt": "2020-03-12T19:54:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {\n+        EvergreenService service = null;\n+        try {\n+            service = EvergreenService.locate(context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atWarn().setCause(e).addKeyValue(\"packageName\", packageName).log(\"Fail to load package\");\n+            return \"\";\n+        }\n+        Object version = service.config.getChild(\"version\");\n+        return version == null ? \"\" : version.toString();\n+    }\n+\n+    private Package getPackage(final String pkgName, final Semver version) throws PackagingException, IOException {\n+        // TODO: handle exceptions with retry\n+        Optional<Package> optionalPackage = store.getPackage(pkgName, version);\n+        if (!optionalPackage.isPresent()) {\n+            throw new UnexpectedPackagingException(\"Unexpected error in job document: package-version doesn't exist \"\n+                    + pkgName + \"-\" + version);\n+        }\n+        return optionalPackage.get();\n+    }\n+\n+    // Get dependency map for the current platform\n+    private Map<String, String> getPackageDependencies(final Package pkg) throws UnexpectedPackagingException {\n+        Object dependencyListForPlatform = PlatformResolver.resolvePlatform((Map) pkg.getDependencies());\n+        if (!(dependencyListForPlatform instanceof Map)) {\n+            throw new UnexpectedPackagingException(\"Unexpected format of dependency map: \" + dependencyListForPlatform);\n+        }\n+        return (Map<String, String>) dependencyListForPlatform;", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3Njk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391876991", "bodyText": "Will remove the platform check for now.", "author": "hui-yang", "createdAt": "2020-03-12T20:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1NTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDcxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391864711", "bodyText": "why is this method not private?", "author": "shaguptashaikh", "createdAt": "2020-03-12T20:05:53Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3Njg3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391876879", "bodyText": "I mock this method entirely in unit tests, will check if there's a better way.", "author": "hui-yang", "createdAt": "2020-03-12T20:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2Njg0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391866842", "bodyText": "nit- just do return resolve(resolvedPackages, packageVersionConstraints, packagesToResolve); ?", "author": "shaguptashaikh", "createdAt": "2020-03-12T20:08:31Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3NjcxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391876710", "bodyText": "If false, we will move on and try other versions for this package.", "author": "hui-yang", "createdAt": "2020-03-12T20:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2Njg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1OTA5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391859096", "bodyText": "change name to indicate that it is packageToDependencyToVersionConstraints.", "author": "abanthiy", "createdAt": "2020-03-12T19:58:55Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1OTU0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391859545", "bodyText": "This does not look right to me. If this is adding an entry for dependencies and then what is ROOT? Do you mean to add an entry for self?\nAs per the comment the nested map should capture version constraints, then why is it storing Resolved version in this case?", "author": "abanthiy", "createdAt": "2020-03-12T19:59:31Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTIzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391929231", "bodyText": "This is a top-level package requirement (actually pinned version right now). ROOT basically means the requirements come from customers. But this is a good feedback, I can optimize by pruning the version tree of these packages.", "author": "hui-yang", "createdAt": "2020-03-12T21:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1OTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDY4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391864680", "bodyText": "Would prefer this method returning the resolvedPackages and throwing the conflict exception, rather than a boolean check here. That would also save an initialization of resolvedPackages in this method, which IMO will make it more readable? (too many similar sounding names of variables)", "author": "abanthiy", "createdAt": "2020-03-12T20:05:51Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMDE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391930140", "bodyText": "All the arguments are passed in instead of created in the current stack. I'm trying to track resolvedPackages in a \"global variable\"", "author": "hui-yang", "createdAt": "2020-03-12T22:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjkxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391976917", "bodyText": "ok", "author": "abanthiy", "createdAt": "2020-03-13T00:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MDg2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391870868", "bodyText": "The listOfDependenctPackages need to change to List of PackageIdentifier?If we are not using version constraints from the deployment document then remove that?", "author": "abanthiy", "createdAt": "2020-03-12T20:15:54Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -17,6 +18,7 @@\n  */\n @JsonInclude(JsonInclude.Include.NON_NULL)\n @Getter\n+@AllArgsConstructor", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMDUwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391930506", "bodyText": "I will clean up versionConstraint and listOfDependentPackages in a separate PR", "author": "hui-yang", "createdAt": "2020-03-12T22:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MDg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MTc2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391871760", "bodyText": "change name to indicate that these are root packages. Maybe - rootPackagesToResolve", "author": "abanthiy", "createdAt": "2020-03-12T20:17:53Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMDkzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391930935", "bodyText": "will do.", "author": "hui-yang", "createdAt": "2020-03-12T22:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MTc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MjI5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391872290", "bodyText": "Can this just be Set of PackageIdentifiers? We should use the model which we have to represent a package", "author": "abanthiy", "createdAt": "2020-03-12T20:19:05Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTIzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391931236", "bodyText": "It can be. Just it's easier this way to get a package based on name.", "author": "hui-yang", "createdAt": "2020-03-12T22:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MjI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjYzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391976639", "bodyText": "It makes it less readable as this variable percolates through different methods. You are eventually constructing the PackageIdentifiers. If you still prefer this prototype I would suggest to rename to indicate what the map holds. resolvedPackageNameToVersion would be my choice here.", "author": "abanthiy", "createdAt": "2020-03-13T00:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MjI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3ODcwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391878703", "bodyText": "Rename this to indicate everythign this method is doing. As I understand - resolve dependencies and updating the version constraints", "author": "abanthiy", "createdAt": "2020-03-12T20:33:00Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTMyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391931324", "bodyText": "will do", "author": "hui-yang", "createdAt": "2020-03-12T22:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3ODcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjQ5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391882496", "bodyText": "rename to indicate what the map holds", "author": "abanthiy", "createdAt": "2020-03-12T20:41:12Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MDE1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391970153", "bodyText": "+1", "author": "fahadmohammed01", "createdAt": "2020-03-13T00:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4NDI3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391984278", "bodyText": "what happens if dependency map for an existing package gets updated with the deployment.\nsay current version:\nA 1.0 depends on C 1.0\nB 1.0 depende on C 1.0\nnew deployment updates C 1.0 to C 2.0 and updates both A and B to use C 2.0", "author": "fahadmohammed01", "createdAt": "2020-03-13T01:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwOTc2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r392509760", "bodyText": "This should work if the version requirements are still compatible.", "author": "hui-yang", "createdAt": "2020-03-13T22:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MzM5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391883394", "bodyText": "At this point I am curious why we do this first? We should be getting list of packages and their resolved version from deployment document. Shouldn't we try to see if those work well? Why explore other versions of a package first?", "author": "abanthiy", "createdAt": "2020-03-12T20:43:15Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMjA3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391932070", "bodyText": "Right now all versions will be checked against the pinned version to get versionsToExplore, but this can be optimized. I was trying to be generic if we decide to use version constraints for top-level packages instead of pinned version.", "author": "hui-yang", "createdAt": "2020-03-12T22:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1OTU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391959593", "bodyText": "Even if you have version constraints on top level, the preference should be given to the resolved version. The list being returned from getVersionsToExplore does not come in that order, if I understand correctly, it currently only add the active version at 0th index. We should be adding the resolved version as next in the list I think.", "author": "abanthiy", "createdAt": "2020-03-12T23:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3ODgwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391978802", "bodyText": "getVersionsToExplore actually filters all version based on the constraint. Since the constraint is a pinned version, eventually this method is only going to return 1 version. Not efficient. I'll definitely fix it.", "author": "hui-yang", "createdAt": "2020-03-13T00:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NTIzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391885235", "bodyText": "I would think that this method would take in Map root packages and reolved versions for them. That info seems to be going in this method via the packageVersionConstraints, but it is not being used that way inside the method. Read my comment on the methos definition.", "author": "abanthiy", "createdAt": "2020-03-12T20:47:15Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MjE2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391892161", "bodyText": "I would prefer to use iterative approach, this will grow rapidly for large number of packages.", "author": "chaurah", "createdAt": "2020-03-12T21:02:55Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0MTM0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391941347", "bodyText": "I don't think we have an iterative approach since we need backtracking.", "author": "hui-yang", "createdAt": "2020-03-12T22:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MjE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjk5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391892994", "bodyText": "If the same package shows up multiple times, all of these steps will get repeated. It would make more sense to get the list of valid versions for each package at the beginning and make it available for all iterations of the same package.", "author": "chaurah", "createdAt": "2020-03-12T21:04:43Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5NjUzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391896532", "bodyText": "One package should not show up multiple times. packagesToResolve is a set. Before a package is added to packagesToResolve, the code checks if the package is already resolved.", "author": "hui-yang", "createdAt": "2020-03-12T21:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczNjgwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391736804", "bodyText": "Why a list of stores?", "author": "fengwang666", "createdAt": "2020-03-12T16:22:13Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -1,19 +1,47 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.PlatformResolver;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.io.IOException;\n+import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n \n-    public DependencyResolver(PackageRegistry packageRegistry) {\n-        this.packageRegistry = packageRegistry;\n+    // TODO: Temporary, should be list of stores", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczODIyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391738222", "bodyText": "Shouldn't the key be PackageIdentifier instead of packageName?", "author": "fengwang666", "createdAt": "2020-03-12T16:24:20Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMzIwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391933202", "bodyText": "This is not the return value. It's a helper to track a package and all its version constraints from depending packages", "author": "hui-yang", "createdAt": "2020-03-12T22:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczODIyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAxNjE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r392016163", "bodyText": "Yeah, but different package name/version can have different version constraints, right?", "author": "fengwang666", "createdAt": "2020-03-13T03:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczODIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2OTE5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391769193", "bodyText": "Probably want to include the conflict versions", "author": "fengwang666", "createdAt": "2020-03-12T17:12:40Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMzUzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391933535", "bodyText": "I'll try to add that", "author": "hui-yang", "createdAt": "2020-03-12T22:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2OTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkwOTIxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391909218", "bodyText": "This doesn't seem correct. For example, pkgA-1 have two dependencies pkgB-1, pkgC-1; pkgB-1 goes through the inner for loop and is added to the newDependencyPackagesToResolve(line138), but pkgC-1 is excluded because it doesn't satisfy the constraint (line 134); in this case the for loop breaks, the code gives up on pkgA-1 and try a different version. In this case, pkgB shouldn't need to be added into newDependencyPackagesToResolve, correct? Only the versions of the pkgA that all its dependencies are met need to be added to newDependencyPackagesToResolve. Did I miss something here?", "author": "fengwang666", "createdAt": "2020-03-12T21:33:15Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzNDkwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391934902", "bodyText": "If for loop breaks, the newDependencyPackagesToResolve will not be used. Resolved packages with version go to resolvedPackages, and packages which are yet to be resolved go to newDependencyPackagesToResolve, which then get added to packagesToResolve", "author": "hui-yang", "createdAt": "2020-03-12T22:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkwOTIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MzEyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391973123", "bodyText": "I think the newDependencyPackagesToResolve will again be set to  a new HashMap with the next version of pkgA (pkgA-2). So it should be ok.", "author": "abanthiy", "createdAt": "2020-03-13T00:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkwOTIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4NTk5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391985994", "bodyText": "I missed the line146-147 when the outer for loop is skipped.", "author": "fengwang666", "createdAt": "2020-03-13T01:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkwOTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MDA2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391970065", "bodyText": "Can we have more descriptive names so its easy to read", "author": "fahadmohammed01", "createdAt": "2020-03-13T00:19:20Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {", "originalCommit": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da2f0e981e43d7ca0f3c624898ba034151bdcd72", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/da2f0e981e43d7ca0f3c624898ba034151bdcd72", "message": "Refactor dependency resolution for packages", "committedDate": "2020-03-13T00:20:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NzY2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391977668", "bodyText": "Remove dead code?", "author": "abanthiy", "createdAt": "2020-03-13T00:53:25Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,256 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+\n+    @Inject\n+    private Context context;\n+\n+    public DependencyResolver(PackageStore store) {\n+        this.store = store;\n+    }\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        return resolvedPackages.entrySet().stream().map(e -> new PackageIdentifier(e.getKey(), e.getValue()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackages          map of package names to a pinned version, which is resolved\n+     * @param packageVersionConstraints map of package names (A) to a map of depending package names (B) to the version\n+     *                                  requirements (from B to A)\n+     * @param packagesToResolve         set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n+     */\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                              Map<String, Map<String, String>> packageVersionConstraints,\n+                              Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageVersionConstraints.get(pkgName).values());\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Found conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Get a ordered list of possible versions to explore for the given package.\n+     *\n+     * @param pkgName                      name of the package to be explored\n+     * @param packageVersionConstraintList list of version constraints for the package\n+     * @return list of versions as Semver instances\n+     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected List<Semver> getVersionsToExplore(final String pkgName,\n+                                                final Collection<String> packageVersionConstraintList)\n+            throws UnexpectedPackagingException {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemverRequirements(packageVersionConstraintList));\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Add active package version running on the device\n+        Optional<String> version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (version.isPresent() && req.isSatisfiedBy(version.get())) {\n+            activeVersion = new Semver(version.get());\n+            versionList.add(activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(v -> Requirement.buildNPM(v).toString())\n+                .collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected Optional<String> getPackageVersionIfActive(final String packageName) {\n+        EvergreenService service = null;\n+        try {\n+            service = EvergreenService.locate(context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atWarn().setCause(e).addKeyValue(\"packageName\", packageName).log(\"Fail to load package\");\n+            return Optional.empty();\n+        }\n+        Object version = service.config.getChild(\"version\");\n+        return version == null ? Optional.empty() : Optional.of(version.toString());\n+    }\n+\n+    private Package getPackage(final String pkgName, final Semver version) throws PackagingException, IOException {\n+        // TODO: handle exceptions with retry\n+        Optional<Package> optionalPackage = store.getPackage(pkgName, version);\n+        if (!optionalPackage.isPresent()) {\n+            throw new UnexpectedPackagingException(\"Unexpected error in job document: package-version doesn't exist \"\n+                    + pkgName + \"-\" + version);\n+        }\n+        return optionalPackage.get();\n+    }\n+\n+    // Get dependency map for the current platform\n+    private Map<String, String> getPackageDependencies(final Package pkg) throws UnexpectedPackagingException {\n+        return pkg.getDependencies();\n+        // TODO: Add platform keyword\n+        //Object dependencyListForPlatform = PlatformResolver.resolvePlatform((Map) pkg.getDependencies());\n+        //if (!(dependencyListForPlatform instanceof Map)) {\n+        //   throw new UnexpectedPackagingException(\"Unexpected format of dependency map: \" +\n+        //   dependencyListForPlatform);\n+        //}\n+        //return (Map<String, String>) dependencyListForPlatform;", "originalCommit": "da2f0e981e43d7ca0f3c624898ba034151bdcd72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3OTE3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391979178", "bodyText": "I'm thinking of reviving it soon once we need platform support.", "author": "hui-yang", "createdAt": "2020-03-13T01:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NzY2OA=="}], "type": "inlineReview"}, {"oid": "32a4dff3988eb46699cc2cc16a7fdb74cba78adc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/32a4dff3988eb46699cc2cc16a7fdb74cba78adc", "message": "Refactor dependency resolution for packages", "committedDate": "2020-03-13T01:05:09Z", "type": "forcePushed"}, {"oid": "466e7fd163102380396264f408452a9ce8b831ad", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/466e7fd163102380396264f408452a9ce8b831ad", "message": "Refactor dependency resolution for packages", "committedDate": "2020-03-16T21:39:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0NzUwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393447502", "bodyText": "In this sense, say A is a root as well as a node in D's tree, can we update A's version through D's deployment?", "author": "wikimonkey", "createdAt": "2020-03-17T05:08:22Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,\n+                                            Map<String, Map<String, String>> packageNameToVersionConstraints,\n+                                            Set<String> packagesToResolve)\n+            throws PackagingException, IOException, PackageVersionConflictException {\n+\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+        logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(\"packageName\", pkgName).log();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+\n+        for (Semver version : versionsToExplore) {\n+            logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                    \"version\", version).log();\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dependencyNameToVersionConstraints = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackageNameToVersion.containsKey(depPkgName)) {\n+                    Semver resolvedVersion = resolvedPackageNameToVersion.get(entry.getKey());\n+                    if (!Requirement.buildNPM(entry.getValue()).isSatisfiedBy(resolvedVersion)) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        logger.atDebug().addKeyValue(\"packageName\", depPkgName)\n+                                .addKeyValue(\"resolvedVersion\", resolvedVersion)\n+                                .addKeyValue(\"dependingPackage\", pkgName)\n+                                .addKeyValue(\"versionConstraints\", entry.getValue())\n+                                .log(\"Resolved package version does not satisfy new version constraints of the \"\n+                                        + \"depending package\");\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+            logger.atTrace().addKeyValue(\"packageName\", pkgName).addKeyValue(\"packageVersion\", version).addKeyValue(\n+                    \"dependencies\", newDependencyPackagesToResolve).log(\"Found new dependencies to resolve\");\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageNameToVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackageNameToVersion.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                    packagesToResolve)) {\n+                logger.atDebug().setEventType(\"resolve-package-done\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                        \"version\", version).log();\n+                return true;\n+            }\n+\n+            // Found conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackageNameToVersion.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        logger.atDebug().setEventType(\"resolve-package-backtrack\").addKeyValue(\"packageName\", pkgName).log(\n+                \"Exhaust all possible versions of package without a solution. Backtracking...\");\n+        return false;\n+    }\n+\n+    /**\n+     * Get a ordered list of possible versions to explore for the given package.\n+     *\n+     * @param pkgName                      name of the package to be explored\n+     * @param packageToVersionConstraints list of version constraints for the package\n+     * @return list of versions as Semver instances\n+     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n+     */\n+    protected List<Semver> getVersionsToExplore(final String pkgName,\n+                                                final Map<String, String> packageToVersionConstraints)\n+            throws UnexpectedPackagingException, PackageVersionConflictException {\n+\n+        List<Semver> versionList = new LinkedList<>();\n+        logger.atDebug().addKeyValue(\"packageName\", pkgName).addKeyValue(\"versionConstraints\",\n+                packageToVersionConstraints).log(\"Parsing version constraints for dependency package\");\n+        Requirement req = Requirement.buildNPM(mergeSemverRequirements(packageToVersionConstraints.values()));\n+\n+        if (packageToVersionConstraints.containsKey(ROOT_REQUIREMENT_KEY)) {", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MDIzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393870230", "bodyText": "Not right now. A should also have a pinned version.", "author": "hui-yang", "createdAt": "2020-03-17T18:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0NzUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0OTQyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393449427", "bodyText": "Why are the method protected? Can they be package private?", "author": "wikimonkey", "createdAt": "2020-03-17T05:17:18Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MTgxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393871812", "bodyText": "Will update.", "author": "hui-yang", "createdAt": "2020-03-17T18:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0OTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MDQ5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393490493", "bodyText": "It seems the resolved version takes precedence. Shouldn't re-consider the version of dependency if the resolved version doesn't satisfy with the new constraint?", "author": "wikimonkey", "createdAt": "2020-03-17T07:40:42Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,\n+                                            Map<String, Map<String, String>> packageNameToVersionConstraints,\n+                                            Set<String> packagesToResolve)\n+            throws PackagingException, IOException, PackageVersionConflictException {\n+\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+        logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(\"packageName\", pkgName).log();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+\n+        for (Semver version : versionsToExplore) {\n+            logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                    \"version\", version).log();\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dependencyNameToVersionConstraints = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackageNameToVersion.containsKey(depPkgName)) {\n+                    Semver resolvedVersion = resolvedPackageNameToVersion.get(entry.getKey());\n+                    if (!Requirement.buildNPM(entry.getValue()).isSatisfiedBy(resolvedVersion)) {", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2OTgwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393869800", "bodyText": "As we have discussed offline, if A -> B, B is already resolved with some version V, and A is a new package to resolve, the code will try out all of A's versions to fit in the current closure before backtracking and experiment other B's versions.", "author": "hui-yang", "createdAt": "2020-03-17T18:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MDQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxNDYwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393814604", "bodyText": "NIT: add some comments explaining why this is needed.\nAlso this can be optimized to save memory. Instead of using a map of map, you can use a map: Map<String, String>. The inner map can be resolved a string value.The key is the packageName, the value is the resolved version constraint of all its depending packages. Every time when a depending package is added or removed, the value can be updated according. This can be done in a separate PR.", "author": "fengwang666", "createdAt": "2020-03-17T16:36:57Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxMTE5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393911196", "bodyText": "Discussed offline. packageNameToVersionConstraints has information about depending packages. We can hold off a bit, wait until feature complete in package manager and see if this information can be useful at all, e.g. in package cache cleanup. I'll create a backlog item for now to track this optimization task.", "author": "hui-yang", "createdAt": "2020-03-17T19:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxNDYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTQxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393825419", "bodyText": "Is there a way to include the package versions that are conflicting?", "author": "fengwang666", "createdAt": "2020-03-17T16:52:12Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NzEwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393867103", "bodyText": "There can be multiple paths which fail in the process. I can add an error list to track all of them. Does that sound good to you?", "author": "hui-yang", "createdAt": "2020-03-17T17:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTg1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393825852", "bodyText": "Why not arraylist?", "author": "fengwang666", "createdAt": "2020-03-17T16:52:48Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,\n+                                            Map<String, Map<String, String>> packageNameToVersionConstraints,\n+                                            Set<String> packagesToResolve)\n+            throws PackagingException, IOException, PackageVersionConflictException {\n+\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+        logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(\"packageName\", pkgName).log();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+\n+        for (Semver version : versionsToExplore) {\n+            logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                    \"version\", version).log();\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dependencyNameToVersionConstraints = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackageNameToVersion.containsKey(depPkgName)) {\n+                    Semver resolvedVersion = resolvedPackageNameToVersion.get(entry.getKey());\n+                    if (!Requirement.buildNPM(entry.getValue()).isSatisfiedBy(resolvedVersion)) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        logger.atDebug().addKeyValue(\"packageName\", depPkgName)\n+                                .addKeyValue(\"resolvedVersion\", resolvedVersion)\n+                                .addKeyValue(\"dependingPackage\", pkgName)\n+                                .addKeyValue(\"versionConstraints\", entry.getValue())\n+                                .log(\"Resolved package version does not satisfy new version constraints of the \"\n+                                        + \"depending package\");\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+            logger.atTrace().addKeyValue(\"packageName\", pkgName).addKeyValue(\"packageVersion\", version).addKeyValue(\n+                    \"dependencies\", newDependencyPackagesToResolve).log(\"Found new dependencies to resolve\");\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageNameToVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackageNameToVersion.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                    packagesToResolve)) {\n+                logger.atDebug().setEventType(\"resolve-package-done\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                        \"version\", version).log();\n+                return true;\n+            }\n+\n+            // Found conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackageNameToVersion.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        logger.atDebug().setEventType(\"resolve-package-backtrack\").addKeyValue(\"packageName\", pkgName).log(\n+                \"Exhaust all possible versions of package without a solution. Backtracking...\");\n+        return false;\n+    }\n+\n+    /**\n+     * Get a ordered list of possible versions to explore for the given package.\n+     *\n+     * @param pkgName                      name of the package to be explored\n+     * @param packageToVersionConstraints list of version constraints for the package\n+     * @return list of versions as Semver instances\n+     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n+     */\n+    protected List<Semver> getVersionsToExplore(final String pkgName,\n+                                                final Map<String, String> packageToVersionConstraints)\n+            throws UnexpectedPackagingException, PackageVersionConflictException {\n+\n+        List<Semver> versionList = new LinkedList<>();", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NTk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393865991", "bodyText": "I thought LinkedList took less memory but more research shows the other way. Will update.", "author": "hui-yang", "createdAt": "2020-03-17T17:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2ODI2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393868263", "bodyText": "LinkedList should be more memory efficient because it doesn't need a contiguous block of memory (which ArrayList over-allocates by 1.5x). Since we're not doing any indexing operations, we have no need for it to be a contiguous block of memory.", "author": "MikeDombo", "createdAt": "2020-03-17T17:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwOTc4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393909784", "bodyText": "@MikeDombo you are right about that, but one node in LinkedList takes more memory space than one node in ArrayList. It's hard to say which one is smaller overall. I'll see if both can be benchmarked in the performance test.", "author": "hui-yang", "createdAt": "2020-03-17T19:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1MzA1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393853059", "bodyText": "Can you add a test case that covers backtracking? It can be done in a separate PR.", "author": "fengwang666", "createdAt": "2020-03-17T17:34:53Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DependencyResolverTest {\n+    @Mock\n+    private PackageStore mockPackageStore;\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private Context context;\n+\n+    @Mock\n+    private EvergreenService mainService;\n+\n+    @BeforeAll\n+    public static void Setup() {\n+        System.setProperty(\"log.fmt\", \"TEXT\");\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+        System.setProperty(\"log.level\", \"TRACE\");\n+    }\n+\n+    @Nested\n+    class MergeSemverRequirementsTest {\n+        @Spy\n+        private DependencyResolver resolver = new DependencyResolver(mockPackageStore, kernel, context);\n+\n+        @Test\n+        public void GIVEN_list_of_version_ranges_WHEN_get_union_THEN_get_version_range() {\n+            List<String> constraints = new LinkedList<>();\n+            constraints.add(\"<3.0\");\n+            constraints.add(\">1.0\");\n+            constraints.add(\">2.0\");\n+            String req = resolver.mergeSemverRequirements(constraints);\n+            assertEquals(\"<3.0 >1.0 >2.0\", req);\n+\n+            Requirement r = Requirement.buildNPM(req);\n+            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n+            assertTrue(r.isSatisfiedBy(\"2.0.1\"));\n+        }\n+\n+        @Test\n+        public void GIVEN_list_of_version_range_and_pinned_version_WHEN_get_union_THEN_get_pinned_version() {\n+            List<String> constraints = new LinkedList<>();\n+            constraints.add(\"<3.0\");\n+            constraints.add(\"1.0.0\");\n+            String req = resolver.mergeSemverRequirements(constraints);\n+            assertEquals(\"<3.0 =1.0.0\", req);\n+\n+            Requirement r = Requirement.buildNPM(req);\n+            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n+            assertTrue(r.isSatisfiedBy(\"1.0.0\"));\n+        }\n+\n+        @Test\n+        public void GIVEN_list_of_version_range_with_conflicts_WHEN_get_union_THEN_get_no_version_match() {\n+            List<String> constraints = new LinkedList<>();\n+            constraints.add(\">4.0\");\n+            constraints.add(\"<3.0\");\n+            String req = resolver.mergeSemverRequirements(constraints);\n+            assertEquals(\">4.0 <3.0\", req);\n+\n+            Requirement r = Requirement.buildNPM(req);\n+            assertFalse(r.isSatisfiedBy(\"4.0.1\"));\n+            assertFalse(r.isSatisfiedBy(\"2.0.0\"));\n+        }\n+    }\n+\n+    @Nested\n+    class GetVersionsToExploreTest{\n+        @Test\n+        public void GIVEN_package_not_active_WHEN_get_versions_THEN_get_version_within_constraint() throws UnexpectedPackagingException, PackageVersionConflictException {\n+            when(mockPackageStore.getPackageVersionsIfExists(\"testPackage\")).thenReturn(Arrays.asList(new Semver(\"1.2\" +\n+                    \".0\"), new Semver(\"1.1.0\"), new Semver(\"1.0.0\")));\n+            DependencyResolver resolver = spy(new DependencyResolver(mockPackageStore, kernel, context));\n+            doReturn(Optional.empty()).when(resolver).getPackageVersionIfActive(any());\n+\n+            Map<String, String> versionConstraints = new HashMap<>();\n+            versionConstraints.putIfAbsent(\"mock\", \">1.0\");\n+            List<Semver> versions = resolver.getVersionsToExplore(\"testPackage\", versionConstraints);\n+            assertEquals(Arrays.asList(new Semver(\"1.2.0\"), new Semver(\"1.1.0\")), versions);\n+        }\n+\n+        @Test\n+        public void GIVEN_package_active_WHEN_get_versions_THEN_get_active_version_first() throws UnexpectedPackagingException, PackageVersionConflictException {\n+            when(mockPackageStore.getPackageVersionsIfExists(\"testPackage\")).thenReturn(Arrays.asList(new Semver(\"1\" +\n+                    \".2.0\"), new Semver(\"1.1.0\"), new Semver(\"1.0.0\")));\n+            DependencyResolver resolver = spy(new DependencyResolver(mockPackageStore, kernel, context));\n+            doReturn(Optional.of(\"1.1.0\")).when(resolver).getPackageVersionIfActive(any());\n+\n+            Map<String, String> versionConstraints = new HashMap<>();\n+            versionConstraints.putIfAbsent(\"mock\", \">1.0\");\n+            List<Semver> versions = resolver.getVersionsToExplore(\"testPackage\", versionConstraints);\n+            assertEquals(Arrays.asList(new Semver(\"1.1.0\"), new Semver(\"1.2.0\")), versions);\n+        }\n+    }\n+\n+    @Nested\n+    class ResolveDependenciesTest{", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NTM2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393865364", "bodyText": "This test case does 1 successful backtrack https://github.com/aws/aws-greengrass-kernel/blob/466e7fd163102380396264f408452a9ce8b831ad/src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java#L268-L278\nSearch logs for backtrack https://paste.amazon.com/show/huiyn/1584467628\nI can also add a more complicated case.", "author": "hui-yang", "createdAt": "2020-03-17T17:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1MzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MTU2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393871562", "bodyText": "And this is the error case with backtracking https://github.com/aws/aws-greengrass-kernel/blob/466e7fd163102380396264f408452a9ce8b831ad/src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java#L289\nLogs: https://paste.amazon.com/show/huiyn/1584468203", "author": "hui-yang", "createdAt": "2020-03-17T18:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1MzA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3Njc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393876783", "bodyText": "Shouldn't kernel be also injected? and could you not use kernel.context instead of having context separately injected here?", "author": "shaguptashaikh", "createdAt": "2020-03-17T18:13:07Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3OTEyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393879129", "bodyText": "Will update", "author": "hui-yang", "createdAt": "2020-03-17T18:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3Njc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwMTIwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393901202", "bodyText": "Thanks for cleaning this up!", "author": "shaguptashaikh", "createdAt": "2020-03-17T18:54:53Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -25,8 +25,7 @@\n public class KernelConfigResolver {\n \n     private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n-    private static final String VERSION_CONFIG_KEY = \"version\";\n-    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";", "originalCommit": "466e7fd163102380396264f408452a9ce8b831ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b79403cbb3bc0c9911f61d00c3437e700096797", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b79403cbb3bc0c9911f61d00c3437e700096797", "message": "Refactor dependency resolution for packages", "committedDate": "2020-03-17T22:05:34Z", "type": "commit"}, {"oid": "3b79403cbb3bc0c9911f61d00c3437e700096797", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b79403cbb3bc0c9911f61d00c3437e700096797", "message": "Refactor dependency resolution for packages", "committedDate": "2020-03-17T22:05:34Z", "type": "forcePushed"}]}