{"pr_number": 98, "pr_title": "Moving to one Iot device SDK. Adding unit tests for DeploymentService", "pr_createdAt": "2020-03-05T20:42:28Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1NjAwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388556003", "bodyText": "Looks like this could throw NPE since you're not checking if Queued exists in the map. Maybe just check for that instead of using isEmpty on L75?", "author": "MikeDombo", "createdAt": "2020-03-05T20:47:28Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -37,49 +38,47 @@\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n \n+    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n+    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n+    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n+    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n+    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n     @Inject\n+    @Setter\n+    private IotJobsHelperFactory iotJobsHelperFactory;\n+    @Inject\n+    @Setter\n+    private ExecutorService executorService;\n+    @Inject\n+    @Setter\n+    private Kernel kernel;\n+\n     private IotJobsHelper iotJobsHelper;\n-    private MqttHelper mqttHelper;\n     private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-    //Thread safe?\n-    private final ExecutorService executorService = context.get(ExecutorService.class);\n     private Future<Boolean> currentProcessStatus = null;\n     private String currentJobId;\n     private DeploymentContext currentDeploymentContext;\n+    @Setter\n+    private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n \n-    private final Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n+    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n         /*\n          * This message is received when either of these things happen\n          * 1. Last job completed (successful/failed)\n          * 2. A new job was queued\n          * 3. A job was cancelled\n          * This message receives the list of Queued and InProgress jobs at the time of this message\n          */\n-        logger.info(\"Received mqtt notify message with payload {}\", awsIotMessage.getStringPayload());\n-\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            //TODO: Check that if there is a current job runnign by the device then thats\n-            // coming in the inProgress list. If its not there then it will be an indication that\n-            // it was cancelled.\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n+        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n+        if (!jobs.isEmpty()) {\n+            if (!jobs.get(JobStatus.QUEUED).isEmpty()) {", "originalCommit": "72ce080cb8645e7b0ea49601d4679019a5946f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxODQ3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388618479", "bodyText": "Thats right!.", "author": "abanthiy", "createdAt": "2020-03-05T23:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1NjAwMw=="}], "type": "inlineReview"}, {"oid": "f29a8dad84eaeff0a27ba0c72be61695eae40dfe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f29a8dad84eaeff0a27ba0c72be61695eae40dfe", "message": "Moving to one Iot device SDK. Adding unit tests for DeploymentService", "committedDate": "2020-03-05T23:05:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTE0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388639147", "bodyText": "If you moved to using nested tests: https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested\nyou could have a @BeforeEach that starts deployment service in a thread for the tests that require it", "author": "rbattle", "createdAt": "2020-03-06T00:16:14Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.internal.verification.Times;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentServiceTest {\n+\n+    private static final String MOCK_DEVICE_PARAMETER = \"mockDeviceParameter\";\n+    private static final String EVERGREEN_SERVICE_FULL_NAME = \"DeploymentService\";\n+    private static final String TEST_JOB_ID_1 = \"TEST_JOB_1\";\n+\n+    @Mock\n+    Topic stateTopic;\n+\n+    @Mock\n+    Topic requiresTopic;\n+\n+    @Mock\n+    Topics mockConfig;\n+\n+    @Mock\n+    Context mockContext;\n+\n+    @Mock\n+    Topic mockTopic;\n+\n+    @Mock\n+    IotJobsHelper mockIotJobsHelper;\n+\n+    @Mock\n+    DeploymentService.IotJobsHelperFactory mockIotJobsHelperFactory;\n+\n+    @Mock\n+    Kernel mockKernel;\n+\n+    @Mock\n+    ExecutorService mockExecutorService;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<JobExecutionsChangedEvent>> jobEventConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<DescribeJobExecutionResponse>> describeJobConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<RejectedError>> rejectedErrorConsumerCaptor;\n+\n+    DeploymentService deploymentService;\n+\n+    @BeforeEach\n+    public void setup() {\n+        //Evergreen service specific mocks\n+        when(mockConfig.createLeafChild(eq(\"_State\"))).thenReturn(stateTopic);\n+        when(stateTopic.getOnce()).thenReturn(State.INSTALLED);\n+        when(mockConfig.createLeafChild(eq(\"requires\"))).thenReturn(requiresTopic);\n+        when(mockConfig.getFullName()).thenReturn(EVERGREEN_SERVICE_FULL_NAME);\n+        when(requiresTopic.dflt(Mockito.any())).thenReturn(requiresTopic);\n+        when(mockConfig.findLeafChild(Mockito.any())).thenReturn(mockTopic);\n+        when(mockConfig.getFullName()).thenReturn(\"DeploymentService\");\n+        when(mockConfig.getContext()).thenReturn(mockContext);\n+\n+        //Deployment service specific mocks\n+        when(mockTopic.getOnce()).thenReturn(MOCK_DEVICE_PARAMETER);\n+        when(mockKernel.deTilde(anyString())).thenAnswer(invocationOnMock -> {\n+            return (String) invocationOnMock.getArguments()[0];\n+        });\n+        when(mockIotJobsHelperFactory\n+                .getIotJobsHelper(anyString(), anyString(), anyString(), anyString(), anyString(), anyString()))\n+                .thenReturn(mockIotJobsHelper);\n+\n+        //Creating the class to be tested\n+        deploymentService = new DeploymentService(mockConfig);\n+        deploymentService.setIotJobsHelperFactory(mockIotJobsHelperFactory);\n+        deploymentService.setExecutorService(mockExecutorService);\n+        deploymentService.setKernel(mockKernel);\n+    }\n+\n+    @AfterEach\n+    public void tearDown() {\n+        deploymentService.shutdown();\n+    }\n+\n+    @Test\n+    public void GIVEN_DeviceConfiguration_THEN_StartDeploymentService()\n+            throws ExecutionException, InterruptedException {\n+        startDeploymentServiceInAnotherThread();", "originalCommit": "47ac30de9a29cce127e767a19655f54a99cd18d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMTQzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388701433", "bodyText": "I will look into this. Thanks for suggestion", "author": "abanthiy", "createdAt": "2020-03-06T03:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTc0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388641745", "bodyText": "This seems brittle. If we are want to ensure the service has started before running the test,\nCould you do something like:\nboolean started = false;\nObject waiter = new Object();\nThread t = new Thread(() -> {\n  deploymentService.startup();\n  synchronized (waiter) {\n    started = true;\n    waiter.notify();\n  }\n);\nt.start();\n\nsynchronized (waiter) {\n  while (!started) {\n    waiter.wait();\n  }\n}\n// deploymentService has started now", "author": "rbattle", "createdAt": "2020-03-06T00:24:38Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.internal.verification.Times;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentServiceTest {\n+\n+    private static final String MOCK_DEVICE_PARAMETER = \"mockDeviceParameter\";\n+    private static final String EVERGREEN_SERVICE_FULL_NAME = \"DeploymentService\";\n+    private static final String TEST_JOB_ID_1 = \"TEST_JOB_1\";\n+\n+    @Mock\n+    Topic stateTopic;\n+\n+    @Mock\n+    Topic requiresTopic;\n+\n+    @Mock\n+    Topics mockConfig;\n+\n+    @Mock\n+    Context mockContext;\n+\n+    @Mock\n+    Topic mockTopic;\n+\n+    @Mock\n+    IotJobsHelper mockIotJobsHelper;\n+\n+    @Mock\n+    DeploymentService.IotJobsHelperFactory mockIotJobsHelperFactory;\n+\n+    @Mock\n+    Kernel mockKernel;\n+\n+    @Mock\n+    ExecutorService mockExecutorService;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<JobExecutionsChangedEvent>> jobEventConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<DescribeJobExecutionResponse>> describeJobConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<RejectedError>> rejectedErrorConsumerCaptor;\n+\n+    DeploymentService deploymentService;\n+\n+    @BeforeEach\n+    public void setup() {\n+        //Evergreen service specific mocks\n+        when(mockConfig.createLeafChild(eq(\"_State\"))).thenReturn(stateTopic);\n+        when(stateTopic.getOnce()).thenReturn(State.INSTALLED);\n+        when(mockConfig.createLeafChild(eq(\"requires\"))).thenReturn(requiresTopic);\n+        when(mockConfig.getFullName()).thenReturn(EVERGREEN_SERVICE_FULL_NAME);\n+        when(requiresTopic.dflt(Mockito.any())).thenReturn(requiresTopic);\n+        when(mockConfig.findLeafChild(Mockito.any())).thenReturn(mockTopic);\n+        when(mockConfig.getFullName()).thenReturn(\"DeploymentService\");\n+        when(mockConfig.getContext()).thenReturn(mockContext);\n+\n+        //Deployment service specific mocks\n+        when(mockTopic.getOnce()).thenReturn(MOCK_DEVICE_PARAMETER);\n+        when(mockKernel.deTilde(anyString())).thenAnswer(invocationOnMock -> {\n+            return (String) invocationOnMock.getArguments()[0];\n+        });\n+        when(mockIotJobsHelperFactory\n+                .getIotJobsHelper(anyString(), anyString(), anyString(), anyString(), anyString(), anyString()))\n+                .thenReturn(mockIotJobsHelper);\n+\n+        //Creating the class to be tested\n+        deploymentService = new DeploymentService(mockConfig);\n+        deploymentService.setIotJobsHelperFactory(mockIotJobsHelperFactory);\n+        deploymentService.setExecutorService(mockExecutorService);\n+        deploymentService.setKernel(mockKernel);\n+    }\n+\n+    @AfterEach\n+    public void tearDown() {\n+        deploymentService.shutdown();\n+    }\n+\n+    @Test\n+    public void GIVEN_DeviceConfiguration_THEN_StartDeploymentService()\n+            throws ExecutionException, InterruptedException {\n+        startDeploymentServiceInAnotherThread();\n+\n+        verify(mockIotJobsHelper).subscribeToEventNotifications(any());\n+        verify(mockIotJobsHelper).subscribeToGetNextJobDecription(any(), any());\n+    }\n+\n+    @Test\n+    public void GIVEN_EventNotification_WHEN_NewJobQueued_THEN_ProcessNotification()\n+            throws ExecutionException, InterruptedException {\n+        startDeploymentServiceInAnotherThread();\n+\n+        verify(mockIotJobsHelper).subscribeToEventNotifications(jobEventConsumerCaptor.capture());\n+        Consumer<JobExecutionsChangedEvent> consumer = jobEventConsumerCaptor.getValue();\n+        JobExecutionsChangedEvent response = new JobExecutionsChangedEvent();\n+        response.jobs = getTestJobs();\n+        consumer.accept(response);\n+        verify(mockIotJobsHelper).requestNextPendingJobDocument();\n+    }\n+\n+    @Test\n+    public void GIVEN_EventNotification_WHEN_JobFinishedNoNewJob_THEN_ProcessNotification()\n+            throws ExecutionException, InterruptedException {\n+        startDeploymentServiceInAnotherThread();\n+\n+        verify(mockIotJobsHelper).subscribeToEventNotifications(jobEventConsumerCaptor.capture());\n+        Consumer<JobExecutionsChangedEvent> consumer = jobEventConsumerCaptor.getValue();\n+        JobExecutionsChangedEvent response = new JobExecutionsChangedEvent();\n+        response.jobs = new HashMap<>();\n+        consumer.accept(response);\n+        verify(mockIotJobsHelper, times(0)).requestNextPendingJobDocument();\n+    }\n+\n+    @Test\n+    public void GIVEN_DescribeJobNotification_WHEN_NewJob_THEN_ProcessNotificationSuccessfully()\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<Boolean> mockBooleanFuture = mock(CompletableFuture.class);\n+        when(mockBooleanFuture.get()).thenReturn(Boolean.TRUE);\n+        when(mockExecutorService.submit(any(DeploymentProcess.class))).thenReturn(mockBooleanFuture);\n+        deploymentService.setPollingFrequency(Duration.ofSeconds(1).toMillis());\n+        startDeploymentServiceInAnotherThread();\n+\n+        verify(mockIotJobsHelper).subscribeToGetNextJobDecription(describeJobConsumerCaptor.capture(), any());\n+        Consumer<DescribeJobExecutionResponse> consumer = describeJobConsumerCaptor.getValue();\n+        DescribeJobExecutionResponse response = new DescribeJobExecutionResponse();\n+        response.execution = getTestJobExecutionData();\n+        consumer.accept(response);\n+        verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n+        verify(mockExecutorService).submit(any(DeploymentProcess.class));\n+        //Wait for the deploymentFrequency after which deployment service will check for the status of future\n+        Thread.sleep(Duration.ofSeconds(1).toMillis());\n+        verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.SUCCEEDED), any());\n+    }\n+\n+    @Test\n+    public void GIVEN_DescribeJobNotification_WHEN_NewJob_THEN_ProcessNotificationUnSuccessfully()\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<Boolean> mockBooleanFuture = mock(CompletableFuture.class);\n+        when(mockBooleanFuture.get()).thenReturn(Boolean.FALSE);\n+        when(mockExecutorService.submit(any(DeploymentProcess.class))).thenReturn(mockBooleanFuture);\n+        deploymentService.setPollingFrequency(Duration.ofSeconds(1).toMillis());\n+        startDeploymentServiceInAnotherThread();\n+\n+        verify(mockIotJobsHelper).subscribeToGetNextJobDecription(describeJobConsumerCaptor.capture(), any());\n+        Consumer<DescribeJobExecutionResponse> consumer = describeJobConsumerCaptor.getValue();\n+        DescribeJobExecutionResponse response = new DescribeJobExecutionResponse();\n+        response.execution = getTestJobExecutionData();\n+        consumer.accept(response);\n+        verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n+        verify(mockExecutorService).submit(any(DeploymentProcess.class));\n+        //Wait for the deploymentFrequency after which deployment service will check for the status of future\n+        Thread.sleep(Duration.ofSeconds(1).toMillis());\n+        verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.FAILED), any());\n+    }\n+\n+    private void startDeploymentServiceInAnotherThread() throws InterruptedException {\n+        Thread t = new Thread(() -> deploymentService.startup());\n+        t.start();\n+        //let the other thread start\n+        Thread.sleep(100);", "originalCommit": "47ac30de9a29cce127e767a19655f54a99cd18d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2ODM3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388668373", "bodyText": "Or use CountdownLatch", "author": "fengwang666", "createdAt": "2020-03-06T01:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMTA4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388701084", "bodyText": "Apart from ensuring that it has started, that thread should have executed upto a certain point (triggered the subscription calls, which I verify later). Just by checking if it has started does not ensure that I think.\n@fengwa-aws If I understand correctly, this requires the deployment service to respond to countDown() signal. Is it common to do this only for testing purposes? Not sure how will it behave with kernel starting the thread, I guess it can be hidden behind conditionals.", "author": "abanthiy", "createdAt": "2020-03-06T03:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNDE4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389924188", "bodyText": "In that case, should reportState(State.RUNNING); happen after it has subscribed successfully?\nAre we ok with it being marked as running, where it is connected but not subscribed? Subscribe can potentially be throttled on the cloud side and we would just see it as a timeout.", "author": "rbattle", "createdAt": "2020-03-09T19:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1ODA2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389958066", "bodyText": "I would assume that would throw ExecutionException and we will mark the service as ERRORED right now. We need to put retry strategy in such cases.\nI can see that reporting RUNNING after subscription is a confirmation of service actually running. But this can break even after this, if the MQTT connection breaks. In that case we will have retry attempts while the service is in RUNNING. I don't think we will be putting the service in INSTALLED/NEW state every time MQTT connection breaks.\nIn the context of running these tests in a separate thread, I am assuming that subscribe calls get invoked within 100ms. Does reportState(State.RUNNING) position affect this?", "author": "abanthiy", "createdAt": "2020-03-09T20:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwMzc0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r390403742", "bodyText": "My reason for asking about moving it was so that then you could block on the state of the service running in the test instead of arbitrary waiting.\nMy main concern is we aren't encoding behavior in tests that can hide race conditions that crop up on slower hardware", "author": "rbattle", "createdAt": "2020-03-10T15:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3Mzg1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r390573854", "bodyText": "ok, I have added CountDownLatch to ensure thread executes until certain point and main test execution thread will wait till that point.", "author": "abanthiy", "createdAt": "2020-03-10T19:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NjQ0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388646442", "bodyText": "This strikes me as odd. Why is this only allowed for unit tests?\nIt looks like you want this so you can pass in a connection instead of having to setup the connection to IoT. Should the jobs helper just expose this constructor only and let whoever is calling it manage opening/closing the connection.\nIt is also strange that you have to explicitly call closeConnection without ever explicitly opening the connection.\nI think it would make for a cleaner abstraction if you moved out creating and opening the connection into DeploymentService, and then use that when initializing the IoT Jobs helper", "author": "rbattle", "createdAt": "2020-03-06T00:37:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -94,6 +82,34 @@ private void setupConnectionToAWSIot(String certificateFile, String privateKeyFi\n         }\n     }\n \n+    /**\n+     * Constructor.\n+     *\n+     * @param thingName       Iot thing name\n+     * @param clientEndpoint  Custom endpoint for the aws account\n+     * @param certificateFile File path for the Iot Thing certificate\n+     * @param privateKeyFile  File path for the private key for Iot thing\n+     * @param rootCaPath      File path for the root CA\n+     * @param clientId        Unique client ID\n+     */\n+    public IotJobsHelper(String thingName, String clientEndpoint, String certificateFile, String privateKeyFile,\n+                         String rootCaPath, String clientId) {\n+        this.thingName = thingName;\n+        setupConnectionToAWSIot(certificateFile, privateKeyFile, clientEndpoint, rootCaPath, clientId);\n+    }\n+\n+    /**\n+     * Constructor to be used in unit tests.\n+     * @param thingName The Iot thing name\n+     * @param mqttClientConnection Mqtt client connection already setup\n+     * @param iotJobsClient Iot Jobs client using the mqtt connection\n+     */\n+    public IotJobsHelper(String thingName, MqttClientConnection mqttClientConnection, IotJobsClient iotJobsClient) {", "originalCommit": "f29a8dad84eaeff0a27ba0c72be61695eae40dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5NzkxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388697911", "bodyText": "I will revisit this.", "author": "abanthiy", "createdAt": "2020-03-06T03:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MjQ2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388642468", "bodyText": "Why can't we use constructor instead of setter?", "author": "fengwang666", "createdAt": "2020-03-06T00:26:33Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -37,49 +38,47 @@\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n \n+    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n+    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n+    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n+    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n+    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n     @Inject\n+    @Setter", "originalCommit": "47ac30de9a29cce127e767a19655f54a99cd18d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTQwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389081402", "bodyText": "+1 for @AllArgsConstructor instead of setters when we're just using it for testing.", "author": "MikeDombo", "createdAt": "2020-03-06T18:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MjQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDcwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388644700", "bodyText": "How is iotJobsHeloperFactory initialized?", "author": "fengwang666", "createdAt": "2020-03-06T00:32:20Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -37,49 +38,47 @@\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n \n+    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n+    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n+    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n+    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n+    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n     @Inject\n+    @Setter\n+    private IotJobsHelperFactory iotJobsHelperFactory;", "originalCommit": "47ac30de9a29cce127e767a19655f54a99cd18d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5NDAzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388694031", "bodyText": "Kernel context initializes all the classes with NoArg constructor", "author": "abanthiy", "createdAt": "2020-03-06T03:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjE2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388666162", "bodyText": "Not sure about reporting ERRORED here. Let's say the device is offline while deploymentService gets started. ExecutionException will be thrown because iotJobsHelper cannot subscribe to the cloud. Then it reports ERRORED to the Kernel and triggers a restart and then deploymentService goes through the same loop. Eventually DeploymentService goes into broken state. Is my reasoning correct? Is that what is desired?\nOur devie code has to expect every outbound call may fail and must handle that in a graceful way.", "author": "fengwang666", "createdAt": "2020-03-06T01:22:18Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -149,21 +151,13 @@ public void startup() {\n         }\n \n         try {\n-            initialize(thingName);\n+            initializeIotJobsHelper(thingName);\n             reportState(State.RUNNING);\n-\n-            // TODO: Move to one SDK.\n-            // Subscribe to change event does not work well with jobs sdk, so using iot sdk to subscribe to notify topic\n-            // The Jobs SDK is flaky with its Future responses. When SubscribeToJobExecutionsChangedEvents\n-            // call is used in Jobs SDK, then PublishDescribeJobExecution is not able to publish the message.\n-            // Tried using different client connections for different subscriptions\n-            String topic = NOTIFY_TOPIC.replace(\"{thingName}\", thingName);\n-            mqttHelper.subscribe(topic, awsIotNotifyMessageHandler);\n-\n+            iotJobsHelper.subscribeToEventNotifications(eventHandler);\n             iotJobsHelper.subscribeToGetNextJobDecription(describeJobExecutionResponseConsumer, rejectedError -> {\n                 logger.error(\"Job subscription got rejected\", rejectedError);\n             });\n-        } catch (ExecutionException | InterruptedException | AWSIotException ex) {\n+        } catch (ExecutionException | InterruptedException ex) {\n             logger.error(\"Caught exception in subscribing to topics\", ex);\n             errored = true;\n             reportState(State.ERRORED);", "originalCommit": "47ac30de9a29cce127e767a19655f54a99cd18d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5NjcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388696704", "bodyText": "In the current implementation this is correct. For now this is desired, since I am solving the case when I assume the device is connected to cloud. But going forward, the case you are highlighting needs to be covered. Also need to think of scenarios where deployment is in progress and connection breaks. I have not worked on error cases in this PR. I plan to cover error scenarios in a separate PR otherwise it will be a bigger PR and I would like to work on it separately.", "author": "abanthiy", "createdAt": "2020-03-06T03:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxODY4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r388718689", "bodyText": "I'm okay we handle it later. Let's capture that in a SIM and put a TODO here to make sure we don't forget that.", "author": "fengwang666", "createdAt": "2020-03-06T05:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2MTc0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389061744", "bodyText": "It has been captured in the backlog spreadsheet.", "author": "abanthiy", "createdAt": "2020-03-06T18:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4Mjc4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389082786", "bodyText": "The isEmpty is redundant with containsKey.", "author": "MikeDombo", "createdAt": "2020-03-06T18:56:30Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -37,49 +38,47 @@\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n \n+    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n+    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n+    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n+    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n+    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n     @Inject\n+    @Setter\n+    private IotJobsHelperFactory iotJobsHelperFactory;\n+    @Inject\n+    @Setter\n+    private ExecutorService executorService;\n+    @Inject\n+    @Setter\n+    private Kernel kernel;\n+\n     private IotJobsHelper iotJobsHelper;\n-    private MqttHelper mqttHelper;\n     private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-    //Thread safe?\n-    private final ExecutorService executorService = context.get(ExecutorService.class);\n     private Future<Boolean> currentProcessStatus = null;\n     private String currentJobId;\n     private DeploymentContext currentDeploymentContext;\n+    @Setter\n+    private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n \n-    private final Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n+    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n         /*\n          * This message is received when either of these things happen\n          * 1. Last job completed (successful/failed)\n          * 2. A new job was queued\n          * 3. A job was cancelled\n          * This message receives the list of Queued and InProgress jobs at the time of this message\n          */\n-        logger.info(\"Received mqtt notify message with payload {}\", awsIotMessage.getStringPayload());\n-\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            //TODO: Check that if there is a current job runnign by the device then thats\n-            // coming in the inProgress list. If its not there then it will be an indication that\n-            // it was cancelled.\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n+        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n+        if (!jobs.isEmpty()) {", "originalCommit": "47ac30de9a29cce127e767a19655f54a99cd18d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "584fe9df20c2869a23ab8582cd03f3849b71e1cf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/584fe9df20c2869a23ab8582cd03f3849b71e1cf", "message": "Refactored as per the review comments", "committedDate": "2020-03-07T02:45:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODA5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389988095", "bodyText": "Does this need to be public? Could you at least make it package-private?", "author": "MikeDombo", "createdAt": "2020-03-09T22:05:50Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -199,28 +234,61 @@ public void startup() {\n     @Override\n     public void shutdown() {\n         receivedShutdown.set(true);\n-        iotJobsHelper.closeConnection();\n+        if (iotJobsHelper != null) {\n+            iotJobsHelper.closeConnection();\n+        }\n     }\n \n-    private void initialize(String thingName) throws AWSIotException {\n+    private void initializeIotJobsHelper(String thingName) {\n         //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        Kernel kernel = context.get(Kernel.class);\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(\"privateKeyPath\"));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(\"certificateFilePath\"));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(\"rootCaPath\"));\n-        String clientEndpoint = getStringParameterFromConfig(\"mqttClientEndpoint\");\n-\n-        mqttHelper = new MqttHelper(clientEndpoint, UUID.randomUUID().toString(), certificateFilePath, privateKeyPath);\n-        iotJobsHelper = new IotJobsHelper(thingName, clientEndpoint, certificateFilePath, privateKeyPath, rootCAPath,\n-                UUID.randomUUID().toString());\n+        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n+        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n+        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n+        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+\n+        this.iotJobsHelper = iotJobsHelperFactory\n+                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n+                        callbacks);\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n+    protected String getStringParameterFromConfig(String parameterName) {\n         String paramValue = \"\";\n         Topic childTopic = config.findLeafChild(parameterName);\n         if (childTopic != null) {\n             paramValue = childTopic.getOnce().toString();\n         }\n         return paramValue;\n     }\n+\n+    public static class IotJobsHelperFactory {", "originalCommit": "ba0fbca428d02933479fb8551044c7b852dadead", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTg0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389999843", "bodyText": "For now, we do not need this public.", "author": "abanthiy", "createdAt": "2020-03-09T22:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODkzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389988933", "bodyText": "You don't necessarily need to do this, you can use Mockito.eq(DEVICE_PARAM_THING_NAME) and such, instead of using this answer with branches.", "author": "MikeDombo", "createdAt": "2020-03-09T22:08:13Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.internal.verification.Times;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentServiceTest {\n+\n+    private static final String MOCK_DEVICE_PARAMETER = \"mockDeviceParameter\";\n+    private static final String EVERGREEN_SERVICE_FULL_NAME = \"DeploymentService\";\n+    private static final String TEST_JOB_ID_1 = \"TEST_JOB_1\";\n+    private static final String MOCK_THING_NAME = \"MockThingName\";\n+    private static final String MOCK_CLIENT_ENDPOINT = \"MockClientEndpoint\";\n+    private static final String MOCK_CERTIFICATE_PATH = \"/home/secrets/certificate.pem.cert\";\n+    private static final String MOCK_PRIVATE_KEY_PATH = \"/home/secrets/privateKey.pem.key\";\n+    private static final String MOCK_ROOTCA_PATH = \"/home/secrets/rootCA.pem\";\n+\n+    @Mock\n+    Topic stateTopic;\n+\n+    @Mock\n+    Topic requiresTopic;\n+\n+    @Mock\n+    Topics mockConfig;\n+\n+    @Mock\n+    Context mockContext;\n+\n+    @Mock\n+    Topic mockTopic;\n+\n+    @Mock\n+    IotJobsHelper mockIotJobsHelper;\n+\n+    @Mock\n+    DeploymentService.IotJobsHelperFactory mockIotJobsHelperFactory;\n+\n+    @Mock\n+    Kernel mockKernel;\n+\n+    @Mock\n+    ExecutorService mockExecutorService;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<JobExecutionsChangedEvent>> jobEventConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<DescribeJobExecutionResponse>> describeJobConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<RejectedError>> rejectedErrorConsumerCaptor;\n+\n+    DeploymentService deploymentService;\n+\n+    @Nested\n+    class DeploymentServiceInitializedWithMocks {\n+\n+        @BeforeEach\n+        public void setup() {\n+            //Evergreen service specific mocks\n+            when(mockConfig.createLeafChild(eq(\"_State\"))).thenReturn(stateTopic);\n+            when(stateTopic.getOnce()).thenReturn(State.INSTALLED);\n+            when(mockConfig.createLeafChild(eq(\"requires\"))).thenReturn(requiresTopic);\n+            when(mockConfig.getFullName()).thenReturn(EVERGREEN_SERVICE_FULL_NAME);\n+            when(requiresTopic.dflt(Mockito.any())).thenReturn(requiresTopic);\n+\n+            when(mockConfig.findLeafChild(Mockito.any())).thenAnswer(invocationOnMock -> {", "originalCommit": "ba0fbca428d02933479fb8551044c7b852dadead", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDY5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r390000690", "bodyText": "I think I will have to create a separate mockTopic in that case for each of the parameter name.", "author": "abanthiy", "createdAt": "2020-03-09T22:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MTAyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389991024", "bodyText": "This method name is a bit inconsistent with the existing code base. The existing code base uses _ instead of camelCase. This method should be:\nGIVEN_jobsClient_and_mqttConnection_WHEN_mqtt_connected_THEN_request_next_pending_jobDoc()\nI don't have a preference, just want to be consistent.", "author": "fengwang666", "createdAt": "2020-03-09T22:13:22Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/IotJobsHelperTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n+import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionSubscriptionRequest;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class IotJobsHelperTest {\n+\n+    private static final String THING_NAME = \"TEST_THING\";\n+    private static final String TEST_JOB_ID = \"TestJobId\";\n+\n+    @Mock\n+    private IotJobsClient mockIotJobsClient;\n+\n+    @Mock\n+    private MqttClientConnection mockMqttClientConnection;\n+\n+    @Mock\n+    Consumer<JobExecutionsChangedEvent> eventConsumer;\n+\n+    @Mock\n+    Consumer<DescribeJobExecutionResponse> describeJobConsumer;\n+\n+    @Mock\n+    Consumer<RejectedError> rejectedErrorConsumer;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<RejectedError>> rejectedErrorCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<UpdateJobExecutionResponse>> updateJobExecutionResponseCaptor;\n+\n+\n+    private IotJobsHelper iotJobsHelper;\n+\n+    @BeforeEach\n+    public void setup() {\n+        iotJobsHelper = new IotJobsHelper(THING_NAME, mockMqttClientConnection, mockIotJobsClient);\n+     }\n+\n+     @Test\n+     public void GIVEN_JobsClientAndMqttConnection_WHEN_MqttConnected_THEN_SubscribeToEventNotifications()\n+             throws ExecutionException, InterruptedException {\n+         CompletableFuture<Integer> integerCompletableFuture = mock(CompletableFuture.class);\n+            when(integerCompletableFuture.get()).thenReturn(1);\n+         when(mockIotJobsClient.SubscribeToJobExecutionsChangedEvents(any(JobExecutionsChangedSubscriptionRequest.class)\n+                 , eq(QualityOfService.AT_LEAST_ONCE), eq(eventConsumer))).thenReturn(integerCompletableFuture);\n+        iotJobsHelper.subscribeToEventNotifications(eventConsumer);\n+         ArgumentCaptor<JobExecutionsChangedSubscriptionRequest> requestArgumentCaptor =\n+                 ArgumentCaptor.forClass(JobExecutionsChangedSubscriptionRequest.class);\n+        verify(mockIotJobsClient).SubscribeToJobExecutionsChangedEvents(requestArgumentCaptor.capture(), eq(\n+                QualityOfService.AT_LEAST_ONCE), eq(eventConsumer));\n+         JobExecutionsChangedSubscriptionRequest actualRequest = requestArgumentCaptor.getValue();\n+         assertEquals(THING_NAME, actualRequest.thingName);\n+     }\n+\n+    @Test\n+    public void GIVEN_JobsClientAndMqttConnection_WHEN_MqttConnected_THEN_SubscribeToGetNextJobDescription()\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<Integer> integerCompletableFuture = mock(CompletableFuture.class);\n+        when(integerCompletableFuture.get()).thenReturn(1);\n+        when(mockIotJobsClient.SubscribeToDescribeJobExecutionAccepted(\n+                any(DescribeJobExecutionSubscriptionRequest.class),\n+                eq(QualityOfService.AT_LEAST_ONCE), eq(describeJobConsumer))).thenReturn(integerCompletableFuture);\n+        when(mockIotJobsClient.SubscribeToDescribeJobExecutionRejected(\n+                any(DescribeJobExecutionSubscriptionRequest.class),\n+                eq(QualityOfService.AT_LEAST_ONCE), eq(rejectedErrorConsumer))).thenReturn(integerCompletableFuture);\n+\n+        iotJobsHelper.subscribeToGetNextJobDecription(describeJobConsumer, rejectedErrorConsumer);\n+        ArgumentCaptor<DescribeJobExecutionSubscriptionRequest> requestArgumentCaptor =\n+                ArgumentCaptor.forClass(DescribeJobExecutionSubscriptionRequest.class);\n+        verify(mockIotJobsClient).SubscribeToDescribeJobExecutionAccepted(requestArgumentCaptor.capture(), eq(\n+                QualityOfService.AT_LEAST_ONCE), eq(describeJobConsumer));\n+        DescribeJobExecutionSubscriptionRequest actualRequest = requestArgumentCaptor.getValue();\n+        assertEquals(THING_NAME, actualRequest.thingName);\n+        assertEquals(\"$next\", actualRequest.jobId);\n+        verify(mockIotJobsClient).SubscribeToDescribeJobExecutionRejected(requestArgumentCaptor.capture(), eq(\n+                QualityOfService.AT_LEAST_ONCE), eq(rejectedErrorConsumer));\n+        actualRequest = requestArgumentCaptor.getValue();\n+        assertEquals(THING_NAME, actualRequest.thingName);\n+        assertEquals(\"$next\", actualRequest.jobId);\n+    }\n+\n+    @Test\n+    public void GIVEN_JobsClientAndMqttConnection_WHEN_MqttConnected_THEN_RequestNextPendingJobDoc() {", "originalCommit": "ba0fbca428d02933479fb8551044c7b852dadead", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NzE4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r389997189", "bodyText": "You don't need mock this. Use\nCompletableFuture.completedFuture(1)", "author": "fengwang666", "createdAt": "2020-03-09T22:31:03Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/IotJobsHelperTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n+import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionSubscriptionRequest;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class IotJobsHelperTest {\n+\n+    private static final String THING_NAME = \"TEST_THING\";\n+    private static final String TEST_JOB_ID = \"TestJobId\";\n+\n+    @Mock\n+    private IotJobsClient mockIotJobsClient;\n+\n+    @Mock\n+    private MqttClientConnection mockMqttClientConnection;\n+\n+    @Mock\n+    Consumer<JobExecutionsChangedEvent> eventConsumer;\n+\n+    @Mock\n+    Consumer<DescribeJobExecutionResponse> describeJobConsumer;\n+\n+    @Mock\n+    Consumer<RejectedError> rejectedErrorConsumer;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<RejectedError>> rejectedErrorCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<UpdateJobExecutionResponse>> updateJobExecutionResponseCaptor;\n+\n+\n+    private IotJobsHelper iotJobsHelper;\n+\n+    @BeforeEach\n+    public void setup() {\n+        iotJobsHelper = new IotJobsHelper(THING_NAME, mockMqttClientConnection, mockIotJobsClient);\n+     }\n+\n+     @Test\n+     public void GIVEN_JobsClientAndMqttConnection_WHEN_MqttConnected_THEN_SubscribeToEventNotifications()\n+             throws ExecutionException, InterruptedException {\n+         CompletableFuture<Integer> integerCompletableFuture = mock(CompletableFuture.class);\n+            when(integerCompletableFuture.get()).thenReturn(1);", "originalCommit": "ba0fbca428d02933479fb8551044c7b852dadead", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDA3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r390000078", "bodyText": "throws Exception", "author": "fengwang666", "createdAt": "2020-03-09T22:38:50Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.internal.verification.Times;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentServiceTest {\n+\n+    private static final String MOCK_DEVICE_PARAMETER = \"mockDeviceParameter\";\n+    private static final String EVERGREEN_SERVICE_FULL_NAME = \"DeploymentService\";\n+    private static final String TEST_JOB_ID_1 = \"TEST_JOB_1\";\n+    private static final String MOCK_THING_NAME = \"MockThingName\";\n+    private static final String MOCK_CLIENT_ENDPOINT = \"MockClientEndpoint\";\n+    private static final String MOCK_CERTIFICATE_PATH = \"/home/secrets/certificate.pem.cert\";\n+    private static final String MOCK_PRIVATE_KEY_PATH = \"/home/secrets/privateKey.pem.key\";\n+    private static final String MOCK_ROOTCA_PATH = \"/home/secrets/rootCA.pem\";\n+\n+    @Mock\n+    Topic stateTopic;\n+\n+    @Mock\n+    Topic requiresTopic;\n+\n+    @Mock\n+    Topics mockConfig;\n+\n+    @Mock\n+    Context mockContext;\n+\n+    @Mock\n+    Topic mockTopic;\n+\n+    @Mock\n+    IotJobsHelper mockIotJobsHelper;\n+\n+    @Mock\n+    DeploymentService.IotJobsHelperFactory mockIotJobsHelperFactory;\n+\n+    @Mock\n+    Kernel mockKernel;\n+\n+    @Mock\n+    ExecutorService mockExecutorService;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<JobExecutionsChangedEvent>> jobEventConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<DescribeJobExecutionResponse>> describeJobConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<RejectedError>> rejectedErrorConsumerCaptor;\n+\n+    DeploymentService deploymentService;\n+\n+    @Nested\n+    class DeploymentServiceInitializedWithMocks {\n+\n+        @BeforeEach\n+        public void setup() {\n+            //Evergreen service specific mocks\n+            when(mockConfig.createLeafChild(eq(\"_State\"))).thenReturn(stateTopic);\n+            when(stateTopic.getOnce()).thenReturn(State.INSTALLED);\n+            when(mockConfig.createLeafChild(eq(\"requires\"))).thenReturn(requiresTopic);\n+            when(mockConfig.getFullName()).thenReturn(EVERGREEN_SERVICE_FULL_NAME);\n+            when(requiresTopic.dflt(Mockito.any())).thenReturn(requiresTopic);\n+\n+            when(mockConfig.findLeafChild(Mockito.any())).thenAnswer(invocationOnMock -> {\n+                String parameterName = invocationOnMock.getArguments()[0].toString();\n+                if (parameterName.equals(DeploymentService.DEVICE_PARAM_THING_NAME)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_THING_NAME);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_MQTT_CLIENT_ENDPOINT)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_CLIENT_ENDPOINT);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_PRIVATE_KEY_PATH)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_PRIVATE_KEY_PATH);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_CERTIFICATE_FILE_PATH)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_CERTIFICATE_PATH);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_ROOT_CA_PATH)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_ROOTCA_PATH);\n+                    return mockTopic;\n+                }\n+\n+                return mockTopic;\n+            });\n+            when(mockConfig.getFullName()).thenReturn(\"DeploymentService\");\n+            when(mockConfig.getContext()).thenReturn(mockContext);\n+\n+            //Deployment service specific mocks\n+            when(mockKernel.deTilde(anyString())).thenAnswer(invocationOnMock -> {\n+                return invocationOnMock.getArguments()[0].toString();\n+            });\n+            when(mockIotJobsHelperFactory.getIotJobsHelper(anyString(), anyString(), anyString(), anyString(),\n+                    anyString(), any(MqttClientConnectionEvents.class)))\n+                    .thenReturn(mockIotJobsHelper);\n+\n+            //Creating the class to be tested\n+            deploymentService =\n+                    new DeploymentService(mockConfig, mockIotJobsHelperFactory, mockExecutorService, mockKernel);\n+        }\n+\n+        @Test\n+        public void GIVEN_DescribeJobNotification_WHEN_NewJob_THEN_ProcessNotificationSuccessfully()", "originalCommit": "ba0fbca428d02933479fb8551044c7b852dadead", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMjc1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r390002757", "bodyText": "The test method doesn't seem matching the content. Shouldn't it be GIVEN_deployment_job_WHEN_deployment_process_fails_THEN_report_failed_job_status? Same for the test above.", "author": "fengwang666", "createdAt": "2020-03-09T22:46:41Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.internal.verification.Times;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n+import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentServiceTest {\n+\n+    private static final String MOCK_DEVICE_PARAMETER = \"mockDeviceParameter\";\n+    private static final String EVERGREEN_SERVICE_FULL_NAME = \"DeploymentService\";\n+    private static final String TEST_JOB_ID_1 = \"TEST_JOB_1\";\n+    private static final String MOCK_THING_NAME = \"MockThingName\";\n+    private static final String MOCK_CLIENT_ENDPOINT = \"MockClientEndpoint\";\n+    private static final String MOCK_CERTIFICATE_PATH = \"/home/secrets/certificate.pem.cert\";\n+    private static final String MOCK_PRIVATE_KEY_PATH = \"/home/secrets/privateKey.pem.key\";\n+    private static final String MOCK_ROOTCA_PATH = \"/home/secrets/rootCA.pem\";\n+\n+    @Mock\n+    Topic stateTopic;\n+\n+    @Mock\n+    Topic requiresTopic;\n+\n+    @Mock\n+    Topics mockConfig;\n+\n+    @Mock\n+    Context mockContext;\n+\n+    @Mock\n+    Topic mockTopic;\n+\n+    @Mock\n+    IotJobsHelper mockIotJobsHelper;\n+\n+    @Mock\n+    DeploymentService.IotJobsHelperFactory mockIotJobsHelperFactory;\n+\n+    @Mock\n+    Kernel mockKernel;\n+\n+    @Mock\n+    ExecutorService mockExecutorService;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<JobExecutionsChangedEvent>> jobEventConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<DescribeJobExecutionResponse>> describeJobConsumerCaptor;\n+\n+    @Captor\n+    ArgumentCaptor<Consumer<RejectedError>> rejectedErrorConsumerCaptor;\n+\n+    DeploymentService deploymentService;\n+\n+    @Nested\n+    class DeploymentServiceInitializedWithMocks {\n+\n+        @BeforeEach\n+        public void setup() {\n+            //Evergreen service specific mocks\n+            when(mockConfig.createLeafChild(eq(\"_State\"))).thenReturn(stateTopic);\n+            when(stateTopic.getOnce()).thenReturn(State.INSTALLED);\n+            when(mockConfig.createLeafChild(eq(\"requires\"))).thenReturn(requiresTopic);\n+            when(mockConfig.getFullName()).thenReturn(EVERGREEN_SERVICE_FULL_NAME);\n+            when(requiresTopic.dflt(Mockito.any())).thenReturn(requiresTopic);\n+\n+            when(mockConfig.findLeafChild(Mockito.any())).thenAnswer(invocationOnMock -> {\n+                String parameterName = invocationOnMock.getArguments()[0].toString();\n+                if (parameterName.equals(DeploymentService.DEVICE_PARAM_THING_NAME)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_THING_NAME);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_MQTT_CLIENT_ENDPOINT)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_CLIENT_ENDPOINT);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_PRIVATE_KEY_PATH)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_PRIVATE_KEY_PATH);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_CERTIFICATE_FILE_PATH)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_CERTIFICATE_PATH);\n+                    return mockTopic;\n+                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_ROOT_CA_PATH)) {\n+                    when(mockTopic.getOnce()).thenReturn(MOCK_ROOTCA_PATH);\n+                    return mockTopic;\n+                }\n+\n+                return mockTopic;\n+            });\n+            when(mockConfig.getFullName()).thenReturn(\"DeploymentService\");\n+            when(mockConfig.getContext()).thenReturn(mockContext);\n+\n+            //Deployment service specific mocks\n+            when(mockKernel.deTilde(anyString())).thenAnswer(invocationOnMock -> {\n+                return invocationOnMock.getArguments()[0].toString();\n+            });\n+            when(mockIotJobsHelperFactory.getIotJobsHelper(anyString(), anyString(), anyString(), anyString(),\n+                    anyString(), any(MqttClientConnectionEvents.class)))\n+                    .thenReturn(mockIotJobsHelper);\n+\n+            //Creating the class to be tested\n+            deploymentService =\n+                    new DeploymentService(mockConfig, mockIotJobsHelperFactory, mockExecutorService, mockKernel);\n+        }\n+\n+        @Test\n+        public void GIVEN_DescribeJobNotification_WHEN_NewJob_THEN_ProcessNotificationSuccessfully()\n+                throws ExecutionException, InterruptedException {\n+            CompletableFuture<Boolean> mockBooleanFuture = mock(CompletableFuture.class);\n+            when(mockBooleanFuture.get()).thenReturn(Boolean.TRUE);\n+            when(mockExecutorService.submit(any(DeploymentProcess.class))).thenReturn(mockBooleanFuture);\n+            deploymentService.setPollingFrequency(Duration.ofSeconds(1).toMillis());\n+            startDeploymentServiceInAnotherThread();\n+\n+            verify(mockIotJobsHelper).subscribeToGetNextJobDecription(describeJobConsumerCaptor.capture(), any());\n+            Consumer<DescribeJobExecutionResponse> consumer = describeJobConsumerCaptor.getValue();\n+            DescribeJobExecutionResponse response = new DescribeJobExecutionResponse();\n+            response.execution = getTestJobExecutionData();\n+            consumer.accept(response);\n+            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n+            verify(mockExecutorService).submit(any(DeploymentProcess.class));\n+            //Wait for the deploymentFrequency after which deployment service will check for the status of future\n+            Thread.sleep(Duration.ofSeconds(1).toMillis());\n+            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.SUCCEEDED), any());\n+        }\n+\n+        @Test\n+        public void GIVEN_DescribeJobNotification_WHEN_NewJob_THEN_ProcessNotificationUnSuccessfully()", "originalCommit": "ba0fbca428d02933479fb8551044c7b852dadead", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMDA3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/98#discussion_r390030076", "bodyText": "Yes that is a better description", "author": "abanthiy", "createdAt": "2020-03-10T00:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMjc1Nw=="}], "type": "inlineReview"}, {"oid": "689e0fdb097af73caebc661c9bb8d70be2fb0f45", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/689e0fdb097af73caebc661c9bb8d70be2fb0f45", "message": "Renaming test as per under_score naming convention. Addressing review comments", "committedDate": "2020-03-10T01:22:46Z", "type": "forcePushed"}, {"oid": "6cbe862f34d983fa31279d16008c7c5030fe5b39", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6cbe862f34d983fa31279d16008c7c5030fe5b39", "message": "Moving to one Iot device SDK. Adding unit tests for DeploymentService", "committedDate": "2020-03-10T19:54:23Z", "type": "commit"}, {"oid": "222932a04f192d478919e39539e4719a0a058c43", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/222932a04f192d478919e39539e4719a0a058c43", "message": "Addressing review comments", "committedDate": "2020-03-10T19:54:23Z", "type": "commit"}, {"oid": "0810952c1c61bb8c436ddf209c5598d004321e8c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0810952c1c61bb8c436ddf209c5598d004321e8c", "message": "Refactored as per the review comments", "committedDate": "2020-03-10T19:54:23Z", "type": "commit"}, {"oid": "2dae929dc79fe3507c0527e5aaf41784df0eca4d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2dae929dc79fe3507c0527e5aaf41784df0eca4d", "message": "Fixing some bugs and removing unnecessary code", "committedDate": "2020-03-10T19:54:23Z", "type": "commit"}, {"oid": "866354311212d786c64ae79540afabfed5fd670b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/866354311212d786c64ae79540afabfed5fd670b", "message": "Renaming test as per under_score naming convention. Addressing review comments", "committedDate": "2020-03-10T19:54:23Z", "type": "commit"}, {"oid": "f7966c0c2f32825312dda44f4762671d6ab3f220", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f7966c0c2f32825312dda44f4762671d6ab3f220", "message": "Fixing a bug", "committedDate": "2020-03-10T19:54:23Z", "type": "commit"}, {"oid": "ea448e5b904144249dacd617245f53d929f32e37", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea448e5b904144249dacd617245f53d929f32e37", "message": "Making unit tests more robus by adding CountDownLatch to deployment service tests", "committedDate": "2020-03-10T19:54:23Z", "type": "commit"}, {"oid": "ea448e5b904144249dacd617245f53d929f32e37", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea448e5b904144249dacd617245f53d929f32e37", "message": "Making unit tests more robus by adding CountDownLatch to deployment service tests", "committedDate": "2020-03-10T19:54:23Z", "type": "forcePushed"}, {"oid": "8d2d524c461980e0281d958959aaae4ad4383ea5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8d2d524c461980e0281d958959aaae4ad4383ea5", "message": "Removing CountDownLatch put in for testing", "committedDate": "2020-03-10T23:38:34Z", "type": "commit"}]}