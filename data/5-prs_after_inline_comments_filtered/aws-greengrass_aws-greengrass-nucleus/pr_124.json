{"pr_number": 124, "pr_title": "Remove dangling services on config merge", "pr_createdAt": "2020-03-19T07:54:27Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124", "timeline": [{"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0a424988ca9579213fae9e867a2c018bc6bbc54f", "message": "remove dangling services on config merge", "committedDate": "2020-03-19T07:49:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDIyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395180227", "bodyText": "nit\nmerge_removes_service instead of  merge_remove_service", "author": "MikeDombo", "createdAt": "2020-03-19T17:01:06Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4MjgwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282803", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDM0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395180349", "bodyText": "remove -log stdout", "author": "MikeDombo", "createdAt": "2020-03-19T17:01:20Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4Mjc3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282778", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDgzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395180833", "bodyText": "Use the public static service key name instead of \"services\"", "author": "MikeDombo", "createdAt": "2020-03-19T17:02:07Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4Mjc2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282763", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MTg1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395181854", "bodyText": "here \"lifecycle\" I believe we have a constant for.", "author": "MikeDombo", "createdAt": "2020-03-19T17:03:38Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(\"lifecycle\")).put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4Mjc1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282752", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MTg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395182530", "bodyText": "always have a timeout on our blocking calls.", "author": "MikeDombo", "createdAt": "2020-03-19T17:04:39Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(\"lifecycle\")).put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get();", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4MjczOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282739", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjkwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395182908", "bodyText": "todo seems todone, right?", "author": "MikeDombo", "createdAt": "2020-03-19T17:05:16Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(\"lifecycle\")).put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get();\n+        //sleeperA should be closed\n+        assertTrue(isSleeperAClosed.get());\n+        // main and sleeperB should be running\n+        assertTrue(State.RUNNING.equals(main.getState()));\n+        assertTrue(State.RUNNING.equals(sleeperB.getState()));\n+        // ensuring config value for sleeperA is removed\n+        assertFalse(kernel.findTopics(\"services\").children.contains(\"sleeperA\"));\n+        // ensure kernel no longer holds a reference of sleeperA\n+        assertThrows(ServiceLoadException.class, () ->  EvergreenService.locate(kernel.context, \"sleeperA\"));\n+    }\n+        // TODO: Work on removing dependencies and stopping and then removing unused dependencies", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDYwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395810608", "bodyText": "remove the todo?", "author": "MikeDombo", "createdAt": "2020-03-20T18:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDE4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395184183", "bodyText": "I don't think that serviceName is accurate in this context. I believe that tag is more appropriate. Also the tag is an Object, not necessarily a string.", "author": "MikeDombo", "createdAt": "2020-03-19T17:07:07Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -81,6 +81,10 @@ public void run() {\n         publishThread.start();\n     }\n \n+    public boolean remove(String serviceName) {", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4MjcyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282726", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDcxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395184712", "bodyText": "Why is this in a separate thread?", "author": "MikeDombo", "createdAt": "2020-03-19T17:07:51Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -658,19 +658,21 @@ protected void shutdown() {\n \n     @Override\n     public void close() {\n-        Periodicity t = periodicityInformation;\n-        if (t != null) {\n-            t.shutdown();\n-        }\n-        //TODO: make close block till the service exits or make close non blocking\n-        // currently close blocks till dependers exit which neither the above\n-        try {\n-            waitForDependersToExit();\n-        } catch (InterruptedException e) {\n-            logger.error(\"Interrupted waiting for dependers to exit\");\n-        }\n-        requestStop();\n-        isClosed.set(true);\n+        context.get(Executor.class).execute(() -> {", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NDAyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395284022", "bodyText": "close() blocks till all its dependers are shutdown. So close() has to be called in the reverse dependency order. Making close run in a different thread allows the caller to call close on a bunch of services in any order. Also this promotes parallelization while closing out services", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NTEzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395285136", "bodyText": "If that's what you want, I would rather let the caller decide to make it run in a separate thread.", "author": "MikeDombo", "createdAt": "2020-03-19T19:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyNDAxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395324010", "bodyText": "Another reason as shirley pointed out is that close blocks till dependersExit but returns before the service actually closes. From the callers perspective its blocking but does not ensure that the service is closed when the method returns. Making the close asynchronous feels more intuitive IMO.", "author": "fahadmohammed01", "createdAt": "2020-03-19T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1NzU3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395357577", "bodyText": "One thing we can do is wait the lifecycle thread to exit.\nFuture<void> close() {\n  Future<void> fut = new Future; \n  executor.submit( () -> {\n    ...// wait dependers exit\n    requestStop();\n    isClose.set(True);\n    lifecycleThread.join();\n    fut.complete();\n  }\n}\n\nThen caller can do something like:\nservices.forEach( s-> {\n  fut = s.close();\n  fut.thenRun(latch.get(s.getName()).countdown());\n);\n// check latches", "author": "ShirleyZheng92", "createdAt": "2020-03-19T22:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4MjUyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395382528", "bodyText": "updated to\nFuture close() {\nFuture fut = new Future;\nexecutor.submit( () -> {\n...// wait dependers exit\nrequestStop();\nisClose.set(True);\nlifecycleThread.join();\nfut.complete();\n}\n}", "author": "fahadmohammed01", "createdAt": "2020-03-19T23:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395187351", "bodyText": "Why are we limiting this to GenericExternalService? We need a way to remove any service don't we?", "author": "MikeDombo", "createdAt": "2020-03-19T17:11:53Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4Mzg0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395283847", "bodyText": "Config will not have entries for services defined using the @ImplementsService ex: IPCService or UpdateSystemSafelyService. When we start supporting services that run inside the JVM but defined via the config we need to revisit this. I added a TODO for the same", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMTU5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395811596", "bodyText": "Why limit ourselves with the filter? Just remove this filter and then check for the name.", "author": "MikeDombo", "createdAt": "2020-03-20T18:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5MTMzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395891336", "bodyText": "Agree. Filtering with name is even easier :)", "author": "leaf94", "createdAt": "2020-03-20T21:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNDQwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395914404", "bodyText": "What am I missing? I need to only filter out GenericExternalService services for now till we handle services running in JVM properly", "author": "fahadmohammed01", "createdAt": "2020-03-20T22:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyODYxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395928611", "bodyText": "We do handle them properly. They do exist in the config. They are EvergreenSevices so they know how to stop and close.", "author": "MikeDombo", "createdAt": "2020-03-20T23:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzNzE5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395937190", "bodyText": "Synced offline. Will update based on how the config is handed down by the DA", "author": "fahadmohammed01", "createdAt": "2020-03-21T00:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzU0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395187543", "bodyText": "Replace with method reference EvergreenService::getName", "author": "MikeDombo", "createdAt": "2020-03-19T17:12:10Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName())", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4MjkwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282900", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4Nzg5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395187896", "bodyText": "Why use the keyset? Just use containsKey", "author": "MikeDombo", "createdAt": "2020-03-19T17:12:42Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName())\n+                .filter(serviceName -> !serviceConfig.keySet().contains(serviceName))", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4Mjk1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395282958", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-19T19:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4Nzg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI3NDYxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395274614", "bodyText": "nit: starting new services and shutting old ones can happen in parallel, right?", "author": "hui-yang", "createdAt": "2020-03-19T19:38:58Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {", "originalCommit": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NjI1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395286251", "bodyText": "before deployment\nservice A depends on service B\nafter deployment\nservice A does not depend on service B and service B has to be removed. Its safe to wait for service A to restart and pick up the changes before shutting down service B", "author": "fahadmohammed01", "createdAt": "2020-03-19T20:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI3NDYxNA=="}], "type": "inlineReview"}, {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794", "message": "addressed minor comments from pr", "committedDate": "2020-03-19T19:53:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0OTIyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395349225", "bodyText": "it shouldn't directly return here. For example, user may want to update a config.yaml from\nrun: foo\n\nto\nstartup: foo\n\nIn the above case, 'run' node gets removed, but the service still exists.\nI'd prefer something like below\n// in EvergreenService.java\npublic final void close() {\n  // call shutdown;\n  // remove all listeners on the service node.\n  // other close logic\n}", "author": "ShirleyZheng92", "createdAt": "2020-03-19T22:14:02Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -41,6 +42,10 @@ public GenericExternalService(Topics c) {\n \n         // when configuration reloads and child Topic changes, restart/re-install the service.\n         c.subscribe((what, child) -> {\n+            // when the service is removed via a deployment this topic itself will be removed\n+            if (WhatHappened.removed.equals(what)) {\n+                return;\n+            }", "originalCommit": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4MjYzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395382633", "bodyText": "added a null check as per offline discussion", "author": "fahadmohammed01", "createdAt": "2020-03-19T23:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0OTIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1NTk5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395355994", "bodyText": "I think this doesn't meet the requirement of deploying multiple groups on to one device. The full solution might require calculate all OrderedDependency() and stop services that's not a dependency of 'main'", "author": "ShirleyZheng92", "createdAt": "2020-03-19T22:31:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,50 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    //TODO: handle removing services that are running within in the JVM but defined via config\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(EvergreenService::getName)\n+                .filter(serviceName -> !serviceConfig.containsKey(serviceName))", "originalCommit": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM3MjU5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395372595", "bodyText": "The assumption is that DA will call mergeInConfig with all the services deployed via multiple groups.", "author": "fahadmohammed01", "createdAt": "2020-03-19T23:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1NTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM3NTkzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395375936", "bodyText": "Should we close or just requestStop? I'm thinking about could a new deployment activates a closed service?", "author": "leaf94", "createdAt": "2020-03-19T23:32:51Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,50 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();", "originalCommit": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4MzkxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395383917", "bodyText": "I think we should close. requestStop can keep the lifecycle thread alive and if a dependency of the removed service gets restarted, the removed service will get restarted.\nA new deployment can add the same service and kernel will create another instance of EvergreenService, it would just not be the same instance.", "author": "fahadmohammed01", "createdAt": "2020-03-20T00:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM3NTkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4Mjg2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395882866", "bodyText": "Make sense!", "author": "leaf94", "createdAt": "2020-03-20T20:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM3NTkzNg=="}], "type": "inlineReview"}, {"oid": "6fc066f3d5f09df970de77824c4ff866bb854544", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6fc066f3d5f09df970de77824c4ff866bb854544", "message": "addressed minor comments in pr", "committedDate": "2020-03-19T23:55:07Z", "type": "commit"}, {"oid": "d631d2d396d5116c16c766115b1d11088b01a16d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d631d2d396d5116c16c766115b1d11088b01a16d", "message": "Merge branch 'master' into remove-service-from-config", "committedDate": "2020-03-20T00:13:17Z", "type": "commit"}, {"oid": "79593188b2546dcf0d0109eb1f85d99d53d51e3a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/79593188b2546dcf0d0109eb1f85d99d53d51e3a", "message": "removed line for check style", "committedDate": "2020-03-20T00:23:34Z", "type": "commit"}, {"oid": "e649d9b3ae22b052264b967e3eb30238f101fef5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e649d9b3ae22b052264b967e3eb30238f101fef5", "message": "minor bug fix and updated test case", "committedDate": "2020-03-20T05:40:14Z", "type": "commit"}, {"oid": "a9f6ea81cd4eecdab6bc0d56d3cc9a4eabc1c957", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a9f6ea81cd4eecdab6bc0d56d3cc9a4eabc1c957", "message": "fixed race condition in updating dependencies when a new service is added and exiting service is removed", "committedDate": "2020-03-20T06:38:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDU0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395810544", "bodyText": "use assertEquals instead.", "author": "MikeDombo", "createdAt": "2020-03-20T18:10:52Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -217,5 +227,65 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_removes_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(EvergreenService.SERVICES_NAMESPACE_TOPIC);\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC))\n+                .put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get(60, TimeUnit.SECONDS);\n+        //sleeperA should be closed\n+        assertTrue(isSleeperAClosed.get());\n+        // main and sleeperB should be running\n+        assertTrue(State.RUNNING.equals(main.getState()));", "originalCommit": "a9f6ea81cd4eecdab6bc0d56d3cc9a4eabc1c957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0MDIwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395840204", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-03-20T19:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NDQ3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395844470", "bodyText": "\"Why limit ourselves with the filter? Just remove this filter and then check for the name.\"\nI have to keep this until we handle services run within the jvm properly", "author": "fahadmohammed01", "createdAt": "2020-03-20T19:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDU0NA=="}], "type": "inlineReview"}, {"oid": "672ab9fabe1352467297c62e68bcf8cb0c117c53", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/672ab9fabe1352467297c62e68bcf8cb0c117c53", "message": "addressed minor pr comments", "committedDate": "2020-03-20T19:09:55Z", "type": "commit"}, {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c12573a59a55ceb8ff790031b00c01a9b71b2de", "message": "increasing timeout for kernelTest", "committedDate": "2020-03-20T20:46:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4Mzk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395883996", "bodyText": "Do we need to check both isClosable and isClosed?", "author": "leaf94", "createdAt": "2020-03-20T20:51:10Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -592,20 +593,23 @@ public Topics findServiceTopic(String name) {\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(\"services\");\n-        Map<String, CountDownLatch> latches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> latches.put((String) key, new CountDownLatch(1)));\n+        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n+\n+        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n+        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+\n+        Map<String, CountDownLatch> servicesClosedLatches = new HashMap<>();\n+        removedServices.forEach(serviceName -> servicesClosedLatches.put(serviceName, new CountDownLatch(1)));\n \n         EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n             if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                latches.get(service.getName()).countDown();\n+                servicesRunningLatches.get(service.getName()).countDown();\n             }\n-            if (latches.values().stream().allMatch(c -> c.getCount() <= 0)) {\n-                totallyCompleteFuture.complete(null);\n+\n+            if (removedServices.contains(service.getName()) && newState.isClosable() && service.isClosed()) {", "originalCommit": "672ab9fabe1352467297c62e68bcf8cb0c117c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4ODg1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395888852", "bodyText": "What i needed was to wait till service completed the close. Since I changed the close to return a future (based on shirleys comments). I can rely on future getting completed. Updated like wise", "author": "fahadmohammed01", "createdAt": "2020-03-20T21:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4Mzk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTU1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395885556", "bodyText": "Could we try to break the removing services part down to another method? I think that will make it more readable and extensible!", "author": "leaf94", "createdAt": "2020-03-20T20:55:19Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -627,6 +631,54 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                        //For services that are already finished count down latch\n+                        if (eg.getState().isClosable()) {\n+                            servicesClosedLatches.get(eg.getName()).countDown();\n+                        }\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));", "originalCommit": "672ab9fabe1352467297c62e68bcf8cb0c117c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNjIzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395906230", "bodyText": "Tried, not sure it looks better. Keeping as it is for now", "author": "fahadmohammed01", "createdAt": "2020-03-20T21:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzE4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395887187", "bodyText": "Maybe add a java doc? :)", "author": "leaf94", "createdAt": "2020-03-20T20:59:23Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -81,6 +81,10 @@ public void run() {\n         publishThread.start();\n     }\n \n+    public boolean remove(Object tag) {", "originalCommit": "6c12573a59a55ceb8ff790031b00c01a9b71b2de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNTcyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395905727", "bodyText": "added", "author": "fahadmohammed01", "createdAt": "2020-03-20T21:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzE4Nw=="}], "type": "inlineReview"}, {"oid": "81edb3f9ef5f44d1d9f743418a907dbc2cdce049", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81edb3f9ef5f44d1d9f743418a907dbc2cdce049", "message": "using future returned by close rather than waiting using latches", "committedDate": "2020-03-20T21:03:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4ODg5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395888894", "bodyText": "Just a thought, should we also check the ordered dependencies list?", "author": "leaf94", "createdAt": "2020-03-20T21:03:59Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -217,5 +227,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_removes_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(EvergreenService.SERVICES_NAMESPACE_TOPIC);\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC))\n+                .put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get(60, TimeUnit.SECONDS);\n+        //sleeperA should be closed\n+        assertTrue(isSleeperAClosed.get());\n+        // main and sleeperB should be running\n+        assertEquals(State.RUNNING, main.getState());\n+        assertEquals(State.RUNNING, sleeperB.getState());\n+        // ensuring config value for sleeperA is removed\n+        assertFalse(kernel.findTopics(\"services\").children.contains(\"sleeperA\"));\n+        // ensure kernel no longer holds a reference of sleeperA\n+        assertThrows(ServiceLoadException.class, () ->  EvergreenService.locate(kernel.context, \"sleeperA\"));", "originalCommit": "6c12573a59a55ceb8ff790031b00c01a9b71b2de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNjI5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395906290", "bodyText": "added", "author": "fahadmohammed01", "createdAt": "2020-03-20T21:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4ODg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTkxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395909914", "bodyText": "I'm considering if this requires a separate thread because what the tread doing is just waiting. But I'm fine with this PR", "author": "ShirleyZheng92", "createdAt": "2020-03-20T22:04:59Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -627,6 +624,51 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {", "originalCommit": "81edb3f9ef5f44d1d9f743418a907dbc2cdce049", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzODQ5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395938491", "bodyText": "the waiting requires to be in a separate thread than publishThread i(n context) so it does not block other topic updates that need to happen", "author": "fahadmohammed01", "createdAt": "2020-03-21T00:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTkxNA=="}], "type": "inlineReview"}, {"oid": "5194a67567de6d28d05cc56e0a9ccc1840e299f0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5194a67567de6d28d05cc56e0a9ccc1840e299f0", "message": "fixed minor comments from PR", "committedDate": "2020-03-20T22:21:48Z", "type": "commit"}, {"oid": "e9dc48b4093e03f6ae7bc3d28d248ef078793643", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e9dc48b4093e03f6ae7bc3d28d248ef078793643", "message": "Merge branch 'master' into remove-service-from-config", "committedDate": "2020-03-20T22:59:22Z", "type": "commit"}]}