{"pr_number": 511, "pr_title": "Mqtt proxy IPC integration", "pr_createdAt": "2020-10-08T23:51:20Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084466", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 118 and 140. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "author": "MikeDombo", "createdAt": "2020-10-08T23:54:19Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);", "originalCommit": "60675cc71de913ea700b2df5e2b8eacece26b93a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084468", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 188. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "author": "MikeDombo", "createdAt": "2020-10-08T23:54:19Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {", "originalCommit": "60675cc71de913ea700b2df5e2b8eacece26b93a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084469", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 193. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "author": "MikeDombo", "createdAt": "2020-10-08T23:54:19Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).kv(\"topic\", topic).log(\"IoT core topic not subscribed\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = subscribeCallbacks.get(serviceName).get(topic);", "originalCommit": "60675cc71de913ea700b2df5e2b8eacece26b93a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084471", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 202. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "author": "MikeDombo", "createdAt": "2020-10-08T23:54:20Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).kv(\"topic\", topic).log(\"IoT core topic not subscribed\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = subscribeCallbacks.get(serviceName).get(topic);\n+            UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(cb).topic(topic).build();\n+\n+            try {\n+                mqttClient.unsubscribe(unsubscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error unsubscribing from IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.get(serviceName).remove(topic);", "originalCommit": "60675cc71de913ea700b2df5e2b8eacece26b93a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084473", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 203. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "author": "MikeDombo", "createdAt": "2020-10-08T23:54:20Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).kv(\"topic\", topic).log(\"IoT core topic not subscribed\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = subscribeCallbacks.get(serviceName).get(topic);\n+            UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(cb).topic(topic).build();\n+\n+            try {\n+                mqttClient.unsubscribe(unsubscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error unsubscribing from IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.get(serviceName).remove(topic);\n+            if (subscribeCallbacks.get(serviceName).isEmpty()) {", "originalCommit": "60675cc71de913ea700b2df5e2b8eacece26b93a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTczOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502551738", "bodyText": "Ditch the if statements, just call the builder method directly, regardless of value", "author": "jbutler", "createdAt": "2020-10-09T16:43:29Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }", "originalCommit": "47fd59b886ad99d06110cc3710d7ebc77a89752f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NDc2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502554763", "bodyText": "I don't think we can wait for the future to complete. If the network is doing it's going to limit throughput to 2 TPS.\nI'll likely add a new API that returns whether or not the message was successfully queued, and that can be used to construct an appropriate response (success if queued, else failure)", "author": "jbutler", "createdAt": "2020-10-09T16:49:11Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }", "originalCommit": "47fd59b886ad99d06110cc3710d7ebc77a89752f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzM1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502557359", "bodyText": "Are these response objects empty? If they are then we need to change that...", "author": "jbutler", "createdAt": "2020-10-09T16:54:21Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();", "originalCommit": "47fd59b886ad99d06110cc3710d7ebc77a89752f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyODc0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502628740", "bodyText": "yeah, currently these responses have no fields. But I don't think we can add anything to these manually because they are the generated models", "author": "popanmol", "createdAt": "2020-10-09T19:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NjU2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503486566", "bodyText": "I took another look at the model, and it looks like errors are modeled separately. What you have here looks good - though I think we could probably pull the error out of the exception instead of hardcoding a generic error. It's helpful for the customer to know it failed because the spool is full", "author": "jbutler", "createdAt": "2020-10-12T19:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MDAzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502560034", "bodyText": "I'm assuming this still needs some work. How do you plan to route this to the correct subscriber? Also, we can't wait on any futures here. It will block the mqtt client thread", "author": "jbutler", "createdAt": "2020-10-09T16:59:25Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final ConcurrentHashMap<String, Consumer<MqttMessage>> serviceSubscribeCallbacks;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            String serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeCallbacks = subscribeCallbacks.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            //TODO: remove callbacks\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            Consumer<MqttMessage> callback = serviceSubscribeCallbacks.computeIfAbsent(topic, t -> {\n+                Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(t);\n+\n+                if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                    subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+                } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                    subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+                }\n+\n+                SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+                try {\n+                    mqttClient.subscribe(subscribeRequest);\n+                } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                    return null;\n+                }\n+\n+                return cb;\n+            });\n+\n+            if (callback == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }", "originalCommit": "47fd59b886ad99d06110cc3710d7ebc77a89752f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNzE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502627163", "bodyText": "this.sendStreamEvent(iotCoreMessage) will automatically route it to the correct subscriber because this handler instance represents the specific subscribe request. And yeah, we should remove the future wait here", "author": "popanmol", "createdAt": "2020-10-09T19:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MDAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NTYxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503485616", "bodyText": "Need qos(request.getQos())", "author": "jbutler", "createdAt": "2020-10-12T19:16:18Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -72,23 +71,15 @@ protected void onStreamClosed() {\n \n         @Override\n         public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n-            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n-                    .topic(request.getTopicName()).retain(request.isRetain());\n-\n-            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n-            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n-            }\n-\n-            PublishRequest publishRequest = publishRequestBuilder.build();\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain()).build();", "originalCommit": "7d923c4172b968c260c4af08f54e18ae5c60f6b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDA4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503580087", "bodyText": "qos() takes in QualityOfService and request.getQos() return QOS, so added a method to convert QOS to QualityOfService", "author": "popanmol", "createdAt": "2020-10-12T23:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NTYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5MTMwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r504291304", "bodyText": "Oh my bad, that's why you had the if statement originally. Didn't see the type difference", "author": "jbutler", "createdAt": "2020-10-13T22:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NTYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NjU4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503496581", "bodyText": "What's the scope of this object? Per client or per request? I'm assuming the former, in which case, what happens if the client makes multiple calls to subscribe to multiple topics?", "author": "jbutler", "createdAt": "2020-10-12T19:43:06Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,211 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain()).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            if (future.isCompletedExceptionally()) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final ConcurrentHashMap<String, Consumer<MqttMessage>> serviceSubscribeCallbacks;\n+\n+        private String subscribedTopic;", "originalCommit": "7d923c4172b968c260c4af08f54e18ae5c60f6b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "03614e4f0259e72b71fb829d4733aa9478381a53", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/03614e4f0259e72b71fb829d4733aa9478381a53", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-16T02:37:32Z", "type": "forcePushed"}, {"oid": "0f3dc26ca37638ab32431cd1aefad5bc8b607c5a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0f3dc26ca37638ab32431cd1aefad5bc8b607c5a", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-19T21:42:51Z", "type": "forcePushed"}, {"oid": "84c9a0fc0f911a81eb796fd22dec63dfd5e23a9a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/84c9a0fc0f911a81eb796fd22dec63dfd5e23a9a", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-19T23:25:20Z", "type": "forcePushed"}, {"oid": "81abff499dea72dbc2a501f19fe239d562780286", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81abff499dea72dbc2a501f19fe239d562780286", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-20T17:43:55Z", "type": "forcePushed"}, {"oid": "86324a8e2bd5728fe702cfcf18158d17d6ad3fbe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/86324a8e2bd5728fe702cfcf18158d17d6ad3fbe", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-21T01:12:49Z", "type": "forcePushed"}, {"oid": "eb22768f065db47fd24882b2e06912bf6added59", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eb22768f065db47fd24882b2e06912bf6added59", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-21T01:41:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMDczMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509430732", "bodyText": "e2e tests are slow, not sure I'd recommend a e2e test. Integ is sufficient given the other coverage that mqtt has.", "author": "MikeDombo", "createdAt": "2020-10-21T16:29:28Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNjAwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509826007", "bodyText": "removed this and added integ tests", "author": "popanmol", "createdAt": "2020-10-22T01:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMDczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMTA4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509431083", "bodyText": "log error", "author": "MikeDombo", "createdAt": "2020-10-21T16:29:57Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {\n+    private Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    protected MqttProxyIPCTest() throws Exception {\n+        super();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (clientConnection != null) {\n+                clientConnection.disconnect();\n+            }\n+            if (socketOptions != null) {\n+                socketOptions.close();\n+            }\n+            kernel.shutdown();\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_subscribe_and_publish_THEN_message_received() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+        kernel = prepareKernelFromConfigFile(\"mqttproxy.yaml\", MqttProxyIPCTest.class, TEST_SERVICE_NAME);\n+        deviceProvisioningHelper.updateKernelConfigWithIotConfiguration(kernel, thingInfo, GAMMA_REGION.toString());\n+\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = TestUtils.getSocketOptionsForIPC();\n+        clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions,\n+                authToken, kernel);\n+\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        String topic = \"A/B/C\";\n+        byte[] payload = \"Hello world\".getBytes(StandardCharsets.UTF_8);\n+\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(topic);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+                if (Arrays.equals(streamEvent.getMessage().getPayload(), payload)\n+                        && streamEvent.getMessage().getTopicName().equals(topic)) {\n+                    cdl.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                return false;", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMjY2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509432667", "bodyText": "You never remove the subscription. If someone unsubscribe, they need to be removed from this map", "author": "MikeDombo", "createdAt": "2020-10-21T16:32:20Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNTg3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509825875", "bodyText": "subscription will be removed by returning null from lambda\nhttps://github.com/aws/aws-greengrass-nucleus/blob/mqtt-proxy/src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java#L259", "author": "popanmol", "createdAt": "2020-10-22T01:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMjY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509433011", "bodyText": "log exception and return an error to the customer", "author": "MikeDombo", "createdAt": "2020-10-21T16:32:52Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNTAyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509825028", "bodyText": "logged exception here and error is returned later\nif (listener == null) {\nthrow new ServiceError(\"Error subscribing to topic \" + topic);\n}", "author": "popanmol", "createdAt": "2020-10-22T01:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyODM5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509828399", "bodyText": "But they have no idea why it failed. We should be helpful to the customer.", "author": "MikeDombo", "createdAt": "2020-10-22T01:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg1OTU5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509859599", "bodyText": "Added the exception and its message to the thrown error", "author": "popanmol", "createdAt": "2020-10-22T03:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzMxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509433312", "bodyText": "this is unsubscribing, what do you need these fields for?", "author": "MikeDombo", "createdAt": "2020-10-21T16:33:22Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;\n+                        }\n+\n+                        subscribedTopic = t;\n+                        subscriptionCallback = cb;\n+                        return this;\n+                    });\n+\n+            if (listener == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            this.sendStreamEvent(iotCoreMessage);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\", justification = \"Should not be static\")\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODE0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509438146", "bodyText": "Is calling both required?", "author": "philcali", "createdAt": "2020-10-21T16:40:41Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {\n+    private Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    protected MqttProxyIPCTest() throws Exception {\n+        super();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (clientConnection != null) {\n+                clientConnection.disconnect();\n+            }\n+            if (socketOptions != null) {\n+                socketOptions.close();\n+            }", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNDM2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509824365", "bodyText": "yeah I believe both these resources need to be closed", "author": "popanmol", "createdAt": "2020-10-22T01:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODI0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509438248", "bodyText": "Add license header", "author": "philcali", "createdAt": "2020-10-21T16:40:50Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODU4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509438580", "bodyText": "Add license header", "author": "philcali", "createdAt": "2020-10-21T16:41:18Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MTM2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509441366", "bodyText": "Add license header", "author": "philcali", "createdAt": "2020-10-21T16:45:25Z", "path": "src/main/java/com/aws/greengrass/ipc/modules/MqttProxyIPCService.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.aws.greengrass.ipc.modules;", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MTUzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509441539", "bodyText": "Add license header", "author": "philcali", "createdAt": "2020-10-21T16:45:41Z", "path": "src/test/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgentTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0NDIzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509444234", "bodyText": "Does this throw a meaningful error?", "author": "philcali", "createdAt": "2020-10-21T16:49:55Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;\n+                        }\n+\n+                        subscribedTopic = t;\n+                        subscriptionCallback = cb;\n+                        return this;\n+                    });\n+\n+            if (listener == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            this.sendStreamEvent(iotCoreMessage);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\", justification = \"Should not be static\")\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.get(topic);\n+            if (listener != null) {\n+                listener.closeStream();", "originalCommit": "eb22768f065db47fd24882b2e06912bf6added59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNDIzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509824237", "bodyText": "this returns a future, so not sure if we should wait for an error to be thrown or just closeStream() and return?", "author": "popanmol", "createdAt": "2020-10-22T01:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0NDIzNA=="}], "type": "inlineReview"}, {"oid": "0306176c23965dc929432e2bf7ac17147472c0de", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0306176c23965dc929432e2bf7ac17147472c0de", "message": "Using new IPC Server library", "committedDate": "2020-10-22T00:41:14Z", "type": "commit"}, {"oid": "b447468e0c2a0e618e9e098a1d3ba491fcf940d2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b447468e0c2a0e618e9e098a1d3ba491fcf940d2", "message": "Making lifecycle APIs work", "committedDate": "2020-10-22T00:41:14Z", "type": "commit"}, {"oid": "d7d7683538abd3ae35c654fcb9084d7c3cc83bed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d7d7683538abd3ae35c654fcb9084d7c3cc83bed", "message": "Updating the server framework library code and smithy generated code", "committedDate": "2020-10-22T00:41:14Z", "type": "commit"}, {"oid": "a5b7c364eb4559fa71ec5557e7fc0c7b55059cd2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a5b7c364eb4559fa71ec5557e7fc0c7b55059cd2", "message": "Adding unit tests for IPCService, LifecycleService and LifecycleAgent", "committedDate": "2020-10-22T00:41:14Z", "type": "commit"}, {"oid": "e978068c7f1822b0bf0ee37e577f2425b9ee9f25", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e978068c7f1822b0bf0ee37e577f2425b9ee9f25", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent", "committedDate": "2020-10-22T00:42:32Z", "type": "commit"}, {"oid": "8ccd0bcb385469adffe696ba89626a1c09d69307", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8ccd0bcb385469adffe696ba89626a1c09d69307", "message": "Updated to latest code for server library and smithy generated code", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "5b9f02a23a805dd52d9bf8083b5cd3cdc43b78ca", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5b9f02a23a805dd52d9bf8083b5cd3cdc43b78ca", "message": "Fixing bug", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "04b71128d2e3b70ca4656bd63ffd0919c69c388c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/04b71128d2e3b70ca4656bd63ffd0919c69c388c", "message": "Changing the aws-crt version to 1.0.0-event-stream-rpc-SNAPSHOT", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "02e6fe70d35212800b3bc942747fc427af926fb8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/02e6fe70d35212800b3bc942747fc427af926fb8", "message": "Fixing bugs", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "279972ae457fec7c59f406f886c96d7301316233", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/279972ae457fec7c59f406f886c96d7301316233", "message": "Fixing ipc server shutdown.", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "a2b4e813f55beba4790f603ebcd4cb77ee8e44b0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2b4e813f55beba4790f603ebcd4cb77ee8e44b0", "message": "Removing windows from build", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "597706fa5667c8ddb28f5ee8cddf60e9efaf67b2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/597706fa5667c8ddb28f5ee8cddf60e9efaf67b2", "message": "Removing the IPC socket descriptor file in IPC startup", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "8c46650312076f7b6cfe41d3daa93c193c8daea2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8c46650312076f7b6cfe41d3daa93c193c8daea2", "message": "Updating integ tests to use the new IPC lifecycle APIs", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "6e442a50989d8005f2a958cd0658f5a99c6bc3b5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6e442a50989d8005f2a958cd0658f5a99c6bc3b5", "message": "Keeping old lifecycle APIs working", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "f1cb44db7db10343d17d4d90b38d8986b893c37e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f1cb44db7db10343d17d4d90b38d8986b893c37e", "message": "Updating the server and client code for ipc library", "committedDate": "2020-10-22T00:42:33Z", "type": "commit"}, {"oid": "d0d611610991cbf6b9494865ebda98d62e95f95b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d0d611610991cbf6b9494865ebda98d62e95f95b", "message": "Adding connect message suppliers and using them for IPC connect", "committedDate": "2020-10-22T00:42:34Z", "type": "commit"}, {"oid": "73ed81834a3374fc1e34798545446a3cdf6f7ab0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/73ed81834a3374fc1e34798545446a3cdf6f7ab0", "message": "Fixing some tests", "committedDate": "2020-10-22T00:42:34Z", "type": "commit"}, {"oid": "c1cf78efea62a5d4a433295f52ed72651a0635ee", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c1cf78efea62a5d4a433295f52ed72651a0635ee", "message": "Updating the event stream rpc server, client and model to latest. Also updating the Greengrass IPC model to latest generated code", "committedDate": "2020-10-22T00:42:34Z", "type": "commit"}, {"oid": "2d5570c27ae29a927de7ca4e80a3ac794724648e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2d5570c27ae29a927de7ca4e80a3ac794724648e", "message": "Updating ipc server and client code with latest exception handling fixes to both", "committedDate": "2020-10-22T00:42:34Z", "type": "commit"}, {"oid": "f5b87d4c3037269be8eb38ce8b1a692e51e91aea", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f5b87d4c3037269be8eb38ce8b1a692e51e91aea", "message": "Addressing review comments", "committedDate": "2020-10-22T00:42:34Z", "type": "commit"}, {"oid": "a8c6d8fa6d3d6b43e0d1bd3e3de8b7aa10c54f3a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a8c6d8fa6d3d6b43e0d1bd3e3de8b7aa10c54f3a", "message": "Fixing some bugs in tests", "committedDate": "2020-10-22T00:42:34Z", "type": "commit"}, {"oid": "98136933e19f552b3e9e42ce4188e477124e86c6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/98136933e19f552b3e9e42ce4188e477124e86c6", "message": "Changing the name of the socket path env variable", "committedDate": "2020-10-22T00:43:07Z", "type": "commit"}, {"oid": "193b474cd7866eb340f2c72d11adbe3fc2eef457", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/193b474cd7866eb340f2c72d11adbe3fc2eef457", "message": "Excluding ipc sdk code from unit test coverage", "committedDate": "2020-10-22T00:43:07Z", "type": "commit"}, {"oid": "163d9121c6328562e18ca1f7a0ba6090b2731292", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/163d9121c6328562e18ca1f7a0ba6090b2731292", "message": "Increasing timeout", "committedDate": "2020-10-22T00:43:07Z", "type": "commit"}, {"oid": "514bd51c14dade8ebd8bb5f1c255b7125cd34677", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/514bd51c14dade8ebd8bb5f1c255b7125cd34677", "message": "Changing the version of CRT repo to pull the latest CRT jar", "committedDate": "2020-10-22T00:43:07Z", "type": "commit"}, {"oid": "2079e4d73710a59c719efc0ceaafe580e09dac9b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2079e4d73710a59c719efc0ceaafe580e09dac9b", "message": "Fixing IPCServicesTest", "committedDate": "2020-10-22T00:43:07Z", "type": "commit"}, {"oid": "eaefbbe4896bfbe3da7cb3ffb3f9034e6c387eba", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eaefbbe4896bfbe3da7cb3ffb3f9034e6c387eba", "message": "Attempting to fix transient issues", "committedDate": "2020-10-22T00:43:07Z", "type": "commit"}, {"oid": "22c3b6001d83d08dd0b56825e33690b89e7f46b2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/22c3b6001d83d08dd0b56825e33690b89e7f46b2", "message": "Updated to generated code from latest smithy model", "committedDate": "2020-10-22T00:43:08Z", "type": "commit"}, {"oid": "f2e7f4c4e26d1fd50f8486f09f79b7d099dc7fcd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f2e7f4c4e26d1fd50f8486f09f79b7d099dc7fcd", "message": "Addressing review comments", "committedDate": "2020-10-22T00:43:08Z", "type": "commit"}, {"oid": "5a14c52f8876f07fd9845c347ed6b9411653c3b9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5a14c52f8876f07fd9845c347ed6b9411653c3b9", "message": "Addressing some more comments", "committedDate": "2020-10-22T00:43:08Z", "type": "commit"}, {"oid": "8cd037bc5485564e0c9f85e01cb53ad20729bfc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8cd037bc5485564e0c9f85e01cb53ad20729bfc1", "message": "Making post event and pre component event calls synchronous", "committedDate": "2020-10-22T00:43:08Z", "type": "commit"}, {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b178164f001d2816f0601d32c7578aaf70d3e84c", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-22T01:16:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzE4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827189", "bodyText": "log", "author": "MikeDombo", "createdAt": "2020-10-22T01:31:09Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCMqttProxyTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.integrationtests.ipc;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+import software.amazon.awssdk.eventstreamrpc.UnmappedDataException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(GGExtension.class)\n+public class IPCMqttProxyTest {\n+    private static final Logger logger = LogManager.getLogger(IPCMqttProxyTest.class);\n+    private static final int TIMEOUT_FOR_MQTTPROXY_SECONDS = 20;\n+    private static final String TEST_TOPIC = \"A/B/C\";\n+    private static final byte[] TEST_PAYLOAD = \"TestPayload\".getBytes(StandardCharsets.UTF_8);\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static MqttClient mqttClient;\n+    private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        mqttClient = mock(MqttClient.class);\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCMqttProxyTest.class.getResource(\"mqttproxy.yaml\").toString());\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(TEST_SERVICE_NAME) && newState.equals(State.RUNNING)) {\n+                awaitIpcServiceLatch.countDown();\n+            }\n+        });\n+        kernel.getContext().put(MqttClient.class, mqttClient);\n+        kernel.launch();\n+        assertTrue(awaitIpcServiceLatch.await(10, TimeUnit.SECONDS));\n+\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = TestUtils.getSocketOptionsForIPC();\n+        clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel);\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (clientConnection != null) {\n+            clientConnection.disconnect();\n+        }\n+        if (socketOptions != null) {\n+            socketOptions.close();\n+        }\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_publish_THEN_message_published() throws Exception {\n+        CompletableFuture<Integer> completableFuture = new CompletableFuture<>();\n+        when(mqttClient.publish(any())).thenReturn(completableFuture);\n+\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        PublishToIoTCoreRequest publishToIoTCoreRequest = new PublishToIoTCoreRequest();\n+        publishToIoTCoreRequest.setPayload(TEST_PAYLOAD);\n+        publishToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        publishToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+        publishToIoTCoreRequest.setRetain(false);\n+        greengrassCoreIPCClient.publishToIoTCore(publishToIoTCoreRequest, Optional.empty()).getResponse()\n+                .get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor = ArgumentCaptor.forClass(PublishRequest.class);\n+        verify(mqttClient).publish(publishRequestArgumentCaptor.capture());\n+        PublishRequest capturedPublishRequest = publishRequestArgumentCaptor.getValue();\n+        assertThat(capturedPublishRequest.getPayload(), is(TEST_PAYLOAD));\n+        assertThat(capturedPublishRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedPublishRequest.isRetain(), is(false));\n+        assertThat(capturedPublishRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_subscribe_THEN_subscribed_and_message_received()\n+            throws Exception {\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+                if (Arrays.equals(streamEvent.getMessage().getPayload(), TEST_PAYLOAD)\n+                        && streamEvent.getMessage().getTopicName().equals(TEST_TOPIC)) {\n+                    cdl.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                logger.atError().cause(error).log(\"Subscribe stream errored\");\n+                return false;\n+            }\n+\n+            @Override\n+            public void onStreamClosed() {\n+\n+            }\n+        };\n+\n+        greengrassCoreIPCClient.subscribeToIoTCore(subscribeToIoTCoreRequest, Optional.of(streamResponseHandler))\n+                .getResponse().get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<SubscribeRequest> subscribeRequestArgumentCaptor\n+                = ArgumentCaptor.forClass(SubscribeRequest.class);\n+        verify(mqttClient).subscribe(subscribeRequestArgumentCaptor.capture());\n+        SubscribeRequest capturedSubscribeRequest = subscribeRequestArgumentCaptor.getValue();\n+        assertThat(capturedSubscribeRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedSubscribeRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+\n+        Consumer<MqttMessage> callback = capturedSubscribeRequest.getCallback();\n+        MqttMessage message = new MqttMessage(TEST_TOPIC, TEST_PAYLOAD);\n+        callback.accept(message);\n+        assertTrue(cdl.await(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS));\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_unsubscribe_THEN_unsubscribed(ExtensionContext context)\n+            throws Exception {\n+        ignoreExceptionOfType(context, UnmappedDataException.class);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                return false;", "originalCommit": "b178164f001d2816f0601d32c7578aaf70d3e84c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827815", "bodyText": "Why are you calling getNow that doesn't give it any time to complete the future.", "author": "MikeDombo", "createdAt": "2020-10-22T01:33:35Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);", "originalCommit": "b178164f001d2816f0601d32c7578aaf70d3e84c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMjQwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509832402", "bodyText": "This is temporary. This will be replaced by insertion in spooler queue and error will be thrown if insertion fails. Can I just remove this for now and only call mqttclient.publish()? Or wait for the future to complete?", "author": "popanmol", "createdAt": "2020-10-22T01:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMjk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509832991", "bodyText": "This is not temporary. The API will not change with spooler.", "author": "MikeDombo", "createdAt": "2020-10-22T01:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMzM0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509833346", "bodyText": "https://github.com/aws/aws-greengrass-nucleus/blob/02b9467d04e752529521141049301ef26626a214/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java#L263\nMaybe make the getTimeout method public and move it into the MqttClient", "author": "MikeDombo", "createdAt": "2020-10-22T01:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2MTM3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509861375", "bodyText": "Added getTimeout() to MqttClient. I haven't removed it from AwsIotMqttClient because it also uses it and if removed, it would need an instance of MqttClient to access it.", "author": "popanmol", "createdAt": "2020-10-22T03:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzk4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827983", "bodyText": "This is not correct. You need to pull the message out of the exception (e.getCause().getMessage()). This should also get logged with the cause.", "author": "MikeDombo", "createdAt": "2020-10-22T01:34:17Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());", "originalCommit": "b178164f001d2816f0601d32c7578aaf70d3e84c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2MDcxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509860719", "bodyText": "logged the exception and thrown ServiceError with error and message", "author": "popanmol", "createdAt": "2020-10-22T03:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyODI0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509828244", "bodyText": "do we have any logging for failed auth attempts?", "author": "MikeDombo", "createdAt": "2020-10-22T01:35:13Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>, Consumer<MqttMessage>>>\n+                serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(l.getRight()).topic(t)\n+                            .build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().cause(e).kv(\"topic\", t).kv(\"service\", serviceName)\n+                                .log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+\n+            subscribeListeners.computeIfPresent(serviceName, (s, listeners) -> {\n+                if (listeners.isEmpty()) {\n+                    return null;\n+                } else {\n+                    return listeners;\n+                }\n+            });\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }", "originalCommit": "b178164f001d2816f0601d32c7578aaf70d3e84c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg1OTk1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509859953", "bodyText": "AuthorizationHandler doesn't log failed auth attempts, it just throws the exception with message.\nI'm adding log with that message here.", "author": "popanmol", "createdAt": "2020-10-22T03:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyODI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyOTE5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509829194", "bodyText": "Would it make sense to just unsubscribe when the subscription stream has ended? Not sure we actually need a separate event. @abanthiy", "author": "MikeDombo", "createdAt": "2020-10-22T01:39:00Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>, Consumer<MqttMessage>>>\n+                serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(l.getRight()).topic(t)\n+                            .build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().cause(e).kv(\"topic\", t).kv(\"service\", serviceName)\n+                                .log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+\n+            subscribeListeners.computeIfPresent(serviceName, (s, listeners) -> {\n+                if (listeners.isEmpty()) {\n+                    return null;\n+                } else {\n+                    return listeners;\n+                }\n+            });\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            Pair<StreamEventPublisher<IoTCoreMessage>, Consumer<MqttMessage>> listener = serviceSubscribeListeners\n+                    .computeIfAbsent(topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            LOGGER.atError().cause(e).kv(\"topic\", t).kv(\"service\", serviceName)\n+                                    .log(\"Unable to subscribe to topic\");\n+                            return null;\n+                        }\n+\n+                        subscribedTopic = t;\n+                        return new Pair<>(this, cb);\n+                    });\n+\n+            if (listener == null) {\n+                throw new ServiceError(\"Error subscribing to topic \" + topic);\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            this.sendStreamEvent(iotCoreMessage);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\", justification = \"Should not be static\")", "originalCommit": "b178164f001d2816f0601d32c7578aaf70d3e84c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c741a29de8d87733809229e13bc24976c5ef74eb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c741a29de8d87733809229e13bc24976c5ef74eb", "message": "Some debugging for failing tests", "committedDate": "2020-10-22T02:16:30Z", "type": "commit"}, {"oid": "09c3b3fa687808b5483e016fb37a323c38993961", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09c3b3fa687808b5483e016fb37a323c38993961", "message": "Adding comments to clarify IpcServer parameters for domain sockets", "committedDate": "2020-10-22T02:54:55Z", "type": "commit"}, {"oid": "2a7b68f38947691662fe244967a566c10edecc77", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2a7b68f38947691662fe244967a566c10edecc77", "message": "Making subscribeToComponent synchronous in DeploymentConfigMerging and DeploymentTaskIntegration test", "committedDate": "2020-10-22T03:20:38Z", "type": "commit"}, {"oid": "b0e9f02ebf976990f9d2e6e0ae40a8a380eae99e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b0e9f02ebf976990f9d2e6e0ae40a8a380eae99e", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-22T03:30:40Z", "type": "commit"}, {"oid": "b0e9f02ebf976990f9d2e6e0ae40a8a380eae99e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b0e9f02ebf976990f9d2e6e0ae40a8a380eae99e", "message": "mqtt proxy ipc integration", "committedDate": "2020-10-22T03:30:40Z", "type": "forcePushed"}, {"oid": "49bef4755248d477edfe87d36070ac94f5dddd6c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/49bef4755248d477edfe87d36070ac94f5dddd6c", "message": "Merge branch 'master' into mqtt-proxy-8", "committedDate": "2020-10-22T17:15:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMzNDk0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510334947", "bodyText": "don't log the message and the cause. Just call log()", "author": "MikeDombo", "createdAt": "2020-10-22T17:26:48Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log(e.getMessage());", "originalCommit": "49bef4755248d477edfe87d36070ac94f5dddd6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3be86ba146181865b72a4c0e5d3aa97f1ad1e62", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3be86ba146181865b72a4c0e5d3aa97f1ad1e62", "message": "unauthorized log", "committedDate": "2020-10-22T18:45:44Z", "type": "commit"}, {"oid": "d049af707ed1b17dda470c50b4138acd91956f21", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d049af707ed1b17dda470c50b4138acd91956f21", "message": "remove Unsubscribe handler from Mqtt Proxy", "committedDate": "2020-10-23T00:53:59Z", "type": "commit"}, {"oid": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9576b4c5ebd8fd3dc13b139e0c2b28b837997258", "message": "Merge branch 'master' into mqtt-proxy", "committedDate": "2020-10-23T00:55:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDE5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550190", "bodyText": "This doesn't make sense. You're formatting e and e.getMessage() only use e.getMessage()", "author": "MikeDombo", "createdAt": "2020-10-23T01:48:06Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.get(mqttClient.getTimeout(), TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to publish to topic\");\n+                throw new ServiceError(String.format(\"Publish to topic %s failed with error %s:%s\", topic, e,", "originalCommit": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDI0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550241", "bodyText": "same as below", "author": "MikeDombo", "createdAt": "2020-10-23T01:48:22Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));", "originalCommit": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDMxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550315", "bodyText": "Same", "author": "MikeDombo", "createdAt": "2020-10-23T01:48:40Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.get(mqttClient.getTimeout(), TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to publish to topic\");\n+                throw new ServiceError(String.format(\"Publish to topic %s failed with error %s:%s\", topic, e,\n+                        e.getMessage()));\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                        .topic(subscribedTopic).build();\n+\n+                try {\n+                    mqttClient.unsubscribe(unsubscribeRequest);\n+                } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                    LOGGER.atError().cause(e).kv(TOPIC_KEY, subscribedTopic).kv(SERVICE_KEY, serviceName)\n+                            .log(\"Stream closed but unable to unsubscribe from topic\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));", "originalCommit": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDMyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550327", "bodyText": "Same", "author": "MikeDombo", "createdAt": "2020-10-23T01:48:44Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.get(mqttClient.getTimeout(), TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to publish to topic\");\n+                throw new ServiceError(String.format(\"Publish to topic %s failed with error %s:%s\", topic, e,\n+                        e.getMessage()));\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                        .topic(subscribedTopic).build();\n+\n+                try {\n+                    mqttClient.unsubscribe(unsubscribeRequest);\n+                } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                    LOGGER.atError().cause(e).kv(TOPIC_KEY, subscribedTopic).kv(SERVICE_KEY, serviceName)\n+                            .log(\"Stream closed but unable to unsubscribe from topic\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            Consumer<MqttMessage> callback = this::forwardToSubscriber;\n+            SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(callback).topic(topic)\n+                    .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to subscribe to topic\");\n+                throw new ServiceError(String.format(\"Subscribe to topic %s failed with error %s:%s\", topic, e,", "originalCommit": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c8c2031c8da93868867971077f881d21c504a82", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5c8c2031c8da93868867971077f881d21c504a82", "message": "throw error with exception message", "committedDate": "2020-10-23T01:58:59Z", "type": "commit"}, {"oid": "833359ba64c045d7274b0e73d65b07b9dbfcd02a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/833359ba64c045d7274b0e73d65b07b9dbfcd02a", "message": "suppress PreserveStackTrace", "committedDate": "2020-10-23T02:26:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwMTQzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511101436", "bodyText": "As discussed offline, this is going to need to change. Need to sign off with Jamie, but current thinking is that we need a separate stream for message delivery events so that we can scalably receive publish requests while offline (i.e. we can't pile up streams, threads, objects, etc -- the spool itself should be the limiting factor).\nWe can address this separately.", "author": "jbutler", "createdAt": "2020-10-23T19:22:12Z", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s\", e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue", "originalCommit": "833359ba64c045d7274b0e73d65b07b9dbfcd02a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MzY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511153674", "bodyText": "Can be backed out after we make the publish changes", "author": "jbutler", "createdAt": "2020-10-23T21:01:38Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -438,4 +438,8 @@ public synchronized void close() {\n     public void addToCallbackEvents(MqttClientConnectionEvents callbacks) {\n         callbackEventManager.addToCallbackEvents(callbacks);\n     }\n+\n+    public int getTimeout() {", "originalCommit": "833359ba64c045d7274b0e73d65b07b9dbfcd02a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1OTQyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511159429", "bodyText": "Is closeStream() async? Sleeping problem isn't the most robust way to handle this", "author": "jbutler", "createdAt": "2020-10-23T21:17:24Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCMqttProxyTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.integrationtests.ipc;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.SubscribeToIoTCoreResponseHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(GGExtension.class)\n+public class IPCMqttProxyTest {\n+    private static final Logger logger = LogManager.getLogger(IPCMqttProxyTest.class);\n+    private static final int TIMEOUT_FOR_MQTTPROXY_SECONDS = 20;\n+    private static final String TEST_TOPIC = \"A/B/C\";\n+    private static final byte[] TEST_PAYLOAD = \"TestPayload\".getBytes(StandardCharsets.UTF_8);\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static MqttClient mqttClient;\n+    private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        mqttClient = mock(MqttClient.class);\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCMqttProxyTest.class.getResource(\"mqttproxy.yaml\").toString());\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(TEST_SERVICE_NAME) && newState.equals(State.FINISHED)) {\n+                awaitIpcServiceLatch.countDown();\n+            }\n+        });\n+        kernel.getContext().put(MqttClient.class, mqttClient);\n+        kernel.launch();\n+        assertTrue(awaitIpcServiceLatch.await(10, TimeUnit.SECONDS));\n+\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = TestUtils.getSocketOptionsForIPC();\n+        clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel);\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (clientConnection != null) {\n+            clientConnection.disconnect();\n+        }\n+        if (socketOptions != null) {\n+            socketOptions.close();\n+        }\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_publish_THEN_message_published() throws Exception {\n+        CompletableFuture<Integer> completableFuture = new CompletableFuture<>();\n+        completableFuture.complete(0);\n+        when(mqttClient.publish(any())).thenReturn(completableFuture);\n+        when(mqttClient.getTimeout()).thenReturn(1000);\n+\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        PublishToIoTCoreRequest publishToIoTCoreRequest = new PublishToIoTCoreRequest();\n+        publishToIoTCoreRequest.setPayload(TEST_PAYLOAD);\n+        publishToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        publishToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+        publishToIoTCoreRequest.setRetain(false);\n+        greengrassCoreIPCClient.publishToIoTCore(publishToIoTCoreRequest, Optional.empty()).getResponse()\n+                .get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor = ArgumentCaptor.forClass(PublishRequest.class);\n+        verify(mqttClient).publish(publishRequestArgumentCaptor.capture());\n+        PublishRequest capturedPublishRequest = publishRequestArgumentCaptor.getValue();\n+        assertThat(capturedPublishRequest.getPayload(), is(TEST_PAYLOAD));\n+        assertThat(capturedPublishRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedPublishRequest.isRetain(), is(false));\n+        assertThat(capturedPublishRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_subscribe_THEN_subscribed_and_message_received()\n+            throws Exception {\n+        CountDownLatch messageLatch = new CountDownLatch(1);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+                if (Arrays.equals(streamEvent.getMessage().getPayload(), TEST_PAYLOAD)\n+                        && streamEvent.getMessage().getTopicName().equals(TEST_TOPIC)) {\n+                    messageLatch.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                logger.atError().cause(error).log(\"Subscribe stream errored\");\n+                return false;\n+            }\n+\n+            @Override\n+            public void onStreamClosed() {\n+\n+            }\n+        };\n+\n+        SubscribeToIoTCoreResponseHandler responseHandler = greengrassCoreIPCClient.subscribeToIoTCore(\n+                subscribeToIoTCoreRequest, Optional.of(streamResponseHandler));\n+        responseHandler.getResponse().get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<SubscribeRequest> subscribeRequestArgumentCaptor\n+                = ArgumentCaptor.forClass(SubscribeRequest.class);\n+        verify(mqttClient).subscribe(subscribeRequestArgumentCaptor.capture());\n+        SubscribeRequest capturedSubscribeRequest = subscribeRequestArgumentCaptor.getValue();\n+        assertThat(capturedSubscribeRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedSubscribeRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+\n+        Consumer<MqttMessage> callback = capturedSubscribeRequest.getCallback();\n+        MqttMessage message = new MqttMessage(TEST_TOPIC, TEST_PAYLOAD);\n+        callback.accept(message);\n+        assertTrue(messageLatch.await(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS));\n+\n+        //close stream -> unsubscribe\n+        responseHandler.closeStream();\n+        Thread.sleep(5);", "originalCommit": "833359ba64c045d7274b0e73d65b07b9dbfcd02a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3NjA4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511176084", "bodyText": "closeStream() returns a future but waiting for the future to complete didn't trigger mqttclient.unsubscribe(), until I added the 5 ms sleep. I think that's probably because completion of closeStream() on client side doesn't necessarily mean onStreamClosed() has been completed on the server side.", "author": "popanmol", "createdAt": "2020-10-23T22:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1OTQyOQ=="}], "type": "inlineReview"}, {"oid": "c6cf86bd67b8739c0af007f9ebd8152d36454534", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c6cf86bd67b8739c0af007f9ebd8152d36454534", "message": "Merge branch 'master' into mqtt-proxy", "committedDate": "2020-10-23T21:51:53Z", "type": "commit"}, {"oid": "6137b15bd835ad90ed2d10f4ac923c2ef2d62cbe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6137b15bd835ad90ed2d10f4ac923c2ef2d62cbe", "message": "Merge branch 'master' into mqtt-proxy", "committedDate": "2020-10-23T22:37:32Z", "type": "commit"}]}