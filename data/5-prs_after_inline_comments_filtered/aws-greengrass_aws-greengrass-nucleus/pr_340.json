{"pr_number": 340, "pr_title": "Add initial AuthZ pub/sub integration", "pr_createdAt": "2020-07-30T19:21:52Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyMTQ2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463221463", "bodyText": "you don't use this method. Get rid of it.", "author": "MikeDombo", "createdAt": "2020-07-30T19:27:40Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -17,4 +17,27 @@\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");\n+\n+        private final String name;\n+\n+        PolicyComponentTypes(String s) {\n+            name = s;\n+        }\n+\n+        public boolean equalsName(String otherName) {", "originalCommit": "f0ee2bf1b709f14d23d1a48ee24df3084ba83018", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyNDgyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463224820", "bodyText": "ok", "author": "avipinku", "createdAt": "2020-07-30T19:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyMTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzODg3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463238876", "bodyText": "pretty sure @Value has this already.", "author": "MikeDombo", "createdAt": "2020-07-30T20:01:15Z", "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "diffHunk": "@@ -4,11 +4,13 @@\n package com.aws.iot.evergreen.auth;\n \n import lombok.Builder;\n+import lombok.EqualsAndHashCode;\n import lombok.NonNull;\n import lombok.Value;\n \n @Builder\n @Value\n+@EqualsAndHashCode", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MDgyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463250827", "bodyText": "will remove", "author": "avipinku", "createdAt": "2020-07-30T20:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzODg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTM2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463239369", "bodyText": "no * imports. setup your IDE to not do this.", "author": "MikeDombo", "createdAt": "2020-07-30T20:02:17Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.*;", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MDg4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463250884", "bodyText": "ah my mistake", "author": "avipinku", "createdAt": "2020-07-30T20:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NjE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463356140", "bodyText": "I am not sure if we follow pascal case or camel case for the config fields? mostly it should be accessControl", "author": "prateek-y", "createdAt": "2020-07-31T01:19:28Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MzkxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463363919", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-07-31T01:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NjE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1OTg5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463359890", "bodyText": "we would need to handle cases when some of the fields are not set by the customer.", "author": "prateek-y", "createdAt": "2020-07-31T01:34:26Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+\n+    /**\n+     * Given a Topics config object, construct and return a list of AuthorizationPolicy objects that may exist.\n+     * @param config Topics\n+     * @return List AuthorizationPolicy\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicy(Topics config) throws AuthorizationException {\n+\n+        Topics accessControlMap = config.findTopics(ACCESS_CONTROL_KEY);\n+        if (accessControlMap == null) {\n+            return null;\n+        }\n+\n+        ArrayList<AuthorizationPolicy> authorizationPolicyList = new ArrayList<>();\n+\n+        //Iterate through all policies\n+        for (Node policyObject : accessControlMap) {\n+\n+            //Initialize these components to null\n+            String policyDescription = null;\n+            Set<String> principals = null;\n+            Set<String> operations = null;\n+            Set<String> resources = null;\n+\n+            for (Node policyComponentNode : (Topics) policyObject) {\n+                //Iterate through the components of this policy\n+                Topic policyComponent = (Topic) policyComponentNode;\n+                PolicyComponentTypes policyComponentKey = toEnum(\n+                        PolicyComponentTypes.class,\n+                        policyComponentNode.getName(),\n+                        PolicyComponentTypes.INVALID_ENUM);\n+                switch (policyComponentKey) {\n+                    case POLICY_DESCRIPTION:\n+                        policyDescription = Coerce.toString(policyComponent);", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMzIxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463413211", "bodyText": "added a test for this", "author": "avipinku", "createdAt": "2020-07-31T05:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1OTg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDE4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360182", "bodyText": "I am not sure if this should be Camel case or pascal case??", "author": "prateek-y", "createdAt": "2020-07-31T01:35:19Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -21,21 +26,29 @@\n import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n \n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.inject.Inject;\n \n //TODO: see if this needs to be a GGService\n-@ImplementsService(name = \"pubsubipc\", autostart = true)\n+@ImplementsService(name = \"pubsub\", autostart = true)", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360593", "bodyText": "rename to \"aws.greengrass.ipc.pubsub\", we're moving toward namespacing all our internal stuff like that.", "author": "MikeDombo", "createdAt": "2020-07-31T01:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2NDA2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463364068", "bodyText": "ok", "author": "avipinku", "createdAt": "2020-07-31T01:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDUyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360524", "bodyText": "remove \"ipc\" from event type.", "author": "prateek-y", "createdAt": "2020-07-31T01:36:45Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -44,13 +57,47 @@ public PubSubIPCService(Topics c) {\n     public void postInject() {\n         BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.PUBSUB;\n         super.postInject();\n+\n+\n+        List<String> opCodes = Stream.of(PubSubClientOpCodes.values())\n+                .map(PubSubClientOpCodes::name)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+        try {\n+            authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n+            //Initialize auth config\n+            updateAuthConfig(this.config);\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"ipc-initialize-pubsub-authorization-error\").setCause(e)\n+                    .addKeyValue(DESTINATION_STRING, destination.name())\n+                    .log(\"Failed to initialize the Pub/Sub service with the Authorization module.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.config.subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    try {\n+                        //If there is a change in a node, reload the entire config\n+                        updateAuthConfig(this.config);\n+                    } catch (AuthorizationException e) {\n+                        logger.atError().setEventType(\"ipc-load-authorization-config-error\").setCause(e)", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2NDc2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463364767", "bodyText": "removed from all logging in this file", "author": "avipinku", "createdAt": "2020-07-31T01:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTAzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463361033", "bodyText": "Any reason you just set the code and not create a PubSubGenericResponse object?", "author": "prateek-y", "createdAt": "2020-07-31T01:39:00Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -101,6 +151,9 @@ public void postInject() {\n             try {\n                 PubSubGenericResponse response =\n                         new PubSubGenericResponse(PubSubResponseStatus.InternalError, e.getMessage());", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2NDcyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463364722", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-07-31T01:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTI2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463361260", "bodyText": "We need to distinguish between the cases when policy is absent and its malformed, and atleast log informative error if its malformed.", "author": "prateek-y", "createdAt": "2020-07-31T01:39:53Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -114,4 +167,23 @@ public void postInject() {\n         }\n         return fut;\n     }\n+\n+    private void updateAuthConfig(Topics config) throws AuthorizationException {\n+        List<AuthorizationPolicy> authorizationPolicyList = AuthorizationUtils\n+                .parseAuthorizationPolicy(config);\n+        if (authorizationPolicyList != null) {", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMzI2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463413265", "bodyText": "added tests for this as well as more logging", "author": "avipinku", "createdAt": "2020-07-31T05:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTI2MA=="}], "type": "inlineReview"}, {"oid": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "message": "Final iteration of authZ pub/sub", "committedDate": "2020-08-04T03:30:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDYyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465264626", "bodyText": "This is commented out because the authhandler starts up before components become registered, which causes this to always fail. We're still discussing how to handle this case.", "author": "avipinku", "createdAt": "2020-08-04T19:01:54Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -185,19 +256,20 @@ private void validatePolicyId(List<AuthorizationPolicy> policies) throws Authori\n         }\n     }\n \n-    private void validateOperations(String componentName, AuthorizationPolicy policy) throws AuthorizationException {\n-        Set<String> operations = policy.getOperations();\n-        if (Utils.isEmpty(operations)) {\n-            throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n-                    + policy.getPolicyId());\n-        }\n-        Set<String> supportedOps = componentToOperationsMap.get(componentName);\n-        // check if operations are valid and registered.\n-        if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n-            throw new AuthorizationException(\n-                    String.format(\"Operation not registered with component %s\", componentName));\n+        private void validateOperations(String componentName, AuthorizationPolicy policy)\n+        throws AuthorizationException {\n+            Set<String> operations = policy.getOperations();\n+            if (Utils.isEmpty(operations)) {\n+                throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n+                        + policy.getPolicyId());\n+            }\n+            //Set<String> supportedOps = componentToOperationsMap.get(componentName);", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mzg5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467273894", "bodyText": "TODO SIM has been created and commented here. Resolving this conversation.", "author": "avipinku", "createdAt": "2020-08-07T21:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465264670", "bodyText": "This is commented out because the authhandler starts up before components become registered, which causes this to always fail. We're still discussing how to handle this case.", "author": "avipinku", "createdAt": "2020-08-04T19:02:00Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -155,13 +193,46 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies policies which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated policies would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }\n+        isComponentRegistered(componentName);\n+        validatePolicyId(policies);\n+        // First validate if all principals and operations are valid\n+        for (AuthorizationPolicy policy: policies) {\n+            validatePrincipals(policy);\n+            validateOperations(componentName, policy);\n+        }\n+\n+        authModule.clearComponentPermissions(componentName);\n+        // now start adding the policies as permissions\n+        for (AuthorizationPolicy policy: policies) {\n+            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        }\n+        this.componentToAuthZConfig.replace(componentName, policies);\n+    }\n+\n     private void isComponentRegistered(String componentName) throws AuthorizationException {\n         if (Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Component name is not specified: \" + componentName);\n         }\n-        if (!componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component not registered: \" + componentName);\n-        }\n+        //if (!componentToOperationsMap.containsKey(componentName)) {\n+        //throw new AuthorizationException(\"Component not registered: \" + componentName);", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5ODc4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465998789", "bodyText": "Is there a way to start authhandler in the end, and let all other components start up and register themselves first?", "author": "prateek-y", "createdAt": "2020-08-05T20:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NTU3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466585579", "bodyText": "Michael confirmed that there is no way to do this, and that this should be dynamic. I'd like to get this initial implementation merged in first and then loop back around to this.", "author": "avipinku", "createdAt": "2020-08-06T17:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5OTc3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467199777", "bodyText": "lets create a backlog task so that we dont miss it.", "author": "prateek-y", "createdAt": "2020-08-07T18:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTEyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269123", "bodyText": "use https://github.com/aws/aws-greengrass-kernel/blob/1972ecb1e01f0ca1fc39b0228c9495b5a3381ccd/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java#L140 instead", "author": "MikeDombo", "createdAt": "2020-08-04T19:10:25Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(\"accessControl\")) {\n+                        return;\n+                    }\n+                    try {\n+                        Topic updatedTopic = (Topic) newv;\n+                        String componentName = updatedTopic.parent.parent.getName();", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431887", "bodyText": "perfect, thanks", "author": "avipinku", "createdAt": "2020-08-05T02:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTIxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269211", "bodyText": "make a const for this string", "author": "MikeDombo", "createdAt": "2020-08-04T19:10:36Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(\"accessControl\")) {", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431882", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTY4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269685", "bodyText": "reformat.", "author": "MikeDombo", "createdAt": "2020-08-04T19:11:27Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -155,13 +193,48 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Update authZ policies for a single component. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * This method clears the existing policies for a component before refreshing with the updated list.\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies policies which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated policies would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }\n+        isComponentRegistered(componentName);\n+        validatePolicyId(policies);\n+        // First validate if all principals and operations are valid\n+        for (AuthorizationPolicy policy: policies) {", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431875", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MDgwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465270809", "bodyText": "don't make your own const. We already have these as consts", "author": "MikeDombo", "createdAt": "2020-08-04T19:13:36Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431865", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MDgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271306", "bodyText": "this isn't needed. Do for (Map.Entry policyEntry : allPoliciesMap.entrySet())", "author": "MikeDombo", "createdAt": "2020-08-04T19:14:26Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431858", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTQyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271428", "bodyText": "again here", "author": "MikeDombo", "createdAt": "2020-08-04T19:14:41Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431852", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTc0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271746", "bodyText": "this cast might fail, make sure that you are handling ClassCastException appropriately somewhere", "author": "MikeDombo", "createdAt": "2020-08-04T19:15:18Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431845", "bodyText": "added checks in multiple cast locations", "author": "avipinku", "createdAt": "2020-08-05T02:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTk4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271985", "bodyText": "do a static import for Collections.singleton", "author": "MikeDombo", "createdAt": "2020-08-04T19:15:44Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431836", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Mjk0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465272945", "bodyText": "This log is completely wrong. All logging needs to end with .log() the message needs to go in the .log(). Putting a string in the atWarn is the event type and not the message. Do not use string.format, use .log(\"{}\", value)", "author": "MikeDombo", "createdAt": "2020-08-04T19:17:36Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * @param config Topics\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);\n+        if (servicesConfig == null) {\n+            logger.atWarn(String.format(\"No services found in config.\"));\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each component\n+        for (Node componentConfigNode : servicesConfig) {\n+            Topics componentConfigTopics = (Topics) componentConfigNode;\n+            String componentName = componentConfigTopics.getName();\n+\n+            //Get the Access Control List for this component\n+            Topics accessControlTopics = componentConfigTopics.findTopics(ACCESS_CONTROL_KEY);\n+            if (accessControlTopics == null) {\n+                logger.atWarn(String.format(\"Component %s has no valid accessControl component field.\", componentName));", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431833", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Mjk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjE1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465276150", "bodyText": "I don't like this idea because it is dependent on the config layout. Use kernel.orderedDependencies() to get the list of all services, then use service.getConfig() to get their config.", "author": "MikeDombo", "createdAt": "2020-08-04T19:24:06Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * @param config Topics\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431827", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjgwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465276803", "bodyText": "this log line can be shortened using our convenience overrides you can do atError(<event type>, <exception>).kv(key, value).log(<stuff>). kv == addKeyValue", "author": "MikeDombo", "createdAt": "2020-08-04T19:25:04Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -44,13 +55,28 @@ public PubSubIPCService(Topics c) {\n     public void postInject() {\n         BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.PUBSUB;\n         super.postInject();\n+\n+\n+        List<String> opCodes = Stream.of(PubSubClientOpCodes.values())\n+                .map(PubSubClientOpCodes::name)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+        try {\n+            authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"initialize-pubsub-authorization-error\").setCause(e)", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431822", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Nzc0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465277740", "bodyText": "shutdown the context in the afterEach otherwise you're leaving a thread running forever.", "author": "MikeDombo", "createdAt": "2020-08-04T19:26:11Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationHandlerTest.java", "diffHunk": "@@ -124,12 +127,18 @@ private AuthorizationPolicy getAuthZPolicyWithEmptyPolicyId() {\n                 .build();\n     }\n \n+    @BeforeEach\n+    void beforeEach() {\n+        when(mockKernel.getConfig()).thenReturn(new Configuration(new Context()));", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431818", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Nzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3OTkxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465279917", "bodyText": "flip these assertions, the actual value should be first and the expected value second.\n\"Expected  to equal \"", "author": "MikeDombo", "createdAt": "2020-08-04T19:28:51Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431812", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3OTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MDI1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465280251", "bodyText": "create a constant for the service name and use that here and in the annotation", "author": "MikeDombo", "createdAt": "2020-08-04T19:29:14Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy.getPolicyDescription()));\n+                assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+                assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+                assertThat(policy.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\", \"*\"));\n+\n+                AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+                assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy2.getPolicyDescription()));\n+                assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+                assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+                assertThat(policy2.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\"));\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_without_description_or_resources_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid_optional.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+            Topics component = config.getRoot();\n+            Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+            assertEquals(1, authorizationPolicyMap.size());\n+            assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+            AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+            assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+            assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+            assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+            assertThat(policy.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy.getResources(), Matchers.nullValue());\n+\n+            AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431803", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MDI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MTc5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465281792", "bodyText": "We shouldn't be throwing nulls. Handle the exception properly when parsing.", "author": "MikeDombo", "createdAt": "2020-08-04T19:30:59Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy.getPolicyDescription()));\n+                assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+                assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+                assertThat(policy.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\", \"*\"));\n+\n+                AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+                assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy2.getPolicyDescription()));\n+                assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+                assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+                assertThat(policy2.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\"));\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_without_description_or_resources_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid_optional.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+            Topics component = config.getRoot();\n+            Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+            assertEquals(1, authorizationPolicyMap.size());\n+            assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+            AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+            assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+            assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+            assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+            assertThat(policy.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy.getResources(), Matchers.nullValue());\n+\n+            AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+            assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+            assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+            assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+            assertThat(policy2.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy2.getResources(), Matchers.nullValue());\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_invalid_pubsub_yaml_file_without_operations_WHEN_auth_parsing_THEN_fail() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_invalid_no_operations.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                assertThrows(NullPointerException.class, () -> AuthorizationUtils", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTc5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431799", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NzgyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465367829", "bodyText": "These policies can be for any module other than pubsub as well. So we need to make it general. Currently it assumes policies are for pubsub right? This policy is for pubsub where is that captured?", "author": "abanthiy", "createdAt": "2020-08-04T22:34:35Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTc4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431789", "bodyText": "This should be usable for any generic policy", "author": "avipinku", "createdAt": "2020-08-05T02:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NzgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2ODgyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465368826", "bodyText": "This should be generic message than being specific to pubsub", "author": "abanthiy", "createdAt": "2020-08-04T22:37:32Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTc1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431752", "bodyText": "good catch, fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2ODgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDY0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466000646", "bodyText": "Lets log all the variables so that its easy for customers to debug.", "author": "prateek-y", "createdAt": "2020-08-05T21:00:11Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+                HashSet<String> principals = new HashSet<>(java.util.Collections.singleton(componentName));\n+\n+                if (policyId == null || operations == null || principals.isEmpty()) {\n+                    String errorMessage = \"Policy component is missing or invalid\";", "originalCommit": "1c88aad1e9b4accc516cb2cd4b2f2ca84ae60d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NTMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466065306", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T23:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDY0Ng=="}], "type": "inlineReview"}, {"oid": "5055bcbee2e9eb715770b7c9a1431c6809318746", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5055bcbee2e9eb715770b7c9a1431c6809318746", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-05T23:36:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466056519", "bodyText": "Change the name to indicate what the mapping is. componentNameToPolicies maybe", "author": "abanthiy", "createdAt": "2020-08-05T23:20:18Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;", "originalCommit": "224689b3cbb8b8ae27a1729e19e315bef85abdf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466578163", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-06T17:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODAyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466078024", "bodyText": "Does this need to be exposed to customer/first party components (not running in same JVM as kernel) by Re:invent 2020? For example to Stream manager over IPC?", "author": "abanthiy", "createdAt": "2020-08-06T00:33:32Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,8 +149,9 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)", "originalCommit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3Nzk3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466577975", "bodyText": "SM and any other components will be making a request to the IPC which will be handled by a separate service. That separate service will then use this method to register SM.", "author": "avipinku", "createdAt": "2020-08-06T17:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTQ4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466085481", "bodyText": "Any reason to choose this path as name?", "author": "abanthiy", "createdAt": "2020-08-06T01:02:09Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -21,21 +24,30 @@\n import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n \n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.inject.Inject;\n \n //TODO: see if this needs to be a GGService\n-@ImplementsService(name = \"pubsubipc\", autostart = true)\n+@ImplementsService(name = PubSubIPCService.PUB_SUB_SERVICE_NAME, autostart = true)\n public class PubSubIPCService extends EvergreenService {\n     private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+    private static final String DESTINATION_STRING = \"destination\";\n+    public static final String PUB_SUB_SERVICE_NAME = \"aws.greengrass.ipc.pubsub\";", "originalCommit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3Nzk5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466577995", "bodyText": "I was told that this is the naming schema we're propagating throughout the kernel", "author": "avipinku", "createdAt": "2020-08-06T17:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTQ4MQ=="}], "type": "inlineReview"}, {"oid": "39ee9af6b4fad604d39653cf8b3b8de019da9800", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/39ee9af6b4fad604d39653cf8b3b8de019da9800", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-06T17:46:20Z", "type": "forcePushed"}, {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/97c1930a83fdcab29960d7c26689c5f0ce8e1033", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-06T18:06:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NDQ5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466594491", "bodyText": "What's ServiceName? Why is it a hardcoded string? It should be passed in as a parameter so this method can be used by other tests as well.", "author": "fengwang666", "createdAt": "2020-08-06T18:07:20Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();\n+    }\n+\n+    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+        Kernel kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());\n+\n+        // ensure awaitIpcServiceLatch starts\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"ServiceName\") && newState.equals(State.RUNNING)) {", "originalCommit": "39ee9af6b4fad604d39653cf8b3b8de019da9800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833266", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NDQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NjMwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466596307", "bodyText": "Use Coerce.toString()", "author": "fengwang666", "createdAt": "2020-08-06T18:10:38Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833275", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NjMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NzEzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466597138", "bodyText": "Instead of using IPCPubSubTest.class, can you make this a method parameter so it can be used by other tests as well?", "author": "fengwang666", "createdAt": "2020-08-06T18:12:11Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();\n+    }\n+\n+    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+        Kernel kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833281", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NzEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTYxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466599617", "bodyText": "This is duplicated across multiple test cases, consider extracting them to a private method.", "author": "fengwang666", "createdAt": "2020-08-06T18:16:45Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833291", "bodyText": "refactored and consolidated this logic", "author": "avipinku", "createdAt": "2020-08-07T05:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzg3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466603872", "bodyText": "Extract ServiceName to a constant.", "author": "fengwang666", "createdAt": "2020-08-06T18:24:40Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833306", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466611928", "bodyText": "Isn't this counter-intuitive? Why would we want to prevent unsubscribe? What would be the use case that a component is allowed to subscribe bu cannot unsubscribe?", "author": "fengwang666", "createdAt": "2020-08-06T18:39:49Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+        IPCClientImpl client2 = new IPCClientImpl(config);\n+        try {\n+            PubSub c2 = new PubSubImpl(client2);\n+\n+            Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+                assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+            });\n+            c.subscribeToTopic(\"a\", cb.getRight());\n+            c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+            cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+            // Now unsubscribe and make sure that we only got the first message in the first client\n+            c.unsubscribeFromTopic(\"a\");\n+            Pair<CompletableFuture<Void>, Consumer<byte[]>> cb2 = asyncAssertOnConsumer((m) -> {\n+                assertEquals(\"second message\", new String(m, StandardCharsets.UTF_8));\n+            });\n+            c2.subscribeToTopic(\"a\", cb2.getRight());\n+            c2.publishToTopic(\"a\", \"second message\".getBytes(StandardCharsets.UTF_8));\n+            cb2.getLeft().get(2, TimeUnit.SECONDS);\n+            cb.getLeft().get(2, TimeUnit.SECONDS);\n+        } finally {\n+            client2.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_subscribe.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        //Reload the kernel with the correct authorization policy\n+        kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n+        Thread.sleep(500);\n+        c.subscribeToTopic(\"a\", cb.getRight()); //now this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+    }\n+\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_subscribe.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+\n+        //TODO: change PubSubImpl L124 to handle PubSubExceptions better by switching on AuthorizationExceptions\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_publish_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_publish.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_unsubscribe_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzMxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833316", "bodyText": "Prateek and I are still discussing this. As we talked about offline, we may need to have a whitelist for certain operations that should not require authorization.", "author": "avipinku", "createdAt": "2020-08-07T05:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMDk4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467200988", "bodyText": "Wait. We dont need anything special, its up to the module owner to decide what operations they want to register. This is exactly why we have registerComponent. This is more for pub sub to decide as module owner. If we want to skip Unsubscribe,  pub sub module wont register it. Simple.", "author": "prateek-y", "createdAt": "2020-08-07T18:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNjY5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467216692", "bodyText": "I think, same as v1, we should only allow customers to add policies for publish and subscribe. In the future, we can extend it to unsubscribe and add a default policy for all to unsubscribe.", "author": "prateek-y", "createdAt": "2020-08-07T18:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NDAyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467274025", "bodyText": "Added a SIM and TODO for this.", "author": "avipinku", "createdAt": "2020-08-07T21:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMzE5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466613191", "bodyText": "Would it be simpler to change this method's parameters to take in only the service name and kernel object? Both the port and address are derived from the kernel object.", "author": "fengwang666", "createdAt": "2020-08-06T18:42:13Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzMyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833328", "bodyText": "refactored and consolidated this logic", "author": "avipinku", "createdAt": "2020-08-07T05:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMzE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466614896", "bodyText": "Do you need a null check on the get method?", "author": "fengwang666", "createdAt": "2020-08-06T18:45:32Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java", "diffHunk": "@@ -38,6 +38,10 @@ public void addPermission(final String destination, Permission permission) throw\n         permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);\n     }\n \n+    public void clearComponentPermissions(String destination) {\n+        permissions.get(destination).clear();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNzA5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466617092", "bodyText": "Also the List<Permission> need to be thread-safe? It seems multiple threads can access it concurrently.", "author": "fengwang666", "createdAt": "2020-08-06T18:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzAzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466623031", "bodyText": "Line66 in the isPresent method also requires a null check on the permissionForDest?", "author": "fengwang666", "createdAt": "2020-08-06T19:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833343", "bodyText": "Added a null check for the get method.\nI don't think permissions will ever be null, since it is initialized in the declaration.\nI've changed the List<Permission> to be a CopyOnWriteArrayList.\nAlso added a null check for permissionsForDest.", "author": "avipinku", "createdAt": "2020-08-07T05:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMTEzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467201136", "bodyText": "Thanks for adding these guards.", "author": "prateek-y", "createdAt": "2020-08-07T18:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzQ1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466623455", "bodyText": "Just initialize it when you declare it.", "author": "fengwang666", "createdAt": "2020-08-06T19:01:15Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833355", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDMzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466624334", "bodyText": "Why not just:\ntry {\n    Map<String, List<AuthorizationPolicy>> componentNameToPolicies = AuthorizationUtils.parseAllAuthorizationPolicies(kernel, logger);", "author": "fengwang666", "createdAt": "2020-08-06T19:02:55Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833365", "bodyText": "good point, fixed", "author": "avipinku", "createdAt": "2020-08-07T05:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNjUzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466626537", "bodyText": "I would make this a class like AuthorizationPolicyParser and pass it in as a dependency of AuthorizationHandler. That way is more object-oriented. Utils is a bit too generic. Also don't mark the methods as static.", "author": "fengwang666", "createdAt": "2020-08-06T19:07:18Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833375", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNjUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466691916", "bodyText": "I saw this method both called here and in the TES. Shouldn't parseAllAuthorizationPolicies() already include TES policy?", "author": "fengwang666", "createdAt": "2020-08-06T21:18:56Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -128,13 +172,14 @@ public void registerComponent(String componentName, Set<String> operations)\n      * Loads authZ policies for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MzY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466693674", "bodyText": "Line 187, why not just return? Do you need to throw an exception? Is policies empty expected or unexpected? If it's expected, then the code can handle it gracefully by just return at that point. If it's not expected, then it's a programming error we should make sure it doesn't happen using testing.", "author": "fengwang666", "createdAt": "2020-08-06T21:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5Nzc3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466697771", "bodyText": "I would revisit every line of the code that throws the AuthorizationException and think again whether that is the desired behavior. We don't want to just fail. For scenarios that we can recover (e.g. empty list), we should just handle it and move on.", "author": "fengwang666", "createdAt": "2020-08-06T21:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833400", "bodyText": "You're right, it shouldn't be necessary to have TES load it in; this should be centralized. Removed it.\nYes, you're right; policies will never be null but it could be empty in the edge case where there are no ACLs specified; i.e.\naccessControl:\n      aws.greengrass.ipc.pubsub:\n\nI've changed this method to not throw and added much more verbose logging instead in order to recover and continue.", "author": "avipinku", "createdAt": "2020-08-07T05:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwNTUzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467205531", "bodyText": "Initially the idea was that each component will have its own policies. Now, we are moving to source based policies, in this case, policies for TES are not specified at TES level, but at other components. TES today allows any component to access it, a default would mean to generate allow for all components, or introduce a new global flag at TES level. This is why source is complicated, and it does not prevent us from multi group overrides anyway because TES config is again gonna get overridden and we are back to the same problem. For now, we should have default policy generator which merges with loaded policies.", "author": "prateek-y", "createdAt": "2020-08-07T18:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODI4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466698286", "bodyText": "This handling is interesting. So if some code throws AuthorizationException, we just stop loading the rest and move on? is that desirable?", "author": "fengwang666", "createdAt": "2020-08-06T21:33:24Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Authorization config.\");\n+        }", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833417", "bodyText": "refactored to do  best-effort parsing and loading, and improve logging at each stage", "author": "avipinku", "createdAt": "2020-08-07T05:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNzU2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466707567", "bodyText": "Shouldn't you do null check on the componentName before parse the policy?", "author": "fengwang666", "createdAt": "2020-08-06T21:55:41Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+                    try {\n+                        Topic updatedTopic = (Topic) newv;\n+                        String componentName = findServiceForNode(updatedTopic);", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833427", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNzU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODM2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466708360", "bodyText": "Is this expected or not? If it's expected, the code can just return.", "author": "fengwang666", "createdAt": "2020-08-06T21:57:50Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -144,24 +189,60 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         isComponentRegistered(componentName);\n         validatePolicyId(policies);\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             validatePrincipals(policy);\n             validateOperations(componentName, policy);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n         }\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Update authZ policies for a single component. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * This method clears the existing policies for a component before refreshing with the updated list.\n+     *\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833452", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMjMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466712308", "bodyText": "Can this ever happen?", "author": "fengwang666", "createdAt": "2020-08-06T22:08:05Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833465", "bodyText": "If the customer specifies the ACL as a map instead of a list or makes a similar formatting error, this will happen", "author": "avipinku", "createdAt": "2020-08-07T05:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMjMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzAzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466713038", "bodyText": "Why not just log and ignore? throw an exception up to the stack is very intrusive. How would the call handle it better?", "author": "fengwang666", "createdAt": "2020-08-06T22:10:08Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833477", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzY2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466713665", "bodyText": "Same comment. Is throwing an exception up the best way to handle the error?", "author": "fengwang666", "createdAt": "2020-08-06T22:11:56Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+\n+                if (policyId == null) {\n+                    String errorMessage = \"Policy ID is missing or invalid\";\n+                    logger.atError(\"missing-policy-component-policyId\")\n+                            .log(errorMessage);\n+                    throw new AuthorizationException(errorMessage);\n+                }\n+                if (operations == null || operations.isEmpty()) {\n+                    String errorMessage = \"Policy operations are missing or invalid\";\n+                    logger.atError(\"missing-policy-component-operations\")\n+                            .log(errorMessage);\n+                    throw new AuthorizationException(errorMessage);\n+                }", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833494", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-07T05:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzY2NQ=="}], "type": "inlineReview"}, {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "message": "Rename AuthorizationUtilsTest to AuthorizationPolicyParserTest", "committedDate": "2020-08-07T17:17:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTQ0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467295446", "bodyText": "this cast is unsafe. Use instanceof to make sure it actually is a topic.", "author": "MikeDombo", "createdAt": "2020-08-07T21:49:59Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +37,57 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+\n+                    Topic updatedTopic = (Topic) newv;", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDgyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344824", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjUyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296527", "bodyText": "use compute otherwise this isn't threadsafe.", "author": "MikeDombo", "createdAt": "2020-08-07T21:51:21Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDgyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344828", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296706", "bodyText": "extra space in single component.", "author": "MikeDombo", "createdAt": "2020-08-07T21:51:34Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344842", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-08T01:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296991", "bodyText": "Why is this a warning, that's not a problem is it?", "author": "MikeDombo", "createdAt": "2020-08-07T21:51:56Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344857", "bodyText": "if this is empty, this means that an ACL was likely malformed or failed to load, since the AuthorizationPolicyParser would have registered an empty ACL list to a componentName that has the \"accessControl\" field.", "author": "avipinku", "createdAt": "2020-08-08T01:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyOTg0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468129842", "bodyText": "But why is that a problem for the acl list to be empty? That is definitely possible to happen, right?", "author": "MikeDombo", "createdAt": "2020-08-10T19:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1ODIxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468158212", "bodyText": "Yeah, you're right. I've changed this to a debug-level log.", "author": "avipinku", "createdAt": "2020-08-10T20:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467297639", "bodyText": "why does it need to be registered first? Why not just handle the registration here?", "author": "MikeDombo", "createdAt": "2020-08-07T21:52:47Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+        try {\n+            isComponentRegistered(componentName);", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTA1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345050", "bodyText": "I think we want each component to register itself on startup, instead of during policy loading. If we registered components here, customers would be able to register all sorts of services just by passing in the config, which seems like a bad idea.", "author": "avipinku", "createdAt": "2020-08-08T01:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMjE0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468132146", "bodyText": "Not sure I follow this logic. Can you explain more? How does registration work, and why can't it be done on-demand instead of during startup? Also, it can't just be during startup because things need to be dynamic.", "author": "MikeDombo", "createdAt": "2020-08-10T19:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0ODIzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468148238", "bodyText": "Registration lets the Auth module know about the operations a component wishes to register for auth. Without such a method, its not possible to validate whether an ACL is valid with a defined operation. What is your suggestion on how to implement such a mechanism.", "author": "prateek-y", "createdAt": "2020-08-10T20:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0OTY3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468149670", "bodyText": "My suggestion is that you don't. The version of a resource server could change at any time which would then make the ACL valid or invalid. We should allow this.", "author": "MikeDombo", "createdAt": "2020-08-10T20:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1NDEzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468154134", "bodyText": "Lets remove the isRegistered part for now. This still has benefit that when a customer specifies an ACL, it is possible to know immediately whether it will work correctly in the future. If we do not have validateOperation then customers will only know that ACL was malformed, when they actually send requests for auth which gets rejected and it will be annoying experience.", "author": "prateek-y", "createdAt": "2020-08-10T20:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MTM5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468191399", "bodyText": "isComponentRegistered actually already doesn't check registration due to the issue we had earlier with the AuthHandler starting before components are registered. I commented out the registration check in isComponentRegistered and added a TODO with SIM link to revisit this.\nI'm leaving the isComponentRegistered check in here for now though, since we have a unit test that tests if the componentName is null.", "author": "avipinku", "createdAt": "2020-08-10T21:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODUyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467298521", "bodyText": "just use put.", "author": "MikeDombo", "createdAt": "2020-08-07T21:53:58Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+        try {\n+            isComponentRegistered(componentName);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-unregistered-component\", e)\n+                    .log(\"Component {} is not registered with the AuthorizationHandler\", componentName);\n+            return;\n+        }\n+\n+        try {\n+            validatePolicyId(policies);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-invalid-policy\", e)\n+                    .log(\"Component {} contains an invalid policy\", componentName);\n+            return;\n+        }\n+\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n+        for (AuthorizationPolicy policy : policies) {\n+            try {\n+                validatePrincipals(policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-principal\", e)\n+                        .log(\"Component {} contains an invalid principal in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+            try {\n+                validateOperations(componentName, policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-operation\", e)\n+                        .log(\"Component {} contains an invalid operation in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+        }\n+        if (isUpdate) {\n+            authModule.clearComponentPermissions(componentName);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        for (AuthorizationPolicy policy : policies) {\n+            try {\n+                addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-add-permission-error\", e)\n+                        .log(\"Error while loading policy {} for component {}\",  policy.getPolicyId(),\n+                                componentName);\n+                continue;\n+            }\n+        }\n+\n+        if (isUpdate) {\n+            this.componentToAuthZConfig.replace(componentName, policies);\n+        } else {\n+            this.componentToAuthZConfig.put(componentName, policies);", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344873", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467299429", "bodyText": "why do you need this?", "author": "MikeDombo", "createdAt": "2020-08-07T21:55:11Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -11,10 +11,34 @@\n \n @Value\n @Builder\n-public class AuthorizationPolicy {\n+public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n     @NonNull String policyId;\n     String policyDescription;\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");\n+\n+        private final String name;\n+\n+        PolicyComponentTypes(String s) {\n+            name = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.name;\n+        }\n+    }\n+\n+    @Override\n+    public int compareTo(AuthorizationPolicy other) {\n+        return this.policyId.compareTo(other.policyId);\n+    }", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344875", "bodyText": "parseAllAuthorizationPolicies() returns an unsorted HashMap, which can cause unit tests to fail between test runs due to differences in policy ordering. I can probably change it to use a TreeMap instead and get rid of this", "author": "avipinku", "createdAt": "2020-08-08T01:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTA5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345096", "bodyText": "You also could change the tests to use the hamcrest matcher containsInAnyOrder, depending on what exactly you're testing", "author": "MikeDombo", "createdAt": "2020-08-08T01:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTM4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345385", "bodyText": "I'd rather not use containsInAnyOrder since I'm checking that each field in the policy matches the expected value.\nI think it may actually be useful to keep this compareTo because otherwise we have no way of comparing policies against each other...", "author": "avipinku", "createdAt": "2020-08-08T01:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTUzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345537", "bodyText": "why would order matter?", "author": "MikeDombo", "createdAt": "2020-08-08T01:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTkxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345914", "bodyText": "Not specifically just for ordering but if we need to compare policies at some point down the road...it doesn't matter too much either way I suppose.", "author": "avipinku", "createdAt": "2020-08-08T01:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTc4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467299785", "bodyText": "instead of catching you can just use instanceof to make sure the cast is safe.", "author": "MikeDombo", "createdAt": "2020-08-07T21:55:39Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344880", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467300519", "bodyText": "the key can't be null anyway, so I don't think this check is needed", "author": "MikeDombo", "createdAt": "2020-08-07T21:56:38Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"load-authorization-access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344884", "bodyText": "removed", "author": "avipinku", "createdAt": "2020-08-08T01:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDkzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467300938", "bodyText": "replace \"service\" with \"component\" everywhere.", "author": "MikeDombo", "createdAt": "2020-08-07T21:57:09Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"load-authorization-access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+                if (policyId == null) {\n+                    logger.atError(\"load-authorization-missing-policy-component-policyId\")\n+                            .log(\"Policy ID is missing or invalid\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            logger.atError(\"load-authorization-config-unknown policy key\")\n+                                    .log(\"Component {} has an invalid policy key in policy {}\", componentName,\n+                                            policyId);\n+                            continue;\n+                    }\n+                }\n+\n+                if (Utils.isEmpty(operations)) {\n+                    String errorMessage = \"Policy operations are missing or invalid\";\n+                    logger.atError(\"load-authorization-missing-policy-component-operations\")\n+                            .log(errorMessage);\n+                    continue;\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(policyId)\n+                        .policyDescription(policyDescription)\n+                        .principals(java.util.Collections.singleton(componentName))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-service-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344892", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDkzOA=="}], "type": "inlineReview"}, {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/68a368746998c94522d4c36d57bf7fa3507330cc", "message": "Revised according to feedback", "committedDate": "2020-08-10T17:53:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNTcxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468125717", "bodyText": "[nit]\nInject these for easier testing.", "author": "MikeDombo", "createdAt": "2020-08-10T19:23:19Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +36,61 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();", "originalCommit": "68a368746998c94522d4c36d57bf7fa3507330cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1ODAzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468158036", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-10T20:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNjMxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468126318", "bodyText": "[nit]\nAdd a k-v for the Node's full name", "author": "MikeDombo", "createdAt": "2020-08-10T19:24:16Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +36,61 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+                    if (!(newv instanceof Topic)) {\n+                        logger.atError(\"update-authorization-formatting-error\")", "originalCommit": "68a368746998c94522d4c36d57bf7fa3507330cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1Nzk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468157993", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-10T20:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNjMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMzQ4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468133482", "bodyText": "the enum isn't invalid, the value is invalid. Change this to \"UNKNOWN\" or \"INVALID_VALUE\"", "author": "MikeDombo", "createdAt": "2020-08-10T19:30:50Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -11,10 +11,34 @@\n \n @Value\n @Builder\n-public class AuthorizationPolicy {\n+public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n     @NonNull String policyId;\n     String policyDescription;\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");", "originalCommit": "68a368746998c94522d4c36d57bf7fa3507330cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1NzkzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468157932", "bodyText": "changed to UNKNOWN", "author": "avipinku", "createdAt": "2020-08-10T20:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMzQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzEyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468233122", "bodyText": "If you're using constructor injection, move this into the constructor instead. Unless there's a reason not to.", "author": "MikeDombo", "createdAt": "2020-08-10T23:05:00Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -29,32 +38,81 @@\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler implements InjectionActions {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+\n+    private final AuthorizationPolicyParser policyParser;\n+\n+    @Override\n+    public void postInject() {", "originalCommit": "94ef07ebab1e8b1bc05374de9caadfa6575119ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzQxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468237412", "bodyText": "Yeah, this is a relic of when I was using field injection. Removed.", "author": "avipinku", "createdAt": "2020-08-10T23:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNDkyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468234923", "bodyText": "again, you could use instanceof instead of catching the exception.", "author": "MikeDombo", "createdAt": "2020-08-10T23:10:58Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                  Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        Object accessControlTopicObject = accessControlTopic.getOnce();\n+\n+        if (!(accessControlTopicObject instanceof List)\n+                || Utils.isEmpty((List) accessControlTopicObject)\n+                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n+            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n+                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {", "originalCommit": "94ef07ebab1e8b1bc05374de9caadfa6575119ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0MTI1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468241259", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-10T23:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNDkyMw=="}], "type": "inlineReview"}, {"oid": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-10T23:11:44Z", "type": "forcePushed"}, {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d01e679683db12e548169c3380e42f1f1b57bc7", "message": " Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-10T23:27:06Z", "type": "commit"}, {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d01e679683db12e548169c3380e42f1f1b57bc7", "message": " Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-10T23:27:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3NTc2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468275761", "bodyText": "Why are we loading tes here? Can tes load itself?", "author": "MikeDombo", "createdAt": "2020-08-11T01:32:23Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -29,32 +37,73 @@\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler  {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+    \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n+     * @param authModule authorization module to store the authorization state\n+     * @param policyParser for parsing a given policy ACL\n      */\n     @Inject\n-    public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n+    public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n+                                AuthorizationPolicyParser policyParser) {\n         this.kernel = kernel;\n+        this.authModule = authModule;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Load default policy for TES\n+        this.loadAuthorizationPolicies(TOKEN_EXCHANGE_SERVICE_TOPICS,", "originalCommit": "5d01e679683db12e548169c3380e42f1f1b57bc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3OTcyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468279723", "bodyText": "We would need this consolidated now, as in the future, components might declare exclusive access to TES. So tes would have to subscribe for auth changes as well. Earlier the plan was that a component would only manage its own auth, so it made sense. Going forward we need to think about default policies in general.", "author": "prateek-y", "createdAt": "2020-08-11T01:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3NTc2MQ=="}], "type": "inlineReview"}, {"oid": "b6f79ca3724dda9bde072197472dee8d3865140e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6f79ca3724dda9bde072197472dee8d3865140e", "message": "Merge branch 'master' into authZ_pubsub", "committedDate": "2020-08-11T02:26:33Z", "type": "commit"}]}