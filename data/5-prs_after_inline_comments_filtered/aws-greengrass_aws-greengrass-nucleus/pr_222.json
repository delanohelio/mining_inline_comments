{"pr_number": 222, "pr_title": "Config store IPC server-side", "pr_createdAt": "2020-05-04T21:05:17Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222", "timeline": [{"oid": "840107cdf5df20f77156ddb995445d2fbae3e062", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/840107cdf5df20f77156ddb995445d2fbae3e062", "message": "Config store IPC", "committedDate": "2020-05-04T21:07:35Z", "type": "forcePushed"}, {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a8aa6c95835d363cce4d94f152256a9051538edc", "message": "Config store IPC", "committedDate": "2020-05-04T21:44:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MzY5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419743695", "bodyText": "Are we sending the entire custom config to listeners on every change?", "author": "ShirleyZheng92", "createdAt": "2020-05-04T21:36:11Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigValueChangedEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> listeners = new ConcurrentHashMap<>();", "originalCommit": "840107cdf5df20f77156ddb995445d2fbae3e062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1OTg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419759865", "bodyText": "Yes we are. You are not subscribing to any sub-tree, you just subscribe to the whole thing.", "author": "MikeDombo", "createdAt": "2020-05-04T22:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MzY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2MzgxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419763813", "bodyText": "However this is definitely up for discussion.", "author": "MikeDombo", "createdAt": "2020-05-04T22:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MzY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0NDkxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419744911", "bodyText": "I'd prefer this under EvergreenService class's static method", "author": "ShirleyZheng92", "createdAt": "2020-05-04T21:38:48Z", "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -153,6 +157,35 @@ public boolean childOf(String n) {\n         return n.equals(name) || parent != null && parent.childOf(n);\n     }\n \n+    /**\n+     * Get path of parents.\n+     *\n+     * @return list of strings with index 0 being the current node's name\n+     */\n+    public List<String> path() {\n+        ArrayList<String> parents = new ArrayList<>();\n+        parents.add(name);\n+\n+        if (parent != null) {\n+            parents.addAll(parent.path());\n+        }\n+        return parents;\n+    }\n+\n+    /**\n+     * Find the service that this node belongs to (or null if it is not under a service).\n+     *\n+     * @return service name or null\n+     */\n+    public String findService() {", "originalCommit": "840107cdf5df20f77156ddb995445d2fbae3e062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2MDE4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419760187", "bodyText": "Can you explain more, that doesn't make much sense to me. I have a reference to some Node and I want to know what service it belongs to.", "author": "MikeDombo", "createdAt": "2020-05-04T22:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0NDkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxMzgwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419813807", "bodyText": "IMO basically something like EvergreenService.findService(Node node);\nconfiguration store as a key-value store doesn't have the concept of 'service'", "author": "ShirleyZheng92", "createdAt": "2020-05-05T01:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0NDkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzU4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419753583", "bodyText": "If we are always completing the future before returning, what's the point of using Future?", "author": "ShirleyZheng92", "createdAt": "2020-05-04T21:57:25Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.aws.iot.evergreen.ipc.modules;\n+\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader.Message;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreClientOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+//TODO: see if this needs to be a GGService\n+@ImplementsService(name = \"configstoreipc\", autostart = true)\n+public class ConfigStoreIPCService extends EvergreenService {\n+    private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent agent;\n+\n+    public ConfigStoreIPCService(Topics c) {\n+        super(c);\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.CONFIG_STORE;\n+        super.postInject();\n+        try {\n+            router.registerServiceCallback(destination.getValue(), this::handleMessage);\n+            logger.atInfo().setEventType(\"ipc-register-request-handler\").addKeyValue(\"destination\", destination.name())\n+                    .log();\n+        } catch (IPCException e) {\n+            logger.atError().setEventType(\"ipc-register-request-handler-error\").setCause(e)\n+                    .addKeyValue(\"destination\", destination.name())\n+                    .log(\"Failed to register service callback to destination\");\n+        }\n+    }\n+\n+    /**\n+     * Handle all requests from the client.\n+     *\n+     * @param message the incoming request\n+     * @param context caller request context\n+     * @return future containing our response\n+     */\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    public Future<Message> handleMessage(Message message, ConnectionContext context) {\n+        CompletableFuture<Message> fut = new CompletableFuture<>();\n+\n+        ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n+        try {\n+            //TODO: add version compatibility check\n+            ConfigStoreClientOpCodes opCode = ConfigStoreClientOpCodes.values()[applicationMessage.getOpCode()];\n+            ConfigStoreGenericResponse configStoreGenericResponse = new ConfigStoreGenericResponse();\n+            if (ConfigStoreClientOpCodes.SUBSCRIBE_ALL.equals(opCode)) {\n+                configStoreGenericResponse = agent.subscribe(context);\n+            } else {\n+                configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);\n+                configStoreGenericResponse.setErrorMessage(\"Unknown request type \" + opCode.toString());\n+            }\n+\n+            ApplicationMessage responseMessage = ApplicationMessage.builder().version(applicationMessage.getVersion())\n+                    .payload(CBOR_MAPPER.writeValueAsBytes(configStoreGenericResponse)).build();\n+            fut.complete(new Message(responseMessage.toByteArray()));", "originalCommit": "a8aa6c95835d363cce4d94f152256a9051538edc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2MTM5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419761396", "bodyText": "This is the interface of our IPC right now. This may well change when we rewrite IPC, however the point is that it gives us flexibility to use another thread if we wanted. All the IPC stuff you see here is just how all our other IPC services work and was copied and then changed from the existing services.", "author": "MikeDombo", "createdAt": "2020-05-04T22:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxMzkwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419813901", "bodyText": "Ok. We can revisit the IPC API", "author": "ShirleyZheng92", "createdAt": "2020-05-05T01:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1ODE0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419758148", "bodyText": "can this be in AfterEach?", "author": "ShirleyZheng92", "createdAt": "2020-05-04T22:08:13Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -186,4 +198,53 @@ void lifecycleTest(ExtensionContext context) throws Exception {\n         ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n         client.disconnect();\n     }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_initial_state_sent(ExtensionContext context) throws Exception {\n+        KernelIPCClientConfig config = KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.findServiceTopic(\"ServiceName\").findLeafChild(SERVICE_UNIQUE_ID_KEY).getOnce())\n+                .build();\n+        IPCClient client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<Map<String, Object>>> p = TestUtils.asyncAssertOnConsumer((a) -> {\n+            assertThat(a, anEmptyMap());\n+        });\n+\n+        c.subscribe(p.getRight());\n+        p.getLeft().get(500, TimeUnit.MILLISECONDS);\n+        client.disconnect();", "originalCommit": "a8aa6c95835d363cce4d94f152256a9051538edc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2MDcyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419760728", "bodyText": "NIT: can you add comment on this function?", "author": "ShirleyZheng92", "createdAt": "2020-05-04T22:14:23Z", "path": "src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java", "diffHunk": "@@ -35,12 +36,21 @@ private TestUtils() {\n     }\n \n     public static <A> Pair<CompletableFuture<Void>, Consumer<A>> asyncAssertOnConsumer(Consumer<A> c) {\n+        return asyncAssertOnConsumer(c, 1);\n+    }\n+\n+    public static <A> Pair<CompletableFuture<Void>, Consumer<A>> asyncAssertOnConsumer(Consumer<A> c, int numCalls) {", "originalCommit": "a8aa6c95835d363cce4d94f152256a9051538edc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTIwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419789201", "bodyText": "Nit- Should this have State in the name?", "author": "shaguptashaikh", "createdAt": "2020-05-04T23:36:09Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigValueChangedEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = node.findService();\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+        // Ensure that the node which changed was part of the custom config\n+        if (node.path().lastIndexOf(EvergreenService.CUSTOM_CONFIG_NAMESPACE) < 0) {\n+            return;\n+        }\n+\n+        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n+                .map(Map.Entry::getValue).forEach(c -> c.accept(\n+                kernel.findServiceTopic(serviceName).createInteriorChild(EvergreenService.CUSTOM_CONFIG_NAMESPACE)\n+                        .toPOJO()));\n+    };\n+\n+    @Override\n+    public void postInject() {\n+        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> listeners.remove(context));\n+            return sendStateUpdateToListener(context);\n+        });\n+\n+        // Immediately send the current state\n+        listeners.get(context).accept(kernel.findServiceTopic(context.getServiceName())\n+                .createInteriorChild(EvergreenService.CUSTOM_CONFIG_NAMESPACE).toPOJO());\n+\n+        return ConfigStoreGenericResponse.builder().status(ConfigStoreResponseStatus.Success).build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendStateUpdateToListener(ConnectionContext context) {", "originalCommit": "a8aa6c95835d363cce4d94f152256a9051538edc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMTU1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419831556", "bodyText": "No, all this was copied from the lifecycle IPC. I thought I changed it all. I'll update the name.", "author": "MikeDombo", "createdAt": "2020-05-05T02:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTIwMQ=="}], "type": "inlineReview"}, {"oid": "9de4a7e7575fed5b5fd8455753a0d8bd368ef624", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9de4a7e7575fed5b5fd8455753a0d8bd368ef624", "message": "Config store IPC", "committedDate": "2020-05-05T19:04:31Z", "type": "commit"}, {"oid": "26715fc2eab5da4762eba0cfe5a3876b97fe299d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/26715fc2eab5da4762eba0cfe5a3876b97fe299d", "message": "Add read() for Config IPC and update subscribe", "committedDate": "2020-05-05T22:58:50Z", "type": "forcePushed"}, {"oid": "7ca54f3651f8da32c546e2ecca7738136c64f58e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7ca54f3651f8da32c546e2ecca7738136c64f58e", "message": "Add read() for Config IPC and update subscribe", "committedDate": "2020-05-05T23:05:02Z", "type": "forcePushed"}, {"oid": "5391dd6d8b43e9f17e89711663471314bfa3f346", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5391dd6d8b43e9f17e89711663471314bfa3f346", "message": "Add read() for Config IPC and update subscribe", "committedDate": "2020-05-05T23:16:47Z", "type": "forcePushed"}, {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "message": "Add read() for Config IPC and update subscribe", "committedDate": "2020-05-05T23:26:55Z", "type": "commit"}, {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "message": "Add read() for Config IPC and update subscribe", "committedDate": "2020-05-05T23:26:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODU5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r420938596", "bodyText": "I've was thinking about where the 'other' type of service runtime config should live, i.e. the one that service reads and writes like a datastore and doesn't change / rollback on deployments. If it lives under the custom namespace then once we introduce removal of config keys in merge, it might get wiped out on deployments because merge might think it was something that existed before but not anymore. It is only somewhat related to this change because depending on where that config lives i.e. under custom key or under a separate key, we will need to adjust this code a little bit too. That is not the scope of this PR though. this code is doing what its supposed to at the moment, but lets discuss the point above soon if it makes sense", "author": "shaguptashaikh", "createdAt": "2020-05-06T16:47:20Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        List<String> nodePath = node.path();\n+        // Ensure that the node which changed was part of the custom config\n+        int customConfigIndex = nodePath.lastIndexOf(CUSTOM_CONFIG_NAMESPACE);\n+        // Compare < 1 because we want to capture only changes under the \"custom\" key and not the \"custom\" key itself\n+        if (customConfigIndex < 1) {\n+            return;\n+        }\n+        // Ensure the path is <service_name>.custom.<other stuff>\n+        // path is reversed, so we check serviceNameIndex - 1 == customConfigIndex\n+        int serviceNameIndex = nodePath.lastIndexOf(serviceName);\n+        if (serviceNameIndex < 0 || (serviceNameIndex - 1) != customConfigIndex) {\n+            return;\n+        }\n+\n+        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n+                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath.get(customConfigIndex - 1)));\n+    };\n+\n+    @Override\n+    public void postInject() {\n+        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> listeners.remove(context));\n+            return sendStoreUpdateToListener(context);\n+        });\n+\n+        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+    }\n+\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context) {\n+        return (changedKey) -> {\n+            ConfigKeyChangedEvent valueChangedEvent = ConfigKeyChangedEvent.builder().changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Read specified key from the service's dynamic config.\n+     * @param readRequest read request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n+                ConfigStoreReadValueResponse.builder();\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        Topics configTopics = serviceTopic.findInteriorChild(CUSTOM_CONFIG_NAMESPACE);", "originalCommit": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0MDEyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r420940128", "bodyText": "I was thinking that like Feng mentioned in Chime, that they should be 2 separate namespaces. Therefore we'd need either separate APIs or else, to add another key/enum/boolean to choose between the \"custom\" space and the \"no-rollback\" (or whatever the proper name is) space.", "author": "MikeDombo", "createdAt": "2020-05-06T16:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5NDI5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r420994297", "bodyText": "NIT: getting path can be a one-time computation", "author": "ShirleyZheng92", "createdAt": "2020-05-06T18:14:01Z", "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -153,6 +155,21 @@ public boolean childOf(String n) {\n         return n.equals(name) || parent != null && parent.childOf(n);\n     }\n \n+    /**\n+     * Get path of parents.\n+     *\n+     * @return list of strings with index 0 being the current node's name\n+     */\n+    public List<String> path() {\n+        ArrayList<String> parents = new ArrayList<>();", "originalCommit": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDA4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421000082", "bodyText": "If using lastIndexOf(),  then customer can't have 'custom' keyword in their custom config . Currently our 'custom' keyword is located as 'services.\n<serviceName>.custom' , IMO it's safe to just check\nif ( !'custom'.equals(nodePath[2])) {\nreturn\n}", "author": "ShirleyZheng92", "createdAt": "2020-05-06T18:23:42Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        List<String> nodePath = node.path();\n+        // Ensure that the node which changed was part of the custom config\n+        int customConfigIndex = nodePath.lastIndexOf(CUSTOM_CONFIG_NAMESPACE);", "originalCommit": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMTA5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421001090", "bodyText": "No, this is the opposite. The path goes from current node to root, so they can have a, custom, b, custom, serviceName, services and that way we will find the real custom which is the last one.", "author": "MikeDombo", "createdAt": "2020-05-06T18:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzk1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421007950", "bodyText": "Then this will fail the case when a service is called 'custom' , although I doubt if customer would do that", "author": "ShirleyZheng92", "createdAt": "2020-05-06T18:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTE5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421009194", "bodyText": "Yes, I'm rewriting it to index from the end instead of using indexOf.", "author": "MikeDombo", "createdAt": "2020-05-06T18:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjcwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421002708", "bodyText": "In current implementation, when a field is removed, this listener will be invoked with (whatHappened.childRemoved, node) parameter, where node is the value before removal . This may cause unintentional behavior here.", "author": "ShirleyZheng92", "createdAt": "2020-05-06T18:28:13Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {", "originalCommit": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwODc5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421008796", "bodyText": "I think that is a good thing because removal is a change, and it shouldn't matter anyway since this config will cause the service to restart.", "author": "MikeDombo", "createdAt": "2020-05-06T18:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDQwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421004405", "bodyText": "If the existing config is custom.foo.bar.zoo and changed to custom.foo.bar.zoo2 , then listener will get the changed key of 'foo' instead of 'foo.bar' ?", "author": "ShirleyZheng92", "createdAt": "2020-05-06T18:30:57Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        List<String> nodePath = node.path();\n+        // Ensure that the node which changed was part of the custom config\n+        int customConfigIndex = nodePath.lastIndexOf(CUSTOM_CONFIG_NAMESPACE);\n+        // Compare < 1 because we want to capture only changes under the \"custom\" key and not the \"custom\" key itself\n+        if (customConfigIndex < 1) {\n+            return;\n+        }\n+        // Ensure the path is <service_name>.custom.<other stuff>\n+        // path is reversed, so we check serviceNameIndex - 1 == customConfigIndex\n+        int serviceNameIndex = nodePath.lastIndexOf(serviceName);\n+        if (serviceNameIndex < 0 || (serviceNameIndex - 1) != customConfigIndex) {\n+            return;\n+        }\n+\n+        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n+                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath.get(customConfigIndex - 1)));", "originalCommit": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwODE5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421008197", "bodyText": "Yes, we expose the custom config as a simple key-value store, not a nested store. That's an implementation detail that the customer doesn't need to know. To the customer there is just a single level to the store.", "author": "MikeDombo", "createdAt": "2020-05-06T18:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDQwNQ=="}], "type": "inlineReview"}, {"oid": "8fd611ef2e143a74881dd4e24f41e68149b89f99", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8fd611ef2e143a74881dd4e24f41e68149b89f99", "message": "Address PR comments", "committedDate": "2020-05-06T19:35:59Z", "type": "commit"}, {"oid": "3ac0b4fbc94efdfc2b81a24d7a7d686eec9d3185", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3ac0b4fbc94efdfc2b81a24d7a7d686eec9d3185", "message": "Merge branch 'master' into configstore", "committedDate": "2020-05-07T01:30:32Z", "type": "commit"}]}