{"pr_number": 281, "pr_title": "Cancel deployment and override safe update in deployment", "pr_createdAt": "2020-06-15T16:45:34Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjg3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440462873", "bodyText": "why is this message part of stdout context?", "author": "MikeDombo", "createdAt": "2020-06-15T21:41:00Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -539,13 +550,73 @@ void GIVEN_service_running_with_rollback_safe_param_WHEN_rollback_THEN_rollback_\n         kernel.getContext().removeGlobalStateChangeListener(listener);\n     }\n \n+    @Test\n+    void GIVEN_kernel_running_single_service_WHEN_deployment_with_skip_safety_check_config_THEN_merge_without_checking_safety()\n+            throws Throwable {\n+\n+        // GIVEN\n+        kernel.parseArgs(\"-i\", getClass().getResource(\"single_service.yaml\").toString());\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+        assertTrue(mainRunning.await(5, TimeUnit.SECONDS));\n+\n+        // WHEN\n+        CountDownLatch mainRestarted = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.countDown();\n+            }\n+        });\n+        AtomicBoolean safeUpdateSkipped= new AtomicBoolean();\n+        Consumer<EvergreenStructuredLogMessage> listener = (m) -> {\n+            if (\"Deployment is configured to skip safety check, not waiting for safe time to update\"", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxMDYyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441010626", "bodyText": "Also I feel this test might easily fail and very hard to debug if we rely on the trivial text match to set the safeUpdateSkipped. If someone changed the text thinking it's just logging/message, and this test will fail without explicit reason....", "author": "leaf94", "createdAt": "2020-06-16T17:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NTY1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441045656", "bodyText": "@MikeDombo  - It shouldn't be out of stdout context, fixing that next time,\n@leaf94 We're using this mechanism in quite a few tests where there is no other way to test that the code has reached a certain stage/performed a certain action as expected in the case of asynchronous workflows. While I agree that test may fail when someone changes the message but they will immediately find out while trying to build that and can fix it, in my opinion that's okay", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2NjMxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440466314", "bodyText": "maybe add a comment here to explain why this is hardcoded.\nI'm fine with the hardcoding, but just a note would be helpful", "author": "MikeDombo", "createdAt": "2020-06-15T21:49:01Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/converter/DeploymentDocumentConverter.java", "diffHunk": "@@ -55,10 +56,10 @@ public static DeploymentDocument convertFromLocalOverrideRequestAndRoot(LocalOve\n         List<DeploymentPackageConfiguration> packageConfigurations =\n                 buildDeploymentPackageConfigurations(localOverrideRequest, newRootComponents);\n \n-\n         return DeploymentDocument.builder().timestamp(localOverrideRequest.getRequestTimestamp())\n                 .deploymentId(localOverrideRequest.getRequestId()).rootPackages(rootPackages)\n-                .deploymentPackageConfigurationList(packageConfigurations).build();\n+                .deploymentPackageConfigurationList(packageConfigurations)\n+                .deploymentSafetyPolicy(DeploymentSafetyPolicy.SKIP_SAFETY_CHECK).build();", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5MDcyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440490723", "bodyText": "can you add comments on the different flows that can happen during cancellation. what happens when the deployment cannot be cancelled etc..", "author": "fahadmohammed01", "createdAt": "2020-06-15T22:55:05Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -241,10 +243,34 @@ private void finishCurrentDeployment() throws InterruptedException {\n \n     @SuppressWarnings(\"PMD.NullAssignment\")\n     private void cancelCurrentDeployment() {", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDAxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440514013", "bodyText": "Does this error happen when no packages are found?", "author": "hui-yang", "createdAt": "2020-06-16T00:12:21Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -112,8 +112,9 @@ public PackageManager(GreengrassRepositoryDownloader greengrassArtifactDownloade\n             packageMetadataList.addAll(\n                     greengrassPackageServiceHelper.listAvailablePackageMetadata(packageName, versionRequirement));\n         } catch (PackageDownloadException e) {\n-            logger.atInfo(\"list-package-versions\")", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyMTY3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440521675", "bodyText": "yes, that's how I found it, the cloud API does try to look it up by platform", "author": "shaguptashaikh", "createdAt": "2020-06-16T00:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440514991", "bodyText": "Can we encapsulate the two variables into a class?", "author": "hui-yang", "createdAt": "2020-06-16T00:15:45Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -29,6 +30,7 @@\n @Singleton\n public class UpdateSystemSafelyService extends EvergreenService {\n     private final Map<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final AtomicBoolean runningUpdateActions = new AtomicBoolean(false);", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTczNDgwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441734800", "bodyText": "I don't think we need to just now, we can do that if this class starts to have a lot more members and it makes sense to group some of them together in one class", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxODUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440518530", "bodyText": "Will this be able to handle situations where job1 is in progress, job2 is queued, and then job1 cancellation is received?", "author": "hui-yang", "createdAt": "2020-06-16T00:28:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -157,27 +158,28 @@ public void startup() throws InterruptedException {\n             // the waiting on currentProcessStatus in its own thread. I currently choose to not do this.\n             Deployment deployment = deploymentsQueue.peek();\n             if (deployment != null) {\n+                if (currentDeploymentTaskMetadata != null && deployment.isCancelled()) {\n+                    logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n+                            .log(\"Canceling the job\");\n+                    //Assuming cancel will either cancel the current job or wait till it finishes\n+                    cancelCurrentDeployment();\n+                }", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1ODM2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441058365", "bodyText": "I'm working on this case now", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxODUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTczNDk2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441734968", "bodyText": "This support has been added now", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxODUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxOTUwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440519505", "bodyText": "I have a small request on this code. Can we encapsulate the workflow from ln122 to ln136 in servicesChangeManager class, so that it can be used both here and in rollback?", "author": "hui-yang", "createdAt": "2020-06-16T00:31:47Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -61,87 +62,93 @@\n     public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n                                                      Map<Object, Object> newConfig) {\n         CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n-        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n-            kernel.getConfig().mergeMap(timestamp, newConfig);\n+            kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n             totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n-        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        AggregateServicesChangeManager servicesChangeManager =\n-                new AggregateServicesChangeManager(kernel, serviceConfig);\n+        if (performSafeUpdate(deploymentDocument.getDeploymentSafetyPolicy())) {\n+            kernel.getContext().get(UpdateSystemSafelyService.class)\n+                    .addUpdateAction(deploymentDocument.getDeploymentId(),\n+                            () -> updateActionForDeployment(newConfig, deploymentDocument, totallyCompleteFuture));\n+        } else {\n+            logger.atInfo().log(\"Deployment is configured to skip safety check, not waiting for safe time to update\");\n+            updateActionForDeployment(newConfig, deploymentDocument, totallyCompleteFuture);\n+        }\n \n+        return totallyCompleteFuture;\n+    }\n+\n+    private void updateActionForDeployment(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n+                                           CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n         String deploymentId = deploymentDocument.getDeploymentId();\n-        kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n \n-            // if the update is cancelled, don't perform merge\n-            if (totallyCompleteFuture.isCancelled()) {\n+        // if the update is cancelled, don't perform merge\n+        if (totallyCompleteFuture.isCancelled()) {\n+            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deployment\", deploymentId)\n+                    .log(\"Future was cancelled so no need to go through with the update\");\n+            return;\n+        }\n+\n+        FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+        if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+            try {\n+                takeSnapshotForRollback(deploymentId);\n+            } catch (IOException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                        .log(\"Failed to take a snapshot for rollback\");\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n                 return;\n             }\n+        }\n \n-            FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n-            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n+\n+        // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n+        long mergeTime = System.currentTimeMillis();\n+\n+        kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n+        // wait until topic listeners finished processing mergeMap changes.\n+        kernel.getContext().runOnPublishQueue(() -> {\n+            // polling to wait for all services to be started.\n+            kernel.getContext().get(ExecutorService.class).execute(() -> {\n+                //TODO: Add timeout\n                 try {\n-                    takeSnapshotForRollback(deploymentId);\n-                } catch (IOException e) {\n-                    // Failed to record snapshot hence did not execute merge, no rollback needed\n-                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                            .log(\"Failed to take a snapshot for rollback\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n-                    return;\n-                }\n-            }\n-            // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n-            long mergeTime = System.currentTimeMillis();\n-\n-            kernel.getConfig().mergeMap(timestamp, newConfig);\n-            // wait until topic listeners finished processing mergeMap changes.\n-            kernel.getContext().runOnPublishQueue(() -> {\n-                // polling to wait for all services to be started.\n-                kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                    //TODO: Add timeout\n-                    try {\n-                        servicesChangeManager.startNewServices();\n-\n-                        // Restart any services that may have been broken before this deployment\n-                        // This is added to allow deployments to fix broken services\n-                        servicesChangeManager.reinstallBrokenServices();\n-\n-                        Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                                .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                        waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                        logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                                + \" old services\");\n-                        if (totallyCompleteFuture.isCancelled()) {\n-                            // TODO : Does this need rolling back to old config?\n-                            logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                                    .log(\"merge-config-cancelled\");\n-                            return;\n-                        }\n-                        servicesChangeManager.removeObsoleteServices();\n-                        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                                .log(\"All services updated\");\n-                        totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n-                    } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                            | ExecutionException e) {\n-                        logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                                .log(\"Deployment failed\");\n-                        if (isAutoRollbackRequested(failureHandlingPolicy)) {\n-                            rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n-                        } else {\n-                            totallyCompleteFuture\n-                                    .complete(new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n-                        }\n+                    servicesChangeManager.startNewServices();", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1ODAwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441058008", "bodyText": "I will give it a shot, there are important logs in the forward vs rollback stage that are different in both cases and I need to give a thought to whether it's worth losing those logs", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxOTUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU2OTE3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440569176", "bodyText": "Do we not need to handle this situation? the current behavior is to cancel the ongoing deployment when a new deployment shows up.", "author": "fahadmohammed01", "createdAt": "2020-06-16T03:44:33Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -157,27 +158,28 @@ public void startup() throws InterruptedException {\n             // the waiting on currentProcessStatus in its own thread. I currently choose to not do this.\n             Deployment deployment = deploymentsQueue.peek();\n             if (deployment != null) {\n+                if (currentDeploymentTaskMetadata != null && deployment.isCancelled()) {\n+                    logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n+                            .log(\"Canceling the job\");\n+                    //Assuming cancel will either cancel the current job or wait till it finishes\n+                    cancelCurrentDeployment();\n+                }\n                 if (currentDeploymentTaskMetadata != null && !deployment.getDeploymentType()\n                         .equals(currentDeploymentTaskMetadata.getDeploymentType())) {\n                     // deployment from another source, wait till the current deployment finish\n                     continue;\n                 }\n-                if (currentDeploymentTaskMetadata != null\n-                        && currentDeploymentTaskMetadata.getDeploymentType() != null) {\n-                    if (deployment.getId().equals(currentDeploymentTaskMetadata.getDeploymentId()) && deployment\n-                            .getDeploymentType().equals(currentDeploymentTaskMetadata.getDeploymentType())) {\n-                        //Duplicate message and already processing this deployment so nothing is needed\n-                        deploymentsQueue.remove();\n-                        continue;\n-                    } else {\n-                        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentDeploymentTaskMetadata.getDeploymentId())\n-                                .log(\"Canceling the job\");\n-                        //Assuming cancel will either cancel the current job or wait till it finishes\n-                        cancelCurrentDeployment();", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTA2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441059060", "bodyText": "Can you elaborate what you mean by 'this' situation? we don't cancel when new deployment shows up, we cancel when a new event notification shows up that can be interpreted as needing cancellation", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU2OTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MDI3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440570275", "bodyText": "This new deployment cancels any ongoing deployment. How do we ensure that its the right deployment that is getting cancelled.\nSay deployment A is going on and device just finished it. Deployment B came through and is in progress, If deployment A gets cancelled now, wouldn't deployment B get cancelled instead of A", "author": "fahadmohammed01", "createdAt": "2020-06-16T03:49:24Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -157,27 +158,28 @@ public void startup() throws InterruptedException {\n             // the waiting on currentProcessStatus in its own thread. I currently choose to not do this.\n             Deployment deployment = deploymentsQueue.peek();\n             if (deployment != null) {\n+                if (currentDeploymentTaskMetadata != null && deployment.isCancelled()) {", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTczNjk4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441736981", "bodyText": "In the latest revision this is taken care of. Please see the cancel section of readme for deployments https://github.com/aws/aws-greengrass-kernel/blob/master/src/main/java/com/aws/iot/evergreen/deployment/README.md As mentioned there, until deployment A is in IN_PROGRESS status in cloud, we will keep getting the same job when we request next job execution until it is reported as succeeded or failed. So we will not encounter this specific scenario", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MDI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MDc4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440570780", "bodyText": "can we rename deploymentprocess to deploymentResultFuture as it is an instance of DeploymentResult", "author": "fahadmohammed01", "createdAt": "2020-06-16T03:51:33Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -241,10 +243,34 @@ private void finishCurrentDeployment() throws InterruptedException {\n \n     @SuppressWarnings(\"PMD.NullAssignment\")\n     private void cancelCurrentDeployment() {\n-        //TODO: Make the deployment task be able to handle the interrupt\n-        // and wait till the job gets cancelled or is finished\n-        if (currentDeploymentTaskMetadata != null) {\n-            currentDeploymentTaskMetadata.getDeploymentProcess().cancel(true);\n+        if (currentDeploymentTaskMetadata.getDeploymentProcess() != null) {", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTczNzAzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441737036", "bodyText": "done", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440574135", "bodyText": "This is misleading, if the cancel is called after the L89 in updateActionForDeployment() then deployment goes forward, but this log would give the impression that the deployment was cancelled.", "author": "fahadmohammed01", "createdAt": "2020-06-16T04:06:46Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentTask.java", "diffHunk": "@@ -73,8 +87,34 @@ public DeploymentResult call()\n                 throw new RetryableDeploymentTaskFailureException(t);\n             }\n             throw new NonRetryableDeploymentTaskFailureException(t);\n-        } catch (InterruptedException | IOException | PackagingException e) {\n+        } catch (InterruptedException e) {\n+            // DeploymentTask received interrupt\n+            handleCancellation(preparePackagesFuture, deploymentMergeFuture);\n+            return null;\n+        } catch (IOException | PackagingException e) {\n             throw new RetryableDeploymentTaskFailureException(e);\n         }\n     }\n+\n+    /*\n+     * Handle deployment cancellation\n+     */\n+    private void handleCancellation(Future<Void> preparePackagesFuture,\n+                                    Future<DeploymentResult> deploymentMergeFuture) {\n+        // Stop downloading packages since the task was cancelled\n+        if (preparePackagesFuture != null && !preparePackagesFuture.isDone()) {\n+            preparePackagesFuture.cancel(true);\n+            logger.atInfo(DEPLOYMENT_TASK_EVENT_TYPE)\n+                    .kv(DEPLOYMENT_ID_LOGGING_KEY, deploymentDocument.getDeploymentId())\n+                    .log(\"Cancelled package download due to received interrupt\");\n+            return;\n+        }\n+        // Cancel deployment config merge future\n+        if (deploymentMergeFuture != null && !deploymentMergeFuture.isDone()) {\n+            deploymentMergeFuture.cancel(true);\n+            logger.atInfo(DEPLOYMENT_TASK_EVENT_TYPE)", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2Njg4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441066885", "bodyText": "updateActionForDeployment() has a check where if the future is cancelled, then don't go ahead with the actual update and return immediately so ideally it should effectively do what we want when the code reaches this point", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NTQ3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441085478", "bodyText": "Yes, my point was if the future is cancelled after that check the deployment will proceed but this log message will indicate that the deployment was cancelled. Am i missing something?", "author": "fahadmohammed01", "createdAt": "2020-06-16T19:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTczODM1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441738352", "bodyText": "That will not happen, since if the merge future was beyond that point, then deployment service would have already discarded it so it will not go through", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzgzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r443277837", "bodyText": "As discussed offline, the logs here will be in-accurate if the future is cancelled after the L89 in updateActionForDeployment() and the updateActionForDeployment() is called directly because DeploymentSafetyPolicy is to SKIP_SAFETY_CHECK.", "author": "fahadmohammed01", "createdAt": "2020-06-22T01:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3OTAxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r443279010", "bodyText": "This log is now saying that it has cancelled the future, but doesnt guarantee that the cancellation was processed. There is a log in the merger that indicates when a deployment is beyond the point of being able to be cancelled. so there should be no confusion, are you suggesting we should change this log? if so, do you have a suggestion?", "author": "shaguptashaikh", "createdAt": "2020-06-22T01:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3OTc2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r443279762", "bodyText": "Do we want to interrupt the deploymentMergeFuture?\ndeploymentMergeFuture.cancel(true); <- should be false?\nWe want to let the deployment run its course if the merge has already started right?", "author": "fahadmohammed01", "createdAt": "2020-06-22T01:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4NjMwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r443286300", "bodyText": "Changed", "author": "shaguptashaikh", "createdAt": "2020-06-22T02:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDgzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440574832", "bodyText": "what happens if the current job is cancelled but there are other queued deployments? would this condition be true ?", "author": "fahadmohammed01", "createdAt": "2020-06-16T04:09:46Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -143,8 +143,15 @@\n             requestNextPendingJobDocument();\n             return;\n         }\n-        //TODO: If there was only one job, then indicate cancellation of that job.\n-        // Empty list will be received.\n+        if (jobs.isEmpty()) {", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTczODc1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441738753", "bodyText": "Please check latest revision which takes care of empty vs other queued jobs", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NDgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NTI4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440575288", "bodyText": "wouldnt returning the value of .remove be more meaning full? Should we make pendingActions concurrentHashMap?", "author": "fahadmohammed01", "createdAt": "2020-06-16T04:11:41Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -76,6 +79,32 @@ protected synchronized void runUpdateActions() {\n         for (EvergreenService s : kernel.orderedDependencies()) {\n             s.disruptionCompleted(); // Notify disruption is over\n         }\n+        runningUpdateActions.set(false);\n+    }\n+\n+    /**\n+     * Check if a pending action with the tag currently exists.\n+     *\n+     * @param tag tag to identify an update action\n+     * @return true if there is a pending action for specified tag\n+     */\n+    public boolean hasPendingUpdateAction(String tag) {\n+        return pendingActions.containsKey(tag);\n+    }\n+\n+    /**\n+     * Discard a pending action if update actions are not already running.\n+     *\n+     * @param tag tag to identify an update action\n+     * @return true if all update actions are pending and requested action could be discarded, false if update actions\n+     *         were already in progress so it's not safe to discard the requested action\n+     */\n+    public boolean discardPendingUpdateAction(String tag) {\n+        if (runningUpdateActions.get()) {\n+            return false;\n+        }\n+        pendingActions.remove(tag);", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NzUzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441067531", "bodyText": "Returning the value has no value for the consumer, deployment service only wants to know if there was an action and if it can be aborted before it starts, it is not interested in what that action is because it doesn't want to invoke it", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4OTA4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441089087", "bodyText": "I was vague, let me clarify. If the remove returns a non-null value it means that the update was removed successfully and deployment wont happen. (yes for this to work runUpdateActions() need to be updated to remove the action first before calling run on the action. Also pendingActions need to be a concurrentHashMap)\nUpdating likewise will ensure that if discardPendingUpdateAction() returns true,  the deployment will not proceed", "author": "fahadmohammed01", "createdAt": "2020-06-16T19:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0MTYwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441741601", "bodyText": "The map is a linkedhashmap so that all actions execute in the order that they were added so changing it to concurrenthashmap will mess up the order.\nAlso, the way discard is working should be adequate in my opinion, -\ni) if pendingActions map has the deployment (tag) and pending actions are running -> discard returns false because it's unsafe to do that now\nii) if pendingActions map has the deployment and pending actions are not running, we remove and return true\niii) if pending actions map does not have the deployment we do not need to do anything, we're already safe, so we return true.\nIn the case of concurrent read and write on the pendingActions map, even if the action gets added to the map, the merge future has a check for if it is cancelled, so it won't perform any action anyway", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3NTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU4MjM1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r440582352", "bodyText": "If discard can ensure that the queued update was discarded without being picked up, we dont have to call cancel on deploymentProcess future. If the deployment is not using UpdateSystemSafelyService the discard will return false and then cancelling the deploymentProcess would make sense.", "author": "fahadmohammed01", "createdAt": "2020-06-16T04:41:48Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -241,10 +243,34 @@ private void finishCurrentDeployment() throws InterruptedException {\n \n     @SuppressWarnings(\"PMD.NullAssignment\")\n     private void cancelCurrentDeployment() {\n-        //TODO: Make the deployment task be able to handle the interrupt\n-        // and wait till the job gets cancelled or is finished\n-        if (currentDeploymentTaskMetadata != null) {\n-            currentDeploymentTaskMetadata.getDeploymentProcess().cancel(true);\n+        if (currentDeploymentTaskMetadata.getDeploymentProcess() != null) {\n+            if (currentDeploymentTaskMetadata.getDeploymentProcess().isDone()) {\n+                logger.atInfo().log(\"Deployment already finished processing, cannot cancel now\");\n+            } else {\n+                boolean canCancelDeployment = context.get(UpdateSystemSafelyService.class)", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MjQ3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441062473", "bodyText": "That's not how it is working, discard API return true only when any updates are currently 'running'. Also, it is written this way to cover as many race conditions as possible, and to cancel if the deployment workflow is in a prior stage like downloading etc, so it's best to cancel this future and have handling for it wherever possible", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU4MjM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxNTM5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441015397", "bodyText": "Similar to above comment about trivial string match... I know it is very hard but we could discuss about if possible to verify the state with variables somehow.", "author": "leaf94", "createdAt": "2020-06-16T17:18:29Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -314,6 +314,93 @@ void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_roll\n         assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, result.getDeploymentStatus());\n     }\n \n+    @Test\n+    @Order(6)\n+    void GIVEN_services_running_WHEN_new_deployment_asks_to_skip_safety_check_THEN_deployment_is_successful(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(2, services.size());\n+        assertThat(services, containsInAnyOrder(\"main\", \"NonDisruptableService\"));\n+        assertEquals(\"1.0.0\", kernel.findServiceTopic(\"NonDisruptableService\")\n+                .find(\"version\").getOnce());\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"SkipSafetyCheck.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal, RedSignal\n+        assertEquals(2, services.size());\n+        assertThat(services, containsInAnyOrder(\"main\", \"NonDisruptableService\"));\n+        assertEquals(\"1.0.1\", kernel.findServiceTopic(\"NonDisruptableService\")\n+                .find(\"version\").getOnce());\n+        assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+    }\n+\n+    @Test\n+    @Order(7)\n+    void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_processing(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(2, services.size());\n+        assertThat(services, containsInAnyOrder(\"main\", \"NonDisruptableService\"));\n+\n+        CountDownLatch cdlUpdateStarted = new CountDownLatch(1);\n+        CountDownLatch cdlMergeCancelled = new CountDownLatch(1);\n+        Consumer<EvergreenStructuredLogMessage> listener = m -> {\n+            Map<String, String> contexts = m.getContexts();\n+            String messageOnStdout = contexts.get(\"stdout\");\n+            if (messageOnStdout != null && messageOnStdout.contains(\"checkIfSafeToUpdate decided it is unsafe to update now\")) {\n+                cdlUpdateStarted.countDown();\n+            }\n+            if (messageOnStdout != null && messageOnStdout.contains(\"Cancelled deployment merge due to interrupt\")) {\n+                cdlMergeCancelled.countDown();\n+            }", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1MTU3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441051573", "bodyText": "In this case I need to cancel only when the waiting for safe to update time has started and there is no way to find out that that has started since the waiting happens in the safe update service's startup thread and there is no return value", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxNTM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxNjAyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441016025", "bodyText": "Is this because the polling frequency is every 30 seconds? Could we reduce it? It shouldn't take 2 minutes to cancel this simple deployment right?", "author": "leaf94", "createdAt": "2020-06-16T17:19:25Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -314,6 +314,93 @@ void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_roll\n         assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, result.getDeploymentStatus());\n     }\n \n+    @Test\n+    @Order(6)\n+    void GIVEN_services_running_WHEN_new_deployment_asks_to_skip_safety_check_THEN_deployment_is_successful(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(2, services.size());\n+        assertThat(services, containsInAnyOrder(\"main\", \"NonDisruptableService\"));\n+        assertEquals(\"1.0.0\", kernel.findServiceTopic(\"NonDisruptableService\")\n+                .find(\"version\").getOnce());\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"SkipSafetyCheck.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal, RedSignal\n+        assertEquals(2, services.size());\n+        assertThat(services, containsInAnyOrder(\"main\", \"NonDisruptableService\"));\n+        assertEquals(\"1.0.1\", kernel.findServiceTopic(\"NonDisruptableService\")\n+                .find(\"version\").getOnce());\n+        assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+    }\n+\n+    @Test\n+    @Order(7)\n+    void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_processing(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(2, services.size());\n+        assertThat(services, containsInAnyOrder(\"main\", \"NonDisruptableService\"));\n+\n+        CountDownLatch cdlUpdateStarted = new CountDownLatch(1);\n+        CountDownLatch cdlMergeCancelled = new CountDownLatch(1);\n+        Consumer<EvergreenStructuredLogMessage> listener = m -> {\n+            Map<String, String> contexts = m.getContexts();\n+            String messageOnStdout = contexts.get(\"stdout\");\n+            if (messageOnStdout != null && messageOnStdout.contains(\"checkIfSafeToUpdate decided it is unsafe to update now\")) {\n+                cdlUpdateStarted.countDown();\n+            }\n+            if (messageOnStdout != null && messageOnStdout.contains(\"Cancelled deployment merge due to interrupt\")) {\n+                cdlMergeCancelled.countDown();\n+            }\n+        };\n+        Slf4jLogAdapter.addGlobalListener(listener);\n+\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"UpdateServiceWithSafetyCheck.json\").toURI(),\n+                System.currentTimeMillis());\n+\n+        assertTrue(cdlUpdateStarted.await(60, TimeUnit.SECONDS));\n+        resultFuture.cancel(true);\n+\n+        assertTrue(cdlMergeCancelled.await(120, TimeUnit.SECONDS));", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0MjI1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441742255", "bodyText": "Yes, I used a larger timeout for testing, but changed it back to what other tests are using, also this is just timeout, so we don't wait everytime for that long", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxNjAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxNzgyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441017821", "bodyText": "Like the comments here. Very helpful!", "author": "leaf94", "createdAt": "2020-06-16T17:22:28Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "diffHunk": "@@ -196,4 +203,64 @@ void GIVEN_deployment_fails_due_to_service_broken_WHEN_failure_policy_is_rollbac\n                 .describeJobExecution(DescribeJobExecutionRequest.builder().jobId(jobId2).thingName(thingInfo.getThingName())\n                         .build()).execution().statusDetails().detailsMap().get(\"detailed-deployment-status\"));\n     }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_some_running_services_WHEN_cancel_event_received_and_kernel_is_waiting_for_safe_time_THEN_deployment_should_be_canceled() throws Exception {\n+        // First Deployment to have some services running in Kernel which has a safety check configured\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .withFailureHandlingPolicy(FailureHandlingPolicy.DO_NOTHING)\n+                .addPackagesEntry(\"NonDisruptableService\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult1 = setAndPublishFleetConfiguration(setRequest1);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult1.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(3), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        // Second deployment to update the service which is currently running an important task so deployment should\n+        // wait for a safe time to update", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTk1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441019959", "bodyText": "Do we need this method? Seems it's more clear if just put this one line as condition.", "author": "leaf94", "createdAt": "2020-06-16T17:26:07Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -282,6 +290,13 @@ private boolean isAutoRollbackRequested(FailureHandlingPolicy failureHandlingPol\n         return FailureHandlingPolicy.ROLLBACK.equals(failureHandlingPolicy);\n     }\n \n+    /*\n+     * Evaluate if the customer specified deployment safety policy is to perform deployment at a safe time\n+     */\n+    private boolean performSafeUpdate(DeploymentSafetyPolicy deploymentSafetyPolicy) {\n+        return DeploymentSafetyPolicy.CHECK_SAFETY.equals(deploymentSafetyPolicy);\n+    }", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0MjMyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441742327", "bodyText": "Changed", "author": "shaguptashaikh", "createdAt": "2020-06-17T18:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMzU5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441023597", "bodyText": "We talked about this before but we didn't have to change at the time - AggregateServicesChangeManager could and should just be a singleton. It right now stores some states like, old services and new services but those could just be simple POJO or DTO - the manager should just take them as input and do the logic. No need to initialize a new AggregateServicesChangeManager every time for a new deployment.\nMaybe now it's the time to refactor this, as this class begins to grow to become unmanageable potentially. With AggregateServicesChangeManager separating out, unit test could also be added for it.", "author": "leaf94", "createdAt": "2020-06-16T17:32:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -61,87 +62,93 @@\n     public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n                                                      Map<Object, Object> newConfig) {\n         CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n-        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n-            kernel.getConfig().mergeMap(timestamp, newConfig);\n+            kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n             totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n-        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        AggregateServicesChangeManager servicesChangeManager =\n-                new AggregateServicesChangeManager(kernel, serviceConfig);\n+        if (performSafeUpdate(deploymentDocument.getDeploymentSafetyPolicy())) {\n+            kernel.getContext().get(UpdateSystemSafelyService.class)\n+                    .addUpdateAction(deploymentDocument.getDeploymentId(),\n+                            () -> updateActionForDeployment(newConfig, deploymentDocument, totallyCompleteFuture));\n+        } else {\n+            logger.atInfo().log(\"Deployment is configured to skip safety check, not waiting for safe time to update\");\n+            updateActionForDeployment(newConfig, deploymentDocument, totallyCompleteFuture);\n+        }\n \n+        return totallyCompleteFuture;\n+    }\n+\n+    private void updateActionForDeployment(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n+                                           CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n         String deploymentId = deploymentDocument.getDeploymentId();\n-        kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n \n-            // if the update is cancelled, don't perform merge\n-            if (totallyCompleteFuture.isCancelled()) {\n+        // if the update is cancelled, don't perform merge\n+        if (totallyCompleteFuture.isCancelled()) {\n+            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deployment\", deploymentId)\n+                    .log(\"Future was cancelled so no need to go through with the update\");\n+            return;\n+        }\n+\n+        FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+        if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+            try {\n+                takeSnapshotForRollback(deploymentId);\n+            } catch (IOException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                        .log(\"Failed to take a snapshot for rollback\");\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n                 return;\n             }\n+        }\n \n-            FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n-            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n+", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NzU2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441057561", "bodyText": "In my opinion it's not a problem that needs refactoring. The POJOs will need to be initialized every time anyway, this class was supposed to serve just as an abstraction that can be reused in forward and rollback deployments to improve readability, it's not a different stage in the deployment. Which is why it is serving both as a container of things like oldservice/newservice etc and exposes some methods that can be performed on them so that they work together.\nGiven that this PR is complex enough and still need a couple more complex edge cases to be solved, I will prioritize that over this", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMzU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNzY3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441027677", "bodyText": "From DeploymentTask got cancelled? How is this working together with line 66-70? Are they the same interruption but happen at the different time? If that's the case should we limit the try-catch block scope?", "author": "leaf94", "createdAt": "2020-06-16T17:39:15Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentTask.java", "diffHunk": "@@ -73,8 +87,34 @@ public DeploymentResult call()\n                 throw new RetryableDeploymentTaskFailureException(t);\n             }\n             throw new NonRetryableDeploymentTaskFailureException(t);\n-        } catch (InterruptedException | IOException | PackagingException e) {\n+        } catch (InterruptedException e) {\n+            // DeploymentTask received interrupt\n+            handleCancellation(preparePackagesFuture, deploymentMergeFuture);", "originalCommit": "50162b5e3826fef38918929073a7b44da70869df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NTM0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441065347", "bodyText": "It is to catch one rare case when the thread has just finished resolve config stage and not started merge stage, and it has been interrupted, but that has not resulted in the InterruptedException. When a task is cancelled, it receives .interrupt() from caller, but it may not immediately throw the InterruptedException if it's not waiting or blocked or sleeping. So in order to make use of the opportunity to not start merge at all if possible, I added line 66-70 so these two thing are working together", "author": "shaguptashaikh", "createdAt": "2020-06-16T18:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNzY3Nw=="}], "type": "inlineReview"}, {"oid": "9aff74a47b010c589c5a14f4b40ec82d24e56e4f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9aff74a47b010c589c5a14f4b40ec82d24e56e4f", "message": "Address comments, implement cancellation with queued jobs", "committedDate": "2020-06-17T03:41:43Z", "type": "forcePushed"}, {"oid": "751c4cfccabf05628223d120b3e255ec3987aaa0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/751c4cfccabf05628223d120b3e255ec3987aaa0", "message": "Address comments, implement cancellation with queued jobs", "committedDate": "2020-06-17T05:34:02Z", "type": "forcePushed"}, {"oid": "db9438d51952bb693eb0bb0a9e2fe261c78d5a5e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/db9438d51952bb693eb0bb0a9e2fe261c78d5a5e", "message": "Address comments, implement cancellation with queued jobs", "committedDate": "2020-06-17T17:41:41Z", "type": "forcePushed"}, {"oid": "075e5d6f9bbcc01b33b9773b4e36b0ba6e01e64e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/075e5d6f9bbcc01b33b9773b4e36b0ba6e01e64e", "message": "Address comments, implement cancellation with queued jobs", "committedDate": "2020-06-17T18:03:21Z", "type": "forcePushed"}, {"oid": "05d2c3a6c05dba8befd6311dfd057f6fef776d89", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/05d2c3a6c05dba8befd6311dfd057f6fef776d89", "message": "Address comments, implement cancellation with queued jobs", "committedDate": "2020-06-17T18:07:12Z", "type": "forcePushed"}, {"oid": "1f43304b36853bbaf2db2a245047dc22365909dc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1f43304b36853bbaf2db2a245047dc22365909dc", "message": "Address comments, implement cancellation with queued jobs", "committedDate": "2020-06-17T19:33:06Z", "type": "forcePushed"}, {"oid": "2fb11f6c34e6a8363e91e52e2e205eb330c7d674", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2fb11f6c34e6a8363e91e52e2e205eb330c7d674", "message": "Address comments, implement cancellation with queued jobs", "committedDate": "2020-06-17T19:38:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NjE0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441796146", "bodyText": "instead of doing a locate and passing the kernel, did you consider just injecting a reference to the DeploymentService class?", "author": "MikeDombo", "createdAt": "2020-06-17T19:53:29Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -570,6 +591,27 @@ protected void subscribeToEventNotifications(Consumer<JobExecutionsChangedEvent>\n         logger.atInfo().log(\"Subscribed to deployment job event notifications.\");\n     }\n \n+    private void evaluateCancellationAndCancelDeploymentIfNeeded() {\n+        try {\n+            EvergreenService deploymentServiceLocateResult = kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);", "originalCommit": "2fb11f6c34e6a8363e91e52e2e205eb330c7d674", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MzkxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r441863916", "bodyText": "First thing I tried, but dependency injection for deployment service has some problem, didn't spend much time on it, maybe it can be done with some minor fix", "author": "shaguptashaikh", "createdAt": "2020-06-17T22:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NjE0Ng=="}], "type": "inlineReview"}, {"oid": "9d46ec1f6a9e4602b22af90821f638f8dbfef813", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9d46ec1f6a9e4602b22af90821f638f8dbfef813", "message": "Changes due to new cloud sdk", "committedDate": "2020-06-17T22:11:05Z", "type": "forcePushed"}, {"oid": "d68f62c4b8aa9d6207b3a1f6efce51b34c6f5f6a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d68f62c4b8aa9d6207b3a1f6efce51b34c6f5f6a", "message": "Changes due to new cloud sdk", "committedDate": "2020-06-17T23:27:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2MjE5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r442362192", "bodyText": "Just to confirm the iot jobs behavior, if a device belongs to multiple groups, each of which schedules some deployments, this device will only get one iot job notification at a time. So there's really no chance that we have more than one deployments in the local queue from iot jobs. Multiple jobs in the local queue must be from different sources. Is that correct?", "author": "hui-yang", "createdAt": "2020-06-18T16:42:49Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -182,6 +192,15 @@\n             // This should not happen as we are converting a HashMap\n             return;\n         }\n+\n+        // Reaching this point means there is no IN_PROGRESS job in cloud because if there was, it would\n+        // have been deduplicated. The fact that we got the next queued deployment means that the previous\n+        // IN_PROGRESS job is either finished with SUCCEEDED/FAILED status or got cancelled", "originalCommit": "eb7514f69e09c054af5e4054a413f3ce262233e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjYxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/281#discussion_r442546617", "bodyText": "Yes, that's the correct understanding", "author": "shaguptashaikh", "createdAt": "2020-06-18T23:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2MjE5Mg=="}], "type": "inlineReview"}, {"oid": "674d78aeb39c6ce67ae52d9f198ebe9817e0a67d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/674d78aeb39c6ce67ae52d9f198ebe9817e0a67d", "message": "Implemented deployment cancellation for IoT jobs based deployments and safety check override", "committedDate": "2020-06-18T23:00:08Z", "type": "forcePushed"}, {"oid": "e724be32a65b09ba6b4a7f5bc26d2dc1318a267b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e724be32a65b09ba6b4a7f5bc26d2dc1318a267b", "message": "Implemented deployment cancellation for IoT jobs based deployments and safety check override", "committedDate": "2020-06-18T23:10:52Z", "type": "forcePushed"}, {"oid": "ea061668224216500431825240ccba541c86f3d3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea061668224216500431825240ccba541c86f3d3", "message": "Implemented deployment cancellation for IoT jobs based deployments and safety check override", "committedDate": "2020-06-18T23:53:02Z", "type": "forcePushed"}, {"oid": "1409688439c1a8ee84d4b8b8cb77df2738b80205", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1409688439c1a8ee84d4b8b8cb77df2738b80205", "message": "Implemented deployment cancellation for IoT jobs based deployments and safety check override", "committedDate": "2020-06-22T02:01:49Z", "type": "forcePushed"}, {"oid": "45e3c057f39e9690b9c51865c333a05e665617ef", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/45e3c057f39e9690b9c51865c333a05e665617ef", "message": "Implemented deployment cancellation for IoT jobs based deployments and safety check override", "committedDate": "2020-06-22T02:05:56Z", "type": "commit"}, {"oid": "45e3c057f39e9690b9c51865c333a05e665617ef", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/45e3c057f39e9690b9c51865c333a05e665617ef", "message": "Implemented deployment cancellation for IoT jobs based deployments and safety check override", "committedDate": "2020-06-22T02:05:56Z", "type": "forcePushed"}, {"oid": "0cfbd1b952949b812e56347bca5998e92e122c83", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0cfbd1b952949b812e56347bca5998e92e122c83", "message": "Merge branch 'master' into cancel-deployment", "committedDate": "2020-06-22T22:19:25Z", "type": "commit"}]}