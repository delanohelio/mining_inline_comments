{"pr_number": 154, "pr_title": "Refactor deployment service", "pr_createdAt": "2020-04-03T01:55:09Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTU4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403195580", "bodyText": "Theoretically we ought to be subscribing to these topics so that we can reconnect if it changes.", "author": "MikeDombo", "createdAt": "2020-04-03T17:54:39Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeviceConfigurationHelper.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.iot.evergreen.deployment.model.DeviceConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class for providing device configuration information.\n+ */\n+public class DeviceConfigurationHelper {\n+\n+    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n+    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n+    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n+    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n+    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    /**\n+     * Retrieves the device configuration information from kernel config to communicate with Iot Cloud.\n+     * @return {@link DeviceConfiguration}\n+     * @throws DeviceConfigurationException when configuration is not available for the device.\n+     */\n+    public DeviceConfiguration getDeviceConfiguration() throws DeviceConfigurationException {\n+        String thingName = getStringParameterFromConfig(DEVICE_PARAM_THING_NAME);\n+        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n+        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n+        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n+        String mqttClientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+        validateDeviceConfiguration(thingName, certificateFilePath, privateKeyPath, rootCAPath, mqttClientEndpoint);\n+        return new DeviceConfiguration(thingName, certificateFilePath, privateKeyPath, rootCAPath, mqttClientEndpoint);\n+    }\n+\n+    private String getStringParameterFromConfig(String parameterName) {\n+        String paramValue = \"\";\n+        //TODO: Update when device provisioning is implemented\n+        Topic childTopic = kernel.lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                DeploymentService.DEPLOYMENT_SERVICE_TOPICS).findLeafChild(parameterName);\n+        if (childTopic != null && childTopic.getOnce() != null) {\n+            paramValue = childTopic.getOnce().toString();", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTE5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403225199", "bodyText": "Yes, I am keeping the restart for later when device provisioning is implemented and expected behavior of restart is also clear.", "author": "abanthiy", "createdAt": "2020-04-03T18:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NjIwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403196202", "bodyText": "Should be null || empty?", "author": "MikeDombo", "createdAt": "2020-04-03T17:55:18Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeviceConfigurationHelper.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.iot.evergreen.deployment.model.DeviceConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class for providing device configuration information.\n+ */\n+public class DeviceConfigurationHelper {\n+\n+    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n+    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n+    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n+    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n+    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    /**\n+     * Retrieves the device configuration information from kernel config to communicate with Iot Cloud.\n+     * @return {@link DeviceConfiguration}\n+     * @throws DeviceConfigurationException when configuration is not available for the device.\n+     */\n+    public DeviceConfiguration getDeviceConfiguration() throws DeviceConfigurationException {\n+        String thingName = getStringParameterFromConfig(DEVICE_PARAM_THING_NAME);\n+        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n+        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n+        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n+        String mqttClientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+        validateDeviceConfiguration(thingName, certificateFilePath, privateKeyPath, rootCAPath, mqttClientEndpoint);\n+        return new DeviceConfiguration(thingName, certificateFilePath, privateKeyPath, rootCAPath, mqttClientEndpoint);\n+    }\n+\n+    private String getStringParameterFromConfig(String parameterName) {\n+        String paramValue = \"\";\n+        //TODO: Update when device provisioning is implemented\n+        Topic childTopic = kernel.lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                DeploymentService.DEPLOYMENT_SERVICE_TOPICS).findLeafChild(parameterName);\n+        if (childTopic != null && childTopic.getOnce() != null) {\n+            paramValue = childTopic.getOnce().toString();\n+        }\n+        return paramValue;\n+    }\n+\n+    private void validateDeviceConfiguration(String thingName, String certificateFilePath, String privateKeyPath,\n+                                             String rootCAPath, String clientEndpoint)\n+            throws DeviceConfigurationException {\n+        List<String> errors = new ArrayList<>();\n+        if (thingName != null && thingName.isEmpty()) {", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMTk1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403221952", "bodyText": "Yeah that's better.", "author": "abanthiy", "createdAt": "2020-04-03T18:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NjIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwODQ3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403208478", "bodyText": "Do the concatenation since this is on a single line.", "author": "MikeDombo", "createdAt": "2020-04-03T18:09:39Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -3,81 +3,220 @@\n \n package com.aws.iot.evergreen.deployment;\n \n+import com.aws.iot.evergreen.deployment.exceptions.AWSIotException;\n+import com.aws.iot.evergreen.deployment.exceptions.ConnectionUnavailableException;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeviceConfiguration;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n import lombok.NoArgsConstructor;\n-import software.amazon.awssdk.crt.CRT;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedSubscriptionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionSubscriptionRequest;\n \n+import java.time.Duration;\n import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n+import javax.inject.Inject;\n \n @NoArgsConstructor\n public class IotJobsHelper {\n \n-    public static final String UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC =\n+    protected static final String UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC =\n             \"$aws/things/{thingName}/jobs/{jobId}/update\" + \"/accepted\";\n-    public static final String UPDATE_SPECIFIC_JOB_REJECTED_TOPIC =\n+    protected static final String UPDATE_SPECIFIC_JOB_REJECTED_TOPIC =\n             \"$aws/things/{thingName}/jobs/{jobId}/update\" + \"/rejected\";", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMDIzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403230232", "bodyText": "Removed concat", "author": "abanthiy", "createdAt": "2020-04-03T18:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwODQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MjIxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404392213", "bodyText": "Remove the : , as it won't make any sense as a structured log.", "author": "MikeDombo", "createdAt": "2020-04-06T21:14:28Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -21,267 +25,153 @@\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n-\n+    @Inject\n     private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n+\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean isConnectedToCloud = new AtomicBoolean(false);\n+    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n \n-    private MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+    private final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n+            //TODO: what about error code 0\n             if (errorCode != 0) {\n-                logger.error(\"Connection interrupted: \" + errorCode + \": \" + CRT.awsErrorString(errorCode));\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                //TODO: Detect this using secondary mechanisms like checking if internet is availalble\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+                isConnectedToCloud.set(false);\n             }\n         }\n \n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n-            logger.info(\"Connection resumed: \" + (sessionPresent ? \"existing session\" : \"clean session\"));\n-        }\n-    };\n-\n-    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n-        /*\n-         * This message is received when either of these things happen\n-         * 1. Last job completed (successful/failed)\n-         * 2. A new job was queued\n-         * 3. A job was cancelled\n-         * This message receives the list of Queued and InProgress jobs at the time of this message\n-         */\n-        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n-        if (jobs.containsKey(JobStatus.QUEUED)) {\n-            //Do not wait on the future in this async handler,\n-            //as it will block the thread which establishes\n-            // the MQTT connection. This will result in frozen MQTT connection\n-            this.iotJobsHelper.requestNextPendingJobDocument();\n-        }\n-    };\n-\n-    private final Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-\n-        JobExecutionData jobExecutionData = response.execution;\n-        currentJobId = jobExecutionData.jobId;\n-        logger.atInfo()\n-                .log(\"Received job description for job id : {} and status {}\", currentJobId, jobExecutionData.status);\n-        logger.addDefaultKeyValue(\"JobId\", currentJobId);\n-        if (jobExecutionData.status == JobStatus.IN_PROGRESS) {\n-            //TODO: Check the currently running process,\n-            // if it is same as this jobId then do nothing. If not then there is something wrong\n-            return;\n-        } else if (jobExecutionData.status == JobStatus.QUEUED) {\n-            //If there is a job running at this time, then it has been canceled in cloud and should be attempted to\n-            // be canceled here\n-            if (currentProcessStatus != null && !currentProcessStatus.cancel(true)) {\n-                //If the cancel is not successful\n-                return;\n-            }\n-            iotJobsHelper.updateJobStatus(currentJobId, JobStatus.IN_PROGRESS, null);\n-\n-            logger.info(\"Updated the status of JobsId {} to {}\", currentJobId, JobStatus.IN_PROGRESS);\n-\n-\n-            DeploymentTask deploymentTask;\n-            try {\n-                deploymentTask = createDeploymentTask(response.execution.jobDocument);\n-            } catch (InvalidRequestException e) {\n-                logger.atError().setCause(e).addKeyValue(\"message\", e.getMessage())\n-                        .log(\"Caught InvalidRequestException while processing a deployment\");\n-                HashMap<String, String> statusDetails = new HashMap<>();\n-                statusDetails.put(\"error\", e.getMessage());\n-                updateJobAsFailed(currentJobId, statusDetails);\n-                return;\n-            }\n-            //Starting the job processing in another thread\n-            currentProcessStatus = executorService.submit(deploymentTask);\n-            logger.atInfo().log(\"Submitted the job with jobId {}\", jobExecutionData.jobId);\n+            logger.atInfo().kv(\"session\", (sessionPresent ? \"existing session\" : \"clean session\"))\n+                    .log(\"Connection resumed: \");", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MzQ2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404393467", "bodyText": "seems unnecessary, but if you want to keep it, that's fine.", "author": "MikeDombo", "createdAt": "2020-04-06T21:16:54Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,201 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match\n+        }\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n+    private void subscribeToIotJobTopics() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot subscribe to topics\");\n+            return;\n+        }\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n \n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n+    private Future<?> runInSeparateThread(Runnable method) {", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0Mzk4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404443983", "bodyText": "I put it for readability to highlight that in async handlers we run the same methods in separate threads", "author": "abanthiy", "createdAt": "2020-04-06T23:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MzQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDQ3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404394476", "bodyText": "Can you explain why ordering by modtime is needed? I understand that it is unordered, but this doesn't explain why we do want it to be ordered.", "author": "MikeDombo", "createdAt": "2020-04-06T21:18:47Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,201 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match\n+        }\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n+    private void subscribeToIotJobTopics() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot subscribe to topics\");\n+            return;\n+        }\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n \n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n \n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private void updateStatusOfPersistedDeployments() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot udpate the status of deploymentsQueue\");\n+            return;\n+        }\n+        synchronized (this.config) {\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            ArrayList<Topic> deployments = new ArrayList<>();\n+            processedDeployments.forEach(d -> deployments.add((Topic) d));\n+            //Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+            ArrayList<Topic> sortedByTimestamp =", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MTY5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404441696", "bodyText": "We want the statuses to be updated in the cloud in the order in which they were processed on the device. This will be accurate representation of what happened on the device, especially when deployment service processes multiple deployments in the order in which they come. Additionally, a customer workflow can depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may error out.", "author": "abanthiy", "createdAt": "2020-04-06T23:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MzM3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404443370", "bodyText": "That makes sense please put this as a comment in the code.", "author": "MikeDombo", "createdAt": "2020-04-06T23:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDkyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404394922", "bodyText": "use @setter ?", "author": "MikeDombo", "createdAt": "2020-04-06T21:19:38Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,201 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match\n+        }\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n+    private void subscribeToIotJobTopics() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot subscribe to topics\");\n+            return;\n+        }\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n \n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n \n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private void updateStatusOfPersistedDeployments() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot udpate the status of deploymentsQueue\");\n+            return;\n+        }\n+        synchronized (this.config) {\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            ArrayList<Topic> deployments = new ArrayList<>();\n+            processedDeployments.forEach(d -> deployments.add((Topic) d));\n+            //Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+            ArrayList<Topic> sortedByTimestamp =\n+                    (ArrayList<Topic>) deployments.stream().sorted(new Comparator<Topic>() {\n+                        @Override\n+                        public int compare(Topic o1, Topic o2) {\n+                            if (Long.valueOf(o1.getModtime()) > Long.valueOf(o2.getModtime())) {\n+                                return 1;\n+                            }\n+                            return -1;\n+                        }\n+                    }).collect(Collectors.toList());\n+\n+            Iterator iterator = sortedByTimestamp.iterator();\n+            while (iterator.hasNext()) {\n+                Topic topic = (Topic) iterator.next();\n+                Map<String, Object> deploymentDetails = (HashMap) topic.getOnce();\n+                String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n+                String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+                logger.atInfo().kv(\"Modified time\", topic.getModtime()).kv(JOB_ID_LOG_KEY_NAME, jobId)\n+                        .kv(\"Status\", status).kv(\"StatusDetails\",\n+                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS).toString())\n+                        .log(\"Updating status of persisted deployment\");\n+                try {\n+                    //TODO: Use the status updater as per the deployment type. Updating deployment status in\n+                    // IotJobs is different from updating a deployment coming from device shadow or local deployments.\n+                    iotJobsHelper.updateJobStatus(jobId, JobStatus.valueOf(status),\n+                            (HashMap<String, String>) deploymentDetails\n+                                    .get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS));\n+                } catch (ExecutionException e) {\n+                    if (e.getCause() instanceof MqttException) {\n+                        //caused due to connectivity issue\n+                        logger.atWarn().log(\"Caught exception while updating job status\");\n+                        break;\n+                    }\n+                    //This happens when job status update gets rejected from the Iot Cloud\n+                    //Want to remove this job from the list and continue updating others\n+                    logger.atError().kv(\"Status\", status).kv(JOB_ID_LOG_KEY_NAME, jobId).setCause(e)\n+                            .log(\"Job status update rejected\");\n+                } catch (TimeoutException e) {\n+                    //assuming this is due to network issue\n+                    logger.info(\"Timed out while updating the job status\");\n+                    break;\n+                } catch (InterruptedException e) {\n+                    logger.atWarn().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"Status\", status)\n+                            .log(\"Got interrupted while updating the job status\");\n+                }\n+                processedDeployments.remove(topic);\n             }\n         }\n     }\n+\n+    @SuppressWarnings({\"PMD.LooseCoupling\"})\n+    private void storeDeploymentStatusInConfig(String jobId, JobStatus status, HashMap<String, String> statusDetails) {\n+        synchronized (this.config) {\n+            logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            Map<String, Object> deploymentDetails = new HashMap<>();\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n+            //TODO: Store the deployment type\n+            //Each status update is uniquely stored\n+            Topic thisJob = processedDeployments.createLeafChild(String.valueOf(System.currentTimeMillis()));\n+            thisJob.setValue(deploymentDetails);\n+        }\n+    }\n+\n+    private DeploymentDocument parseAndValidateJobDocument(String jobDocumentString) throws InvalidRequestException {\n+        if (jobDocumentString == null || jobDocumentString.isEmpty()) {\n+            throw new InvalidRequestException(\"Job document cannot be empty\");\n+        }\n+        try {\n+            return OBJECT_MAPPER.readValue(jobDocumentString, DeploymentDocument.class);\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);\n+        }\n+    }\n+\n+    void setDeploymentsQueue(LinkedBlockingQueue<Deployment> deploymentsQueue) {", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MzAzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404443037", "bodyText": "Do not want this method to be public", "author": "abanthiy", "createdAt": "2020-04-06T23:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MzMxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404443310", "bodyText": "OK then, why is the method needed at all? Can't you just perform the set directly?", "author": "MikeDombo", "createdAt": "2020-04-06T23:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NTIxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404445215", "bodyText": "I am using to set the deploymentsQueue (private field) in the unit tests (same package) so need this method.", "author": "abanthiy", "createdAt": "2020-04-06T23:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NjMxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404376319", "bodyText": "NIT: \"sessionPresent\", \"true/false\"", "author": "ShirleyZheng92", "createdAt": "2020-04-06T20:44:12Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -21,267 +25,153 @@\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n-\n+    @Inject\n     private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n+\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean isConnectedToCloud = new AtomicBoolean(false);\n+    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n \n-    private MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+    private final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n+            //TODO: what about error code 0\n             if (errorCode != 0) {\n-                logger.error(\"Connection interrupted: \" + errorCode + \": \" + CRT.awsErrorString(errorCode));\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                //TODO: Detect this using secondary mechanisms like checking if internet is availalble\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+                isConnectedToCloud.set(false);\n             }\n         }\n \n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n-            logger.info(\"Connection resumed: \" + (sessionPresent ? \"existing session\" : \"clean session\"));\n-        }\n-    };\n-\n-    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n-        /*\n-         * This message is received when either of these things happen\n-         * 1. Last job completed (successful/failed)\n-         * 2. A new job was queued\n-         * 3. A job was cancelled\n-         * This message receives the list of Queued and InProgress jobs at the time of this message\n-         */\n-        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n-        if (jobs.containsKey(JobStatus.QUEUED)) {\n-            //Do not wait on the future in this async handler,\n-            //as it will block the thread which establishes\n-            // the MQTT connection. This will result in frozen MQTT connection\n-            this.iotJobsHelper.requestNextPendingJobDocument();\n-        }\n-    };\n-\n-    private final Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-\n-        JobExecutionData jobExecutionData = response.execution;\n-        currentJobId = jobExecutionData.jobId;\n-        logger.atInfo()\n-                .log(\"Received job description for job id : {} and status {}\", currentJobId, jobExecutionData.status);\n-        logger.addDefaultKeyValue(\"JobId\", currentJobId);\n-        if (jobExecutionData.status == JobStatus.IN_PROGRESS) {\n-            //TODO: Check the currently running process,\n-            // if it is same as this jobId then do nothing. If not then there is something wrong\n-            return;\n-        } else if (jobExecutionData.status == JobStatus.QUEUED) {\n-            //If there is a job running at this time, then it has been canceled in cloud and should be attempted to\n-            // be canceled here\n-            if (currentProcessStatus != null && !currentProcessStatus.cancel(true)) {\n-                //If the cancel is not successful\n-                return;\n-            }\n-            iotJobsHelper.updateJobStatus(currentJobId, JobStatus.IN_PROGRESS, null);\n-\n-            logger.info(\"Updated the status of JobsId {} to {}\", currentJobId, JobStatus.IN_PROGRESS);\n-\n-\n-            DeploymentTask deploymentTask;\n-            try {\n-                deploymentTask = createDeploymentTask(response.execution.jobDocument);\n-            } catch (InvalidRequestException e) {\n-                logger.atError().setCause(e).addKeyValue(\"message\", e.getMessage())\n-                        .log(\"Caught InvalidRequestException while processing a deployment\");\n-                HashMap<String, String> statusDetails = new HashMap<>();\n-                statusDetails.put(\"error\", e.getMessage());\n-                updateJobAsFailed(currentJobId, statusDetails);\n-                return;\n-            }\n-            //Starting the job processing in another thread\n-            currentProcessStatus = executorService.submit(deploymentTask);\n-            logger.atInfo().log(\"Submitted the job with jobId {}\", jobExecutionData.jobId);\n+            logger.atInfo().kv(\"session\", (sessionPresent ? \"existing session\" : \"clean session\"))", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0ODQ5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403148499", "bodyText": "Use Util.isEmpty() in the Util class.", "author": "fengwang666", "createdAt": "2020-04-03T17:00:30Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeviceConfigurationHelper.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.iot.evergreen.deployment.model.DeviceConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class for providing device configuration information.\n+ */\n+public class DeviceConfigurationHelper {\n+\n+    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n+    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n+    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n+    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n+    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    /**\n+     * Retrieves the device configuration information from kernel config to communicate with Iot Cloud.\n+     * @return {@link DeviceConfiguration}\n+     * @throws DeviceConfigurationException when configuration is not available for the device.\n+     */\n+    public DeviceConfiguration getDeviceConfiguration() throws DeviceConfigurationException {\n+        String thingName = getStringParameterFromConfig(DEVICE_PARAM_THING_NAME);\n+        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n+        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n+        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n+        String mqttClientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+        validateDeviceConfiguration(thingName, certificateFilePath, privateKeyPath, rootCAPath, mqttClientEndpoint);\n+        return new DeviceConfiguration(thingName, certificateFilePath, privateKeyPath, rootCAPath, mqttClientEndpoint);\n+    }\n+\n+    private String getStringParameterFromConfig(String parameterName) {\n+        String paramValue = \"\";\n+        //TODO: Update when device provisioning is implemented\n+        Topic childTopic = kernel.lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                DeploymentService.DEPLOYMENT_SERVICE_TOPICS).findLeafChild(parameterName);\n+        if (childTopic != null && childTopic.getOnce() != null) {\n+            paramValue = childTopic.getOnce().toString();\n+        }\n+        return paramValue;\n+    }\n+\n+    private void validateDeviceConfiguration(String thingName, String certificateFilePath, String privateKeyPath,\n+                                             String rootCAPath, String clientEndpoint)\n+            throws DeviceConfigurationException {\n+        List<String> errors = new ArrayList<>();\n+        if (thingName != null && thingName.isEmpty()) {", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0ODk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403148993", "bodyText": "Why not initialize it when you declare?", "author": "fengwang666", "createdAt": "2020-04-03T17:01:03Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -21,267 +25,153 @@\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n-\n+    @Inject\n     private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n+\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean isConnectedToCloud = new AtomicBoolean(false);\n+    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0OTQyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r403149424", "bodyText": "Maybe an error instead? I imagine most customers would want to use cloud deployment feature.", "author": "fengwang666", "createdAt": "2020-04-03T17:01:34Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,201 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"", "originalCommit": "e35c5c47dafb6478eed9c1ed023bbbeafeba5632", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1NDkyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405054927", "bodyText": "With intermittent connection this is expected and do we want  logs to show errors for which customers won't have any action?", "author": "abanthiy", "createdAt": "2020-04-07T19:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0OTQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MDkyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405240926", "bodyText": "maybe reword the log to be more clear: Fail to connect to IoT cloud due to connectivity issue, will retry later.", "author": "fengwang666", "createdAt": "2020-04-08T03:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0OTQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUwNDU1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404504556", "bodyText": "Does Jobs client provide these?", "author": "fengwang666", "createdAt": "2020-04-07T02:47:47Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -94,35 +233,107 @@ public void closeConnection() {\n      * @param jobId            The jobId to be updated\n      * @param status           The {@link JobStatus} to which to update\n      * @param statusDetailsMap map with job status details\n+     * @throws ExecutionException   if update fails\n+     * @throws InterruptedException if the thread gets interrupted\n+     * @throws TimeoutException     if the operation does not complete within the given time\n      */\n     @SuppressWarnings(\"PMD.LooseCoupling\")\n-    public void updateJobStatus(String jobId, JobStatus status, HashMap<String, String> statusDetailsMap) {\n+    public void updateJobStatus(String jobId, JobStatus status, HashMap<String, String> statusDetailsMap)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        if (!isConnectionEstablished) {\n+            logger.atWarn().log(CONNECTION_NOT_ESTABLISHED_WARNING_MESSAGE);\n+            return;\n+        }\n         UpdateJobExecutionSubscriptionRequest subscriptionRequest = new UpdateJobExecutionSubscriptionRequest();\n         subscriptionRequest.thingName = thingName;\n         subscriptionRequest.jobId = jobId;\n+        CompletableFuture<Void> gotResponse = new CompletableFuture<>();\n         iotJobsClient.SubscribeToUpdateJobExecutionAccepted(subscriptionRequest, QualityOfService.AT_LEAST_ONCE,\n                 (response) -> {\n-                    logger.info(\"Marked job \" + jobId + \"as \" + status);\n-                    String topicForJobId = UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC.replace(\"{thingName}\", thingName)\n+                    logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"Status\", status)\n+                            .log(\"Job status updated accepted\");\n+                    String acceptTopicForJobId = UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC.replace(\"{thingName}\", thingName)\n                             .replace(\"{jobId}\", jobId);\n-                    connection.unsubscribe(topicForJobId);\n+                    connection.unsubscribe(acceptTopicForJobId);\n+                    gotResponse.complete(null);\n                 });\n \n         iotJobsClient.SubscribeToUpdateJobExecutionRejected(subscriptionRequest, QualityOfService.AT_LEAST_ONCE,\n                 (response) -> {\n-                    logger.error(\"Job \" + jobId + \" not updated as \" + status);\n-                    String topicForJobId = UPDATE_SPECIFIC_JOB_REJECTED_TOPIC.replace(\"{thingName}\", thingName)\n+                    logger.atWarn().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"Status\", status)\n+                            .log(\"Job status updated rejected\");\n+                    String rejectTopicForJobId = UPDATE_SPECIFIC_JOB_REJECTED_TOPIC.replace(\"{thingName}\", thingName)\n                             .replace(\"{jobId}\", jobId);\n-                    //TODO: Add retry for updating the job or throw error\n-                    connection.unsubscribe(topicForJobId);\n+                    connection.unsubscribe(rejectTopicForJobId);\n+                    //TODO: Can this be due to duplicate messages being sent for the job?\n+                    gotResponse.completeExceptionally(new Exception(response.message));\n                 });\n \n         UpdateJobExecutionRequest updateJobRequest = new UpdateJobExecutionRequest();\n         updateJobRequest.jobId = jobId;\n         updateJobRequest.status = status;\n         updateJobRequest.statusDetails = statusDetailsMap;\n         updateJobRequest.thingName = thingName;\n-        iotJobsClient.PublishUpdateJobExecution(updateJobRequest, QualityOfService.AT_LEAST_ONCE);\n+        try {\n+            iotJobsClient.PublishUpdateJobExecution(updateJobRequest, QualityOfService.AT_LEAST_ONCE).get();\n+        } catch (ExecutionException e) {\n+            gotResponse.completeExceptionally(e.getCause());\n+        }\n+        gotResponse.get(TIMEOUT_FOR_RESPONSE_FROM_IOT_CLOUD_SECONDS, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Request the job description of the next available job for this Iot Thing.\n+     * It publishes on the $aws/things/{thingName}/jobs/$next/get topic.\n+     */\n+    public void requestNextPendingJobDocument() {\n+        if (!isConnectionEstablished) {\n+            logger.atWarn().log(CONNECTION_NOT_ESTABLISHED_WARNING_MESSAGE);\n+            return;\n+        }\n+        DescribeJobExecutionRequest describeJobExecutionRequest = new DescribeJobExecutionRequest();\n+        describeJobExecutionRequest.thingName = thingName;\n+        describeJobExecutionRequest.jobId = \"$next\";\n+        describeJobExecutionRequest.includeJobDocument = true;\n+        //This method is specifically called from an async event notification handler. Async handler cannot block on\n+        // this future as that will freeze the MQTT connection.\n+        iotJobsClient.PublishDescribeJobExecution(describeJobExecutionRequest, QualityOfService.AT_LEAST_ONCE);\n+    }\n+\n+    /**\n+     * Subscribe to the mqtt topics needed for getting Iot Jobs notifications.\n+     *\n+     * @throws InterruptedException           When operation is interrupted\n+     * @throws AWSIotException                When there is an exception from the Iot cloud\n+     * @throws ConnectionUnavailableException When connection to cloud is not available\n+     */\n+    public void subscribeToJobsTopics() throws InterruptedException, AWSIotException, ConnectionUnavailableException {\n+        if (!isConnectionEstablished) {\n+            logger.atWarn().log(CONNECTION_NOT_ESTABLISHED_WARNING_MESSAGE);\n+            return;\n+        }\n+        try {\n+            //TODO: Add retry in case of Throttling, Timeout and LimitExceed exception", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4NjY4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405186685", "bodyText": "No jobs client does not provide retries afaik", "author": "abanthiy", "createdAt": "2020-04-08T00:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUwNDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNDQ4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404514484", "bodyText": "I argue this boolean flag is unnecessary. When the underlying client makes a request to the IoT endpoint, it will know whether it's connected or not. When the boolean flag is evaluated true, it doesn't guarantee that the connection is on at the time when the client makes the request to IoT Jobs; when the boolean flag is evaluated false, it also doesn't guarantee that the connection is off at the time when the client makes the request to IoT Jobs. Adding the flag doesn't provide any benefits here.", "author": "fengwang666", "createdAt": "2020-04-07T03:29:27Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -21,267 +25,153 @@\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n-\n+    @Inject\n     private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n+\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean isConnectedToCloud = new AtomicBoolean(false);", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzNjQ2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405036462", "bodyText": "I see your point but in our demo we got the feedback to be able to determine the connection status using secondary mechanisms. Thus value of this flag will be set when we introduce those mechanisms. I have a TODO for this as well. The attempt here is to not send the Mqtt requests when device knows (with a good probability ) that the connection is not available and if its incorrect eventually the device will know when connection is available", "author": "abanthiy", "createdAt": "2020-04-07T18:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNDQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzOTUwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405239505", "bodyText": "I would leave that to the future. Ideally the connection status shouldn't concern DeploymentService. Every line of the code that is not used now becomes dead weight and makes the code harder to maintain.", "author": "fengwang666", "createdAt": "2020-04-08T03:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNDQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxOTE4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404519189", "bodyText": "connectToAWSIot() potentially can block for a long time if the device is offline. We need to discuss the implication of this. According to the current lifecycle state transition, DeploymentService will be stuck in startup() step and potentially times out after a period of time and is set to ERRORED. After a few times, DeploymentService will be set to BROKEN. This is not desirable.\nDepending on the exception from connectToAWSIot(), we should handle them differently:\n\n500 or 429 (throttled), set deployment service to running, backoff and retry;\nnetwork is off, set deployment service to running, wait and retry;\nother 400 error, really shouldn't occur. The device is bricked if this happens.\n\nTo simplify the logic, I'm okay if we first set the deployment service to running and then try to connect to IoT.\nI'm okay we create a SIM and address this in a separate PR.", "author": "fengwang666", "createdAt": "2020-04-07T03:49:51Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -21,267 +25,153 @@\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n-\n+    @Inject\n     private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n+\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean isConnectedToCloud = new AtomicBoolean(false);\n+    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n \n-    private MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+    private final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n+            //TODO: what about error code 0\n             if (errorCode != 0) {\n-                logger.error(\"Connection interrupted: \" + errorCode + \": \" + CRT.awsErrorString(errorCode));\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                //TODO: Detect this using secondary mechanisms like checking if internet is availalble\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+                isConnectedToCloud.set(false);\n             }\n         }\n \n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n-            logger.info(\"Connection resumed: \" + (sessionPresent ? \"existing session\" : \"clean session\"));\n-        }\n-    };\n-\n-    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n-        /*\n-         * This message is received when either of these things happen\n-         * 1. Last job completed (successful/failed)\n-         * 2. A new job was queued\n-         * 3. A job was cancelled\n-         * This message receives the list of Queued and InProgress jobs at the time of this message\n-         */\n-        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n-        if (jobs.containsKey(JobStatus.QUEUED)) {\n-            //Do not wait on the future in this async handler,\n-            //as it will block the thread which establishes\n-            // the MQTT connection. This will result in frozen MQTT connection\n-            this.iotJobsHelper.requestNextPendingJobDocument();\n-        }\n-    };\n-\n-    private final Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-\n-        JobExecutionData jobExecutionData = response.execution;\n-        currentJobId = jobExecutionData.jobId;\n-        logger.atInfo()\n-                .log(\"Received job description for job id : {} and status {}\", currentJobId, jobExecutionData.status);\n-        logger.addDefaultKeyValue(\"JobId\", currentJobId);\n-        if (jobExecutionData.status == JobStatus.IN_PROGRESS) {\n-            //TODO: Check the currently running process,\n-            // if it is same as this jobId then do nothing. If not then there is something wrong\n-            return;\n-        } else if (jobExecutionData.status == JobStatus.QUEUED) {\n-            //If there is a job running at this time, then it has been canceled in cloud and should be attempted to\n-            // be canceled here\n-            if (currentProcessStatus != null && !currentProcessStatus.cancel(true)) {\n-                //If the cancel is not successful\n-                return;\n-            }\n-            iotJobsHelper.updateJobStatus(currentJobId, JobStatus.IN_PROGRESS, null);\n-\n-            logger.info(\"Updated the status of JobsId {} to {}\", currentJobId, JobStatus.IN_PROGRESS);\n-\n-\n-            DeploymentTask deploymentTask;\n-            try {\n-                deploymentTask = createDeploymentTask(response.execution.jobDocument);\n-            } catch (InvalidRequestException e) {\n-                logger.atError().setCause(e).addKeyValue(\"message\", e.getMessage())\n-                        .log(\"Caught InvalidRequestException while processing a deployment\");\n-                HashMap<String, String> statusDetails = new HashMap<>();\n-                statusDetails.put(\"error\", e.getMessage());\n-                updateJobAsFailed(currentJobId, statusDetails);\n-                return;\n-            }\n-            //Starting the job processing in another thread\n-            currentProcessStatus = executorService.submit(deploymentTask);\n-            logger.atInfo().log(\"Submitted the job with jobId {}\", jobExecutionData.jobId);\n+            logger.atInfo().kv(\"sessionPresent\", (sessionPresent ? \"true\" : \"false\"))\n+                    .log(\"Connection resumed\");\n+            isConnectedToCloud.set(true);\n+            runInSeparateThread(() -> {\n+                subscribeToIotJobTopics();\n+                updateStatusOfPersistedDeployments();\n+            });\n         }\n-\n     };\n \n-    private DeploymentTask createDeploymentTask(Map<String, Object> jobDocument) throws InvalidRequestException {\n-\n-        DeploymentDocument deploymentDocument = parseAndValidateJobDocument(jobDocument);\n-        return new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n-                deploymentDocument);\n-    }\n-\n-    private DeploymentDocument parseAndValidateJobDocument(Map<String, Object> jobDocument)\n-            throws InvalidRequestException {\n-        if (jobDocument == null) {\n-            String errorMessage = \"Job document cannot be empty\";\n-            throw new InvalidRequestException(errorMessage);\n-        }\n-        DeploymentDocument deploymentDocument = null;\n-        try {\n-            String jobDocumentString = OBJECT_MAPPER.writeValueAsString(jobDocument);\n-            deploymentDocument = OBJECT_MAPPER.readValue(jobDocumentString, DeploymentDocument.class);\n-            return deploymentDocument;\n-        } catch (JsonProcessingException e) {\n-            String errorMessage = \"Unable to parse the job document\";\n-            throw new InvalidRequestException(errorMessage, e);\n-        }\n-    }\n-\n-    private void updateJobAsSucceeded(String jobId, HashMap<String, String> statusDetails) {\n-        iotJobsHelper.updateJobStatus(jobId, JobStatus.SUCCEEDED, statusDetails);\n-        logger.addDefaultKeyValue(\"JobId\", \"\");\n-    }\n-\n-    private void updateJobAsFailed(String jobId, HashMap<String, String> statusDetails) {\n-        iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n-        logger.addDefaultKeyValue(\"JobId\", \"\");\n-    }\n-\n     /**\n      * Constructor.\n      *\n      * @param topics the configuration coming from kernel\n      */\n     public DeploymentService(Topics topics) {\n         super(topics);\n+        deploymentsQueue = new LinkedBlockingQueue<>();\n     }\n \n     /**\n      * Constructor for unit testing.\n      *\n      * @param topics               The configuration coming from  kernel\n-     * @param iotJobsHelperFactory Factory object for creating IotJobHelper\n      * @param executorService      Executor service coming from kernel\n      * @param kernel               The evergreen kernel\n      * @param dependencyResolver   {@link DependencyResolver}\n      * @param packageStore         {@link PackageStore}\n      * @param kernelConfigResolver {@link KernelConfigResolver}\n      */\n-    public DeploymentService(Topics topics, IotJobsHelperFactory iotJobsHelperFactory, ExecutorService executorService,\n-                             Kernel kernel, DependencyResolver dependencyResolver, PackageStore packageStore,\n-                             KernelConfigResolver kernelConfigResolver) {\n+\n+    DeploymentService(Topics topics, ExecutorService executorService, Kernel kernel,\n+                      DependencyResolver dependencyResolver, PackageStore packageStore,\n+                      KernelConfigResolver kernelConfigResolver, IotJobsHelper iotJobsHelper) {\n         super(topics);\n-        this.iotJobsHelperFactory = iotJobsHelperFactory;\n         this.executorService = executorService;\n         this.kernel = kernel;\n         this.dependencyResolver = dependencyResolver;\n         this.packageStore = packageStore;\n         this.kernelConfigResolver = kernelConfigResolver;\n+        this.iotJobsHelper = iotJobsHelper;\n+        deploymentsQueue = new LinkedBlockingQueue<>();\n     }\n \n+\n     @Override\n     public void startup() {\n-        // Reset shutdown signal since we're trying to startup here\n-        this.receivedShutdown.set(false);\n-        logger.info(\"Starting up the Deployment Service\");\n-        String thingName = getStringParameterFromConfig(DEVICE_PARAM_THING_NAME);\n-        //TODO: Add any other checks to verify device provisioned to communicate with Iot Cloud\n-        if (thingName.isEmpty()) {\n-            logger.info(\"There is no thingName assigned to this device. Cannot communicate with cloud.\"\n-                    + \" Finishing deployment service\");\n-            reportState(State.FINISHED);\n-            return;\n-        }\n-\n         try {\n-            initializeIotJobsHelper(thingName);\n-            iotJobsHelper.connectToAwsIot();\n-            iotJobsHelper.subscribeToEventNotifications(eventHandler);\n-            iotJobsHelper.subscribeToGetNextJobDecription(describeJobExecutionResponseConsumer, rejectedError -> {\n-                logger.error(\"Job subscription got rejected\", rejectedError);\n-                //TODO: Add retry logic for subscribing\n-            });\n+            logger.info(\"Starting up the Deployment Service\");\n+            // Reset shutdown signal since we're trying to startup here\n+            this.receivedShutdown.set(false);\n+            connectToAWSIot();\n             reportState(State.RUNNING);", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA0MTcxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405041719", "bodyText": "Deployment service will not block for long time. It will timeout after 1 minute (as per values set right now) and throw ConnectionUnavailableException in which case it will keep running in offline mode. I already have a TODO for retrying in case Throttling and limit exceed exceptions in IotJobsHelper class. Any other exception is being captured as AWSIotException in which case right now we not erroring the service but I have a comment to revisit that strategy since I was not sure of erroring the service was the right behavior in that case. We never want the device to become a brick.", "author": "abanthiy", "createdAt": "2020-04-07T18:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxOTE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MDA2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405240067", "bodyText": "In the case of 400 error (non 429), even if we don't error the service, I don't know how we can recover because the device cannot connect to the cloud for deployment. Anyway that's a separate discussion.", "author": "fengwang666", "createdAt": "2020-04-08T03:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxOTE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwOTUyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405709523", "bodyText": "Yes but erroring out service means shutting doors for local deployment and individual device deployments (using shadows). We can visit this when we implement multiple mechanisms", "author": "abanthiy", "createdAt": "2020-04-08T17:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxOTE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyMDYwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404520604", "bodyText": "So this will be blocking...how would you cancel an in progress deployment when a new deployment comes in?", "author": "fengwang666", "createdAt": "2020-04-07T03:56:38Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwODIzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405208232", "bodyText": "It will only get into this method when the currentProcessStatus.isDone() is true. So this should not be blocking.", "author": "abanthiy", "createdAt": "2020-04-08T01:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyMDYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODI2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404538267", "bodyText": "I find this nested condition a bit difficult to read. We can simplify the code like this:\nwhile(!receivedShutdown.get()) {\n    if (currentProcessStatus != null && currentProcessStatus.isDone()) {\n        finishCurrentDeployment();\n    }\n    deployment = deploymentsQueue.poll();\n    if (deployment != null) {\n        if (currentProcessStatus != null && !currentProcessStatus.isDone()) {\n             // cancelDeployment()\n        }\n        createNewDeployment(deployment);\n    }\n    Thread.sleep(pollFrequency); //e.g. every 1min\n}", "author": "fengwang666", "createdAt": "2020-04-07T05:09:15Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -21,267 +25,153 @@\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n-\n+    @Inject\n     private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n+\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean isConnectedToCloud = new AtomicBoolean(false);\n+    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n \n-    private MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+    private final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n+            //TODO: what about error code 0\n             if (errorCode != 0) {\n-                logger.error(\"Connection interrupted: \" + errorCode + \": \" + CRT.awsErrorString(errorCode));\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                //TODO: Detect this using secondary mechanisms like checking if internet is availalble\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+                isConnectedToCloud.set(false);\n             }\n         }\n \n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n-            logger.info(\"Connection resumed: \" + (sessionPresent ? \"existing session\" : \"clean session\"));\n-        }\n-    };\n-\n-    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n-        /*\n-         * This message is received when either of these things happen\n-         * 1. Last job completed (successful/failed)\n-         * 2. A new job was queued\n-         * 3. A job was cancelled\n-         * This message receives the list of Queued and InProgress jobs at the time of this message\n-         */\n-        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n-        if (jobs.containsKey(JobStatus.QUEUED)) {\n-            //Do not wait on the future in this async handler,\n-            //as it will block the thread which establishes\n-            // the MQTT connection. This will result in frozen MQTT connection\n-            this.iotJobsHelper.requestNextPendingJobDocument();\n-        }\n-    };\n-\n-    private final Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-\n-        JobExecutionData jobExecutionData = response.execution;\n-        currentJobId = jobExecutionData.jobId;\n-        logger.atInfo()\n-                .log(\"Received job description for job id : {} and status {}\", currentJobId, jobExecutionData.status);\n-        logger.addDefaultKeyValue(\"JobId\", currentJobId);\n-        if (jobExecutionData.status == JobStatus.IN_PROGRESS) {\n-            //TODO: Check the currently running process,\n-            // if it is same as this jobId then do nothing. If not then there is something wrong\n-            return;\n-        } else if (jobExecutionData.status == JobStatus.QUEUED) {\n-            //If there is a job running at this time, then it has been canceled in cloud and should be attempted to\n-            // be canceled here\n-            if (currentProcessStatus != null && !currentProcessStatus.cancel(true)) {\n-                //If the cancel is not successful\n-                return;\n-            }\n-            iotJobsHelper.updateJobStatus(currentJobId, JobStatus.IN_PROGRESS, null);\n-\n-            logger.info(\"Updated the status of JobsId {} to {}\", currentJobId, JobStatus.IN_PROGRESS);\n-\n-\n-            DeploymentTask deploymentTask;\n-            try {\n-                deploymentTask = createDeploymentTask(response.execution.jobDocument);\n-            } catch (InvalidRequestException e) {\n-                logger.atError().setCause(e).addKeyValue(\"message\", e.getMessage())\n-                        .log(\"Caught InvalidRequestException while processing a deployment\");\n-                HashMap<String, String> statusDetails = new HashMap<>();\n-                statusDetails.put(\"error\", e.getMessage());\n-                updateJobAsFailed(currentJobId, statusDetails);\n-                return;\n-            }\n-            //Starting the job processing in another thread\n-            currentProcessStatus = executorService.submit(deploymentTask);\n-            logger.atInfo().log(\"Submitted the job with jobId {}\", jobExecutionData.jobId);\n+            logger.atInfo().kv(\"sessionPresent\", (sessionPresent ? \"true\" : \"false\"))\n+                    .log(\"Connection resumed\");\n+            isConnectedToCloud.set(true);\n+            runInSeparateThread(() -> {\n+                subscribeToIotJobTopics();\n+                updateStatusOfPersistedDeployments();\n+            });\n         }\n-\n     };\n \n-    private DeploymentTask createDeploymentTask(Map<String, Object> jobDocument) throws InvalidRequestException {\n-\n-        DeploymentDocument deploymentDocument = parseAndValidateJobDocument(jobDocument);\n-        return new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n-                deploymentDocument);\n-    }\n-\n-    private DeploymentDocument parseAndValidateJobDocument(Map<String, Object> jobDocument)\n-            throws InvalidRequestException {\n-        if (jobDocument == null) {\n-            String errorMessage = \"Job document cannot be empty\";\n-            throw new InvalidRequestException(errorMessage);\n-        }\n-        DeploymentDocument deploymentDocument = null;\n-        try {\n-            String jobDocumentString = OBJECT_MAPPER.writeValueAsString(jobDocument);\n-            deploymentDocument = OBJECT_MAPPER.readValue(jobDocumentString, DeploymentDocument.class);\n-            return deploymentDocument;\n-        } catch (JsonProcessingException e) {\n-            String errorMessage = \"Unable to parse the job document\";\n-            throw new InvalidRequestException(errorMessage, e);\n-        }\n-    }\n-\n-    private void updateJobAsSucceeded(String jobId, HashMap<String, String> statusDetails) {\n-        iotJobsHelper.updateJobStatus(jobId, JobStatus.SUCCEEDED, statusDetails);\n-        logger.addDefaultKeyValue(\"JobId\", \"\");\n-    }\n-\n-    private void updateJobAsFailed(String jobId, HashMap<String, String> statusDetails) {\n-        iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n-        logger.addDefaultKeyValue(\"JobId\", \"\");\n-    }\n-\n     /**\n      * Constructor.\n      *\n      * @param topics the configuration coming from kernel\n      */\n     public DeploymentService(Topics topics) {\n         super(topics);\n+        deploymentsQueue = new LinkedBlockingQueue<>();\n     }\n \n     /**\n      * Constructor for unit testing.\n      *\n      * @param topics               The configuration coming from  kernel\n-     * @param iotJobsHelperFactory Factory object for creating IotJobHelper\n      * @param executorService      Executor service coming from kernel\n      * @param kernel               The evergreen kernel\n      * @param dependencyResolver   {@link DependencyResolver}\n      * @param packageStore         {@link PackageStore}\n      * @param kernelConfigResolver {@link KernelConfigResolver}\n      */\n-    public DeploymentService(Topics topics, IotJobsHelperFactory iotJobsHelperFactory, ExecutorService executorService,\n-                             Kernel kernel, DependencyResolver dependencyResolver, PackageStore packageStore,\n-                             KernelConfigResolver kernelConfigResolver) {\n+\n+    DeploymentService(Topics topics, ExecutorService executorService, Kernel kernel,\n+                      DependencyResolver dependencyResolver, PackageStore packageStore,\n+                      KernelConfigResolver kernelConfigResolver, IotJobsHelper iotJobsHelper) {\n         super(topics);\n-        this.iotJobsHelperFactory = iotJobsHelperFactory;\n         this.executorService = executorService;\n         this.kernel = kernel;\n         this.dependencyResolver = dependencyResolver;\n         this.packageStore = packageStore;\n         this.kernelConfigResolver = kernelConfigResolver;\n+        this.iotJobsHelper = iotJobsHelper;\n+        deploymentsQueue = new LinkedBlockingQueue<>();\n     }\n \n+\n     @Override\n     public void startup() {\n-        // Reset shutdown signal since we're trying to startup here\n-        this.receivedShutdown.set(false);\n-        logger.info(\"Starting up the Deployment Service\");\n-        String thingName = getStringParameterFromConfig(DEVICE_PARAM_THING_NAME);\n-        //TODO: Add any other checks to verify device provisioned to communicate with Iot Cloud\n-        if (thingName.isEmpty()) {\n-            logger.info(\"There is no thingName assigned to this device. Cannot communicate with cloud.\"\n-                    + \" Finishing deployment service\");\n-            reportState(State.FINISHED);\n-            return;\n-        }\n-\n         try {\n-            initializeIotJobsHelper(thingName);\n-            iotJobsHelper.connectToAwsIot();\n-            iotJobsHelper.subscribeToEventNotifications(eventHandler);\n-            iotJobsHelper.subscribeToGetNextJobDecription(describeJobExecutionResponseConsumer, rejectedError -> {\n-                logger.error(\"Job subscription got rejected\", rejectedError);\n-                //TODO: Add retry logic for subscribing\n-            });\n+            logger.info(\"Starting up the Deployment Service\");\n+            // Reset shutdown signal since we're trying to startup here\n+            this.receivedShutdown.set(false);\n+            connectToAWSIot();\n             reportState(State.RUNNING);\n-        } catch (ExecutionException | InterruptedException ex) {\n-            logger.error(\"Caught exception in subscribing to topics\", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-        logger.info(\"Running deployment service\");\n-        while (!receivedShutdown.get() && !errored) {\n-            try {\n-                if (currentProcessStatus != null) {\n-                    logger.info(\"Getting the status of the current process\");\n-\n-                    currentProcessStatus.get();\n-                    updateJobAsSucceeded(currentJobId, null);\n-                    currentProcessStatus = null;\n+            logger.info(\"Running deployment service\");\n+\n+            while (!receivedShutdown.get()) {\n+                Deployment deployment = null;\n+                //Cannot wait on queue because need to listen to queue as well as the currentProcessStatus future.\n+                //One thread cannot wait on both. If we want to make this completely event driven then we need to put\n+                // the waiting on currentProcessStatus in its own thread. I currently choose to not do this.\n+                if ((currentProcessStatus != null && currentProcessStatus.isDone())\n+                        || (deployment = deploymentsQueue.poll()) != null) {\n+                    if (deployment == null) { //Current job finished\n+                        finishCurrentDeployment();\n+                    } else { //Received new deployment\n+                        createNewDeployment(deployment);\n+                    }", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1MDExNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405050117", "bodyText": "I can modify it to be similar to this. Cancellation requires jobId check so those will be introduced here.", "author": "abanthiy", "createdAt": "2020-04-07T19:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0Mjc4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404542780", "bodyText": "I would cancel the deployment outside this method. It's not a clean separation to cancel an old deployment in the createNewDeployment method.", "author": "fengwang666", "createdAt": "2020-04-07T05:25:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzU3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405217575", "bodyText": "Yes I have refactored for cancel to be outside of create method", "author": "abanthiy", "createdAt": "2020-04-08T02:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0Mjc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MzQzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404543434", "bodyText": "Is this going to happen in reality? Which can cause this?", "author": "fengwang666", "createdAt": "2020-04-07T05:27:21Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405217484", "bodyText": "The QoS we use for Mqtt is 1 which ensure at least once delivery. So yes we can get duplicate messages.", "author": "abanthiy", "createdAt": "2020-04-08T02:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MzQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDAyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404544022", "bodyText": "I would try really hard to avoid assigning null to a variable. It now put the burden on the programmers to always perform null check before referencing the variable. We should avoid null in the code as much as possible.", "author": "fengwang666", "createdAt": "2020-04-07T05:29:09Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzEzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405217134", "bodyText": "I agree that assigning null should be avoided. But sometimes it cannot be, many java library methods return null and use it. For this case, I have converted it to be an Optional, it will look like :\n\ncurrentProcessStatus = Optional.empty();\ncurrentJobId = Optional.empty();\n\nWith these changes the readability of the code elsewhere gets affected (gets better for one and not so much for other I think), specially with currentProcessStatus (as it is a Future). But this does not prevent programmer from doing a check, they now have to do a isPresent() check or variation of that. Although with Optional it may be more intuitive. Also optional comes with space and time overhead - https://homes.cs.washington.edu/~mernst/advice/nothing-is-better-than-optional.html#overhead\nI will continue thinking of better way, let me know what you think of this and if you have any other suggestion.", "author": "abanthiy", "createdAt": "2020-04-08T02:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MjE4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405242188", "bodyText": "I don't have a good way either. Let's keep it this way for now and can come back later.", "author": "fengwang666", "createdAt": "2020-04-08T03:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDQ3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404544475", "bodyText": "Given the size of the method, this (and the storeDeploymentStatusInConfig()) probably are worth pulling out to its own class. Another benefit of moving this to a separate class is that it enables you to move callbacks into IotJobsHelper class. I'm okay to leave it to a future PR.", "author": "fengwang666", "createdAt": "2020-04-07T05:30:42Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match\n+        }\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n+    private void subscribeToIotJobTopics() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot subscribe to topics\");\n+            return;\n+        }\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n \n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n \n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private void updateStatusOfPersistedDeployments() {", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyMjAyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405222023", "bodyText": "Ya we can move these to separate classes. I agree the flexibility of moving callbacks to the class which maintains mqtt connection is good!. This may also change when Mqtt proxy is in place? (Not sure right now).", "author": "abanthiy", "createdAt": "2020-04-08T02:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDg3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404544878", "bodyText": "Whenever there is a synchronized keyword, it warrants a comment explaining the expected thread pattern of this method.", "author": "fengwang666", "createdAt": "2020-04-07T05:32:08Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match\n+        }\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n+    private void subscribeToIotJobTopics() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot subscribe to topics\");\n+            return;\n+        }\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n \n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n \n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private void updateStatusOfPersistedDeployments() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot udpate the status of deploymentsQueue\");\n+            return;\n+        }\n+        synchronized (this.config) {", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwNzQ1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405207457", "bodyText": "I feel this should sync on \"this.config.child(PROCESSED_DEPLOYMENTS_TOPICS)\" instead of the config topics", "author": "ShirleyZheng92", "createdAt": "2020-04-08T01:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyMzUzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405223536", "bodyText": "Added a comment explaining the synchronized", "author": "abanthiy", "createdAt": "2020-04-08T02:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2MTM1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405861352", "bodyText": "@ShirleyZheng92 Updated the object to sync on", "author": "abanthiy", "createdAt": "2020-04-08T22:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NDg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NjQ5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404546492", "bodyText": "use Util.isEmpty().", "author": "fengwang666", "createdAt": "2020-04-07T05:37:24Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match\n+        }\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n+    private void subscribeToIotJobTopics() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot subscribe to topics\");\n+            return;\n+        }\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n \n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n \n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private void updateStatusOfPersistedDeployments() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot udpate the status of deploymentsQueue\");\n+            return;\n+        }\n+        synchronized (this.config) {\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            ArrayList<Topic> deployments = new ArrayList<>();\n+            processedDeployments.forEach(d -> deployments.add((Topic) d));\n+            // Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+            // We want the statuses to be updated in the cloud in the order in which they were processed on the device.\n+            // This will be accurate representation of what happened on the device, especially when deployment service\n+            // processes multiple deployments in the order in which they come. Additionally, a customer workflow can\n+            // depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may\n+            // error out.\n+            ArrayList<Topic> sortedByTimestamp =\n+                    (ArrayList<Topic>) deployments.stream().sorted(new Comparator<Topic>() {\n+                        @Override\n+                        public int compare(Topic o1, Topic o2) {\n+                            if (Long.valueOf(o1.getModtime()) > Long.valueOf(o2.getModtime())) {\n+                                return 1;\n+                            }\n+                            return -1;\n+                        }\n+                    }).collect(Collectors.toList());\n+\n+            Iterator iterator = sortedByTimestamp.iterator();\n+            while (iterator.hasNext()) {\n+                Topic topic = (Topic) iterator.next();\n+                Map<String, Object> deploymentDetails = (HashMap) topic.getOnce();\n+                String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n+                String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+                logger.atInfo().kv(\"Modified time\", topic.getModtime()).kv(JOB_ID_LOG_KEY_NAME, jobId)\n+                        .kv(\"Status\", status).kv(\"StatusDetails\",\n+                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS).toString())\n+                        .log(\"Updating status of persisted deployment\");\n+                try {\n+                    //TODO: Use the status updater as per the deployment type. Updating deployment status in\n+                    // IotJobs is different from updating a deployment coming from device shadow or local deployments.\n+                    iotJobsHelper.updateJobStatus(jobId, JobStatus.valueOf(status),\n+                            (HashMap<String, String>) deploymentDetails\n+                                    .get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS));\n+                } catch (ExecutionException e) {\n+                    if (e.getCause() instanceof MqttException) {\n+                        //caused due to connectivity issue\n+                        logger.atWarn().log(\"Caught exception while updating job status\");\n+                        break;\n+                    }\n+                    //This happens when job status update gets rejected from the Iot Cloud\n+                    //Want to remove this job from the list and continue updating others\n+                    logger.atError().kv(\"Status\", status).kv(JOB_ID_LOG_KEY_NAME, jobId).setCause(e)\n+                            .log(\"Job status update rejected\");\n+                } catch (TimeoutException e) {\n+                    //assuming this is due to network issue\n+                    logger.info(\"Timed out while updating the job status\");\n+                    break;\n+                } catch (InterruptedException e) {\n+                    logger.atWarn().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"Status\", status)\n+                            .log(\"Got interrupted while updating the job status\");\n+                }\n+                processedDeployments.remove(topic);\n             }\n         }\n     }\n+\n+    @SuppressWarnings({\"PMD.LooseCoupling\"})\n+    private void storeDeploymentStatusInConfig(String jobId, JobStatus status, HashMap<String, String> statusDetails) {\n+        synchronized (this.config) {\n+            logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            Map<String, Object> deploymentDetails = new HashMap<>();\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n+            //TODO: Store the deployment type\n+            //Each status update is uniquely stored\n+            Topic thisJob = processedDeployments.createLeafChild(String.valueOf(System.currentTimeMillis()));\n+            thisJob.setValue(deploymentDetails);\n+        }\n+    }\n+\n+    private DeploymentDocument parseAndValidateJobDocument(String jobDocumentString) throws InvalidRequestException {\n+        if (jobDocumentString == null || jobDocumentString.isEmpty()) {", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NzE4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404547181", "bodyText": "Same argument as isConnectedToCloud, this boolean is not necessary.", "author": "fengwang666", "createdAt": "2020-04-07T05:39:30Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -3,81 +3,220 @@\n \n package com.aws.iot.evergreen.deployment;\n \n+import com.aws.iot.evergreen.deployment.exceptions.AWSIotException;\n+import com.aws.iot.evergreen.deployment.exceptions.ConnectionUnavailableException;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeviceConfiguration;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n import lombok.NoArgsConstructor;\n-import software.amazon.awssdk.crt.CRT;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedSubscriptionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionSubscriptionRequest;\n \n+import java.time.Duration;\n import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n+import javax.inject.Inject;\n \n @NoArgsConstructor\n public class IotJobsHelper {\n \n-    public static final String UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC =\n-            \"$aws/things/{thingName}/jobs/{jobId}/update\" + \"/accepted\";\n-    public static final String UPDATE_SPECIFIC_JOB_REJECTED_TOPIC =\n-            \"$aws/things/{thingName}/jobs/{jobId}/update\" + \"/rejected\";\n+    protected static final String UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC =\n+            \"$aws/things/{thingName}/jobs/{jobId}/update/accepted\";\n+    protected static final String UPDATE_SPECIFIC_JOB_REJECTED_TOPIC =\n+            \"$aws/things/{thingName}/jobs/{jobId}/update/rejected\";\n+\n+    private static final int MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final int MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    //The time within which device expects an acknowledgement from Iot cloud after publishing an MQTT message\n+    //This value needs to be revisited and set to more realistic numbers\n+    private static final long TIMEOUT_FOR_RESPONSE_FROM_IOT_CLOUD_SECONDS = (long) Duration.ofMinutes(5).getSeconds();\n+    //The time it takes for device to publish a message\n+    //This value needs to be revisited and set to more realistic numbers\n+    private static final long TIMEOUT_FOR_IOT_JOBS_OPERATIONS_SECONDS = (long) Duration.ofMinutes(1).getSeconds();\n+\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n+    private static final String CONNECTION_NOT_ESTABLISHED_WARNING_MESSAGE =\n+            \"Connection not established with Iot cloud. First establish connection to AWS Iot\";\n \n-    //IotJobsHelper is not in Context, so initializing a new one here. It will be added to context in later iterations\n     private static Logger logger = LogManager.getLogger(IotJobsHelper.class);\n \n+    @Inject\n+    private DeviceConfigurationHelper deviceConfigurationHelper;\n+\n+    @Inject\n+    @Setter\n+    private AWSIotMqttConnectionFactory awsIotMqttConnectionFactory;\n+\n+    @Setter\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n     private String thingName;\n     private IotJobsClient iotJobsClient;\n     private MqttClientConnection connection;\n+    private boolean isConnectionEstablished = false;", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODQ1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405188456", "bodyText": "This is specifically because of the methods exposed by this class. None of the other methods should be called unless connected to AWS Iot as the connection variable will be uninitialized. The reason for not haivng connection established in constructor is in one of my other replies.", "author": "abanthiy", "createdAt": "2020-04-08T00:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NzE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0ODQ5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404548498", "bodyText": "Curious why you choose the current way instead of a factory method:\niotJobsHelper = IoTJobsHelperFactory.create(deploymentsQueue, callbacks);\n\nThe factory method can hide the details of \"connect to AWS Iot\", which shouldn't concern the deployment service.", "author": "fengwang666", "createdAt": "2020-04-07T05:43:55Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1NDI0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405054247", "bodyText": "In cases when we want to retry connecting to AWS Iot, we should not be creating the Iot jobs helper again. So I think this method should be exposed to Deployments service.", "author": "abanthiy", "createdAt": "2020-04-07T19:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0ODQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MDUwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405240508", "bodyText": "Why can't retry connection be handled inside iotJobsHelper? For better encapsulation, DeploymentService shouldn't need to manage the connection to IoT or any other services.", "author": "fengwang666", "createdAt": "2020-04-08T03:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0ODQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NjEyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405846129", "bodyText": "I am not completely convinced with this. IMO a connection should be established when triggered and similary it should be closed gracefully, as compared to connection being established when initializing an object.", "author": "abanthiy", "createdAt": "2020-04-08T22:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0ODQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0OTc1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404549753", "bodyText": "What's this for?", "author": "fengwang666", "createdAt": "2020-04-07T05:47:50Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/exceptions/AWSIotException.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment.exceptions;\n+\n+public class AWSIotException extends Exception {\n+\n+    static final long serialVersionUID = -3387516993124229948L;", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2MDMwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405060309", "bodyText": "Exception is Serializable, so PMD requires us to have the serialVersionUID since the child class must also be Serializable.", "author": "MikeDombo", "createdAt": "2020-04-07T19:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0OTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5MDYxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r404990617", "bodyText": "Add a log when trying to connect with necessary parameter for debugging unsuccessful connection ?", "author": "leaf94", "createdAt": "2020-04-07T17:35:20Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -3,81 +3,220 @@\n \n package com.aws.iot.evergreen.deployment;\n \n+import com.aws.iot.evergreen.deployment.exceptions.AWSIotException;\n+import com.aws.iot.evergreen.deployment.exceptions.ConnectionUnavailableException;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeviceConfiguration;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n import lombok.NoArgsConstructor;\n-import software.amazon.awssdk.crt.CRT;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionSubscriptionRequest;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n+import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedSubscriptionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n import software.amazon.awssdk.iot.iotjobs.model.RejectedError;\n import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionRequest;\n import software.amazon.awssdk.iot.iotjobs.model.UpdateJobExecutionSubscriptionRequest;\n \n+import java.time.Duration;\n import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n+import javax.inject.Inject;\n \n @NoArgsConstructor\n public class IotJobsHelper {\n \n-    public static final String UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC =\n-            \"$aws/things/{thingName}/jobs/{jobId}/update\" + \"/accepted\";\n-    public static final String UPDATE_SPECIFIC_JOB_REJECTED_TOPIC =\n-            \"$aws/things/{thingName}/jobs/{jobId}/update\" + \"/rejected\";\n+    protected static final String UPDATE_SPECIFIC_JOB_ACCEPTED_TOPIC =\n+            \"$aws/things/{thingName}/jobs/{jobId}/update/accepted\";\n+    protected static final String UPDATE_SPECIFIC_JOB_REJECTED_TOPIC =\n+            \"$aws/things/{thingName}/jobs/{jobId}/update/rejected\";\n+\n+    private static final int MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final int MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    //The time within which device expects an acknowledgement from Iot cloud after publishing an MQTT message\n+    //This value needs to be revisited and set to more realistic numbers\n+    private static final long TIMEOUT_FOR_RESPONSE_FROM_IOT_CLOUD_SECONDS = (long) Duration.ofMinutes(5).getSeconds();\n+    //The time it takes for device to publish a message\n+    //This value needs to be revisited and set to more realistic numbers\n+    private static final long TIMEOUT_FOR_IOT_JOBS_OPERATIONS_SECONDS = (long) Duration.ofMinutes(1).getSeconds();\n+\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n+    private static final String CONNECTION_NOT_ESTABLISHED_WARNING_MESSAGE =\n+            \"Connection not established with Iot cloud. First establish connection to AWS Iot\";\n \n-    //IotJobsHelper is not in Context, so initializing a new one here. It will be added to context in later iterations\n     private static Logger logger = LogManager.getLogger(IotJobsHelper.class);\n \n+    @Inject\n+    private DeviceConfigurationHelper deviceConfigurationHelper;\n+\n+    @Inject\n+    @Setter\n+    private AWSIotMqttConnectionFactory awsIotMqttConnectionFactory;\n+\n+    @Setter\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n     private String thingName;\n     private IotJobsClient iotJobsClient;\n     private MqttClientConnection connection;\n+    private boolean isConnectionEstablished = false;\n \n-    private MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n-        @Override\n-        public void onConnectionInterrupted(int errorCode) {\n-            if (errorCode != 0) {\n-                logger.error(\"Connection interrupted: \" + errorCode + \": \" + CRT.awsErrorString(errorCode));\n-            }\n-        }\n-\n-        @Override\n-        public void onConnectionResumed(boolean sessionPresent) {\n-            logger.info(\"Connection resumed: \" + (sessionPresent ? \"existing session\" : \"clean session\"));\n+    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n+        /*\n+         * This message is received when either of these things happen\n+         * 1. Last job completed (successful/failed)\n+         * 2. A new job was queued\n+         * 3. A job was cancelled\n+         * This message receives the list of Queued and InProgress jobs at the time of this message\n+         */\n+        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n+        if (jobs.containsKey(JobStatus.QUEUED)) {\n+            //Do not wait on the future in this async handler,\n+            //as it will block the thread which establishes\n+            // the MQTT connection. This will result in frozen MQTT connection\n+            requestNextPendingJobDocument();\n         }\n+        //TODO: If there was only one job, then indicate cancellation of that job.\n+        // Empty list will be received.\n     };\n \n     /**\n-     * Connects to AWS Iot Cloud.\n-     *\n-     * @throws ExecutionException if connecting fails\n-     * @throws InterruptedException if interrupted while connecting\n+     * Handler that gets invoked when a job description is received.\n+     * Next pending job description is requested when an mqtt message\n+     * is published using {@Code requestNextPendingJobDocument} in {@link IotJobsHelper}\n      */\n-    public void connectToAwsIot() throws ExecutionException, InterruptedException {\n-        connection.connect().get();\n-    }\n+    private final Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n+        if (response.execution == null) {\n+            return;\n+        }\n+        JobExecutionData jobExecutionData = response.execution;\n+\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobExecutionData.jobId).kv(\"Status\", jobExecutionData.status)\n+                .log(\"Received Iot job description\", jobExecutionData.jobId, jobExecutionData.status);\n+\n+        String documentString;\n+        try {\n+            documentString = OBJECT_MAPPER.writeValueAsString(jobExecutionData.jobDocument);\n+        } catch (JsonProcessingException e) {\n+            //TODO: Handle when job document is incorrect json.\n+            // This should not happen as we are converting a HashMap\n+            return;\n+        }\n+        Deployment deployment =\n+                new Deployment(documentString, Deployment.DeploymentType.IOT_JOBS, jobExecutionData.jobId);\n+\n+        if (deploymentsQueue.offer(deployment)) {\n+            logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobExecutionData.jobId).log(\"Added the job to the queue\");\n+        }\n+    };\n+\n \n     /**\n-     * Constructor to be used in unit tests.\n+     * Constructor for unit testing.\n      *\n-     * @param thingName            The Iot thing name\n      * @param mqttClientConnection Mqtt client connection already setup\n      * @param iotJobsClient        Iot Jobs client using the mqtt connection\n      */\n-    public IotJobsHelper(String thingName, MqttClientConnection mqttClientConnection, IotJobsClient iotJobsClient) {\n-        this.thingName = thingName;\n+    IotJobsHelper(MqttClientConnection mqttClientConnection, IotJobsClient iotJobsClient,\n+                  DeviceConfigurationHelper deviceConfigurationHelper) throws DeviceConfigurationException {\n         this.connection = mqttClientConnection;\n         this.iotJobsClient = iotJobsClient;\n+        this.deviceConfigurationHelper = deviceConfigurationHelper;\n+        this.thingName = deviceConfigurationHelper.getDeviceConfiguration().getThingName();\n+        isConnectionEstablished = true;\n+    }\n+\n+    public static class AWSIotMqttConnectionFactory {\n+        /**\n+         * Get the mqtt connection from device configuration.\n+         *\n+         * @param deviceConfiguration The device configuration {@link DeviceConfiguration}\n+         * @param callbacks           Mqtt callbacks invoked on connection events\n+         * @return {@link MqttClientConnection}\n+         */\n+        public MqttClientConnection getAwsIotMqttConnection(DeviceConfiguration deviceConfiguration,\n+                                                            MqttClientConnectionEvents callbacks) {\n+            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n+                 HostResolver resolver = new HostResolver(eventLoopGroup);\n+                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n+                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n+                         .newMtlsBuilderFromPath(deviceConfiguration.getCertificateFilePath(),\n+                                 deviceConfiguration.getPrivateKeyFilePath())) {\n+                builder.withCertificateAuthorityFromPath(null, deviceConfiguration.getRootCAFilePath())\n+                        //TODO: With MQTT proxy this will change\n+                        .withEndpoint(deviceConfiguration.getMqttClientEndpoint())\n+                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n+                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks)\n+                        .withKeepAliveMs(MQTT_KEEP_ALIVE_TIMEOUT).withPingTimeoutMs(MQTT_PING_TIMEOUT);\n+                return builder.build();\n+            }\n+        }\n     }\n \n+    /**\n+     * Connects to AWS Iot Cloud.\n+     *\n+     * @param deploymentsQueue The queue to which add the {@link DeploymentTask}\n+     * @param callbacks        The callback methods to call when connection interruption or resume happens\n+     * @throws InterruptedException           if interrupted while connecting\n+     * @throws DeviceConfigurationException   if the device is not configured to communicate with AWS Iot cloud\n+     * @throws AWSIotException                when an exception occurs in AWS Iot mqtt broker\n+     * @throws ConnectionUnavailableException if the connection to AWS Iot cloud is not available\n+     */\n+    public void connectToAwsIot(LinkedBlockingQueue deploymentsQueue, MqttClientConnectionEvents callbacks)\n+            throws InterruptedException, DeviceConfigurationException, AWSIotException, ConnectionUnavailableException {\n+\n+        DeviceConfiguration deviceConfiguration = deviceConfigurationHelper.getDeviceConfiguration();\n+        connection = awsIotMqttConnectionFactory.getAwsIotMqttConnection(deviceConfiguration, callbacks);\n+        try {\n+            //TODO: Add retry for Throttling, Limit exceed exception\n+            connection.connect().get(TIMEOUT_FOR_IOT_JOBS_OPERATIONS_SECONDS, TimeUnit.SECONDS);", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwNDgwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405204800", "bodyText": "Added a debug log with configuration information", "author": "abanthiy", "createdAt": "2020-04-08T01:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5MDYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxMjM3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406912374", "bodyText": "Done", "author": "abanthiy", "createdAt": "2020-04-10T19:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5MDYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwODE5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405208192", "bodyText": "When can this happen? do you want to return the function in this case?", "author": "ShirleyZheng92", "createdAt": "2020-04-08T01:34:23Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -293,58 +183,206 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n+    private void connectToAWSIot() throws InterruptedException {\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connectToAwsIot(deploymentsQueue, callbacks);\n+            isConnectedToCloud.set(true);\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Connectivity issue while communicating with AWS Iot cloud.\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+    }\n \n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        //Check if this is for cancellation\n+        if (this.currentJobId != null) {\n+            if (this.currentJobId.equals(deployment.getId())) {\n+                //This is a duplicate message, already processing this deployment\n+                return;\n+            }\n+            //TODO: Cancel the current deployment if the Ids do not match\n+        }\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n+    private void subscribeToIotJobTopics() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot subscribe to topics\");\n+            return;\n+        }\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n \n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n \n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private void updateStatusOfPersistedDeployments() {\n+        if (!isConnectedToCloud.get()) {\n+            logger.atInfo().log(\"Not connected to cloud so cannot udpate the status of deploymentsQueue\");\n+            return;\n+        }\n+        synchronized (this.config) {\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            ArrayList<Topic> deployments = new ArrayList<>();\n+            processedDeployments.forEach(d -> deployments.add((Topic) d));\n+            // Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+            // We want the statuses to be updated in the cloud in the order in which they were processed on the device.\n+            // This will be accurate representation of what happened on the device, especially when deployment service\n+            // processes multiple deployments in the order in which they come. Additionally, a customer workflow can\n+            // depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may\n+            // error out.\n+            ArrayList<Topic> sortedByTimestamp =\n+                    (ArrayList<Topic>) deployments.stream().sorted(new Comparator<Topic>() {\n+                        @Override\n+                        public int compare(Topic o1, Topic o2) {\n+                            if (Long.valueOf(o1.getModtime()) > Long.valueOf(o2.getModtime())) {\n+                                return 1;\n+                            }\n+                            return -1;\n+                        }\n+                    }).collect(Collectors.toList());\n+\n+            Iterator iterator = sortedByTimestamp.iterator();\n+            while (iterator.hasNext()) {\n+                Topic topic = (Topic) iterator.next();\n+                Map<String, Object> deploymentDetails = (HashMap) topic.getOnce();\n+                String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n+                String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+                logger.atInfo().kv(\"Modified time\", topic.getModtime()).kv(JOB_ID_LOG_KEY_NAME, jobId)\n+                        .kv(\"Status\", status).kv(\"StatusDetails\",\n+                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS).toString())\n+                        .log(\"Updating status of persisted deployment\");\n+                try {\n+                    //TODO: Use the status updater as per the deployment type. Updating deployment status in\n+                    // IotJobs is different from updating a deployment coming from device shadow or local deployments.\n+                    iotJobsHelper.updateJobStatus(jobId, JobStatus.valueOf(status),\n+                            (HashMap<String, String>) deploymentDetails\n+                                    .get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS));\n+                } catch (ExecutionException e) {\n+                    if (e.getCause() instanceof MqttException) {\n+                        //caused due to connectivity issue\n+                        logger.atWarn().log(\"Caught exception while updating job status\");\n+                        break;\n+                    }\n+                    //This happens when job status update gets rejected from the Iot Cloud\n+                    //Want to remove this job from the list and continue updating others\n+                    logger.atError().kv(\"Status\", status).kv(JOB_ID_LOG_KEY_NAME, jobId).setCause(e)\n+                            .log(\"Job status update rejected\");\n+                } catch (TimeoutException e) {\n+                    //assuming this is due to network issue\n+                    logger.info(\"Timed out while updating the job status\");\n+                    break;\n+                } catch (InterruptedException e) {\n+                    logger.atWarn().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"Status\", status)\n+                            .log(\"Got interrupted while updating the job status\");", "originalCommit": "3fe6ef0e62f7c166a4bc56b1b1c4b80730e3585d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2MTk5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r405861994", "bodyText": "This can happen when the thread executing this method is interrupted while it is waiting on the update of job status. Yes I have updated the catch block to break in case of InterruptedException.", "author": "abanthiy", "createdAt": "2020-04-08T22:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwODE5Mg=="}], "type": "inlineReview"}, {"oid": "4cbaeb930e9a5c53882ea6e70cfe22f13e65a7cb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4cbaeb930e9a5c53882ea6e70cfe22f13e65a7cb", "message": "Rebasing with master", "committedDate": "2020-04-09T03:58:33Z", "type": "forcePushed"}, {"oid": "fa35bc8041bc120ed2c651c4d863e4812dbffd4f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fa35bc8041bc120ed2c651c4d863e4812dbffd4f", "message": "Rebasing with master", "committedDate": "2020-04-09T23:26:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxODM2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406518368", "bodyText": "What error can it be? Is it 500? I would retry connect if it's 500 error.", "author": "fengwang666", "createdAt": "2020-04-09T22:47:33Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,208 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {", "originalCommit": "fa33b1b269657e2c1f7019faa6a6f7d0746df84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkwMzk0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406903949", "bodyText": "Those retries will be handled inside iotJobsHelper. This in my understanding will be 5XX which come after max retries and 4XX error except 429", "author": "abanthiy", "createdAt": "2020-04-10T19:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxODM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxOTAwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406519006", "bodyText": "Add a comment explaining why set them to null.", "author": "fengwang666", "createdAt": "2020-04-09T22:49:24Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,208 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;", "originalCommit": "fa33b1b269657e2c1f7019faa6a6f7d0746df84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxMjIxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406912217", "bodyText": "Done", "author": "abanthiy", "createdAt": "2020-04-10T19:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxOTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMTc3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406521777", "bodyText": "Don't you need to reset currentJobId to null in the catch block? If createDeployment() fails and the code enters the catch block, currentJobId will be non-null. Next time a new deployment is created, the code goes to line 170 (cancelCurrentDeployment) and causes NPE at line 247.\nWe need to add more tests for this kind of error cases.", "author": "fengwang666", "createdAt": "2020-04-09T22:58:15Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,208 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n+    }\n+\n+    private void cancelCurrentDeployment() {\n+        //TODO: Make the deployment task be able to handle the interrupt\n+        // and wait till the job gets cancelled or is finished\n+        currentProcessStatus.cancel(true);\n+        currentProcessStatus = null;\n+        currentJobId = null;\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);", "originalCommit": "fa33b1b269657e2c1f7019faa6a6f7d0746df84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxMTY0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406911647", "bodyText": "Thats right. Moved the setting of currentJobId to after the catch block once we are sure the task has been submitted. Yes I agree we need more tests for error cases. I will continue doing that in subsequent PRs.", "author": "abanthiy", "createdAt": "2020-04-10T19:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMTc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMjYwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406522601", "bodyText": "Null check for currentProcessStatus before referencing...", "author": "fengwang666", "createdAt": "2020-04-09T23:00:56Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,208 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n+    }\n+\n+    private void cancelCurrentDeployment() {\n+        //TODO: Make the deployment task be able to handle the interrupt\n+        // and wait till the job gets cancelled or is finished\n+        currentProcessStatus.cancel(true);", "originalCommit": "fa33b1b269657e2c1f7019faa6a6f7d0746df84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxMjE5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406912199", "bodyText": "Done", "author": "abanthiy", "createdAt": "2020-04-10T19:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMjYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MTQ0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406541444", "bodyText": "log the cause?", "author": "fengwang666", "createdAt": "2020-04-10T00:10:22Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,208 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n+    }\n+\n+    private void cancelCurrentDeployment() {\n+        //TODO: Make the deployment task be able to handle the interrupt\n+        // and wait till the job gets cancelled or is finished\n+        currentProcessStatus.cancel(true);\n+        currentProcessStatus = null;\n+        currentJobId = null;\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        currentJobId = deployment.getId();\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n         }\n-        return paramValue;\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n     }\n \n-    public static class IotJobsHelperFactory {\n-\n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n-\n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private void subscribeToIotJobTopics() {\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n+        }\n+    }\n+\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n+\n+    //TODO: Move this to a separate class along with storeDeploymentStatusInConfig.\n+    private void updateStatusOfPersistedDeployments() {\n+        //This method can be called is a separate thread when mqtt connection resumes. While this happens a\n+        // deployment can finish and config can get updated with the latest deployment's status using the\n+        // storeDeploymentStatusInConfig. The two threads use the same topics in the config and thus need to be\n+        // synchronized\n+        synchronized (this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS)) {\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            ArrayList<Topic> deployments = new ArrayList<>();\n+            processedDeployments.forEach(d -> deployments.add((Topic) d));\n+            // Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+            // We want the statuses to be updated in the cloud in the order in which they were processed on the device.\n+            // This will be accurate representation of what happened on the device, especially when deployment service\n+            // processes multiple deployments in the order in which they come. Additionally, a customer workflow can\n+            // depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may\n+            // error out.\n+            ArrayList<Topic> sortedByTimestamp =\n+                    (ArrayList<Topic>) deployments.stream().sorted(new Comparator<Topic>() {\n+                        @Override\n+                        public int compare(Topic o1, Topic o2) {\n+                            if (Long.valueOf(o1.getModtime()) > Long.valueOf(o2.getModtime())) {\n+                                return 1;\n+                            }\n+                            return -1;\n+                        }\n+                    }).collect(Collectors.toList());\n+\n+            Iterator iterator = sortedByTimestamp.iterator();\n+            while (iterator.hasNext()) {\n+                Topic topic = (Topic) iterator.next();\n+                Map<String, Object> deploymentDetails = (HashMap) topic.getOnce();\n+                String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n+                String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+                logger.atInfo().kv(\"Modified time\", topic.getModtime()).kv(JOB_ID_LOG_KEY_NAME, jobId)\n+                        .kv(\"Status\", status).kv(\"StatusDetails\",\n+                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS).toString())\n+                        .log(\"Updating status of persisted deployment\");\n+                try {\n+                    //TODO: Use the status updater as per the deployment type. Updating deployment status in\n+                    // IotJobs is different from updating a deployment coming from device shadow or local deployments.\n+                    iotJobsHelper.updateJobStatus(jobId, JobStatus.valueOf(status),\n+                            (HashMap<String, String>) deploymentDetails\n+                                    .get(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS));\n+                } catch (ExecutionException e) {\n+                    if (e.getCause() instanceof MqttException) {\n+                        //caused due to connectivity issue\n+                        logger.atWarn().log(\"Caught exception while updating job status\");", "originalCommit": "fa35bc8041bc120ed2c651c4d863e4812dbffd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxMjE0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406912147", "bodyText": "Done", "author": "abanthiy", "createdAt": "2020-04-10T19:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4NTEwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406885108", "bodyText": "make this final", "author": "MikeDombo", "createdAt": "2020-04-10T18:29:33Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -7,283 +7,181 @@\n import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.ImplementsService;\n import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.AWSIotException;\n+import com.aws.iot.evergreen.deployment.exceptions.ConnectionUnavailableException;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n import com.aws.iot.evergreen.deployment.exceptions.InvalidRequestException;\n import com.aws.iot.evergreen.deployment.exceptions.NonRetryableDeploymentTaskFailureException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.packagemanager.DependencyResolver;\n import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n import com.aws.iot.evergreen.packagemanager.PackageStore;\n+import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n+    @Inject\n+    private final IotJobsHelper iotJobsHelper;\n \n-    private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n+    // If a device is unable to connect to AWS Iot upon starting due to network availability this flag will be set\n+    // which will indicate the device to retry connecting to AWS Iot cloud after polling frequency\n+    private final AtomicBoolean retryConnectingToAWSIot = new AtomicBoolean(false);\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue = new LinkedBlockingQueue<>();", "originalCommit": "fa35bc8041bc120ed2c651c4d863e4812dbffd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkwNDYzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406904630", "bodyText": "Have a setter this for unit testing", "author": "abanthiy", "createdAt": "2020-04-10T19:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4NTEwOA=="}], "type": "inlineReview"}, {"oid": "ae3c48fdb0396f3c866393a31dbd27b5e548d109", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae3c48fdb0396f3c866393a31dbd27b5e548d109", "message": "Persisting deployment status during MQTT connection breakage", "committedDate": "2020-04-10T21:10:23Z", "type": "commit"}, {"oid": "58563344c0508d03b790d1876b906dc8418db646", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/58563344c0508d03b790d1876b906dc8418db646", "message": "Addressed review comments", "committedDate": "2020-04-10T21:10:23Z", "type": "commit"}, {"oid": "55698480fdd5b771f530e093d7b9e8f1cc48dd52", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/55698480fdd5b771f530e093d7b9e8f1cc48dd52", "message": "Adding execution number to the job update call", "committedDate": "2020-04-10T21:10:24Z", "type": "commit"}, {"oid": "f7db026d7f36d4a5df96bd11ed77aee68129c1ba", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f7db026d7f36d4a5df96bd11ed77aee68129c1ba", "message": "Updating the status of deployments in the order of their completion. Refactoring DeploymentTask to parse the job document", "committedDate": "2020-04-10T21:10:24Z", "type": "commit"}, {"oid": "f6e8fe2918a333eab21f1fc9d9540fdd6d9f3b65", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f6e8fe2918a333eab21f1fc9d9540fdd6d9f3b65", "message": "Changing logging format", "committedDate": "2020-04-10T21:10:24Z", "type": "commit"}, {"oid": "4dac6cee62ed104ce122ae7ee1cb4039e66db34f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4dac6cee62ed104ce122ae7ee1cb4039e66db34f", "message": "Persisting job execution number", "committedDate": "2020-04-10T21:10:24Z", "type": "commit"}, {"oid": "686313c23e0ed08d04aab72cdf2fd56b27ae8a14", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/686313c23e0ed08d04aab72cdf2fd56b27ae8a14", "message": "Removing spying from DeploymentTaskTest", "committedDate": "2020-04-10T21:10:24Z", "type": "commit"}, {"oid": "30d85a2b8683446b2d2134e385739f44e466d55a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/30d85a2b8683446b2d2134e385739f44e466d55a", "message": "Refactoring Deployment Service", "committedDate": "2020-04-10T21:10:24Z", "type": "commit"}, {"oid": "72e1eac283fdeb125bdb076a4c53d2561833a765", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/72e1eac283fdeb125bdb076a4c53d2561833a765", "message": "Updating the status in separate thread", "committedDate": "2020-04-10T21:10:24Z", "type": "commit"}, {"oid": "4f466c4e1c58276ca4b93e78b2bc3bfb148ac7f1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4f466c4e1c58276ca4b93e78b2bc3bfb148ac7f1", "message": "Refactoring Deployment service to receive deployments from multiple sources", "committedDate": "2020-04-10T21:11:56Z", "type": "commit"}, {"oid": "af10a48db9422e3e9cb19f335b87f5b7fa2eee3e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af10a48db9422e3e9cb19f335b87f5b7fa2eee3e", "message": "Refactoring deployment service. Rebasing with master", "committedDate": "2020-04-10T21:11:56Z", "type": "commit"}, {"oid": "e6f91c18d39ad1fa0ee9a755a89a84c479b5dfe8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e6f91c18d39ad1fa0ee9a755a89a84c479b5dfe8", "message": "Addressing review comments", "committedDate": "2020-04-10T21:11:56Z", "type": "commit"}, {"oid": "1bfce01f6cd74ef27cfd9cf7c90b211e3d95e7fa", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1bfce01f6cd74ef27cfd9cf7c90b211e3d95e7fa", "message": "Addressing review comments", "committedDate": "2020-04-10T21:11:56Z", "type": "commit"}, {"oid": "d47a76dbb9c54eb41cdb9cbb91fba427c093979a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d47a76dbb9c54eb41cdb9cbb91fba427c093979a", "message": "Rebasing with master", "committedDate": "2020-04-10T21:11:56Z", "type": "commit"}, {"oid": "50dd27cb4c3024996e581978f428979239923e04", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/50dd27cb4c3024996e581978f428979239923e04", "message": "Addressing final comments", "committedDate": "2020-04-10T21:11:56Z", "type": "commit"}, {"oid": "14a49c41c072d815fe03b16c61d2fbbd1767b839", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/14a49c41c072d815fe03b16c61d2fbbd1767b839", "message": "Updating the readme", "committedDate": "2020-04-10T21:11:56Z", "type": "commit"}, {"oid": "14a49c41c072d815fe03b16c61d2fbbd1767b839", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/14a49c41c072d815fe03b16c61d2fbbd1767b839", "message": "Updating the readme", "committedDate": "2020-04-10T21:11:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0Njg3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406946871", "bodyText": "Since these are used in your test as well from what I remember, why not have these be public so that it can be reused instead of copied?", "author": "MikeDombo", "createdAt": "2020-04-10T21:13:23Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -7,283 +7,181 @@\n import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.ImplementsService;\n import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.AWSIotException;\n+import com.aws.iot.evergreen.deployment.exceptions.ConnectionUnavailableException;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n import com.aws.iot.evergreen.deployment.exceptions.InvalidRequestException;\n import com.aws.iot.evergreen.deployment.exceptions.NonRetryableDeploymentTaskFailureException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.packagemanager.DependencyResolver;\n import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n import com.aws.iot.evergreen.packagemanager.PackageStore;\n+import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";", "originalCommit": "14a49c41c072d815fe03b16c61d2fbbd1767b839", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NTkzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406995935", "bodyText": "I do not see them being used in tests", "author": "abanthiy", "createdAt": "2020-04-11T00:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0Njg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0NzY1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406947657", "bodyText": "You don't need to catch this anymore, startup is allowed to throw InterruptedException, which is expected when EG wants to stop your service.", "author": "MikeDombo", "createdAt": "2020-04-10T21:15:45Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -7,283 +7,181 @@\n import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.ImplementsService;\n import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.AWSIotException;\n+import com.aws.iot.evergreen.deployment.exceptions.ConnectionUnavailableException;\n+import com.aws.iot.evergreen.deployment.exceptions.DeviceConfigurationException;\n import com.aws.iot.evergreen.deployment.exceptions.InvalidRequestException;\n import com.aws.iot.evergreen.deployment.exceptions.NonRetryableDeploymentTaskFailureException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.packagemanager.DependencyResolver;\n import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n import com.aws.iot.evergreen.packagemanager.PackageStore;\n+import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import lombok.Getter;\n import lombok.Setter;\n import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n-import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n-import software.amazon.awssdk.iot.iotjobs.IotJobsClient;\n-import software.amazon.awssdk.iot.iotjobs.model.DescribeJobExecutionResponse;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionData;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionSummary;\n-import software.amazon.awssdk.iot.iotjobs.model.JobExecutionsChangedEvent;\n+import software.amazon.awssdk.crt.mqtt.MqttException;\n import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n \n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n @ImplementsService(name = \"DeploymentService\", autostart = true)\n public class DeploymentService extends EvergreenService {\n+\n+    public static final String DEPLOYMENT_SERVICE_TOPICS = \"DeploymentService\";\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n     private static final ObjectMapper OBJECT_MAPPER =\n             new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n-    //TODO: Change this to be taken from config or user input. Maybe as part of deployment document\n-    private static final Path LOCAL_ARTIFACT_SOURCE =\n-            Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n-\n-    public static final String DEVICE_PARAM_THING_NAME = \"thingName\";\n-    public static final String DEVICE_PARAM_MQTT_CLIENT_ENDPOINT = \"mqttClientEndpoint\";\n-    public static final String DEVICE_PARAM_PRIVATE_KEY_PATH = \"privateKeyPath\";\n-    public static final String DEVICE_PARAM_CERTIFICATE_FILE_PATH = \"certificateFilePath\";\n-    public static final String DEVICE_PARAM_ROOT_CA_PATH = \"rootCaPath\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    private static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n \n     @Inject\n+    @Setter\n     private ExecutorService executorService;\n     @Inject\n     private Kernel kernel;\n     @Inject\n-    private IotJobsHelperFactory iotJobsHelperFactory;\n-    @Inject\n     private DependencyResolver dependencyResolver;\n     @Inject\n     private PackageStore packageStore;\n     @Inject\n     private KernelConfigResolver kernelConfigResolver;\n \n+    @Inject\n+    private final IotJobsHelper iotJobsHelper;\n \n-    private IotJobsHelper iotJobsHelper;\n-    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    private boolean errored;\n     @Getter\n     private Future<Void> currentProcessStatus = null;\n-    private String currentJobId;\n+    private String currentJobId = null;\n \n+    @Getter\n+    private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n+    // If a device is unable to connect to AWS Iot upon starting due to network availability this flag will be set\n+    // which will indicate the device to retry connecting to AWS Iot cloud after polling frequency\n+    private final AtomicBoolean retryConnectingToAWSIot = new AtomicBoolean(false);\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue = new LinkedBlockingQueue<>();\n \n-    private MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+    final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n+            //TODO: what about error code 0\n             if (errorCode != 0) {\n-                logger.error(\"Connection interrupted: \" + errorCode + \": \" + CRT.awsErrorString(errorCode));\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                //TODO: Detect this using secondary mechanisms like checking if internet is availalble\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n             }\n         }\n \n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n-            logger.info(\"Connection resumed: \" + (sessionPresent ? \"existing session\" : \"clean session\"));\n-        }\n-    };\n-\n-    private final Consumer<JobExecutionsChangedEvent> eventHandler = event -> {\n-        /*\n-         * This message is received when either of these things happen\n-         * 1. Last job completed (successful/failed)\n-         * 2. A new job was queued\n-         * 3. A job was cancelled\n-         * This message receives the list of Queued and InProgress jobs at the time of this message\n-         */\n-        Map<JobStatus, List<JobExecutionSummary>> jobs = event.jobs;\n-        if (jobs.containsKey(JobStatus.QUEUED)) {\n-            //Do not wait on the future in this async handler,\n-            //as it will block the thread which establishes\n-            // the MQTT connection. This will result in frozen MQTT connection\n-            this.iotJobsHelper.requestNextPendingJobDocument();\n-        }\n-    };\n-\n-    private final Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-\n-        JobExecutionData jobExecutionData = response.execution;\n-        currentJobId = jobExecutionData.jobId;\n-        logger.atInfo()\n-                .log(\"Received job description for job id : {} and status {}\", currentJobId, jobExecutionData.status);\n-        logger.addDefaultKeyValue(\"JobId\", currentJobId);\n-        if (jobExecutionData.status == JobStatus.IN_PROGRESS) {\n-            //TODO: Check the currently running process,\n-            // if it is same as this jobId then do nothing. If not then there is something wrong\n-            return;\n-        } else if (jobExecutionData.status == JobStatus.QUEUED) {\n-            //If there is a job running at this time, then it has been canceled in cloud and should be attempted to\n-            // be canceled here\n-            if (currentProcessStatus != null && !currentProcessStatus.cancel(true)) {\n-                //If the cancel is not successful\n-                return;\n-            }\n-            iotJobsHelper.updateJobStatus(currentJobId, JobStatus.IN_PROGRESS, null);\n-\n-            logger.info(\"Updated the status of JobsId {} to {}\", currentJobId, JobStatus.IN_PROGRESS);\n-\n-\n-            DeploymentTask deploymentTask;\n-            try {\n-                deploymentTask = createDeploymentTask(response.execution.jobDocument);\n-            } catch (InvalidRequestException e) {\n-                logger.atError().setCause(e).addKeyValue(\"message\", e.getMessage())\n-                        .log(\"Caught InvalidRequestException while processing a deployment\");\n-                HashMap<String, String> statusDetails = new HashMap<>();\n-                statusDetails.put(\"error\", e.getMessage());\n-                updateJobAsFailed(currentJobId, statusDetails);\n-                return;\n-            }\n-            //Starting the job processing in another thread\n-            currentProcessStatus = executorService.submit(deploymentTask);\n-            logger.atInfo().log(\"Submitted the job with jobId {}\", jobExecutionData.jobId);\n+            logger.atInfo().kv(\"sessionPresent\", (sessionPresent ? \"true\" : \"false\")).log(\"Connection resumed\");\n+            runInSeparateThread(() -> {\n+                subscribeToIotJobTopics();\n+                updateStatusOfPersistedDeployments();\n+            });\n         }\n-\n     };\n \n-    private DeploymentTask createDeploymentTask(Map<String, Object> jobDocument) throws InvalidRequestException {\n-\n-        DeploymentDocument deploymentDocument = parseAndValidateJobDocument(jobDocument);\n-        return new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n-                deploymentDocument);\n-    }\n-\n-    private DeploymentDocument parseAndValidateJobDocument(Map<String, Object> jobDocument)\n-            throws InvalidRequestException {\n-        if (jobDocument == null) {\n-            String errorMessage = \"Job document cannot be empty\";\n-            throw new InvalidRequestException(errorMessage);\n-        }\n-        DeploymentDocument deploymentDocument = null;\n-        try {\n-            String jobDocumentString = OBJECT_MAPPER.writeValueAsString(jobDocument);\n-            deploymentDocument = OBJECT_MAPPER.readValue(jobDocumentString, DeploymentDocument.class);\n-            return deploymentDocument;\n-        } catch (JsonProcessingException e) {\n-            String errorMessage = \"Unable to parse the job document\";\n-            throw new InvalidRequestException(errorMessage, e);\n-        }\n-    }\n-\n-    private void updateJobAsSucceeded(String jobId, HashMap<String, String> statusDetails) {\n-        iotJobsHelper.updateJobStatus(jobId, JobStatus.SUCCEEDED, statusDetails);\n-        logger.addDefaultKeyValue(\"JobId\", \"\");\n-    }\n-\n-    private void updateJobAsFailed(String jobId, HashMap<String, String> statusDetails) {\n-        iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n-        logger.addDefaultKeyValue(\"JobId\", \"\");\n-    }\n-\n     /**\n      * Constructor.\n      *\n      * @param topics the configuration coming from kernel\n      */\n     public DeploymentService(Topics topics) {\n         super(topics);\n+        this.iotJobsHelper = new IotJobsHelper(deploymentsQueue, callbacks);\n     }\n \n     /**\n      * Constructor for unit testing.\n      *\n      * @param topics               The configuration coming from  kernel\n-     * @param iotJobsHelperFactory Factory object for creating IotJobHelper\n      * @param executorService      Executor service coming from kernel\n      * @param kernel               The evergreen kernel\n      * @param dependencyResolver   {@link DependencyResolver}\n      * @param packageStore         {@link PackageStore}\n      * @param kernelConfigResolver {@link KernelConfigResolver}\n      */\n-    public DeploymentService(Topics topics, IotJobsHelperFactory iotJobsHelperFactory, ExecutorService executorService,\n-                             Kernel kernel, DependencyResolver dependencyResolver, PackageStore packageStore,\n-                             KernelConfigResolver kernelConfigResolver) {\n+\n+    DeploymentService(Topics topics, ExecutorService executorService, Kernel kernel,\n+                      DependencyResolver dependencyResolver, PackageStore packageStore,\n+                      KernelConfigResolver kernelConfigResolver, IotJobsHelper iotJobsHelper) {\n         super(topics);\n-        this.iotJobsHelperFactory = iotJobsHelperFactory;\n         this.executorService = executorService;\n         this.kernel = kernel;\n         this.dependencyResolver = dependencyResolver;\n         this.packageStore = packageStore;\n         this.kernelConfigResolver = kernelConfigResolver;\n+        this.iotJobsHelper = iotJobsHelper;\n     }\n \n+\n     @Override\n     public void startup() {\n-        // Reset shutdown signal since we're trying to startup here\n-        this.receivedShutdown.set(false);\n-        logger.info(\"Starting up the Deployment Service\");\n-        String thingName = getStringParameterFromConfig(DEVICE_PARAM_THING_NAME);\n-        //TODO: Add any other checks to verify device provisioned to communicate with Iot Cloud\n-        if (thingName.isEmpty()) {\n-            logger.info(\"There is no thingName assigned to this device. Cannot communicate with cloud.\"\n-                    + \" Finishing deployment service\");\n-            reportState(State.FINISHED);\n-            return;\n-        }\n-\n         try {\n-            initializeIotJobsHelper(thingName);\n-            iotJobsHelper.connectToAwsIot();\n-            iotJobsHelper.subscribeToEventNotifications(eventHandler);\n-            iotJobsHelper.subscribeToGetNextJobDecription(describeJobExecutionResponseConsumer, rejectedError -> {\n-                logger.error(\"Job subscription got rejected\", rejectedError);\n-                //TODO: Add retry logic for subscribing\n-            });\n+            logger.info(\"Starting up the Deployment Service\");\n+            // Reset shutdown signal since we're trying to startup here\n+            this.receivedShutdown.set(false);\n+            connectToAWSIot();\n             reportState(State.RUNNING);\n-        } catch (ExecutionException | InterruptedException ex) {\n-            logger.error(\"Caught exception in subscribing to topics\", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-        logger.info(\"Running deployment service\");\n-        while (!receivedShutdown.get() && !errored) {\n-            try {\n-                if (currentProcessStatus != null) {\n-                    logger.info(\"Getting the status of the current process\");\n-\n-                    currentProcessStatus.get();\n-                    updateJobAsSucceeded(currentJobId, null);\n-                    currentProcessStatus = null;\n+            logger.info(\"Running deployment service\");\n+\n+            while (!receivedShutdown.get()) {\n+                if (currentProcessStatus != null && currentProcessStatus.isDone()) {\n+                    finishCurrentDeployment();\n+                }\n+                //Cannot wait on queue because need to listen to queue as well as the currentProcessStatus future.\n+                //One thread cannot wait on both. If we want to make this completely event driven then we need to put\n+                // the waiting on currentProcessStatus in its own thread. I currently choose to not do this.\n+                Deployment deployment = deploymentsQueue.poll();\n+                if (deployment != null) {\n+                    if (currentJobId != null) {\n+                        if (deployment.getId().equals(currentJobId)) {\n+                            //Duplicate message and already processing this deployment so nothing is needed\n+                            continue;\n+                        } else {\n+                            //Assuming cancel will either cancel the current job or wait till it finishes\n+                            cancelCurrentDeployment();\n+                        }\n+                    }\n+                    createNewDeployment(deployment);\n                 }\n                 Thread.sleep(pollingFrequency);\n-            } catch (InterruptedException ex) {\n-                logger.atError().log(\"Interrupted while sleeping in DA\");\n-                errored = true;\n-                reportState(State.ERRORED);\n-            } catch (ExecutionException e) {\n-                logger.atError().setCause(e).addKeyValue(\"jobId\", currentJobId)\n-                        .log(\"Caught exception while getting the status of the Job\");\n-                Throwable t = e.getCause();\n-                if (t instanceof NonRetryableDeploymentTaskFailureException) {\n-                    HashMap<String, String> statusDetails = new HashMap<>();\n-                    statusDetails.put(\"error\", t.getMessage());\n-                    updateJobAsFailed(currentJobId, statusDetails);\n+\n+                if (retryConnectingToAWSIot.get()) {\n+                    connectToAWSIot();\n                 }\n-                currentProcessStatus = null;\n-                //TODO: Handle retryable error\n             }\n+        } catch (InterruptedException e) {", "originalCommit": "14a49c41c072d815fe03b16c61d2fbbd1767b839", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NjAwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406996003", "bodyText": "Removed it", "author": "abanthiy", "createdAt": "2020-04-11T00:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0NzY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODMzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406948330", "bodyText": "some logging? This would seem to be a significant event.", "author": "MikeDombo", "createdAt": "2020-04-10T21:18:02Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,212 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        // Setting this to null to indicate there is not current deployment being processed\n+        // Did not use optionals over null due to performance\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n+    }\n+\n+    private void cancelCurrentDeployment() {\n+        //TODO: Make the deployment task be able to handle the interrupt", "originalCommit": "14a49c41c072d815fe03b16c61d2fbbd1767b839", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NTEzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406995130", "bodyText": "Added logs when triggering cancel", "author": "abanthiy", "createdAt": "2020-04-11T00:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODc3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406948771", "bodyText": "Why not create this in the constructor and then save the Topics as a field?", "author": "MikeDombo", "createdAt": "2020-04-10T21:19:14Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,212 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        // Setting this to null to indicate there is not current deployment being processed\n+        // Did not use optionals over null due to performance\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n+    }\n+\n+    private void cancelCurrentDeployment() {\n+        //TODO: Make the deployment task be able to handle the interrupt\n+        // and wait till the job gets cancelled or is finished\n+        if (currentProcessStatus != null) {\n+            currentProcessStatus.cancel(true);\n+            currentProcessStatus = null;\n+            currentJobId = null;\n+        }\n+    }\n+\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n+        }\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n+        currentJobId = deployment.getId();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void subscribeToIotJobTopics() {\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n         }\n-        return paramValue;\n     }\n \n-    public static class IotJobsHelperFactory {\n-\n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n-\n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n+\n+    //TODO: Move this to a separate class along with storeDeploymentStatusInConfig.\n+    private void updateStatusOfPersistedDeployments() {\n+        //This method can be called is a separate thread when mqtt connection resumes. While this happens a\n+        // deployment can finish and config can get updated with the latest deployment's status using the\n+        // storeDeploymentStatusInConfig. The two threads use the same topics in the config and thus need to be\n+        // synchronized\n+        synchronized (this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS)) {\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);", "originalCommit": "14a49c41c072d815fe03b16c61d2fbbd1767b839", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDUxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406994513", "bodyText": "Does it matter? This code would still stay same I believe", "author": "abanthiy", "createdAt": "2020-04-11T00:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5ODEwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406998105", "bodyText": "Because then you wouldn't need to duplicate all this code x2. You can just have processedDeployments as a field and refer to it at any time easily. Once the topic is created you don't need to create it again.", "author": "MikeDombo", "createdAt": "2020-04-11T01:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5ODU1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406998552", "bodyText": "This does not create again but returns the existing topic if it exists. Even then I would still use the same code to get the processedDeployments topics to be safe.", "author": "abanthiy", "createdAt": "2020-04-11T01:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5ODc2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406998767", "bodyText": "I know that it doesn't recreate the node. But why run the same code twice in a row?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    synchronized (this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS)) {\n          \n          \n            \n                        Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n          \n          \n            \n                Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n          \n          \n            \n                    synchronized (processedDeployments) {", "author": "MikeDombo", "createdAt": "2020-04-11T01:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5OTYzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406999635", "bodyText": "Agree", "author": "abanthiy", "createdAt": "2020-04-11T01:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0ODc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0OTAwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406949001", "bodyText": "This case seems unsafe, I don't know if it is guaranteed that Collectors.toList() always gives an ArrayList. If you don't need specifically an ArrayList, then just use List.", "author": "MikeDombo", "createdAt": "2020-04-10T21:19:59Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -295,58 +193,212 @@ public void shutdown() {\n         }\n     }\n \n-    private void initializeIotJobsHelper(String thingName) {\n-        //TODO: Get it from bootstrap config. Path of Bootstrap config should be taken as argument to kernel?\n-        String privateKeyPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_PRIVATE_KEY_PATH));\n-        String certificateFilePath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_CERTIFICATE_FILE_PATH));\n-        String rootCAPath = kernel.deTilde(getStringParameterFromConfig(DEVICE_PARAM_ROOT_CA_PATH));\n-        String clientEndpoint = getStringParameterFromConfig(DEVICE_PARAM_MQTT_CLIENT_ENDPOINT);\n-\n-        logger.atInfo().kv(\"privateKeyPath\", privateKeyPath).kv(\"certificatePath\", certificateFilePath)\n-                .kv(\"rootCAPath\", rootCAPath).kv(\"endpoint\", clientEndpoint).kv(\"thingName\", thingName).log();\n-        this.iotJobsHelper = iotJobsHelperFactory\n-                .getIotJobsHelper(thingName, certificateFilePath, privateKeyPath, rootCAPath, clientEndpoint,\n-                        callbacks);\n+    private void connectToAWSIot() throws InterruptedException {\n+\n+        retryConnectingToAWSIot.set(false);\n+        try {\n+            //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+            iotJobsHelper.connect();\n+        } catch (DeviceConfigurationException e) {\n+            //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+            logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                    + \"Device will now operate in offline mode\");\n+        } catch (ConnectionUnavailableException e) {\n+            //TODO: Add retry logic to connect again when connection availalble\n+            logger.atWarn().setCause(e).log(\"Fail to connect to IoT cloud due to connectivity issue, will retry later. \"\n+                    + \"Device will now operate in offline mode\");\n+            retryConnectingToAWSIot.set(true);\n+        } catch (AWSIotException e) {\n+            //This is a non transient exception and might require customer's attention\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should error the service in this case\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private void finishCurrentDeployment() throws InterruptedException {\n+        logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, currentJobId).log(\"Current deployment finished\");\n+        try {\n+            //No timeout is set here. Detection of error is delegated to downstream components like\n+            // dependency resolver, package downloader, kernel which will have more visibility\n+            // if something is going wrong\n+            currentProcessStatus.get();\n+            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+        } catch (ExecutionException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, currentJobId).setCause(e)\n+                    .log(\"Caught exception while getting the status of the Job\");\n+            Throwable t = e.getCause();\n+            if (t instanceof NonRetryableDeploymentTaskFailureException) {\n+                HashMap<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"error\", t.getMessage());\n+                storeDeploymentStatusInConfig(currentJobId, JobStatus.FAILED, statusDetails);\n+            }\n+            //TODO: resubmit the job in case of RetryableDeploymentTaskFailureException\n+        }\n+        // Setting this to null to indicate there is not current deployment being processed\n+        // Did not use optionals over null due to performance\n+        currentProcessStatus = null;\n+        currentJobId = null;\n+        updateStatusOfPersistedDeployments();\n+    }\n+\n+    private void cancelCurrentDeployment() {\n+        //TODO: Make the deployment task be able to handle the interrupt\n+        // and wait till the job gets cancelled or is finished\n+        if (currentProcessStatus != null) {\n+            currentProcessStatus.cancel(true);\n+            currentProcessStatus = null;\n+            currentJobId = null;\n+        }\n+    }\n+\n+    private void createNewDeployment(Deployment deployment) {\n+        logger.atInfo().kv(\"DeploymentId\", deployment.getId())\n+                .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                .log(\"Received deployment in the queue\");\n+        DeploymentDocument deploymentDocument;\n+        try {\n+            logger.atInfo().kv(\"document\", deployment.getDeploymentDocument())\n+                    .log(\"Recevied deployment document in queue\");\n+            deploymentDocument = parseAndValidateJobDocument(deployment.getDeploymentDocument());\n+        } catch (InvalidRequestException e) {\n+            logger.atError().kv(JOB_ID_LOG_KEY_NAME, deployment.getId())\n+                    .kv(\"DeploymentType\", deployment.getDeploymentType().toString())\n+                    .log(\"Invalid document for deployment\");\n+            HashMap<String, String> statusDetails = new HashMap<>();\n+            statusDetails.put(\"error\", e.getMessage());\n+            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            return;\n+        }\n+        DeploymentTask deploymentTask =\n+                new DeploymentTask(dependencyResolver, packageStore, kernelConfigResolver, kernel, logger,\n+                        deploymentDocument);\n+        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n+        updateStatusOfPersistedDeployments();\n+        currentProcessStatus = executorService.submit(deploymentTask);\n+        currentJobId = deployment.getId();\n     }\n \n-    private String getStringParameterFromConfig(String parameterName) {\n-        String paramValue = \"\";\n-        Topic childTopic = config.findLeafChild(parameterName);\n-        if (childTopic != null) {\n-            paramValue = childTopic.getOnce().toString();\n+    private void subscribeToIotJobTopics() {\n+        try {\n+            iotJobsHelper.subscribeToJobsTopics();\n+        } catch (ConnectionUnavailableException e) {\n+            logger.atWarn().setCause(e).log(\"No connection available during subscribing to topic. \"\n+                    + \"Will retry when connection is available\");\n+        } catch (InterruptedException e) {\n+            //Since this method can run as runnable cannot throw exception so handling exceptions here\n+            logger.atWarn().log(\"Interrupted while running deployment service\");\n+            //TODO: Perform any cleanup that needs to be done\n+            reportState(State.FINISHED);\n+        } catch (AWSIotException e) {\n+            //Device will run in offline mode if it is not able to subscribe to Iot Jobs topics\n+            logger.atError().setCause(e).log(\"Caught an exception from AWS Iot cloud\");\n+            //TODO: Revisit if we should erroring the service in this case\n         }\n-        return paramValue;\n     }\n \n-    public static class IotJobsHelperFactory {\n-\n-        /**\n-         * Returns IotJobsHelper {@link IotJobsHelper}.\n-         *\n-         * @param thingName           Iot thing name\n-         * @param certificateFilePath Device certificate file path\n-         * @param privateKeyPath      Device private key file path\n-         * @param rootCAPath          Root CA file path\n-         * @param clientEndpoint      Mqtt endpoint for the customer account\n-         * @param callbacks           Callback for handling Mqtt connection events\n-         * @return\n-         */\n-        public IotJobsHelper getIotJobsHelper(String thingName, String certificateFilePath, String privateKeyPath,\n-                                              String rootCAPath, String clientEndpoint,\n-                                              MqttClientConnectionEvents callbacks) {\n-            try (EventLoopGroup eventLoopGroup = new EventLoopGroup(1);\n-                 HostResolver resolver = new HostResolver(eventLoopGroup);\n-                 ClientBootstrap clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-                 AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder\n-                         .newMtlsBuilderFromPath(certificateFilePath, privateKeyPath)) {\n-                builder.withCertificateAuthorityFromPath(null, rootCAPath).withEndpoint(clientEndpoint)\n-                        .withClientId(UUID.randomUUID().toString()).withCleanSession(true)\n-                        .withBootstrap(clientBootstrap).withConnectionEventCallbacks(callbacks);\n-\n-                MqttClientConnection connection = builder.build();\n-                IotJobsClient iotJobsClient = new IotJobsClient(connection);\n-                return new IotJobsHelper(thingName, connection, iotJobsClient);\n+    private Future<?> runInSeparateThread(Runnable method) {\n+        return executorService.submit(method);\n+    }\n+\n+    //TODO: Move this to a separate class along with storeDeploymentStatusInConfig.\n+    private void updateStatusOfPersistedDeployments() {\n+        //This method can be called is a separate thread when mqtt connection resumes. While this happens a\n+        // deployment can finish and config can get updated with the latest deployment's status using the\n+        // storeDeploymentStatusInConfig. The two threads use the same topics in the config and thus need to be\n+        // synchronized\n+        synchronized (this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS)) {\n+            Topics processedDeployments = this.config.createInteriorChild(PROCESSED_DEPLOYMENTS_TOPICS);\n+            ArrayList<Topic> deployments = new ArrayList<>();\n+            processedDeployments.forEach(d -> deployments.add((Topic) d));\n+            // Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+            // We want the statuses to be updated in the cloud in the order in which they were processed on the device.\n+            // This will be accurate representation of what happened on the device, especially when deployment service\n+            // processes multiple deployments in the order in which they come. Additionally, a customer workflow can\n+            // depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may\n+            // error out.\n+            ArrayList<Topic> sortedByTimestamp =\n+                    (ArrayList<Topic>) deployments.stream().sorted(new Comparator<Topic>() {", "originalCommit": "14a49c41c072d815fe03b16c61d2fbbd1767b839", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5Nzc2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r406997769", "bodyText": "ArrayList is not required, changed it to List.", "author": "abanthiy", "createdAt": "2020-04-11T01:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0OTAwMQ=="}], "type": "inlineReview"}, {"oid": "bca234863272d7d9e721aa2df3b3cd8b9b4defb4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bca234863272d7d9e721aa2df3b3cd8b9b4defb4", "message": "Fixing DI bugs", "committedDate": "2020-04-10T23:22:19Z", "type": "commit"}, {"oid": "49698de61ccfc034fec6e2b43ad0de97e6d4937d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/49698de61ccfc034fec6e2b43ad0de97e6d4937d", "message": "Adding logs for cancelling job", "committedDate": "2020-04-11T00:46:11Z", "type": "commit"}, {"oid": "2ae50bf7dfb6219a79bbd64869f9d0c27bade15d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2ae50bf7dfb6219a79bbd64869f9d0c27bade15d", "message": "Throwing InterruptedException in deployment service startup", "committedDate": "2020-04-11T00:59:59Z", "type": "commit"}, {"oid": "f82576f727552c34fe4972e8e8b5171d37572a78", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f82576f727552c34fe4972e8e8b5171d37572a78", "message": "Calling creat processedDeployments topics methos only once", "committedDate": "2020-04-11T01:24:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAwMDY5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/154#discussion_r407000693", "bodyText": "this fail has no effect. any exception from the DA will be logged, but won't effect the test. What you can do for this is to run it in an executor, get the future from it, and call get on the future which will then throw the exception in the main testing thread, which would cause the test to fail if there were any exceptions.\nBut it might be OK for it to have no effect in this case.", "author": "MikeDombo", "createdAt": "2020-04-11T01:36:08Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -80,184 +71,240 @@\n     @Mock\n     private KernelConfigResolver kernelConfigResolver;\n \n-    @Captor\n-    ArgumentCaptor<Consumer<JobExecutionsChangedEvent>> jobEventConsumerCaptor;\n+    DeploymentService deploymentService;\n+    LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        // initialize Evergreen service specific mocks\n+        serviceFullName = \"DeploymentService\";\n+        initializeMockedConfig();\n+        when(stateTopic.getOnce()).thenReturn(State.INSTALLED);\n+        //Creating the class to be tested\n+        deploymentService =\n+                new DeploymentService(config, mockExecutorService, mockKernel,\n+                        dependencyResolver, packageStore, kernelConfigResolver, mockIotJobsHelper);\n+        deploymentsQueue = new LinkedBlockingQueue<>();\n+        deploymentService.setDeploymentsQueue(deploymentsQueue);\n+    }\n \n-    @Captor\n-    ArgumentCaptor<Consumer<DescribeJobExecutionResponse>> describeJobConsumerCaptor;\n+    @Nested\n+    public class ServiceStartup {\n \n-    DeploymentService deploymentService;\n+        @BeforeEach\n+        public void startService() throws Exception {\n+            startDeploymentServiceInAnotherThread();\n+        }\n \n+        @AfterEach\n+        public void tearDown() {\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_device_configured_THEN_start_deployment_service()\n+                throws Exception {\n+            verify(mockIotJobsHelper).connect();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_service_running_WHEN_connection_resumed_THEN_subscriptions_redone()\n+                throws Exception {\n+            deploymentService.setExecutorService(mockKernel.context.get(ExecutorService.class));\n+            verify(mockIotJobsHelper).connect();\n+            MqttClientConnectionEvents callbacks = deploymentService.callbacks;\n+            callbacks.onConnectionResumed(true);\n+            //Wait for the subscription to be executed in separate thread\n+            Thread.sleep(Duration.ofSeconds(1).toMillis());\n+            verify(mockIotJobsHelper).subscribeToJobsTopics();\n+        }\n+    }\n \n     @Nested\n-    class DeploymentServiceInitializedWithMocks {\n+    class DeploymentInProgress {\n+\n+        CompletableFuture<Void> mockFuture = new CompletableFuture<>();\n \n         @BeforeEach\n-        public void setup() {\n-            // initialize Evergreen service specific mocks\n-            serviceFullName = \"DeploymentService\";\n-            initializeMockedConfig();\n-            when(stateTopic.getOnce()).thenReturn(State.INSTALLED);\n-\n-            when(config.findLeafChild(Mockito.any())).thenAnswer(invocationOnMock -> {\n-                String parameterName = invocationOnMock.getArguments()[0].toString();\n-                if (parameterName.equals(DeploymentService.DEVICE_PARAM_THING_NAME)) {\n-                    when(deviceParamTopic.getOnce()).thenReturn(MOCK_THING_NAME);\n-                    return deviceParamTopic;\n-                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_MQTT_CLIENT_ENDPOINT)) {\n-                    when(deviceParamTopic.getOnce()).thenReturn(MOCK_CLIENT_ENDPOINT);\n-                    return deviceParamTopic;\n-                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_PRIVATE_KEY_PATH)) {\n-                    when(deviceParamTopic.getOnce()).thenReturn(MOCK_PRIVATE_KEY_PATH);\n-                    return deviceParamTopic;\n-                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_CERTIFICATE_FILE_PATH)) {\n-                    when(deviceParamTopic.getOnce()).thenReturn(MOCK_CERTIFICATE_PATH);\n-                    return deviceParamTopic;\n-                } else if (parameterName.equals(DeploymentService.DEVICE_PARAM_ROOT_CA_PATH)) {\n-                    when(deviceParamTopic.getOnce()).thenReturn(MOCK_ROOTCA_PATH);\n-                    return deviceParamTopic;\n-                }\n-                return deviceParamTopic;\n-            });\n-\n-            //Deployment service specific mocks\n-            when(mockKernel.deTilde(anyString())).thenAnswer(invocationOnMock -> {\n-                return invocationOnMock.getArguments()[0].toString();\n-            });\n-            when(mockIotJobsHelperFactory.getIotJobsHelper(anyString(), anyString(), anyString(), anyString(),\n-                    anyString(), any(MqttClientConnectionEvents.class)))\n-                    .thenReturn(mockIotJobsHelper);\n-\n-            //Creating the class to be tested\n-            deploymentService =\n-                    new DeploymentService(config, mockIotJobsHelperFactory, mockExecutorService, mockKernel,\n-                            dependencyResolver, packageStore, kernelConfigResolver);\n+        public void setup() throws Exception {\n+            Topics processedDeploymentsTopics =\n+                    mockKernel.lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                            DeploymentService.DEPLOYMENT_SERVICE_TOPICS,\n+                            DeploymentService.PROCESSED_DEPLOYMENTS_TOPICS);\n+            when(config.createInteriorChild(eq(DeploymentService.PROCESSED_DEPLOYMENTS_TOPICS)))\n+                    .thenReturn(processedDeploymentsTopics);\n+            deploymentService.setPollingFrequency(Duration.ofSeconds(1).toMillis());\n+            mockFuture.complete(null);\n+            deploymentsQueue.put(new Deployment(\"{\\\"DeploymentId\\\":\\\"testId\\\"}\",\n+                    Deployment.DeploymentType.IOT_JOBS, TEST_JOB_ID_1));\n         }\n \n         @Test\n         public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_report_succeeded_job_status()\n-                throws ExecutionException, InterruptedException {\n-            CompletableFuture<Void> mockFuture = new CompletableFuture<>();\n-            mockFuture.complete(null);\n+                throws Exception {\n             when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFuture);\n-            deploymentService.setPollingFrequency(Duration.ofSeconds(1).toMillis());\n             startDeploymentServiceInAnotherThread();\n+            verify(mockIotJobsHelper).connect();\n \n-            verify(mockIotJobsHelper).subscribeToGetNextJobDecription(describeJobConsumerCaptor.capture(), any());\n-            Consumer<DescribeJobExecutionResponse> consumer = describeJobConsumerCaptor.getValue();\n-            DescribeJobExecutionResponse response = new DescribeJobExecutionResponse();\n-            response.execution = getTestJobExecutionData();\n-            consumer.accept(response);\n-\n-            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n-            verify(mockExecutorService).submit(any(DeploymentTask.class));\n-            //Wait for the enough time after which deployment service would have updated the status of job\n+            //Wait for the enough time after which deployment service would have processed the job from the queue\n             Thread.sleep(Duration.ofSeconds(2).toMillis());\n-\n-            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.SUCCEEDED), any());\n+            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS),\n+                    any());\n+            verify(mockExecutorService).submit(any(DeploymentTask.class));\n+            verify(mockIotJobsHelper)\n+                    .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.SUCCEEDED), any());\n             deploymentService.shutdown();\n         }\n \n+\n         @Test\n         public void GIVEN_deployment_job_WHEN_deployment_process_fails_THEN_report_failed_job_status()\n-                throws ExecutionException, InterruptedException {\n-            CompletableFuture<Void> mockFuture = new CompletableFuture<>();\n+                throws Exception {\n+            CompletableFuture<Void> mockFutureWithException = new CompletableFuture<>();\n             Throwable t = new NonRetryableDeploymentTaskFailureException(null);\n-            mockFuture.completeExceptionally(t);\n-            when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFuture);\n-            deploymentService.setPollingFrequency(Duration.ofSeconds(1).toMillis());\n+            mockFutureWithException.completeExceptionally(t);\n+            when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFutureWithException);\n             startDeploymentServiceInAnotherThread();\n \n-            verify(mockIotJobsHelper).subscribeToGetNextJobDecription(describeJobConsumerCaptor.capture(), any());\n-            Consumer<DescribeJobExecutionResponse> consumer = describeJobConsumerCaptor.getValue();\n-            DescribeJobExecutionResponse response = new DescribeJobExecutionResponse();\n-            response.execution = getTestJobExecutionData();\n-            consumer.accept(response);\n-\n-            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n-            verify(mockExecutorService).submit(any(DeploymentTask.class));\n-            //Wait for the enough time after which deployment service would have updated the status of job\n+            //Wait for the enough time after which deployment service would have processed the job from the queue\n             Thread.sleep(Duration.ofSeconds(2).toMillis());\n-            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.FAILED), any());\n+            verify(mockExecutorService).submit(any(DeploymentTask.class));\n+            verify(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS),\n+                    any());\n+            verify(mockIotJobsHelper)\n+                    .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.FAILED), any());\n             deploymentService.shutdown();\n         }\n \n         @Nested\n-        public class WithDefaultServiceRunning {\n+        public class MqttConnectionBreaks {\n \n-            @BeforeEach\n-            public void startService() throws InterruptedException {\n-                startDeploymentServiceInAnotherThread();\n-            }\n+            ArgumentCaptor<MqttClientConnectionEvents> mqttEventCaptor;\n \n-            @AfterEach\n-            public void tearDown() {\n-                deploymentService.shutdown();\n+            @BeforeEach\n+            public void setup() {\n+                mqttEventCaptor =\n+                        ArgumentCaptor.forClass(MqttClientConnectionEvents.class);\n             }\n \n             @Test\n-            public void GIVEN_device_configured_THEN_start_deployment_service()\n-                    throws ExecutionException, InterruptedException {\n+            public void GIVEN_deployment_job_WHEN_mqtt_breaks_on_success_job_update_THEN_persist_deployment_update_later()\n+                    throws Exception {\n+                when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFuture);\n+                ExecutionException e = new ExecutionException(new MqttException(\"Connection error\"));\n+                doNothing().when(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS),\n+                        any());\n+                doThrow(e).doNothing().when(mockIotJobsHelper)\n+                        .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.SUCCEEDED), any());\n+                InOrder mockIotJobsHelperInOrder = inOrder(mockIotJobsHelper);\n \n-                verify(mockIotJobsHelper).subscribeToEventNotifications(any());\n-                verify(mockIotJobsHelper).subscribeToGetNextJobDecription(any(), any());\n+                startDeploymentServiceInAnotherThread();\n+                //Wait for the enough time after which deployment service would have processed the job from the queue\n+                Thread.sleep(Duration.ofSeconds(2).toMillis());\n+\n+                verify(mockIotJobsHelper).connect();\n+                MqttClientConnectionEvents callbacks = deploymentService.callbacks;\n+\n+                callbacks.onConnectionInterrupted(1);\n+                Topics processedDeployments = mockKernel.lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS, DeploymentService.PROCESSED_DEPLOYMENTS_TOPICS);\n+                assertEquals(1, processedDeployments.size());\n+\n+                //Using actual executor service for running the method in a separate thread\n+                deploymentService.setExecutorService(mockKernel.context.get(ExecutorService.class));\n+                callbacks.onConnectionResumed(true);\n+                //Wait for job statuses to be updated\n+                Thread.sleep(Duration.ofSeconds(1).toMillis());\n+                mockIotJobsHelperInOrder.verify(mockIotJobsHelper, times(2))\n+                        .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.SUCCEEDED),  any());\n+                processedDeployments = mockKernel.lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS, DeploymentService.PROCESSED_DEPLOYMENTS_TOPICS);\n+                assertEquals(0, processedDeployments.size());\n             }\n \n             @Test\n-            public void GIVEN_subscribed_to_EventNotifications_WHEN_new_job_queued_THEN_process_notification()\n+            public void GIVEN_deployment_service_running_WHEN_mqtt_connection_resumed_THEN_subscribe_to_topics_again()\n                     throws Exception {\n+                when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFuture);\n+                InOrder mockIotJobsHelperInOrder = inOrder(mockIotJobsHelper);\n+                startDeploymentServiceInAnotherThread();\n+                Thread.sleep(Duration.ofSeconds(2).toMillis());\n+\n+                deploymentService.setExecutorService(mockKernel.context.get(ExecutorService.class));\n+                MqttClientConnectionEvents callbacks = deploymentService.callbacks;\n \n-                verify(mockIotJobsHelper).subscribeToEventNotifications(jobEventConsumerCaptor.capture());\n-                Consumer<JobExecutionsChangedEvent> consumer = jobEventConsumerCaptor.getValue();\n-                JobExecutionsChangedEvent response = new JobExecutionsChangedEvent();\n-                response.jobs = getTestJobs();\n-                consumer.accept(response);\n-                verify(mockIotJobsHelper).requestNextPendingJobDocument();\n+                callbacks.onConnectionInterrupted(1);\n+                callbacks.onConnectionResumed(true);\n+                //Wait for the DeploymentService thread to run at least one iteration of the loop\n+                Thread.sleep(Duration.ofSeconds(2).toMillis());\n+                mockIotJobsHelperInOrder.verify(mockIotJobsHelper).subscribeToJobsTopics();\n             }\n \n             @Test\n-            public void GIVEN_subscribed_to_EventNotifications_WHEN_job_finished_and_no_job_THEN_process_notification()\n+            public void GIVEN_multiple_deployment_jobs_WHEN_mqtt_breaks_THEN_persist_deployments_update_later()\n                     throws Exception {\n+                CompletableFuture<Void> mockFutureWitException = new CompletableFuture<>();\n+                Throwable t = new NonRetryableDeploymentTaskFailureException(null);\n+                mockFutureWitException.completeExceptionally(t);\n+                doReturn(mockFuture, mockFutureWitException).when(mockExecutorService).submit(any(DeploymentTask.class));\n+                ExecutionException executionException = new ExecutionException(new MqttException(\"Connection error\"));\n+                doNothing().when(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS),\n+                        any());\n+                doNothing().when(mockIotJobsHelper).updateJobStatus(eq(TEST_JOB_ID_2), eq(JobStatus.IN_PROGRESS),\n+                        any());\n+                doThrow(executionException).doThrow(executionException).doNothing().doNothing()\n+                        .when(mockIotJobsHelper).updateJobStatus(any(), or(eq(JobStatus.SUCCEEDED),\n+                        eq(JobStatus.FAILED)),  any());\n+\n+                InOrder mockIotJobsHelperInOrder = inOrder(mockIotJobsHelper);\n \n-                verify(mockIotJobsHelper).subscribeToEventNotifications(jobEventConsumerCaptor.capture());\n-                Consumer<JobExecutionsChangedEvent> consumer = jobEventConsumerCaptor.getValue();\n-                JobExecutionsChangedEvent response = new JobExecutionsChangedEvent();\n-                response.jobs = new HashMap<>();\n-                consumer.accept(response);\n-                verify(mockIotJobsHelper, times(0)).requestNextPendingJobDocument();\n+                startDeploymentServiceInAnotherThread();\n+                verify(mockIotJobsHelper).connect();\n+\n+                //Wait for the enough time after which deployment service would have updated the status of job\n+                Thread.sleep(Duration.ofSeconds(2).toMillis());\n+                //Submit TEST_JOB_2\n+                deploymentsQueue.put(new Deployment(\"{\\\"DeploymentId\\\":\\\"testId\\\"}\",\n+                        Deployment.DeploymentType.IOT_JOBS, TEST_JOB_ID_2));\n+                //Wait for the enough time after which deployment service would have updated the status of job\n+                Thread.sleep(Duration.ofSeconds(2).toMillis());\n+                //Using actual executor service for running the method in a separate thread\n+                deploymentService.setExecutorService(mockKernel.context.get(ExecutorService.class));\n+                MqttClientConnectionEvents callbacks = deploymentService.callbacks;\n+                callbacks.onConnectionResumed(true);\n+                //Wait for main thread to update the persisted deployment statuses\n+                Thread.sleep(Duration.ofSeconds(2).toMillis());\n+\n+                mockIotJobsHelperInOrder.verify(mockIotJobsHelper)\n+                        .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS),\n+                                any());\n+                mockIotJobsHelperInOrder.verify(mockIotJobsHelper, times(3))\n+                        .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.SUCCEEDED),  any());\n+                mockIotJobsHelperInOrder.verify(mockIotJobsHelper)\n+                        .updateJobStatus(eq(TEST_JOB_ID_2), eq(JobStatus.IN_PROGRESS),\n+                                any());\n+                mockIotJobsHelperInOrder.verify(mockIotJobsHelper, times(1))\n+                        .updateJobStatus(eq(TEST_JOB_ID_2), eq(JobStatus.FAILED),  any());\n+\n+                Topics processedDeployments = mockKernel.lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS, DeploymentService.PROCESSED_DEPLOYMENTS_TOPICS);\n+                assertEquals(0, processedDeployments.size());\n             }\n-\n         }\n-\n     }\n \n     private void startDeploymentServiceInAnotherThread() throws InterruptedException {\n-        Thread t = new Thread(() -> deploymentService.startup());\n+        Thread t = new Thread(() -> {\n+            try {\n+                deploymentService.startup();\n+            } catch (InterruptedException e) {\n+                fail(\"Deployment service thread interrupted\");", "originalCommit": "f82576f727552c34fe4972e8e8b5171d37572a78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f8e679d3ccb77e647a6709a3467ba8f04011e18d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f8e679d3ccb77e647a6709a3467ba8f04011e18d", "message": "Merge branch 'master' into refactorDeploymentService", "committedDate": "2020-04-13T18:03:11Z", "type": "commit"}, {"oid": "e212c00a0055916dc3f06143dc49c405cf90063c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e212c00a0055916dc3f06143dc49c405cf90063c", "message": "Reducing PMD count", "committedDate": "2020-04-13T18:43:05Z", "type": "commit"}]}