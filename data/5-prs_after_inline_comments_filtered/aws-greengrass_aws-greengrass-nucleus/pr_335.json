{"pr_number": 335, "pr_title": "Implement Fleet Status Service", "pr_createdAt": "2020-07-28T20:43:56Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335", "timeline": [{"oid": "128dd0dc8d8365c5a7255aebf9faafe3245db062", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/128dd0dc8d8365c5a7255aebf9faafe3245db062", "message": "Implment Fleet Status Service.", "committedDate": "2020-07-27T19:26:39Z", "type": "commit"}, {"oid": "8552e1ffb051ce3248ecf548aa498181c83588dd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8552e1ffb051ce3248ecf548aa498181c83588dd", "message": "Add more unit tests.", "committedDate": "2020-07-27T20:54:48Z", "type": "commit"}, {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b2d9fecfb5d97eb5df95a6048a820987304caf53", "message": "Adding logic to handle getting dependencies fleet config from root components.", "committedDate": "2020-07-28T20:01:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2OTg5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461869891", "bodyText": "why do we need the account id? That should be kept somewhat private.", "author": "MikeDombo", "createdAt": "2020-07-28T20:49:29Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeviceConfiguration.java", "diffHunk": "@@ -73,10 +74,11 @@ public DeviceConfiguration(Kernel kernel) {\n      * @param certificateFilePath certificate location on device\n      * @param rootCaFilePath      downloaded RootCA location on device\n      * @param awsRegion           aws region for the device\n+     * @param accountId           aws region for the device\n      */\n     public DeviceConfiguration(Kernel kernel, String thingName, String iotDataEndpoint, String iotCredEndpoint,\n                                String privateKeyPath, String certificateFilePath, String rootCaFilePath,\n-                               String awsRegion) {\n+                               String awsRegion, String accountId) {", "originalCommit": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MTgyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461871829", "bodyText": "We need it to build the fleet configuration arn. I am currently getting the account ID from the thing arn since we don't store it anywhere. Any reason it should be private?", "author": "nikkhilmuthye", "createdAt": "2020-07-28T20:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2OTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MzAxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461873013", "bodyText": "What \"fleet configuration arn\"?", "author": "MikeDombo", "createdAt": "2020-07-28T20:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2OTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NDU1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461874554", "bodyText": "https://github.com/aws/aws-greengrass-kernel/pull/335/files#diff-b8c895a010e61c7e47aaf9145fa4f187R257", "author": "nikkhilmuthye", "createdAt": "2020-07-28T20:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2OTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MDk4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461870989", "bodyText": "don't log. We already log this elsewhere", "author": "MikeDombo", "createdAt": "2020-07-28T20:51:32Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    public static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+    public static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    /**\n+     * Constructor for EvergreenService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        logger.atTrace().log(\"Service name: {}, oldState: {}, newState: {}\",", "originalCommit": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MTU3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461871570", "bodyText": "OverallStatus", "author": "MikeDombo", "createdAt": "2020-07-28T20:52:41Z", "path": "src/main/java/com/aws/iot/evergreen/fss/OverAllStatus.java", "diffHunk": "@@ -0,0 +1,11 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+public enum OverAllStatus {", "originalCommit": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MTc3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461871770", "bodyText": "perform a nullcheck", "author": "MikeDombo", "createdAt": "2020-07-28T20:53:05Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -509,6 +510,7 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n             context.get(Kernel.class).clearODcache();\n+            context.get(FleetStatusService.class).updateRemovedDependencies(removedDependencies);", "originalCommit": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NTc0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461875747", "bodyText": "This is a really bad idea.\nIf you want the full arn, which I'm not sure that you do because just the group name should be fine, then save the full arn from the deployment instead of trying to reconstruct it (incorrectly).", "author": "MikeDombo", "createdAt": "2020-07-28T21:00:07Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    public static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+    public static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    /**\n+     * Constructor for EvergreenService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        logger.atTrace().log(\"Service name: {}, oldState: {}, newState: {}\",\n+                evergreenService.getName(), oldState, newState);\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverAllStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        return true;\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverAllStatus overAllStatus) {\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (ExecutionException | InterruptedException | TimeoutException | JsonProcessingException e) {\n+            logger.atError().cause(e);\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();\n+\n+        try {\n+            EvergreenService deploymentService2 = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            Topics groupsToRootPackages2 =\n+                    deploymentService2.getConfig().lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS);\n+\n+            // Get all the groups associated to the root components.\n+            groupsToRootPackages2.iterator().forEachRemaining(groupNode -> {\n+                Topics groupTopics = (Topics) groupNode;\n+                String groupName = groupTopics.getName();\n+                groupNamesSet.add(groupName);\n+\n+                groupTopics.iterator().forEachRemaining(pkgNode -> {\n+                    Topics pkgTopics = (Topics) pkgNode;\n+                    Topic lookup = pkgTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY);\n+                    String groupVersion = (String) lookup.getOnce();\n+                    String groupName2 = Arn.builder()\n+                            .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                            .withService(FLEET_STATUS_ARN_SERVICE)\n+                            .withAccountId(Coerce.toString(deviceConfiguration.getAccountId()))\n+                            .withRegion(Coerce.toString(deviceConfiguration.getAWSRegion()))\n+                            .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, groupName,\n+                                    groupVersion))", "originalCommit": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NDM0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461884349", "bodyText": "The reason why we are sending the fleet config arn instead of just the groupName -> https://quip-amazon.com/t39VAoABQarS/Fleet-Status-Service-Design-WIP#cLV9CAoR9lx\nAlso, will see how we can store the arn during deployment.", "author": "nikkhilmuthye", "createdAt": "2020-07-28T21:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NjE1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461876158", "bodyText": "this won't do anything. You need to end all logs with .log() so that it actually logs", "author": "MikeDombo", "createdAt": "2020-07-28T21:00:50Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    public static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+    public static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    /**\n+     * Constructor for EvergreenService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        logger.atTrace().log(\"Service name: {}, oldState: {}, newState: {}\",\n+                evergreenService.getName(), oldState, newState);\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverAllStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        return true;\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverAllStatus overAllStatus) {\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (ExecutionException | InterruptedException | TimeoutException | JsonProcessingException e) {\n+            logger.atError().cause(e);\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();\n+\n+        try {\n+            EvergreenService deploymentService2 = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            Topics groupsToRootPackages2 =\n+                    deploymentService2.getConfig().lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS);\n+\n+            // Get all the groups associated to the root components.\n+            groupsToRootPackages2.iterator().forEachRemaining(groupNode -> {\n+                Topics groupTopics = (Topics) groupNode;\n+                String groupName = groupTopics.getName();\n+                groupNamesSet.add(groupName);\n+\n+                groupTopics.iterator().forEachRemaining(pkgNode -> {\n+                    Topics pkgTopics = (Topics) pkgNode;\n+                    Topic lookup = pkgTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY);\n+                    String groupVersion = (String) lookup.getOnce();\n+                    String groupName2 = Arn.builder()\n+                            .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                            .withService(FLEET_STATUS_ARN_SERVICE)\n+                            .withAccountId(Coerce.toString(deviceConfiguration.getAccountId()))\n+                            .withRegion(Coerce.toString(deviceConfiguration.getAWSRegion()))\n+                            .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, groupName,\n+                                    groupVersion))\n+                            .build().toString();\n+                    Set<String> groupSet = packageToGroupsMappingCache\n+                            .getOrDefault(pkgTopics.getName(), new HashSet<>());\n+                    groupSet.add(groupName2);\n+                    packageToGroupsMappingCache.put(pkgTopics.getName(), groupSet);\n+                    pendingPackagesList.add(pkgTopics.getName());\n+                });\n+            });\n+        } catch (ServiceLoadException e) {\n+            return packageToGroupsMappingCache;\n+        }\n+\n+        // Associate the groups to the dependant services based on the services it is depending on.\n+        while (!pendingPackagesList.isEmpty()) {\n+            String pkgList = pendingPackagesList.get(0);\n+            try {\n+                EvergreenService evergreenService = this.kernel.locate(pkgList);\n+                Set<String> groupName2 = packageToGroupsMappingCache\n+                        .getOrDefault(evergreenService.getName(), new HashSet<>());\n+\n+                evergreenService.getDependencies().forEach((evergreenService1, dependencyType) -> {\n+                    pendingPackagesList.add(evergreenService1.getName());\n+                    Set<String> groupSet = packageToGroupsMappingCache\n+                            .getOrDefault(evergreenService1.getName(), new HashSet<>());\n+                    groupSet.addAll(groupName2);\n+                    packageToGroupsMappingCache.put(evergreenService1.getName(), groupSet);\n+                });\n+            } catch (ServiceLoadException ex) {\n+                logger.atError().cause(ex);", "originalCommit": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64abcf5ae449710fc424588f4e63bf7e1daced48", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/64abcf5ae449710fc424588f4e63bf7e1daced48", "message": "Address PR comments.", "committedDate": "2020-07-28T21:44:10Z", "type": "commit"}, {"oid": "55f06d0295042ffc8bb46985d92a115ecc3a0806", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/55f06d0295042ffc8bb46985d92a115ecc3a0806", "message": "Merge branch 'master' into fss", "committedDate": "2020-07-28T21:51:29Z", "type": "commit"}, {"oid": "2ff7bf1dca17179164bb861d0836572f9d13f8b5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2ff7bf1dca17179164bb861d0836572f9d13f8b5", "message": "Fix build after addressing PR comments.", "committedDate": "2020-07-28T22:02:02Z", "type": "commit"}, {"oid": "ec534235d151d68e0f8949c3d8d2c8c97223f6b3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec534235d151d68e0f8949c3d8d2c8c97223f6b3", "message": "Merge branch 'master' into fss", "committedDate": "2020-07-28T23:31:34Z", "type": "commit"}, {"oid": "398d2e48386806279227544a24b080f012e13177", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/398d2e48386806279227544a24b080f012e13177", "message": "Handle MQTT connection interruptions.", "committedDate": "2020-07-29T03:35:55Z", "type": "commit"}, {"oid": "be9543ba5a68c5b762b4b4caae2837121a6bfcc5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/be9543ba5a68c5b762b4b4caae2837121a6bfcc5", "message": "Merge branch 'master' into fss", "committedDate": "2020-07-29T03:36:54Z", "type": "commit"}, {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae4a15d8a0908fe5e944fca412405d11b410e342", "message": "fix build.", "committedDate": "2020-07-29T03:53:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NTIzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463295237", "bodyText": "Is this duplicate information? deploymentGroupTopics already is a map of group name (1:1 mapping to deployment ID) to deploymentGroupToRootPackages map", "author": "hui-yang", "createdAt": "2020-07-30T21:59:18Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -210,23 +211,25 @@ private void finishCurrentDeployment() throws InterruptedException {\n             DeploymentResult result = currentDeploymentTaskMetadata.getDeploymentResultFuture().get();\n             if (result != null) {\n                 DeploymentResult.DeploymentStatus deploymentStatus = result.getDeploymentStatus();\n+\n                 Map<String, String> statusDetails = new HashMap<>();\n                 statusDetails.put(\"detailed-deployment-status\", deploymentStatus.name());\n                 if (deploymentStatus.equals(DeploymentResult.DeploymentStatus.SUCCESSFUL)) {\n                     //Add the root packages of successful deployment to the configuration\n                     DeploymentDocument deploymentDocument = currentDeploymentTaskMetadata.getDeploymentDocument();\n                     Topics deploymentGroupTopics = config.lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS,\n                             deploymentDocument.getGroupName());\n+\n                     Map<Object, Object> deploymentGroupToRootPackages = new HashMap<>();\n                     // TODO: Removal of group from the mappings. Currently there is no action taken when a device is\n                     //  removed from a thing group. Empty configuration is treated as a valid config for a group but\n                     //  not treated as removal.\n                     deploymentDocument.getDeploymentPackageConfigurationList().stream().forEach(pkgConfig -> {\n-                        if (pkgConfig.isRootComponent()) {\n-                            Map<Object, Object> pkgDetails = new HashMap<>();\n-                            pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());\n-                            deploymentGroupToRootPackages.put(pkgConfig.getPackageName(), pkgDetails);\n-                        }\n+                        Map<Object, Object> pkgDetails = new HashMap<>();\n+                        pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());\n+                        pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                                deploymentDocument.getDeploymentId());", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4NzQxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463387419", "bodyText": "the deploymentId is the group arn. We need the complete information about the group while sending the FSS data.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T03:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NTIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NTc5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463295797", "bodyText": "This version is used to resolve component version among multiple groups. Could you keep the same logic to only persist version for root components?", "author": "hui-yang", "createdAt": "2020-07-30T22:00:31Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -210,23 +211,25 @@ private void finishCurrentDeployment() throws InterruptedException {\n             DeploymentResult result = currentDeploymentTaskMetadata.getDeploymentResultFuture().get();\n             if (result != null) {\n                 DeploymentResult.DeploymentStatus deploymentStatus = result.getDeploymentStatus();\n+\n                 Map<String, String> statusDetails = new HashMap<>();\n                 statusDetails.put(\"detailed-deployment-status\", deploymentStatus.name());\n                 if (deploymentStatus.equals(DeploymentResult.DeploymentStatus.SUCCESSFUL)) {\n                     //Add the root packages of successful deployment to the configuration\n                     DeploymentDocument deploymentDocument = currentDeploymentTaskMetadata.getDeploymentDocument();\n                     Topics deploymentGroupTopics = config.lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS,\n                             deploymentDocument.getGroupName());\n+\n                     Map<Object, Object> deploymentGroupToRootPackages = new HashMap<>();\n                     // TODO: Removal of group from the mappings. Currently there is no action taken when a device is\n                     //  removed from a thing group. Empty configuration is treated as a valid config for a group but\n                     //  not treated as removal.\n                     deploymentDocument.getDeploymentPackageConfigurationList().stream().forEach(pkgConfig -> {\n-                        if (pkgConfig.isRootComponent()) {\n-                            Map<Object, Object> pkgDetails = new HashMap<>();\n-                            pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());\n-                            deploymentGroupToRootPackages.put(pkgConfig.getPackageName(), pkgDetails);\n-                        }\n+                        Map<Object, Object> pkgDetails = new HashMap<>();\n+                        pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NjUzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463296535", "bodyText": "Does it have to be a map instead of list?", "author": "hui-yang", "createdAt": "2020-07-30T22:02:20Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -33,26 +33,32 @@\n \n     private Topics processedDeployments;\n \n-    private final Map<DeploymentType, Function<Map<String, Object>, Boolean>> deploymentStatusConsumer\n+    private final Map<DeploymentType, Map<String, Function<Map<String, Object>, Boolean>>> deploymentStatusConsumerMap", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxOTk4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463319985", "bodyText": "It just keeps it from being subscribed to multiple times from the same functionality.", "author": "nikkhilmuthye", "createdAt": "2020-07-30T23:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NjUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzQ0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463297448", "bodyText": "nit: is this thing name or thing arn? Same for thinggroups?", "author": "hui-yang", "createdAt": "2020-07-30T22:04:28Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMDE5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463320197", "bodyText": "Its not an arn. Its the thing name and the group name.", "author": "nikkhilmuthye", "createdAt": "2020-07-30T23:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjQ1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465142453", "bodyText": "Its not an arn. Its the thing name and the group name.\n\nWhat \"group name\"?", "author": "fengwang666", "createdAt": "2020-08-04T15:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2ODk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465168991", "bodyText": "The \"group name\" was referred to the thinggroups field which has been removed since.", "author": "nikkhilmuthye", "createdAt": "2020-08-04T16:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzkwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463297905", "bodyText": "Is this a list of groups? Is it intended to be String?", "author": "hui-yang", "createdAt": "2020-07-30T22:05:37Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;\n+\n+    @JsonProperty(\"thingGroups\")\n+    private String thingGroups;", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5ODYwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463298602", "bodyText": "Maybe we should have a \"unstable\" if soft dependencies are broken.", "author": "hui-yang", "createdAt": "2020-07-30T22:07:30Z", "path": "src/main/java/com/aws/iot/evergreen/fss/OverallStatus.java", "diffHunk": "@@ -0,0 +1,11 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+public enum OverallStatus {\n+    HEALTHY,\n+    UNHEALTHY", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjI4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465446284", "bodyText": "Added a SIM task to investigate this. https://sim.amazon.com/issues/da8d4b01-33b0-4fed-9dc3-988b9c28a384", "author": "nikkhilmuthye", "createdAt": "2020-08-05T03:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5ODYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5OTQ4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463299480", "bodyText": "I'm not so sure about this. If a dependency is removed from one service, it can still be used by another. You may need a reference index map or simply list all services from kernel periodically", "author": "hui-yang", "createdAt": "2020-07-30T22:09:53Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -552,6 +553,10 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n             context.get(Kernel.class).clearODcache();\n+            FleetStatusService fleetStatusService = context.get(FleetStatusService.class);\n+            if (fleetStatusService != null) {\n+                fleetStatusService.updateRemovedDependencies(removedDependencies);", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMjA2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463322066", "bodyText": "I take care of that logic when the deployment finishes in https://github.com/aws/aws-greengrass-kernel/pull/335/files#diff-b8c895a010e61c7e47aaf9145fa4f187R207. Here i remove the \"removed dependency\" from the list if the service is still running.", "author": "nikkhilmuthye", "createdAt": "2020-07-30T23:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5OTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5OTc5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463299792", "bodyText": "extract this to be a helper function", "author": "hui-yang", "createdAt": "2020-07-30T22:10:40Z", "path": "src/test/java/com/aws/iot/evergreen/easysetup/DeviceProvisioningHelperTest.java", "diffHunk": "@@ -169,8 +170,11 @@ public void GIVEN_test_update_device_config_WHEN_thing_info_provided_THEN_add_co\n         Kernel kernel = new Kernel()\n                 .parseArgs(\"-i\", getClass().getResource(\"blank_config.yaml\").toString(), \"-r\", tempRootDir.toString());\n \n+        String thingArn = Arn.builder().withService(\"testService\")\n+                .withRegion(TEST_REGION).withAccountId(\"12345\").withPartition(\"testPartition\").withResource(\"testResoruce\")\n+                .build().toString();", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMDEzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463300135", "bodyText": "Intentional? Could you explain why?", "author": "hui-yang", "createdAt": "2020-07-30T22:11:34Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "diffHunk": "@@ -183,7 +183,7 @@ void GIVEN_package_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_ver\n \n             DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(pkgA), Collections\n                     .singletonList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, DeploymentSafetyPolicy.CHECK_SAFETY);\n+                     \"\", 1L, FailureHandlingPolicy.DO_NOTHING, DeploymentSafetyPolicy.CHECK_SAFETY);", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4NDk2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463384961", "bodyText": "My Bad. Will revert.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T03:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMDEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMTI1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463301251", "bodyText": "Why only IOT_JOBS?", "author": "hui-yang", "createdAt": "2020-07-30T22:14:42Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY2NTg5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463665896", "bodyText": "I figured that for local deployments, the cloud has no knowledge about the deployment so it would not know what to do about the information.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMTI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMTc1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463301750", "bodyText": "Do you plan to cancel periodicUpdateFuture and restart a new one in this case?", "author": "hui-yang", "createdAt": "2020-07-30T22:15:55Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNDU1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463304552", "bodyText": "Is this correct? If overAllStatus is unhealthy due to svc1, it can be set back to healthy by svc2?", "author": "hui-yang", "createdAt": "2020-07-30T22:23:20Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM5MzU0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463393542", "bodyText": "Good catch. I think something went wrong when I refactored some code. Will make the changes.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T04:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNDc0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463304741", "bodyText": "same as above.\nThis common logic may be extracted to a function", "author": "hui-yang", "createdAt": "2020-07-30T22:23:49Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNTgyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463305827", "bodyText": "Thanks for the comment. It helps understanding the reasoning", "author": "hui-yang", "createdAt": "2020-07-30T22:26:45Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNjI5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463306299", "bodyText": "Why is this generated each time? Is it possible to change thingname in kernel runtime?", "author": "hui-yang", "createdAt": "2020-07-30T22:28:04Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNzc5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463307798", "bodyText": "Is this thread-safe? Can event-triggered and periodic update happen at the same time?", "author": "hui-yang", "createdAt": "2020-07-30T22:31:00Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTk5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463309992", "bodyText": "Why do we need this while loop? What is pendingPackagesList?", "author": "hui-yang", "createdAt": "2020-07-30T22:36:43Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();\n+\n+        try {\n+            EvergreenService deploymentService2 = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            Topics groupsToRootPackages2 =\n+                    deploymentService2.getConfig().lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS);\n+\n+            // Get all the groups associated to the root components.\n+            groupsToRootPackages2.iterator().forEachRemaining(groupNode -> {\n+                Topics groupTopics = (Topics) groupNode;\n+                String groupName = groupTopics.getName();\n+                groupNamesSet.add(groupName);\n+\n+                groupTopics.iterator().forEachRemaining(pkgNode -> {\n+                    Topics pkgTopics = (Topics) pkgNode;\n+                    Topic lookup = pkgTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID);\n+                    String groupDeploymentId = (String) lookup.getOnce();\n+                    Set<String> groupDeploymentIdSet = packageToGroupsMappingCache\n+                            .getOrDefault(pkgTopics.getName(), new HashSet<>());\n+                    groupDeploymentIdSet.add(groupDeploymentId);\n+                    packageToGroupsMappingCache.put(pkgTopics.getName(), groupDeploymentIdSet);\n+                    pendingPackagesList.add(pkgTopics.getName());\n+                });\n+            });\n+        } catch (ServiceLoadException e) {\n+            return packageToGroupsMappingCache;\n+        }\n+\n+        // Associate the groups to the dependant services based on the services it is depending on.\n+        while (!pendingPackagesList.isEmpty()) {", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4Njg0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463386847", "bodyText": "This is to map the group information for all the dependent services since that is not stored as a topic.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T03:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxMDk1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463310956", "bodyText": "Why are evergreenServiceMap and removedDependencies maps instead of sets?", "author": "hui-yang", "createdAt": "2020-07-30T22:39:44Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4NzE1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463387159", "bodyText": "We needed a concurrent map to be thread safe. I don't believe there is a concurrent HashSet in java. The only way I know is to use a ConcurrentHashMap and then get the keySet.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T03:31:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxMDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4NzQzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463387433", "bodyText": "CopyOnWriteArraySet is what you can use for a threadsafe set.", "author": "MikeDombo", "createdAt": "2020-07-31T03:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxMDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNjA1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463406055", "bodyText": "Or you do this way:\nSet<EvergreenService> services = Collections.newSetFromMap(new ConcurrentHashMap<>());", "author": "fengwang666", "createdAt": "2020-07-31T05:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxMDk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwMzkwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463403907", "bodyText": "overAllStatus -> overallStatus", "author": "fengwang666", "createdAt": "2020-07-31T04:52:52Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;\n+\n+    @JsonProperty(\"thingGroups\")\n+    private String thingGroups;\n+\n+    @JsonProperty(\"overallDeviceStatus\")\n+    private OverallStatus overAllStatus;", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwMzk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463403993", "bodyText": "What's sequenceNumber for?", "author": "fengwang666", "createdAt": "2020-07-31T04:53:22Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;\n+\n+    @JsonProperty(\"thingGroups\")\n+    private String thingGroups;\n+\n+    @JsonProperty(\"overallDeviceStatus\")\n+    private OverallStatus overAllStatus;\n+\n+    @JsonProperty(\"sequenceNumber\")\n+    private long sequenceNumber;", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MDU1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463680553", "bodyText": "https://quip-amazon.com/t39VAoABQarS/Fleet-Status-Service-Design-WIP#cLV9CAg65rd\nUsed for ordering of messages in the cloud.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwMzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDE3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463404171", "bodyText": "What's fleetConfigArn? Why is it included here?", "author": "fengwang666", "createdAt": "2020-07-31T04:54:13Z", "path": "src/main/java/com/aws/iot/evergreen/fss/ComponentStatusDetails.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ComponentStatusDetails {\n+    @JsonProperty(\"componentName\")\n+    private String componentName;\n+\n+    @JsonProperty(\"version\")\n+    private String version;\n+\n+    @JsonProperty(\"fleetConfigArn\")\n+    private String fleetConfigArn;", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3MDY2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463670667", "bodyText": "https://quip-amazon.com/t39VAoABQarS/Fleet-Status-Service-Design-WIP#cLV9CA29MTo", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzYwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465137606", "bodyText": "If I understand correctly, this is the list of the group configuration arns that deploy this component. I would change it to a List instead of string. Also consider rename it to groupConfigArns. We have not used fleet across the code base.", "author": "fengwang666", "createdAt": "2020-08-04T15:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MjgwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465292800", "bodyText": "The configration arns can be either a thing group arn or a thing arn. So I think we can rename it to fleetConfigArns", "author": "nikkhilmuthye", "createdAt": "2020-08-04T19:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDQwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463404408", "bodyText": "What's the difference between these two? Why do you need both?", "author": "fengwang666", "createdAt": "2020-07-31T04:54:58Z", "path": "src/main/java/com/aws/iot/evergreen/fss/ComponentStatusDetails.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ComponentStatusDetails {\n+    @JsonProperty(\"componentName\")\n+    private String componentName;\n+\n+    @JsonProperty(\"version\")\n+    private String version;\n+\n+    @JsonProperty(\"fleetConfigArn\")\n+    private String fleetConfigArn;\n+\n+    @JsonProperty(\"statusDetails\")\n+    private String statusDetails;\n+\n+    @JsonProperty(\"status\")\n+    private State state;\n+}", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3MTI1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463671252", "bodyText": "The status details will have extra information like if the component has any error, the status details will contain the error/exception information. I have not implemented that yet since Fahad is working on getting the exception information in the SDK design.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMDI1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464610257", "bodyText": "If that's the case (extra info only for error) then name it statusErrorMessage.", "author": "leaf94", "createdAt": "2020-08-03T19:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNzc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464637783", "bodyText": "I feel we need to keep this generic. The idea was to add any additional information about the status to be shown to the customer. An exception is just one of those reason. We might want to add in some aggregations in the future to the number of times a component restarted in a given time. That will be added in this field as well.", "author": "nikkhilmuthye", "createdAt": "2020-08-03T20:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTM5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409390", "bodyText": "Why is newState.equals(State.ERRORED part of the condition?", "author": "fengwang666", "createdAt": "2020-07-31T05:16:47Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTc0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409745", "bodyText": "Debug level? Why info?", "author": "fengwang666", "createdAt": "2020-07-31T05:18:25Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3MTc3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463671774", "bodyText": "I felt it might be useful information for the customer to know why periodic update was not triggered. But I can change it to debug.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTgwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409804", "bodyText": "Debug level is sufficient.", "author": "fengwang666", "createdAt": "2020-07-31T05:18:38Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTg0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409846", "bodyText": "Debug level", "author": "fengwang666", "createdAt": "2020-07-31T05:18:51Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTMxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463411317", "bodyText": "Why? If deployment service is broken, we don't want to report to FSS?", "author": "fengwang666", "createdAt": "2020-07-31T05:24:50Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3MjcwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463672708", "bodyText": "Good point. I was thinking that the overall status would say it was UNHEALTHY but we don't necessarily need to give the auto-started components information.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMjg3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463412872", "bodyText": "Why do you put the service into the map before the condition check?", "author": "fengwang666", "createdAt": "2020-07-31T05:31:26Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1ODU1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465158555", "bodyText": "Why do you put the service into the map before the condition check?\n\nCan you address the comment?", "author": "fengwang666", "createdAt": "2020-08-04T15:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMjg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjY3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465446677", "bodyText": "The condition checks if the new state of the component is BROKEN and if there is an ongoing deployment. If there is no ongoing deployment, only then go ahead and update the status of this component we just added in the map.", "author": "nikkhilmuthye", "createdAt": "2020-08-05T03:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMjg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDAwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463414000", "bodyText": "Why are these two different methods? Isn't schedulePeriodicFssDataUpdate part of handleMqttConnectionResumed?", "author": "fengwang666", "createdAt": "2020-07-31T05:36:12Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3MzMxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463673314", "bodyText": "handleMqttConnectionResumed  will update any FSS data to be uploaded to the cloud. schedulePeriodicFssDataUpdate  will schedule the periodic update back since we have canceled it when the network was interrupted.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDU1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463414551", "bodyText": "Why not just roll this into schedulePeriodicFssDataUpdate() method? You can define when to start the first scheduled task using lastPeriodicUpdateTime.", "author": "fengwang666", "createdAt": "2020-07-31T05:38:29Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDgwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463414803", "bodyText": "Why is this necessary? Shouldn't this be only triggered by deployment or service broken?", "author": "fengwang666", "createdAt": "2020-07-31T05:39:29Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NDM2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463674360", "bodyText": "If the network was broken after the deployment was started and resumed after the deployment finished, but before the periodic update was triggered, then we need to send that information.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjAwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463686009", "bodyText": "MQTT client component can spool messages. Once the network recovers, the MQTT client will automatically retry unpublished events.", "author": "fengwang666", "createdAt": "2020-07-31T15:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxOTEyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464019126", "bodyText": "We don't want to spool the MQTT messages for FSS. If the device is offline for a long time, once the device is online, it will immediately send the FSS data.", "author": "nikkhilmuthye", "createdAt": "2020-08-02T01:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNTM4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463415382", "bodyText": "This variable is updated by different threads. It needs to be synchronized. Using volatile or atomic variable.\nAlso isConnected is a better name.", "author": "fengwang666", "createdAt": "2020-07-31T05:41:53Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NTE3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463675177", "bodyText": "Yep. I was using AtomicVariable but it was giving me some exception about the variable being boolean. Will use volatile", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNjIxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463416212", "bodyText": "How do you know it's healthy? What if a service has been broken for two days?", "author": "fengwang666", "createdAt": "2020-07-31T05:45:07Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NTcxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463685710", "bodyText": "We aggregate the overall state for all components in the kernel below. this is just to initialize the variable.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNjIxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4OTE0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463689144", "bodyText": "The way it's written is very misleading. Why do you need to initialize the variable here?", "author": "fengwang666", "createdAt": "2020-07-31T15:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNjIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMDI1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463420250", "bodyText": "Why LinkedList?", "author": "fengwang666", "createdAt": "2020-07-31T06:00:07Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NjMzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463676334", "bodyText": "LinkedList class can act as a list and queue both because it implements List and Deque interfaces. Also LinkedList is better for manipulating data. So I felt I should use it.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMDI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMTI2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463421268", "bodyText": "Have you thought about using Periodicity class?", "author": "fengwang666", "createdAt": "2020-07-31T06:03:59Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3ODcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463678706", "bodyText": "I did consider using it. I felt that it was for an entire service to run periodically and the  FSS is doing more than just start and perform some action and finish.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMTI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463422158", "bodyText": "Don't use Package. We rename it to component now.", "author": "fengwang666", "createdAt": "2020-07-31T06:07:12Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {", "originalCommit": "ae4a15d8a0908fe5e944fca412405d11b410e342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjg5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463422890", "bodyText": "Also please don't use parameter to get output.", "author": "fengwang666", "createdAt": "2020-07-31T06:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyNDkzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463424934", "bodyText": "The whole methods seems messy. Can we try not to compute it every time here? Why can't the deployment compute the information and update it in every deployment?", "author": "fengwang666", "createdAt": "2020-07-31T06:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3OTI3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463679275", "bodyText": "It does cache it. So it only calculates it after every deployment. Not everytime.\nWill change the names and the parameter.", "author": "nikkhilmuthye", "createdAt": "2020-07-31T15:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463686674", "bodyText": "Would it be better to put this logic in the deployment service, persist the data in the config object, and fss just read from the config object?", "author": "fengwang666", "createdAt": "2020-07-31T15:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA=="}], "type": "inlineReview"}, {"oid": "078dd74d2338e05eff66ad262f35d01fd2d7ea07", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/078dd74d2338e05eff66ad262f35d01fd2d7ea07", "message": "Address PR comments.", "committedDate": "2020-07-31T19:20:09Z", "type": "commit"}, {"oid": "73c1b6fa7f1ea934244faf5de2dc319b7c84c683", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/73c1b6fa7f1ea934244faf5de2dc319b7c84c683", "message": "Merge branch 'master' into fss", "committedDate": "2020-07-31T22:06:31Z", "type": "commit"}, {"oid": "ae678893914cbc3204240aaa23dc8d2c13944e5b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae678893914cbc3204240aaa23dc8d2c13944e5b", "message": "Merge branch 'master' into fss", "committedDate": "2020-08-03T14:16:31Z", "type": "commit"}, {"oid": "0b752cd7684eed191d797a9651c91a283e374eb4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b752cd7684eed191d797a9651c91a283e374eb4", "message": "Address more PR comments. Move component to groups mapping in Deployment Service.", "committedDate": "2020-08-03T16:04:57Z", "type": "commit"}, {"oid": "46b5456ba80bda6f79061adc84501e2d2348beaa", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/46b5456ba80bda6f79061adc84501e2d2348beaa", "message": "Add unit test for DeploymentService.", "committedDate": "2020-08-03T19:08:54Z", "type": "commit"}, {"oid": "a2106eb3b605303948e4f100df101d5d8f315654", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2106eb3b605303948e4f100df101d5d8f315654", "message": "Fix build.", "committedDate": "2020-08-03T19:16:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzY1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464607654", "bodyText": "I guess you just copied this over but for better readability\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Thread.sleep(10_000);\n          \n          \n            \n                    TimeUnit.SECONDS.sleep(10);", "author": "leaf94", "createdAt": "2020-08-03T19:07:30Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        Thread.sleep(10_000);", "originalCommit": "0b752cd7684eed191d797a9651c91a283e374eb4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzc2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464607769", "bodyText": "nice name. very clear", "author": "leaf94", "createdAt": "2020-08-03T19:07:45Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        Thread.sleep(10_000);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {", "originalCommit": "0b752cd7684eed191d797a9651c91a283e374eb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwOTE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464609163", "bodyText": "What about test for trigger when broken? I'd say that's also an important one?", "author": "leaf94", "createdAt": "2020-08-03T19:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDA4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464634083", "bodyText": "The plan is to have a proper test document and then implement the test suite in the next PR since this PR is already big enough. But yes. that test will be added.", "author": "nikkhilmuthye", "createdAt": "2020-08-03T20:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyNjA1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465126050", "bodyText": "Cool", "author": "leaf94", "createdAt": "2020-08-04T15:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMTM4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464611388", "bodyText": "Should also verify it doesn't contain removed services? maybe by assert on fleetStatusDetails2. getComponentStatusDetails.size()?", "author": "leaf94", "createdAt": "2020-08-03T19:15:30Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        Thread.sleep(10_000);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(String.format(\"$aws/things/%s/evergreen/health/json\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")\n+                        .withConfiguration(\"{\\\"sampleText\\\":\\\"FCS integ test\\\"}\"))\n+                .addPackagesEntry(\"SomeService\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult1 = setAndPublishFleetConfiguration(setRequest1);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult1.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        String someServiceName = getCloudDeployedComponent(\"SomeService\").getName();\n+\n+        // Second deployment to remove some services deployed previously\n+        SetConfigurationRequest setRequest2 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult2 = setAndPublishFleetConfiguration(setRequest2);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult2.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        // Ensure that main is finished, which is its terminal state, so this means that all updates ought to be done\n+        assertThat(kernel.getMain()::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThat(getCloudDeployedComponent(\"CustomerApp\")::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThrows(ServiceLoadException.class, () -> getCloudDeployedComponent(\"SomeService\").getState());\n+\n+        assertTrue(cdl.await(1, TimeUnit.MINUTES), \"All messages published and received\");\n+        assertEquals(2, mqttMessagesList.get().size());\n+\n+        Arn arn = Arn.builder()\n+                .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                .withService(FLEET_STATUS_ARN_SERVICE)\n+                .withAccountId(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getAccountId()))\n+                .withRegion(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getRegion()))\n+                .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, \"thinggroup/\" + thingGroupName, \"1\"))\n+                .build();\n+\n+        Set<String> userComponentsCloudName = new HashSet<>();\n+        userComponentsCloudName.add(getCloudDeployedComponent(\"Mosquitto\").getName());\n+        userComponentsCloudName.add(getCloudDeployedComponent(\"CustomerApp\").getName());\n+        userComponentsCloudName.add(getCloudDeployedComponent(\"GreenSignal\").getName());\n+        userComponentsCloudName.add(someServiceName);\n+        // Check the MQTT messages.\n+        MqttMessage receivedMqttMessage1 = mqttMessagesList.get().get(0);\n+        assertNotNull(receivedMqttMessage1.getPayload());\n+        FleetStatusDetails fleetStatusDetails1 = DESERIALIZER.readValue(receivedMqttMessage1.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails1.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails1.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails1.getOverallStatus());\n+        assertThat(fleetStatusDetails1.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(getCloudDeployedComponent(\"Mosquitto\").getName(), someServiceName,\n+                        getCloudDeployedComponent(\"CustomerApp\").getName(),\n+                        getCloudDeployedComponent(\"GreenSignal\").getName(),\n+                        \"main\", \"pubsubipc\", \"IPCService\", \"FleetStatusService\", \"lifecycleipc\", \"configstoreipc\",\n+                        \"SafeSystemUpdate\", \"DeploymentService\", \"servicediscovery\"));\n+        fleetStatusDetails1.getComponentStatusDetails().forEach(componentStatusDetails -> {\n+            if (userComponentsCloudName.contains(componentStatusDetails.getComponentName())) {\n+                assertEquals(arn.toString(), componentStatusDetails.getFleetConfigArn());\n+            }\n+        });\n+\n+        MqttMessage receivedMqttMessage2 = mqttMessagesList.get().get(1);\n+        assertNotNull(receivedMqttMessage2.getPayload());\n+        FleetStatusDetails fleetStatusDetails2 = DESERIALIZER.readValue(receivedMqttMessage2.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails2.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails2.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails2.getOverallStatus());\n+        assertThat(fleetStatusDetails2.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(someServiceName));", "originalCommit": "0b752cd7684eed191d797a9651c91a283e374eb4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMjE0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464612147", "bodyText": "Good job", "author": "leaf94", "createdAt": "2020-08-03T19:16:56Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -73,8 +76,8 @@\n \n     private static final VerificationWithTimeout WAIT_FOUR_SECONDS = timeout(Duration.ofSeconds(4).toMillis());\n \n-    @Spy\n-    Kernel mockKernel;\n+    @Mock\n+    private Kernel mockKernel;", "originalCommit": "a2106eb3b605303948e4f100df101d5d8f315654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1ab528e77b23609514fda0fe1cbf7eaa18fcad46", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1ab528e77b23609514fda0fe1cbf7eaa18fcad46", "message": "Fix flaky unit test. Address some PR comments.", "committedDate": "2020-08-03T22:02:48Z", "type": "commit"}, {"oid": "b37fc029b907693b9b15232ed1a4ea241a93e88f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b37fc029b907693b9b15232ed1a4ea241a93e88f", "message": "Fix one more flaky test.", "committedDate": "2020-08-03T22:17:43Z", "type": "commit"}, {"oid": "c01c5a0bb197627b9692a929d4a097c15c405dcf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c01c5a0bb197627b9692a929d4a097c15c405dcf", "message": "Do not update FSS data during initialization.", "committedDate": "2020-08-03T22:45:10Z", "type": "commit"}, {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "message": "Fix build.", "committedDate": "2020-08-03T22:50:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMTcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465131706", "bodyText": "This reminds me ask that have you done re-connect test (manual) ?", "author": "leaf94", "createdAt": "2020-08-04T15:21:06Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzQzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465137438", "bodyText": "I'd say this worths a README.md to explain how FSS agent works", "author": "leaf94", "createdAt": "2020-08-04T15:29:10Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjU2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465142568", "bodyText": "Why not List and use , joining?", "author": "leaf94", "createdAt": "2020-08-04T15:36:23Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        Topics componentsToGroupsTopics = null;\n+        try {\n+            EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                    DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+        }\n+\n+        Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = \"\";\n+            if (finalComponentsToGroupsTopics != null) {\n+                Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                        .map(String::valueOf).collect(Collectors.joining(\",\"));\n+            }", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwNzY4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465407680", "bodyText": "This is related to Feng's comment about #335 (comment).\nList<String> works a lot better", "author": "leaf94", "createdAt": "2020-08-05T00:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465144055", "bodyText": "This catch looks weird. JsonProcessingException is thrown by SERIALIZER? That should not be \"Unable to publish xxx\".\nInstead, do you want to catch all other exception so that this thread can continue even if mqttClient is throwing some error?", "author": "leaf94", "createdAt": "2020-08-04T15:38:31Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        Topics componentsToGroupsTopics = null;\n+        try {\n+            EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                    DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+        }\n+\n+        Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = \"\";\n+            if (finalComponentsToGroupsTopics != null) {\n+                Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                        .map(String::valueOf).collect(Collectors.joining(\",\"));\n+            }\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxOTM5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465819391", "bodyText": "The MQTT client publish method signature does not mention any exception it can throw. So I don't know which other exceptions we need to add here.\nAlso, if the SERIALIZER  throws a JsonProcessingException then we won't be publishing the fleet status service.", "author": "nikkhilmuthye", "createdAt": "2020-08-05T15:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjM3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465146374", "bodyText": "Is passing overAllStatus.get() into it necessary? Seems the only place of .set is getting the result by getOverallStatusBasedOnServiceState  so you always compute from the evergreen service map.", "author": "leaf94", "createdAt": "2020-08-04T15:41:57Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNzM2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465817368", "bodyText": "The OverallStatus needs to be computed from all the running components. The getOverallStatusBasedOnServiceState will look at the overall status passed. If it is already UNHEALTHY, then it means that some other component is BROKEN and we don't want to change the overallstatus to HEALTHY if the next component is running fine.", "author": "nikkhilmuthye", "createdAt": "2020-08-05T15:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjY5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465152699", "bodyText": "Since both evergreenServiceMap can be update by other threads, during updateFleetStatusServiceData (specifically after reading from the map), there might be some data added in, which would be cleared here.\nI will recommend moving the clear to right after you read the map. Although there are still tiny bit of chance without a readAndClear atomic operation", "author": "leaf94", "createdAt": "2020-08-04T15:51:09Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzOTc1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465139752", "bodyText": "If the JSON key is the same as the variable name, you don't need the annotation.", "author": "fengwang666", "createdAt": "2020-08-04T15:32:22Z", "path": "src/main/java/com/aws/iot/evergreen/fss/ComponentStatusDetails.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ComponentStatusDetails {\n+    @JsonProperty(\"componentName\")\n+    private String componentName;", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465144097", "bodyText": "evergreen is just a code name. We shouldn't use evergreen in the topic name.", "author": "fengwang666", "createdAt": "2020-08-04T15:38:34Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2OTY0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465169649", "bodyText": "This is the currently topic we have on the cloud side. Will talk to Saili/Eric to change it.", "author": "nikkhilmuthye", "createdAt": "2020-08-04T16:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MzE1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468783151", "bodyText": "This will need to be configurable.", "author": "MikeDombo", "createdAt": "2020-08-11T18:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMDk4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468900987", "bodyText": "Why does this have to be configurable? The topic should not change dynamically since it is a reserved topic.", "author": "nikkhilmuthye", "createdAt": "2020-08-11T22:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTYzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468901637", "bodyText": "Cloud team talked to us; we need it configurable to hit different staged endpoints for beta/gamma testing.", "author": "MikeDombo", "createdAt": "2020-08-11T22:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDY2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465144664", "bodyText": "Should this be static? Shouldn't it be final?", "author": "fengwang666", "createdAt": "2020-08-04T15:39:25Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NTA0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465145049", "bodyText": "Isn't millisecond a bit extreme? Why not just use second as unit?", "author": "fengwang666", "createdAt": "2020-08-04T15:39:58Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjIyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465146225", "bodyText": "This is probably not sufficient across different platforms. Add a TODO to refactor this out to be more robust.", "author": "fengwang666", "createdAt": "2020-08-04T15:41:44Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDE3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465150170", "bodyText": "Is this correct? Let's say, yesterday at 8pm the device sent out status update to the cloud; today at 7:59 the machine is restarted or FleetStatusService is restarted, now the lastPeriodicUpdateTime is 7:59 today and next update will be tomorrow.\nThe lastPeriodicUpdateTime needs to be persisted in the config object.", "author": "fengwang666", "createdAt": "2020-08-04T15:47:25Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjIyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465152226", "bodyText": "I believe in the previous round of review, two methods are suggested on concurrentSet. Can you update it? It's a minor detail but it does reflect our coding bar. This repository is intended to be open-source and many ppl will read this code.", "author": "fengwang666", "createdAt": "2020-08-04T15:50:28Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NzA3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465157075", "bodyText": "And why are they static?", "author": "fengwang666", "createdAt": "2020-08-04T15:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MjQ1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465172459", "bodyText": "The reason I didn't use ConcurrentSet was because the Evergreen Service does not implement the equals overrided method. Without doing that, I don't think it is a good practice to have the equals operation to happen on the object level which will be based on the memory addresses.", "author": "nikkhilmuthye", "createdAt": "2020-08-04T16:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NDQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465174439", "bodyText": "The hashCode will be based on memory address which is correct and guaranteed to be unique. You can safely switch it to a set.", "author": "MikeDombo", "createdAt": "2020-08-04T16:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NjM5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465156395", "bodyText": "This variable needs to be synchronized and thread-safe.", "author": "fengwang666", "createdAt": "2020-08-04T15:56:41Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NzgxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465157813", "bodyText": "Why is it a static variable?", "author": "fengwang666", "createdAt": "2020-08-04T15:58:38Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;", "originalCommit": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "deea385d5d81782257b6a81f6d732b9cf9ca7d54", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/deea385d5d81782257b6a81f6d732b9cf9ca7d54", "message": "Address PR comments.", "committedDate": "2020-08-04T23:35:14Z", "type": "commit"}, {"oid": "9880e4ca20f5b818bbf9291c6757a34e90f43b3d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9880e4ca20f5b818bbf9291c6757a34e90f43b3d", "message": "Merge branch 'master' into fss", "committedDate": "2020-08-04T23:36:08Z", "type": "commit"}, {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/23041bda698ec4eab619263f4bf97c40a08cc6dd", "message": "Refactor some code.", "committedDate": "2020-08-05T16:06:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MjUwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467272506", "bodyText": "shutdown can throw. Put the cleanup inside of a finally block so that it always cleans up", "author": "MikeDombo", "createdAt": "2020-08-07T21:16:52Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mjc4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467272781", "bodyText": "let's get a const for this format", "author": "MikeDombo", "createdAt": "2020-08-07T21:17:47Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(String.format(\"$aws/things/%s/evergreen/health/json\", thingInfo.getThingName()))", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MzMyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467273327", "bodyText": "can we not hardcode these services? Their names and existence is likely to change.", "author": "MikeDombo", "createdAt": "2020-08-07T21:19:22Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(String.format(\"$aws/things/%s/evergreen/health/json\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")\n+                        .withConfiguration(\"{\\\"sampleText\\\":\\\"FCS integ test\\\"}\"))\n+                .addPackagesEntry(\"SomeService\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult1 = setAndPublishFleetConfiguration(setRequest1);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult1.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        String someServiceName = getCloudDeployedComponent(\"SomeService\").getName();\n+\n+        // Second deployment to remove some services deployed previously\n+        SetConfigurationRequest setRequest2 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult2 = setAndPublishFleetConfiguration(setRequest2);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult2.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        // Ensure that main is finished, which is its terminal state, so this means that all updates ought to be done\n+        assertThat(kernel.getMain()::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThat(getCloudDeployedComponent(\"CustomerApp\")::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThrows(ServiceLoadException.class, () -> getCloudDeployedComponent(\"SomeService\").getState());\n+\n+        assertTrue(cdl.await(1, TimeUnit.MINUTES), \"All messages published and received\");\n+        assertEquals(2, mqttMessagesList.get().size());\n+\n+        Arn arn = Arn.builder()\n+                .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                .withService(FLEET_STATUS_ARN_SERVICE)\n+                .withAccountId(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getAccountId()))\n+                .withRegion(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getRegion()))\n+                .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, \"thinggroup/\" + thingGroupName, \"1\"))\n+                .build();\n+\n+        // Check the MQTT messages.\n+        // The first MQTT message should have all the services whose status changed during the first deployment.\n+        // This will include the system and user components.\n+        MqttMessage receivedMqttMessage1 = mqttMessagesList.get().get(0);\n+        assertNotNull(receivedMqttMessage1.getPayload());\n+        FleetStatusDetails fleetStatusDetails1 = DESERIALIZER.readValue(receivedMqttMessage1.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails1.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails1.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails1.getOverallStatus());\n+        assertThat(fleetStatusDetails1.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(getCloudDeployedComponent(\"Mosquitto\").getName(), someServiceName,\n+                        getCloudDeployedComponent(\"CustomerApp\").getName(),\n+                        getCloudDeployedComponent(\"GreenSignal\").getName(),\n+                        \"main\", \"pubsubipc\", \"IPCService\", \"FleetStatusService\", \"lifecycleipc\", \"configstoreipc\",\n+                        \"SafeSystemUpdate\", \"DeploymentService\", \"servicediscovery\"));", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mzc4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467273788", "bodyText": "do not read from children it should be private anyway", "author": "MikeDombo", "createdAt": "2020-08-07T21:20:41Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -418,4 +432,56 @@ void setDeploymentsQueue(LinkedBlockingQueue<Deployment> deploymentsQueue) {\n     public DeploymentTaskMetadata getCurrentDeploymentTaskMetadata() {\n         return currentDeploymentTaskMetadata;\n     }\n+\n+    private void setComponentsToGroupsMapping(Topics groupsToRootComponents) {\n+         if (groupsToRootComponents.children == null || groupsToRootComponents.children.size() == 0) {\n+            return;\n+        }", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mzg5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467273892", "bodyText": "use Coerce.toString(lookup)", "author": "MikeDombo", "createdAt": "2020-08-07T21:21:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -418,4 +432,56 @@ void setDeploymentsQueue(LinkedBlockingQueue<Deployment> deploymentsQueue) {\n     public DeploymentTaskMetadata getCurrentDeploymentTaskMetadata() {\n         return currentDeploymentTaskMetadata;\n     }\n+\n+    private void setComponentsToGroupsMapping(Topics groupsToRootComponents) {\n+         if (groupsToRootComponents.children == null || groupsToRootComponents.children.size() == 0) {\n+            return;\n+        }\n+        List<String> pendingComponentsList = new LinkedList<>();\n+        Map<Object, Object> componentsToGroupsMappingCache = new ConcurrentHashMap<>();\n+        Topics componentsToGroupsTopics;\n+\n+        componentsToGroupsTopics = getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        // Get all the groups associated to the root components.\n+        groupsToRootComponents.iterator().forEachRemaining(groupNode -> {\n+            Topics componentTopics = (Topics) groupNode;\n+\n+            Topic lookup = componentTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID);\n+            String groupDeploymentId = (String) lookup.getOnce();", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NTU3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467275570", "bodyText": "instead of reduce, you should be able to do allMatch", "author": "MikeDombo", "createdAt": "2020-08-07T21:23:49Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -118,7 +125,10 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n                 DeploymentType deploymentType = (DeploymentType)\n                         deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n \n-                if (!getConsumerForDeploymentType(deploymentType).apply(deploymentDetails)) {\n+                boolean allConsumersUpdated = getConsumersForDeploymentType(deploymentType).stream()\n+                        .map(consumer -> consumer.apply(deploymentDetails))\n+                        .reduce(true, (a, b) -> a && b);", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4MzQyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467283425", "bodyText": "Don't put this logic here. Now you're making all services dependent on FSS.\nInstead, have FSS subscribe to the services topic in the config store and listen for changes to that.", "author": "MikeDombo", "createdAt": "2020-08-07T21:34:09Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -555,7 +556,13 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 DependencyInfo dependencyInfo = dependencies.remove(dependency);\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n-            context.get(Kernel.class).clearODcache();\n+            Kernel kernel = context.get(Kernel.class);\n+            kernel.clearODcache();\n+            FleetStatusService fleetStatusService = (FleetStatusService) kernel\n+                    .locate(FleetStatusService.FLEET_STATUS_SERVICE_TOPICS);\n+            if (fleetStatusService != null) {\n+                fleetStatusService.updateRemovedDependencies(removedDependencies);", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NDEzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467284130", "bodyText": "put this in a finally, or after each to make sure that it is always shutdown.", "author": "MikeDombo", "createdAt": "2020-08-07T21:35:04Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -167,20 +174,78 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_correctly_map_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics deploymentGroupTopics = Topics.of(context, EXPECTED_GROUP_NAME, allGroupTopics);\n+            Topic pkgTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\");\n+            Topic groupTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                    \"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\");\n+            Map<String, Node> pkgDetails = new HashMap<>();\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgTopic1);\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID, groupTopic1);\n+            Topics pkgTopics = Topics.of(context, EXPECTED_ROOT_PACKAGE_NAME, deploymentGroupTopics);\n+            pkgTopics.children.putAll(pkgDetails);\n+            deploymentGroupTopics.children.put(EXPECTED_ROOT_PACKAGE_NAME, pkgTopics);\n+\n+            doNothing().when(mockComponentsToGroupPackages).replaceAndWait(any());\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(deploymentGroupTopics);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(mockComponentsToGroupPackages);\n+            when(mockKernel.locate(any())).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }\n+            }).when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            jobSucceededLatch.await(10, TimeUnit.SECONDS);\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(mockComponentsToGroupPackages).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",\n+                    ((Map<String, Boolean>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                            .containsKey(\"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\"));\n+\n+            deploymentService.shutdown();", "originalCommit": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8d0b4b76686323e858681b93d0030ad707b5f34c", "message": "Address PR comments.", "committedDate": "2020-08-10T15:11:20Z", "type": "commit"}, {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/efb1b09410111b5fb71e74c0316fd424959f6a92", "message": "Merge branch 'master' into fss", "committedDate": "2020-08-11T18:33:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3ODYyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468778623", "bodyText": "I'm not sure this is still correct. We're now using random names for our components. Have a look at the other tests and verify that this still passes.", "author": "MikeDombo", "createdAt": "2020-08-11T18:25:29Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusService;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (kernel != null) {\n+                kernel.shutdown();\n+            }\n+        } finally {\n+            // Cleanup all IoT thing resources we created\n+            cleanup();\n+        }\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(FleetStatusService.FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyNjA2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468826064", "bodyText": "Yes it does work. We do get random component names. It gets set in setAndPublishFleetConfiguration", "author": "nikkhilmuthye", "createdAt": "2020-08-11T19:50:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3ODYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3OTQ2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468779468", "bodyText": "Why check against empty list? Just assertThat(..., is(empty())", "author": "MikeDombo", "createdAt": "2020-08-11T18:27:04Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusService;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (kernel != null) {\n+                kernel.shutdown();\n+            }\n+        } finally {\n+            // Cleanup all IoT thing resources we created\n+            cleanup();\n+        }\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(FleetStatusService.FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")\n+                        .withConfiguration(\"{\\\"sampleText\\\":\\\"FCS integ test\\\"}\"))\n+                .addPackagesEntry(\"SomeService\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult1 = setAndPublishFleetConfiguration(setRequest1);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult1.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        String someServiceName = getCloudDeployedComponent(\"SomeService\").getName();\n+        Set<String> componentNames = new HashSet<>();\n+        componentNames.add(getCloudDeployedComponent(\"Mosquitto\").getName());\n+        componentNames.add(someServiceName);\n+        componentNames.add(getCloudDeployedComponent(\"CustomerApp\").getName());\n+        componentNames.add(getCloudDeployedComponent(\"GreenSignal\").getName());\n+        kernel.orderedDependencies().forEach(evergreenService -> {\n+            if(evergreenService.isAutostart() || evergreenService.getName().equals(\"main\")) {\n+                componentNames.add(evergreenService.getName());\n+            }\n+        });\n+\n+        // Second deployment to remove some services deployed previously\n+        SetConfigurationRequest setRequest2 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult2 = setAndPublishFleetConfiguration(setRequest2);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult2.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        // Ensure that main is finished, which is its terminal state, so this means that all updates ought to be done\n+        assertThat(kernel.getMain()::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThat(getCloudDeployedComponent(\"CustomerApp\")::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThrows(ServiceLoadException.class, () -> getCloudDeployedComponent(\"SomeService\").getState());\n+\n+        assertTrue(cdl.await(1, TimeUnit.MINUTES), \"All messages published and received\");\n+        assertEquals(2, mqttMessagesList.get().size());\n+\n+        Arn arn = Arn.builder()\n+                .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                .withService(FLEET_STATUS_ARN_SERVICE)\n+                .withAccountId(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getAccountId()))\n+                .withRegion(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getRegion()))\n+                .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, \"thinggroup/\" + thingGroupName, \"1\"))\n+                .build();\n+\n+        // Check the MQTT messages.\n+        // The first MQTT message should have all the services whose status changed during the first deployment.\n+        // This will include the system and user components.\n+        MqttMessage receivedMqttMessage1 = mqttMessagesList.get().get(0);\n+        assertNotNull(receivedMqttMessage1.getPayload());\n+        FleetStatusDetails fleetStatusDetails1 = DESERIALIZER.readValue(receivedMqttMessage1.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails1.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails1.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails1.getOverallStatus());\n+        fleetStatusDetails1.getComponentStatusDetails().forEach(componentStatusDetails -> {\n+            componentNames.remove(componentStatusDetails.getComponentName());\n+        });\n+        assertTrue(componentNames.isEmpty());\n+        fleetStatusDetails1.getComponentStatusDetails().forEach(componentStatusDetails -> {\n+            assertEquals(Collections.singletonList(arn.toString()), componentStatusDetails.getFleetConfigArns());\n+        });\n+\n+        // The second MQTT message should contain only one component information which was removed during the second\n+        // deployment.\n+        // The configuration arns for that component should be empty to indicate that it was removed from all groups.\n+        MqttMessage receivedMqttMessage2 = mqttMessagesList.get().get(1);\n+        assertNotNull(receivedMqttMessage2.getPayload());\n+        FleetStatusDetails fleetStatusDetails2 = DESERIALIZER.readValue(receivedMqttMessage2.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails2.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails2.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails2.getOverallStatus());\n+        assertEquals(1, fleetStatusDetails2.getComponentStatusDetails().size());\n+        assertThat(fleetStatusDetails2.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(someServiceName));\n+        assertEquals(Collections.emptyList(), fleetStatusDetails2.getComponentStatusDetails().get(0).getFleetConfigArns());", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MDEyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468780127", "bodyText": "when using coerce, don't call getOnce.", "author": "MikeDombo", "createdAt": "2020-08-11T18:28:15Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -418,4 +432,51 @@ void setDeploymentsQueue(LinkedBlockingQueue<Deployment> deploymentsQueue) {\n     public DeploymentTaskMetadata getCurrentDeploymentTaskMetadata() {\n         return currentDeploymentTaskMetadata;\n     }\n+\n+    private void setComponentsToGroupsMapping(Topics groupsToRootComponents) {\n+        List<String> pendingComponentsList = new LinkedList<>();\n+        Map<Object, Object> componentsToGroupsMappingCache = new ConcurrentHashMap<>();\n+        Topics componentsToGroupsTopics = getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        // Get all the groups associated to the root components.\n+        groupsToRootComponents.iterator().forEachRemaining(groupNode -> {\n+            Topics componentTopics = (Topics) groupNode;\n+\n+            Topic lookup = componentTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID);\n+            String groupDeploymentId = Coerce.toString(lookup.getOnce());", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MjQyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468782425", "bodyText": "this can be simplified to stream().filter().map().collect()", "author": "MikeDombo", "createdAt": "2020-08-11T18:32:40Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -128,12 +137,14 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n         }\n     }\n \n-    protected Function<Map<String, Object>, Boolean> getConsumerForDeploymentType(DeploymentType type) {\n-        return deploymentStatusConsumer.computeIfAbsent(type, deploymentType -> {\n-            logger.atDebug().kv(\"DeploymentType\", deploymentType)\n-                    .log(\"Consumer for type not found, dropping status update\");\n-            return (status) -> true;\n+    protected List<Function<Map<String, Object>, Boolean>> getConsumersForDeploymentType(DeploymentType type) {\n+        List<Function<Map<String, Object>, Boolean>> callbacks = new ArrayList<>();\n+        deploymentStatusConsumerMap.forEach((deploymentType, stringFunctionMap) -> {\n+            if (deploymentType == type) {\n+                stringFunctionMap.forEach((s, mapBooleanFunction) -> callbacks.add(mapBooleanFunction));\n+            }\n         });\n+        return callbacks;", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MzA0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468783042", "bodyText": "do all these need to be public? If not, let's scope it down. If you need it in testing, make it package-private.", "author": "MikeDombo", "createdAt": "2020-08-11T18:33:48Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MzgwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468783805", "bodyText": "thing name can change. This needs to be a subscribe.", "author": "MikeDombo", "createdAt": "2020-08-11T18:35:08Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NDM4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468784382", "bodyText": "Why store these as fields at all? If you're using the config store for persistence, then don't copy it into local fields; that's just going to cause synchronization issues.", "author": "MikeDombo", "createdAt": "2020-08-11T18:36:12Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NTQyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468785427", "bodyText": "I do see that your usages look safe, but why not just have this method cancel the old scheduled task? That way it is much safer and won't be broken by future changes.", "author": "MikeDombo", "createdAt": "2020-08-11T18:38:09Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {", "originalCommit": "8d0b4b76686323e858681b93d0030ad707b5f34c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NjE2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468786162", "bodyText": "Why only if there's no deployment? BROKEN at any time is bad.", "author": "MikeDombo", "createdAt": "2020-08-11T18:39:33Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMTMxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468831312", "bodyText": "If it is during deployment, then we will send this information when the deployment finishes. But if a component goes to BROKEN when there is no ongoing deployment, then we need to send that information immediately.", "author": "nikkhilmuthye", "createdAt": "2020-08-11T20:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNzk1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468917958", "bodyText": "Sounds like a likely race to me. What's the downside of omitting this check?", "author": "MikeDombo", "createdAt": "2020-08-11T23:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NjE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4Njg4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468786881", "bodyText": "[nit]\nYou don't need to call 'toString'", "author": "MikeDombo", "createdAt": "2020-08-11T18:40:52Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NzQ3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468787476", "bodyText": "This logic is awfully familiar. Extract it out to a private method.", "author": "MikeDombo", "createdAt": "2020-08-11T18:41:35Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMjEyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468832123", "bodyText": "The logic is similar but they work on different objects when get ordered dependencies. One works on allEvergreenServicesNameMap and the other on a local object evergreenServiceSet", "author": "nikkhilmuthye", "createdAt": "2020-08-11T20:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NzgxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468787815", "bodyText": "this doesn't need to be threadsafe as far as I can tell.", "author": "MikeDombo", "createdAt": "2020-08-11T18:41:56Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4OTEyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468789122", "bodyText": "why do you need to synchronize? You're only adding to this set which is fine to do. Also, this set is based on a concurrent hashmap, so all concurrent operations ought to be safe.", "author": "MikeDombo", "createdAt": "2020-08-11T18:43:19Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MDc0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468790747", "bodyText": "Why is this map named like this? What is the Instant for?", "author": "MikeDombo", "createdAt": "2020-08-11T18:45:01Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMzA1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468833059", "bodyText": "So we need to know when was the last time we updated information about this service. This instant will get updated whenever we trigger an event based update. We need this information to that a component was not updated when a second deployment occurred. which would mean that it was removed from the kernel.\nThis logic will go away once we implement the callback from the deployment service to get notification of added/removed components.", "author": "nikkhilmuthye", "createdAt": "2020-08-11T20:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MDc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MTYzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468791632", "bodyText": "Why are you keeping a set of services? If you want a set of service, call kernel.orderedDependencies().\nIt looks like there's a lot of duplicated data in this service which exists elsewhere in Evergreen.", "author": "MikeDombo", "createdAt": "2020-08-11T18:45:54Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMzkxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468833918", "bodyText": "I updated the name of this object to updatedEvergreenServiceSet. This set has the list of all services whose status changed. This is used in the event triggered approach to send the data of only those components whose statuses have changed.", "author": "nikkhilmuthye", "createdAt": "2020-08-11T20:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5Mjc2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468792765", "bodyText": "getName returns a string. You shouldn't need valueOf", "author": "MikeDombo", "createdAt": "2020-08-11T18:47:05Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MzI4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468793280", "bodyText": "instead of materializing a list and then doing addAll, you can just add in a foreach of the stream.", "author": "MikeDombo", "createdAt": "2020-08-11T18:47:53Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDQ2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794467", "bodyText": "this log isn't helping anyone. We already log when things start", "author": "MikeDombo", "createdAt": "2020-08-11T18:50:09Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDY0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794647", "bodyText": "you don't need to override startup at all if this is all you're doing. You can just let the super class handle it", "author": "MikeDombo", "createdAt": "2020-08-11T18:50:31Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzNTA1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468835051", "bodyText": "We need this start up method since the super class' method is not accessible in the tests.", "author": "nikkhilmuthye", "createdAt": "2020-08-11T20:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDczMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794733", "bodyText": "again, not a helpful log", "author": "MikeDombo", "createdAt": "2020-08-11T18:50:39Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        logger.atInfo().log(\"Stopping Fleet status service.\");", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDkwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794908", "bodyText": "make this package-private if it is only for unit tests.", "author": "MikeDombo", "createdAt": "2020-08-11T18:50:57Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        logger.atInfo().log(\"Stopping Fleet status service.\");\n+        if (!this.periodicUpdateFuture.isCancelled()) {\n+            this.periodicUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * Used for unit tests only. Adds a list of evergreen services of previously\n+     *\n+     * @param evergreenServices List of evergreen services to add\n+     * @param instant last time the service was processed.\n+     */\n+    public void addEvergreenServicesToPreviouslyKnownServicesList(List<EvergreenService> evergreenServices,\n+                                                                  Instant instant) {\n+        evergreenServices.forEach(evergreenService -> allEvergreenServicesNameMap.put(evergreenService, instant));\n+    }\n+\n+    /**\n+     * Used for unit tests only.\n+     */\n+    public void clearEvergreenServiceSet() {", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NTAyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468795021", "bodyText": "package-private", "author": "MikeDombo", "createdAt": "2020-08-11T18:51:10Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        logger.atInfo().log(\"Stopping Fleet status service.\");\n+        if (!this.periodicUpdateFuture.isCancelled()) {\n+            this.periodicUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * Used for unit tests only. Adds a list of evergreen services of previously\n+     *\n+     * @param evergreenServices List of evergreen services to add\n+     * @param instant last time the service was processed.\n+     */\n+    public void addEvergreenServicesToPreviouslyKnownServicesList(List<EvergreenService> evergreenServices,", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NTE0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468795147", "bodyText": "undo this", "author": "MikeDombo", "createdAt": "2020-08-11T18:51:23Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -556,7 +556,8 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 DependencyInfo dependencyInfo = dependencies.remove(dependency);\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n-            context.get(Kernel.class).clearODcache();\n+            Kernel kernel = context.get(Kernel.class);\n+            kernel.clearODcache();", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NTkyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468795926", "bodyText": "instead of this, you can use verify with a timeout.", "author": "MikeDombo", "createdAt": "2020-08-11T18:52:53Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,128 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }\n+            }).when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NzAzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468797037", "bodyText": "same here.", "author": "MikeDombo", "createdAt": "2020-08-11T18:54:53Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,128 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }\n+            }).when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            jobSucceededLatch.await(10, TimeUnit.SECONDS);\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",\n+                    ((Map<String, Boolean>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                            .get(TEST_CONFIGURATION_ARN).equals(true));\n+\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_correctly_map_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics deploymentGroupTopics = Topics.of(context, EXPECTED_GROUP_NAME, allGroupTopics);\n+            Topic pkgTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\");\n+            Topic groupTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                    \"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\");\n+            Map<String, Node> pkgDetails = new HashMap<>();\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgTopic1);\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID, groupTopic1);\n+            Topics pkgTopics = Topics.of(context, EXPECTED_ROOT_PACKAGE_NAME, deploymentGroupTopics);\n+            pkgTopics.children.putAll(pkgDetails);\n+            deploymentGroupTopics.children.put(EXPECTED_ROOT_PACKAGE_NAME, pkgTopics);\n+\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(deploymentGroupTopics);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(mockComponentsToGroupPackages);\n+            when(mockKernel.locate(any())).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NzQ4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468797485", "bodyText": "shut this down at the end of each test", "author": "MikeDombo", "createdAt": "2020-08-11T18:55:42Z", "path": "src/test/java/com/aws/iot/evergreen/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,693 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.config.EvergreenLogConfig;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGServiceTestUtil;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.slf4j.event.Level;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_SEQUENCE_NUMBER_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class FleetStatusServiceTest extends EGServiceTestUtil {\n+    @Mock\n+    private MqttClient mockMqttClient;\n+    @Mock\n+    private DeviceConfiguration mockDeviceConfiguration;\n+    @Mock\n+    private DeploymentStatusKeeper mockDeploymentStatusKeeper;\n+    @Mock\n+    private Kernel mockKernel;\n+    @Mock\n+    private EvergreenService mockEvergreenService1;\n+    @Mock\n+    private EvergreenService mockEvergreenService2;\n+    @Mock\n+    private DeploymentService mockDeploymentService;\n+    @Captor\n+    private ArgumentCaptor<Function<Map<String, Object>, Boolean>> consumerArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<MqttClientConnectionEvents> mqttClientConnectionEventsArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<GlobalStateChangeListener> addGlobalStateChangeListenerArgumentCaptor;\n+\n+    private ScheduledThreadPoolExecutor ses;\n+    private FleetStatusService fleetStatusService;\n+\n+    @BeforeEach\n+    public void setup() {\n+        serviceFullName = \"FleetStatusService\";\n+        initializeMockedConfig();\n+        ses = new ScheduledThreadPoolExecutor(4);", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NzU4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468797581", "bodyText": "Do not use order", "author": "MikeDombo", "createdAt": "2020-08-11T18:55:52Z", "path": "src/test/java/com/aws/iot/evergreen/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,693 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.config.EvergreenLogConfig;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGServiceTestUtil;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.slf4j.event.Level;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_SEQUENCE_NUMBER_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class FleetStatusServiceTest extends EGServiceTestUtil {\n+    @Mock\n+    private MqttClient mockMqttClient;\n+    @Mock\n+    private DeviceConfiguration mockDeviceConfiguration;\n+    @Mock\n+    private DeploymentStatusKeeper mockDeploymentStatusKeeper;\n+    @Mock\n+    private Kernel mockKernel;\n+    @Mock\n+    private EvergreenService mockEvergreenService1;\n+    @Mock\n+    private EvergreenService mockEvergreenService2;\n+    @Mock\n+    private DeploymentService mockDeploymentService;\n+    @Captor\n+    private ArgumentCaptor<Function<Map<String, Object>, Boolean>> consumerArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<MqttClientConnectionEvents> mqttClientConnectionEventsArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<GlobalStateChangeListener> addGlobalStateChangeListenerArgumentCaptor;\n+\n+    private ScheduledThreadPoolExecutor ses;\n+    private FleetStatusService fleetStatusService;\n+\n+    @BeforeEach\n+    public void setup() {\n+        serviceFullName = \"FleetStatusService\";\n+        initializeMockedConfig();\n+        ses = new ScheduledThreadPoolExecutor(4);\n+        Topic thingNameTopic = Topic.of(context, DEVICE_PARAM_THING_NAME, \"testThing\");\n+        lenient().when(mockDeviceConfiguration.getThingName()).thenReturn(thingNameTopic);\n+        lenient().when(mockEvergreenService2.getName()).thenReturn(\"MockService2\");\n+        lenient().when(mockEvergreenService1.getName()).thenReturn(\"MockService\");\n+        EvergreenLogConfig.getInstance().setLevel(Level.DEBUG);\n+        Topic sequenceNumberTopic = Topic.of(context, FLEET_STATUS_SEQUENCE_NUMBER_TOPIC, \"0\");\n+        when(config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)).thenReturn(sequenceNumberTopic);\n+        Topic lastPeriodicUpdateTime = Topic.of(context, FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC, Instant.now().toEpochMilli());\n+        when(config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)).thenReturn(lastPeriodicUpdateTime);\n+    }\n+\n+    @AfterEach\n+    public void cleanUp() {\n+        fleetStatusService.shutdown();\n+        fleetStatusService.clearEvergreenServiceSet();\n+    }\n+\n+    @Test\n+    @Order(1)", "originalCommit": "efb1b09410111b5fb71e74c0316fd424959f6a92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9c5311f43f61725a316d2881e0bafabba5c17053", "message": "Address PR comments.", "committedDate": "2020-08-11T22:26:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMzE2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468903168", "bodyText": "completely remove this log", "author": "MikeDombo", "createdAt": "2020-08-11T22:36:56Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -349,14 +364,14 @@ private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallS\n \n \n     @Override\n-    public void startup() {\n-        logger.atInfo().log(\"Starting Fleet status service.\");\n-        reportState(State.RUNNING);\n+    public void startup() throws InterruptedException {\n+        logger.atDebug().log(\"Starting Fleet status service.\");", "originalCommit": "9c5311f43f61725a316d2881e0bafabba5c17053", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMzIzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468903230", "bodyText": "completely remove", "author": "MikeDombo", "createdAt": "2020-08-11T22:37:07Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -349,14 +364,14 @@ private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallS\n \n \n     @Override\n-    public void startup() {\n-        logger.atInfo().log(\"Starting Fleet status service.\");\n-        reportState(State.RUNNING);\n+    public void startup() throws InterruptedException {\n+        logger.atDebug().log(\"Starting Fleet status service.\");\n+        super.startup();\n     }\n \n     @Override\n     public void shutdown() {\n-        logger.atInfo().log(\"Stopping Fleet status service.\");\n+        logger.atDebug().log(\"Stopping Fleet status service.\");", "originalCommit": "9c5311f43f61725a316d2881e0bafabba5c17053", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMzM5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468903394", "bodyText": "use shutdownNow", "author": "MikeDombo", "createdAt": "2020-08-11T22:37:32Z", "path": "src/test/java/com/aws/iot/evergreen/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -102,26 +101,27 @@ public void setup() {\n         initializeMockedConfig();\n         ses = new ScheduledThreadPoolExecutor(4);\n         Topic thingNameTopic = Topic.of(context, DEVICE_PARAM_THING_NAME, \"testThing\");\n-        lenient().when(mockDeviceConfiguration.getThingName()).thenReturn(thingNameTopic);\n         lenient().when(mockEvergreenService2.getName()).thenReturn(\"MockService2\");\n         lenient().when(mockEvergreenService1.getName()).thenReturn(\"MockService\");\n         EvergreenLogConfig.getInstance().setLevel(Level.DEBUG);\n+        when(config.lookup(DEVICE_PARAM_THING_NAME)).thenReturn(thingNameTopic);\n+        when(mockDeviceConfiguration.getThingName()).thenReturn(thingNameTopic);\n         Topic sequenceNumberTopic = Topic.of(context, FLEET_STATUS_SEQUENCE_NUMBER_TOPIC, \"0\");\n-        when(config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)).thenReturn(sequenceNumberTopic);\n+        lenient().when(config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)).thenReturn(sequenceNumberTopic);\n         Topic lastPeriodicUpdateTime = Topic.of(context, FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC, Instant.now().toEpochMilli());\n-        when(config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)).thenReturn(lastPeriodicUpdateTime);\n+        lenient().when(config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)).thenReturn(lastPeriodicUpdateTime);\n     }\n \n     @AfterEach\n     public void cleanUp() {\n+        ses.shutdown();", "originalCommit": "9c5311f43f61725a316d2881e0bafabba5c17053", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "46e0cc4b4439f2e5f762bc8564b4283b08e29af0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/46e0cc4b4439f2e5f762bc8564b4283b08e29af0", "message": "Address more PR comments. Make publish topic configurable.", "committedDate": "2020-08-11T23:01:40Z", "type": "commit"}, {"oid": "d5ee6593054658179276e4da214f40276de4ecd6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5ee6593054658179276e4da214f40276de4ecd6", "message": "Merge branch 'master' into fss", "committedDate": "2020-08-11T23:04:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNjY5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468916697", "bodyText": "use hamcrest to your advantage. http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/core/AnyOf.html\nhttp://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/collection/IsEmptyCollection.html\nhttp://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/core/IsNull.html", "author": "MikeDombo", "createdAt": "2020-08-11T23:17:33Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,114 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());", "originalCommit": "d5ee6593054658179276e4da214f40276de4ecd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNjg4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468916880", "bodyText": "use hamcrest to properly check equality.\nassertThat(x, is(true))", "author": "MikeDombo", "createdAt": "2020-08-11T23:18:08Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,114 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",", "originalCommit": "d5ee6593054658179276e4da214f40276de4ecd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNzA3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468917077", "bodyText": "use hamcrest\nassertThat(x, hasKey(y))\nhttp://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/collection/IsMapContaining.html#hasKey(K)", "author": "MikeDombo", "createdAt": "2020-08-11T23:18:52Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,114 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",\n+                    ((Map<String, Boolean>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                            .get(TEST_CONFIGURATION_ARN).equals(true));\n+\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_correctly_map_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics deploymentGroupTopics = Topics.of(context, EXPECTED_GROUP_NAME, allGroupTopics);\n+            Topic pkgTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\");\n+            Topic groupTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                    \"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\");\n+            Map<String, Node> pkgDetails = new HashMap<>();\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgTopic1);\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID, groupTopic1);\n+            Topics pkgTopics = Topics.of(context, EXPECTED_ROOT_PACKAGE_NAME, deploymentGroupTopics);\n+            pkgTopics.children.putAll(pkgDetails);\n+            deploymentGroupTopics.children.put(EXPECTED_ROOT_PACKAGE_NAME, pkgTopics);\n+\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(deploymentGroupTopics);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(mockComponentsToGroupPackages);\n+            when(mockKernel.locate(any())).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(mockComponentsToGroupPackages).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",", "originalCommit": "d5ee6593054658179276e4da214f40276de4ecd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/189cb87cc5ecfd6402df103a84959bb18a4af11e", "message": "Address PR comments on tests.", "committedDate": "2020-08-11T23:54:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MzQ1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470283454", "bodyText": "Do we need a filter here? Why not map.get(type)?", "author": "hui-yang", "createdAt": "2020-08-13T22:28:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -128,12 +137,11 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n         }\n     }\n \n-    protected Function<Map<String, Object>, Boolean> getConsumerForDeploymentType(DeploymentType type) {\n-        return deploymentStatusConsumer.computeIfAbsent(type, deploymentType -> {\n-            logger.atDebug().kv(\"DeploymentType\", deploymentType)\n-                    .log(\"Consumer for type not found, dropping status update\");\n-            return (status) -> true;\n-        });\n+    protected List<Function<Map<String, Object>, Boolean>> getConsumersForDeploymentType(DeploymentType type) {\n+        return deploymentStatusConsumerMap.entrySet().stream()\n+                .filter(deploymentTypeMapEntry -> type.equals(deploymentTypeMapEntry.getKey()))", "originalCommit": "189cb87cc5ecfd6402df103a84959bb18a4af11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NDA4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470284088", "bodyText": "Can you add a javadoc? What is the boolean in the return object?", "author": "hui-yang", "createdAt": "2020-08-13T22:29:58Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -128,12 +137,11 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n         }\n     }\n \n-    protected Function<Map<String, Object>, Boolean> getConsumerForDeploymentType(DeploymentType type) {\n-        return deploymentStatusConsumer.computeIfAbsent(type, deploymentType -> {\n-            logger.atDebug().kv(\"DeploymentType\", deploymentType)\n-                    .log(\"Consumer for type not found, dropping status update\");\n-            return (status) -> true;\n-        });\n+    protected List<Function<Map<String, Object>, Boolean>> getConsumersForDeploymentType(DeploymentType type) {", "originalCommit": "189cb87cc5ecfd6402df103a84959bb18a4af11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NTEyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470285126", "bodyText": "You can use KERNEL_VERSION in kernel pkg for now", "author": "hui-yang", "createdAt": "2020-08-13T22:32:55Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC =\n+            \"$aws/things/{thingName}/evergreen/health/json\";\n+    static final String FLEET_STATUS_SERVICE_PUBLISH_TOPICS = \"fleetStatusServicePublishTopic\";\n+    static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private String updateFssDataTopic;\n+    private String thingName;\n+    private final MqttClient mqttClient;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final Set<EvergreenService> updatedEvergreenServiceSet =\n+            Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final Object periodicUpdateInProgressLock = new Object();\n+    private int periodicUpdateIntervalSec;\n+    public String fleetStatusServicePublishTopic = DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeploymentStatusKeeper deploymentStatusKeeper,\n+                              Kernel kernel, DeviceConfiguration deviceConfiguration) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        updateThingNameAndPublishTopic(Coerce.toString(deviceConfiguration.getThingName()));\n+        topics.lookup(DeviceConfiguration.DEVICE_PARAM_THING_NAME)\n+                .subscribe((why, node) -> updateThingNameAndPublishTopic(Coerce.toString(node)));\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_SERVICE_PUBLISH_TOPICS)\n+                .dflt(DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC)\n+                .subscribe((why, newv) -> {\n+                    fleetStatusServicePublishTopic = Coerce.toString(newv);\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";", "originalCommit": "189cb87cc5ecfd6402df103a84959bb18a4af11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NjY1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470286655", "bodyText": "I saw this call in 3 places, here, updatePeriodicFleetStatusData and updateEventTriggeredFleetStatusData. How are these 3 coordinated?\nI was assuming updateEventTriggeredFleetStatusData to be synchronized, unless you can explain the reasons", "author": "hui-yang", "createdAt": "2020-08-13T22:37:29Z", "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC =\n+            \"$aws/things/{thingName}/evergreen/health/json\";\n+    static final String FLEET_STATUS_SERVICE_PUBLISH_TOPICS = \"fleetStatusServicePublishTopic\";\n+    static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private String updateFssDataTopic;\n+    private String thingName;\n+    private final MqttClient mqttClient;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final Set<EvergreenService> updatedEvergreenServiceSet =\n+            Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final Object periodicUpdateInProgressLock = new Object();\n+    private int periodicUpdateIntervalSec;\n+    public String fleetStatusServicePublishTopic = DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeploymentStatusKeeper deploymentStatusKeeper,\n+                              Kernel kernel, DeviceConfiguration deviceConfiguration) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        updateThingNameAndPublishTopic(Coerce.toString(deviceConfiguration.getThingName()));\n+        topics.lookup(DeviceConfiguration.DEVICE_PARAM_THING_NAME)\n+                .subscribe((why, node) -> updateThingNameAndPublishTopic(Coerce.toString(node)));\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_SERVICE_PUBLISH_TOPICS)\n+                .dflt(DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC)\n+                .subscribe((why, newv) -> {\n+                    fleetStatusServicePublishTopic = Coerce.toString(newv);\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void updateThingNameAndPublishTopic(String newThingName) {\n+        if (newThingName != null) {\n+            thingName = newThingName;\n+            updateFssDataTopic = fleetStatusServicePublishTopic.replace(\"{thingName}\", thingName);\n+        }\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (periodicUpdateFuture != null) {\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        synchronized (periodicUpdateInProgressLock) {\n+            Instant lastPeriodicUpdateTime = Instant.ofEpochMilli(Coerce.toLong(getPeriodicUpdateTimeTopic()));\n+\n+            if (lastPeriodicUpdateTime.plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+                updatePeriodicFleetStatusData();\n+            } else if (isDuringConnectionResumed) {\n+                updateEventTriggeredFleetStatusData();\n+            }\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (updatedEvergreenServiceSet) {\n+            updatedEvergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(updatedEvergreenServiceSet, OverallStatus.UNHEALTHY);", "originalCommit": "189cb87cc5ecfd6402df103a84959bb18a4af11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5OTEyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470299127", "bodyText": "Synced offline. Most places should be thread-safe, and updateEventTriggeredFleetStatusData needs to be protected.", "author": "hui-yang", "createdAt": "2020-08-13T23:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NjY1NQ=="}], "type": "inlineReview"}, {"oid": "a79c19640b4702496015c639b5e7af6fa434cd66", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a79c19640b4702496015c639b5e7af6fa434cd66", "message": "Address PR comments", "committedDate": "2020-08-13T23:41:53Z", "type": "commit"}, {"oid": "b4d26e45d46522f5c1fe92e99106c03794f56799", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b4d26e45d46522f5c1fe92e99106c03794f56799", "message": "Merge branch 'master' into fss", "committedDate": "2020-08-13T23:43:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzOTY5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470339696", "bodyText": "instead of hardcoding this, why not grab it from the const?", "author": "MikeDombo", "createdAt": "2020-08-14T00:45:16Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -171,7 +171,7 @@ void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_f\n         assertNotNull(receivedMqttMessage2.getPayload());\n         FleetStatusDetails fleetStatusDetails2 = DESERIALIZER.readValue(receivedMqttMessage2.getPayload(), FleetStatusDetails.class);\n         assertEquals(thingInfo.getThingName(), fleetStatusDetails2.getThing());\n-        assertEquals(\"1.0.0\", fleetStatusDetails2.getGgcVersion());\n+        assertEquals(\"2.0.0\", fleetStatusDetails2.getGgcVersion());", "originalCommit": "a79c19640b4702496015c639b5e7af6fa434cd66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4OTUyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470689524", "bodyText": "I don't really like asserting on a const value. With hard coding the value here, it makes sure if the value of the const is changed, the engineer changing it knows it will affect the FSS feature too.", "author": "nikkhilmuthye", "createdAt": "2020-08-14T15:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzOTY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyNzkxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470727915", "bodyText": "Changing the kernel version and no other functionality shouldn't break this test.", "author": "MikeDombo", "createdAt": "2020-08-14T16:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzOTY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyODExMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470728110", "bodyText": "Also, you make this assertion in many of the tests which doesn't seem very necessary", "author": "MikeDombo", "createdAt": "2020-08-14T16:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzOTY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczMDgyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470730828", "bodyText": "Sure. I can change it to use the const. But the reason why I did the assertion in all those places was to make sure no matter what path is taken to upload the FSS data, we always have that field set.", "author": "nikkhilmuthye", "createdAt": "2020-08-14T16:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzOTY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczMjM0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470732349", "bodyText": "Thank you. If they are taking different paths, then that's good to assert on each one.", "author": "MikeDombo", "createdAt": "2020-08-14T16:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzOTY5Ng=="}], "type": "inlineReview"}, {"oid": "e939a1b82a7343f6e4f945df66f3339a73ddde29", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e939a1b82a7343f6e4f945df66f3339a73ddde29", "message": "Use const KERNEL_VERSION in tests.", "committedDate": "2020-08-14T16:36:33Z", "type": "commit"}]}