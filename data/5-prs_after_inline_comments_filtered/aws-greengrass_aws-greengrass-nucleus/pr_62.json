{"pr_number": 62, "pr_title": "Add Package Model, Package Recipe schema model and Semver based versi\u2026", "pr_createdAt": "2020-02-13T04:32:21Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5Mzk3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378993978", "bodyText": "For ease of use by customers, we probably want to treat the keys case-insensitive.\nOBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);", "author": "MikeDombo", "createdAt": "2020-02-13T17:02:12Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyODQ1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379028456", "bodyText": "That could work, are there any keyword like life cycle states that the kernel is reading as case sensitive? There shouldn't be any other issue.", "author": "chaurah", "createdAt": "2020-02-13T18:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5Mzk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5OTU5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380899590", "bodyText": "Ideally it would not be case sensitive, but right now we're looking everything up as lowercase. I put this comment since your JSON properties here are capitalized in pascal case.", "author": "MikeDombo", "createdAt": "2020-02-18T19:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5Mzk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NTMwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378995301", "bodyText": "Lombok should be able to help with these getters/setters and constructors.", "author": "MikeDombo", "createdAt": "2020-02-13T17:03:33Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final IPackageConfig recipe;\n+\n+    /**", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyOTM1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379029353", "bodyText": "Will double check for getters/setters in all classes.", "author": "chaurah", "createdAt": "2020-02-13T18:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NTMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NjU2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378996564", "bodyText": "Any reason not to just put @getter onto the entire class so you don't have to repeat it all the time here?", "author": "MikeDombo", "createdAt": "2020-02-13T17:05:39Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    @Getter", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzQ1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379027451", "bodyText": "Makes sense, I think I was trying to hide some of them but ended up adding getters to all. I will update to class level.", "author": "chaurah", "createdAt": "2020-02-13T18:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NjU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NzYwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378997602", "bodyText": "This is probably fine, but you could also just use a stream and filter it instead of using removeIf, then return the filtered list. Then you wouldn't need this note at all.", "author": "MikeDombo", "createdAt": "2020-02-13T17:07:32Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    @Getter\n+    private final String version;\n+\n+    @Getter\n+    private final int major;\n+\n+    @Getter\n+    private final int minor;\n+\n+    @Getter\n+    private final int patch;\n+\n+    // Unused at the moment\n+    @Getter\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    @Getter\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare\n+    }\n+\n+    /**\n+     * Check if given version is in range\n+     */\n+    public static boolean isVersionInRange(String testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        return isVersionInRange(new EvergreenPackageVersion(testVersion), range);\n+    }\n+\n+    /**\n+     * Check if given version is in range\n+     * NOTE: Quick fix, Probably can be simplfied, the List is redundant\n+     */\n+    public static boolean isVersionInRange(EvergreenPackageVersion testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        List<EvergreenPackageVersion> versions = new ArrayList<>();\n+        versions.add(testVersion);\n+\n+        applyRangeToInput(versions, range);\n+        return !versions.isEmpty();\n+    }\n+\n+    /**\n+     * Apply provided range to a list of versions.\n+     * NOTE: The input list WILL BE mutated and contain the result of applying the provided range conditions.", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNjg5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379026897", "bodyText": "I will do a bit more refactoring after I add in all the range keywords. Will look into stream + filter at that point, thanks for pointing it out", "author": "chaurah", "createdAt": "2020-02-13T18:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NzYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5ODY3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378998671", "bodyText": "Not sure if we have guidelines yet, but looking at the code so far, the interface should just be PackageConfig and the implementation PackageConfigImpl. Something to discuss briefly post-scrum.", "author": "MikeDombo", "createdAt": "2020-02-13T17:09:26Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/IPackageConfig.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+public interface IPackageConfig {", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNTkxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379025917", "bodyText": "Fine with either approach as long as we are consistent. This is just what I have used in the past. +1 on postscrum discussion.", "author": "chaurah", "createdAt": "2020-02-13T18:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5ODY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTcyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378999721", "bodyText": "I know this is WIP, so that's fine, but we have a bigger list of OSes in the Kernel currently if you look at the method pickByOS.", "author": "MikeDombo", "createdAt": "2020-02-13T17:11:07Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackage;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.IPackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements IPackageConfig {\n+    private final Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    private static final String DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT\n+            = \"Default platform config was not found when parsing recipe for package\";\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<IArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifacts();\n+    }\n+\n+    @Override\n+    public HashMap<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<IArtifactProvider> artifacts;\n+\n+        private final HashMap<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle Map of all lifecycle configurations\n+         * @param artifactUrls Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") Map<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifactUrls,\n+                                             @JsonProperty(\"dependencies\") List<EvergreenPackageDependency>\n+                                                             dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: Migrate to deserializing artifact providers directly\n+            if (artifactUrls == null) {\n+                this.artifacts = Collections.emptySet();\n+            } else {\n+                HashSet<IArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifactUrls) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }\n+                this.artifacts = providerSet;\n+            }\n+            this.dependencies = new HashMap<>();\n+            if (dependencies != null && !dependencies.isEmpty()) {\n+                for (EvergreenPackageDependency entry : dependencies) {\n+                    // TODO: This is an ugly hack, figure out how to get Jackson to parse an array of key value pairs\n+                    //  as map\n+                    this.dependencies.put(entry.getPackageName(), entry.getPackageVersion());\n+                }\n+            }\n+        }\n+\n+        public Map<String, Object> getLifecycle() {\n+            return lifecycle;\n+        }\n+\n+        public Set<IArtifactProvider> getArtifacts() {\n+            return artifacts;\n+        }\n+\n+        public HashMap<String, String> getDependencies() {\n+            return dependencies;\n+        }\n+\n+    }\n+\n+    public enum SupportedPlatforms {", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNTQ2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379025464", "bodyText": "Good catch, going to pull those in.", "author": "chaurah", "createdAt": "2020-02-13T17:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwMDQ0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379000442", "bodyText": "We're going with the outputstream way of doing it? I commented on Jason's PR earlier and he seemed to like the idea that the caller would pass a File that they want the artifact to be written to. That way the artifact stays out of Java's memory as much as possible.", "author": "MikeDombo", "createdAt": "2020-02-13T17:12:26Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/IArtifactProvider.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Path;\n+\n+public interface IArtifactProvider {\n+\n+    ByteArrayOutputStream loadArtifact(String artifactUrl);", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNDU2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379024561", "bodyText": "Leftover from copy pasta, removing that.", "author": "chaurah", "createdAt": "2020-02-13T17:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwMDQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwMTI0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379001240", "bodyText": "Unused?", "author": "MikeDombo", "createdAt": "2020-02-13T17:13:57Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/TestHelper.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class TestHelper {\n+    public static final String MONITORING_SERVICE_PACKAGE_NAME = \"MonitoringService\";\n+    public static final String CONVEYOR_BELT_PACKAGE_NAME = \"ConveyorBelt\";\n+\n+    public static final String TEST_RECIPE_FMT = \"RecipeTemplateVersion: '2020-01-25'\\n\"", "originalCommit": "e986b0edfc94850f69483e53357e0b4654d1c8cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNDk3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379024974", "bodyText": "Leftover again, I initially put test recipes here but realized it just makes a lot more sense to have test packages. Removing.", "author": "chaurah", "createdAt": "2020-02-13T17:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwMTI0MA=="}], "type": "inlineReview"}, {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "message": "Improve code quality, add full list of supported platforms, improve unit test coverage", "committedDate": "2020-02-14T23:22:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMDQzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380900430", "bodyText": "I don't think this is needed at all. If you just have @AllArgsConstructor from lombok then Jackson should be abel to serialize/deserialize.", "author": "MikeDombo", "createdAt": "2020-02-18T19:55:09Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NjM0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382296349", "bodyText": "Cleaned up as much as possible in new commit. This file has been renamed to PackageRecipe.java to address some confusion by other reviewers.", "author": "chaurah", "createdAt": "2020-02-20T22:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMDQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMDc2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380900764", "bodyText": "[nit]\nLombok for getters and constructor. @Getter and @AllArgsConstructor.", "author": "MikeDombo", "createdAt": "2020-02-18T19:55:44Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageDependency.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+public class EvergreenPackageDependency {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NjMwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382296309", "bodyText": "Done", "author": "chaurah", "createdAt": "2020-02-20T22:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMDc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMTY5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380901699", "bodyText": "Very likely this may want to throw something.", "author": "MikeDombo", "createdAt": "2020-02-18T19:57:35Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactProvider.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Path;\n+\n+public interface ArtifactProvider {\n+\n+    void downloadArtifactToPath(Path outPath);", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NjQ0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382296442", "bodyText": "Updated", "author": "chaurah", "createdAt": "2020-02-20T22:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMTY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NjY4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380956682", "bodyText": "What's this for? It's not being used.", "author": "fengwang666", "createdAt": "2020-02-18T21:51:05Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageLifecycle.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+public interface PackageLifecycle {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxMjEwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381512100", "bodyText": "I'm not sure it's necessary to have an interface or a class for that matter for lifecycle, if it's deserialized as Map<String, Object> from the recipe, we can work with that directly.", "author": "shaguptashaikh", "createdAt": "2020-02-19T20:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NjY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NjYxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382296616", "bodyText": "Removed, this was a placeholder but based on recent discussions it's not needed anymore", "author": "chaurah", "createdAt": "2020-02-20T22:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NjY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjA3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382376074", "bodyText": "+1 for not necessary. By the name suggested, it's lifecycle data mode. So interface seems unnecessary.", "author": "wikimonkey", "createdAt": "2020-02-21T03:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Njg1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380956855", "bodyText": "What's this for? It's not being used.", "author": "fengwang666", "createdAt": "2020-02-18T21:51:30Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackagePlatformConfig.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+public interface PackagePlatformConfig {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NjY4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382296686", "bodyText": "Removed", "author": "chaurah", "createdAt": "2020-02-20T22:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Njg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1OTc4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380959784", "bodyText": "Why is this needed?", "author": "fengwang666", "createdAt": "2020-02-18T21:57:30Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/exceptions/PackagingException.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package com.aws.iot.evergreen.packagemanager.exceptions;\n+\n+public class PackagingException extends Exception {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNjk4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382226982", "bodyText": "+1, particular why is checked exception? Also do you want to distinguish between retryable or non-retryable? I  would suggest to define specific exceptions with the use cases.", "author": "wikimonkey", "createdAt": "2020-02-20T20:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1OTc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzMjcxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382232710", "bodyText": "We are preferring checked exceptions always, see: https://w.amazon.com/bin/view/AWS/Greengrass/GGC/Greenlake/DevelopmentGuideline/#HExceptionhandling", "author": "MikeDombo", "createdAt": "2020-02-20T20:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1OTc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5Njk0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382296948", "bodyText": "This is the parent for all Packaging Exceptions. Allows components which don't care to catch individual exceptions to just catch the base and take some decision.", "author": "chaurah", "createdAt": "2020-02-20T22:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1OTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MTUzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380961535", "bodyText": "Not sure if this is desired. Why do you want to make the package name case-insensitive?", "author": "fengwang666", "createdAt": "2020-02-18T22:01:09Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        this.packageVersion = packageVersion;\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.recipe =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifacts() {\n+        return recipe.getArtifactProviders();\n+    }\n+\n+    public HashMap<String, String> getDependencies() {\n+        return recipe.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static EvergreenPackage getPackageObject(String recipe) {\n+        EvergreenPackage pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, EvergreenPackage.class);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to parse recipe\", e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof EvergreenPackage)) {\n+            return false;\n+        }\n+\n+        EvergreenPackage pkg = (EvergreenPackage) obj;\n+        boolean ret = true;\n+        if (!pkg.getPackageName().equalsIgnoreCase(getPackageName())) {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MjYyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381492620", "bodyText": "Good point, switching to equals", "author": "chaurah", "createdAt": "2020-02-19T19:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MTUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzM3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380963375", "bodyText": "Why do we need to override this?", "author": "fengwang666", "createdAt": "2020-02-18T22:05:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        this.packageVersion = packageVersion;\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.recipe =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifacts() {\n+        return recipe.getArtifactProviders();\n+    }\n+\n+    public HashMap<String, String> getDependencies() {\n+        return recipe.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static EvergreenPackage getPackageObject(String recipe) {\n+        EvergreenPackage pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, EvergreenPackage.class);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to parse recipe\", e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof EvergreenPackage)) {\n+            return false;\n+        }\n+\n+        EvergreenPackage pkg = (EvergreenPackage) obj;\n+        boolean ret = true;\n+        if (!pkg.getPackageName().equalsIgnoreCase(getPackageName())) {\n+            ret = false;\n+        } else if (!pkg.getPackageVersion().equals((getPackageVersion()))) {\n+            ret = false;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MzE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381493163", "bodyText": "Collections/Maps etc can break if you override only equals and not hashcode. Findbugs also throws a warning.", "author": "chaurah", "createdAt": "2020-02-19T19:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODUwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382878505", "bodyText": "Replaced with lombok generated code.", "author": "chaurah", "createdAt": "2020-02-22T02:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MDQxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381070411", "bodyText": "Why does PackageConfig need to be an interface? Also why not just name it PackageRecipe?", "author": "fengwang666", "createdAt": "2020-02-19T04:23:34Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageConfig.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+public interface PackageConfig {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5NzE5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381497197", "bodyText": "Package Recipe is the term we're using for the full recipe file. The hierarchy at the moment is:\nPackageRecipe.java -> maps to full recipe file\nPackageConfig.java -> versioned, maps to the specific section called config in the full recipe", "author": "chaurah", "createdAt": "2020-02-19T19:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MDQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTIyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381071225", "bodyText": "Let's use a consistent way to name unit test. Some of the codebase uses the behavior driven development pattern: \"GIVEN...WHEN...THEN\".", "author": "fengwang666", "createdAt": "2020-02-19T04:27:34Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageTests.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class EvergreenPackageTests {\n+\n+    @Test\n+    public void testPackageCreateSuccess() {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5Nzc4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382297788", "bodyText": "I was following one of the other test classes, but this makes sense. Updated to GIVEN...WHEN...THEN", "author": "chaurah", "createdAt": "2020-02-20T22:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTg3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381071879", "bodyText": "This doesn't help when someone needs to update the code. Can you add a readme describing how the versioning works with concrete examples?", "author": "fengwang666", "createdAt": "2020-02-19T04:30:51Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MzY1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381493658", "bodyText": "There will be a Readme and a quip doc. I'll add more information to the comments as well.", "author": "chaurah", "createdAt": "2020-02-19T19:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNjEwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381506108", "bodyText": "Maybe we've already discussed and decided this but do they have a library(of acceptable size) we can depend on instead of maintaining this? Or do they only have guidelines for specs?", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODA4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382298082", "bodyText": "I hadn't found a usable alternative at the time. Have an option now and migrated to using that directly. This file has been removed.", "author": "chaurah", "createdAt": "2020-02-20T22:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTk3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381071979", "bodyText": "unused, then remove them.", "author": "fengwang666", "createdAt": "2020-02-19T04:31:24Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5Mzg3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381493879", "bodyText": "Removing them, will add again if we decide to go ahead and use these.", "author": "chaurah", "createdAt": "2020-02-19T19:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MjczMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381072733", "bodyText": "These two the same. I see a lot of redundant input in this list. We only need one valid input for each category. We should try to be precise when writing unit tests. It makes the code easier to maintain.", "author": "fengwang666", "createdAt": "2020-02-19T04:34:35Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMTM1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381501351", "bodyText": "This is the full list taken as is from semver.org. I agree there are redundant inputs in the list but at the same time, I don't think there's any reason to modify what the spec website is providing as a complete list of test versions.\nI should add a comment to that effect though, it seems to have been lost when I moved these strings around.", "author": "chaurah", "createdAt": "2020-02-19T19:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MjczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODE3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382298176", "bodyText": "This file has been removed.", "author": "chaurah", "createdAt": "2020-02-20T22:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MjczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MjgzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381072830", "bodyText": "Same here. Please remove the redundant invalid versions.", "author": "fengwang666", "createdAt": "2020-02-19T04:35:12Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMTc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381501783", "bodyText": "See comment above.", "author": "chaurah", "createdAt": "2020-02-19T19:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MjgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MzYwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381073609", "bodyText": "This doesn't seem to be conventional. By convention, you use @before annotation to perform the common step in a test.", "author": "fengwang666", "createdAt": "2020-02-19T04:38:32Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMTkxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381501913", "bodyText": "Updating", "author": "chaurah", "createdAt": "2020-02-19T19:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODIyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382298228", "bodyText": "This file has been removed.", "author": "chaurah", "createdAt": "2020-02-20T22:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3Mzc5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381073793", "bodyText": "These are different test cases. Please break them into separate test cases.", "author": "fengwang666", "createdAt": "2020-02-19T04:39:13Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {\n+        testInputList = new ArrayList<>();\n+        testInputList.add(new EvergreenPackageVersion(\"1.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.4.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.8.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.9.9\"));\n+        testInputList.add(new EvergreenPackageVersion(\"3.3.0\"));\n+    }\n+\n+    @Test\n+    public void testVersioning() {\n+        try {\n+            for(String sValid : validVersionList) {\n+                assertTrue(EvergreenPackageVersion.isValidVersion(sValid));\n+            }\n+            for(String sInvalid : invalidVersionsList) {\n+                assertFalse(EvergreenPackageVersion.isValidVersion(sInvalid));\n+            }\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeHyphens() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4Mjg3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381082871", "bodyText": "Also, in this case specifically, you should be using assertEquals.", "author": "MikeDombo", "createdAt": "2020-02-19T05:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3Mzc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NDc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381074783", "bodyText": "You don't need this! The test will fail if an exception is thrown.", "author": "fengwang666", "createdAt": "2020-02-19T04:43:38Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {\n+        testInputList = new ArrayList<>();\n+        testInputList.add(new EvergreenPackageVersion(\"1.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.4.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.8.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.9.9\"));\n+        testInputList.add(new EvergreenPackageVersion(\"3.3.0\"));\n+    }\n+\n+    @Test\n+    public void testVersioning() {\n+        try {\n+            for(String sValid : validVersionList) {\n+                assertTrue(EvergreenPackageVersion.isValidVersion(sValid));\n+            }\n+            for(String sInvalid : invalidVersionsList) {\n+                assertFalse(EvergreenPackageVersion.isValidVersion(sInvalid));\n+            }\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeHyphens() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.5 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"2 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2.9\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(\"1.5.0\", \"1.4.0 - 2\"));\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"1.5.0\"),\n+                                                                \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(\"2.5.0\", \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"2.5.0\"),\n+                                                                 \"1.4.0 - 2\"));\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NDg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381074865", "bodyText": "Same here. break them into multiple tests.", "author": "fengwang666", "createdAt": "2020-02-19T04:44:03Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {\n+        testInputList = new ArrayList<>();\n+        testInputList.add(new EvergreenPackageVersion(\"1.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.4.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.8.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.9.9\"));\n+        testInputList.add(new EvergreenPackageVersion(\"3.3.0\"));\n+    }\n+\n+    @Test\n+    public void testVersioning() {\n+        try {\n+            for(String sValid : validVersionList) {\n+                assertTrue(EvergreenPackageVersion.isValidVersion(sValid));\n+            }\n+            for(String sInvalid : invalidVersionsList) {\n+                assertFalse(EvergreenPackageVersion.isValidVersion(sInvalid));\n+            }\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeHyphens() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.5 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"2 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2.9\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(\"1.5.0\", \"1.4.0 - 2\"));\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"1.5.0\"),\n+                                                                \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(\"2.5.0\", \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"2.5.0\"),\n+                                                                 \"1.4.0 - 2\"));\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeComparators() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \">1.4.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \">1.4\");\n+            assertTrue(testInputCopyList.size() == 4);", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NTIzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381075236", "bodyText": "Probably don't want to throw RuntimeException here.", "author": "fengwang666", "createdAt": "2020-02-19T04:45:55Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        this.packageVersion = packageVersion;\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.recipe =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifacts() {\n+        return recipe.getArtifactProviders();\n+    }\n+\n+    public HashMap<String, String> getDependencies() {\n+        return recipe.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static EvergreenPackage getPackageObject(String recipe) {\n+        EvergreenPackage pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, EvergreenPackage.class);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to parse recipe\", e);", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MjMwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381492309", "bodyText": "Looking through other components to see what folks are doing.", "author": "chaurah", "createdAt": "2020-02-19T19:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382298439", "bodyText": "Updated to checked exception", "author": "chaurah", "createdAt": "2020-02-20T22:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2OTI5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381469299", "bodyText": "This looks unused, if you do need it it probably shouldn't be public?", "author": "shaguptashaikh", "createdAt": "2020-02-19T18:41:12Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODU0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382298540", "bodyText": "Removed for this PR", "author": "chaurah", "createdAt": "2020-02-20T22:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2OTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3MTUxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381471514", "bodyText": "Will be better if we used one term for this, if it's recipe maybe this class should be called recipe?", "author": "shaguptashaikh", "createdAt": "2020-02-19T18:45:05Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODY4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382298686", "bodyText": "Renamed to PackageRecipe.java", "author": "chaurah", "createdAt": "2020-02-20T22:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3MTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5ODY3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381498671", "bodyText": "Should this be called getArtifactProviders? 'getArtifacts' kind of suggests that you are downloading/fetching the actual artifacts but it looks like after this method call you'll still need to call the download method on each artifact provider", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:35:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfig {\n+    private final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    private static final String DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT\n+            = \"Default platform config was not found when parsing recipe for package\";\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException       Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms25Jan2020.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifacts();\n+    }\n+\n+    @Override\n+    public HashMap<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<ArtifactProvider> artifacts;\n+\n+        private final HashMap<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle    Map of all lifecycle configurations\n+         * @param artifactUrls Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires     Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") Map<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifactUrls,\n+                                             @JsonProperty(\"dependencies\") List<EvergreenPackageDependency>\n+                                                     dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: Migrate to deserializing artifact providers directly\n+            if (artifactUrls == null) {\n+                this.artifacts = Collections.emptySet();\n+            } else {\n+                HashSet<ArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifactUrls) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }\n+                this.artifacts = providerSet;\n+            }\n+            this.dependencies = new HashMap<>();\n+            if (dependencies != null && !dependencies.isEmpty()) {\n+                for (EvergreenPackageDependency entry : dependencies) {\n+                    // TODO: This is an ugly hack, figure out how to get Jackson to parse an array of key value pairs\n+                    //  as map\n+                    this.dependencies.put(entry.getPackageName(), entry.getPackageVersion());\n+                }\n+            }\n+        }\n+\n+        public Map<String, Object> getLifecycle() {\n+            return lifecycle;\n+        }\n+\n+        public Set<ArtifactProvider> getArtifacts() {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODc1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382298759", "bodyText": "Updated", "author": "chaurah", "createdAt": "2020-02-20T22:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5ODY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMDcxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381500719", "bodyText": "Should this list be managed by Kernel and reused by package manager if it needs to?", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:38:55Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfig {\n+    private final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    private static final String DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT\n+            = \"Default platform config was not found when parsing recipe for package\";\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException       Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms25Jan2020.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifacts();\n+    }\n+\n+    @Override\n+    public HashMap<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<ArtifactProvider> artifacts;\n+\n+        private final HashMap<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle    Map of all lifecycle configurations\n+         * @param artifactUrls Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires     Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") Map<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifactUrls,\n+                                             @JsonProperty(\"dependencies\") List<EvergreenPackageDependency>\n+                                                     dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: Migrate to deserializing artifact providers directly\n+            if (artifactUrls == null) {\n+                this.artifacts = Collections.emptySet();\n+            } else {\n+                HashSet<ArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifactUrls) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }\n+                this.artifacts = providerSet;\n+            }\n+            this.dependencies = new HashMap<>();\n+            if (dependencies != null && !dependencies.isEmpty()) {\n+                for (EvergreenPackageDependency entry : dependencies) {\n+                    // TODO: This is an ugly hack, figure out how to get Jackson to parse an array of key value pairs\n+                    //  as map\n+                    this.dependencies.put(entry.getPackageName(), entry.getPackageVersion());\n+                }\n+            }\n+        }\n+\n+        public Map<String, Object> getLifecycle() {\n+            return lifecycle;\n+        }\n+\n+        public Set<ArtifactProvider> getArtifacts() {\n+            return artifacts;\n+        }\n+\n+        public HashMap<String, String> getDependencies() {\n+            return dependencies;\n+        }\n+\n+    }\n+\n+    public enum SupportedPlatforms25Jan2020 {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTI2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382299266", "bodyText": "It's possible the kernel list differs from what individual recipes have. I considered reusing the kernel list initially but I don't think we want the hard link when it's very simple to avoid.", "author": "chaurah", "createdAt": "2020-02-20T22:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMzE2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381503162", "bodyText": "Don't see how this is used, suppose it will be in the following PR? Will it talk to the cloud service? If it doesn't then maybe call it LocalPackageStore or something", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:43:27Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackage;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageVersion;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTQ0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382299440", "bodyText": "Yes, creating a second PR for implementations of this interface.", "author": "chaurah", "createdAt": "2020-02-20T22:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMzE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzUxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381507515", "bodyText": "Nit - the code here is self explanatory, probably don't need this documentation", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:51:29Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382299530", "bodyText": "This file has been removed.", "author": "chaurah", "createdAt": "2020-02-20T22:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzk3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381507975", "bodyText": "Nit - is this a TODO? maybe we should mark all TODOs as TODOs so it's easier to find them for IDEs", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:52:18Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTU4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382299587", "bodyText": "This file has been removed.", "author": "chaurah", "createdAt": "2020-02-20T22:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTQ1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381509454", "bodyText": "Remove this now?", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:55:06Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     */\n+    public static boolean isVersionInRange(String testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        return isVersionInRange(new EvergreenPackageVersion(testVersion), range);\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     * NOTE: Quick fix, Probably can be simplfied, the List is redundant\n+     */\n+    public static boolean isVersionInRange(EvergreenPackageVersion testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        List<EvergreenPackageVersion> versions = new ArrayList<>();\n+        versions.add(testVersion);\n+\n+        applyRangeToInput(versions, range);\n+        return !versions.isEmpty();\n+    }\n+\n+    /**\n+     * Apply provided range to a list of versions.\n+     * NOTE: The input list WILL BE mutated and contain the result of applying the provided range conditions.\n+     *\n+     */\n+    public static void applyRangeToInput(List<EvergreenPackageVersion> versions, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        // NOTE: Only supports major.minor.patch for the moment\n+        // NOTE: This is only for ONE SINGLE comparator set, we may not support multiple sets, TBD\n+        // Multiple comparator sets are range conditions separated by either whitespace or ||\n+        // https://www.npmjs.com/package/semver#ranges\n+\n+        // Apply Hyphen Ranges X.Y.Z - A.B.C\n+        final Matcher hyphenRangeMatcher = HYPHEN_RANGE_PATTERN.matcher(range);\n+        if (hyphenRangeMatcher.matches()) {\n+            // matched hyphen range pattern\n+            // Construct lower bound\n+            /*System.out.println(\"Full match: \" + hyphenRangeMatcher.group(0));\n+            for (int i = 1; i <= hyphenRangeMatcher.groupCount(); i++) {\n+                System.out.println(\"Group \" + i + \": \" + hyphenRangeMatcher.group(i));\n+            }\n+            System.out.println(\"\\n\\n\");*/\n+\n+            String lowerBoundStr = String.format(VERSION_FMT, hyphenRangeMatcher.group(1),\n+                                         (hyphenRangeMatcher.group(2) != null) ? hyphenRangeMatcher.group(2) : \"0\",\n+                                         (hyphenRangeMatcher.group(3) != null) ? hyphenRangeMatcher.group(3) : \"0\");\n+            EvergreenPackageVersion lowerBound = new EvergreenPackageVersion(lowerBoundStr);\n+            String upperBoundStr = String.format(VERSION_FMT, hyphenRangeMatcher.group(6),\n+                                         (hyphenRangeMatcher.group(7) != null) ? hyphenRangeMatcher.group(7) : \"0\",\n+                                         (hyphenRangeMatcher.group(8) != null) ? hyphenRangeMatcher.group(8) : \"0\");\n+            EvergreenPackageVersion upperBound = new EvergreenPackageVersion(upperBoundStr);\n+\n+            versions.removeIf(\n+                    ver -> (ver.compareTo(lowerBound) < 0 || ver.compareTo(upperBound) >= 0));\n+\n+            // Range was a complete match, no need to proceed further\n+            return;\n+        }\n+\n+        String processedRange = range;\n+        // Convert X-Ranges 1.2.x 1.X 1.2.* * to < or >\n+        // Convert Tilde Ranges ~1.2.3 ~1.2 ~1 to < or >\n+        // Convert Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4 to < or >\n+\n+        final Matcher comparisionRangeMatcher = COMPARISION_RANGE_PATTERN.matcher(processedRange);\n+        if (comparisionRangeMatcher.matches()) {\n+            /*System.out.println(\"Full match: \" + comparisionRangeMatcher.group(0));\n+            for (int i = 1; i <= comparisionRangeMatcher.groupCount(); i++) {\n+                System.out.println(\"Group \" + i + \": \" + comparisionRangeMatcher.group(i));\n+            }*/\n+", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382299636", "bodyText": "This file has been removed.", "author": "chaurah", "createdAt": "2020-02-20T22:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTkwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381509905", "bodyText": "Was this for debugging, want to remove it now?", "author": "shaguptashaikh", "createdAt": "2020-02-19T19:55:59Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     */\n+    public static boolean isVersionInRange(String testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        return isVersionInRange(new EvergreenPackageVersion(testVersion), range);\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     * NOTE: Quick fix, Probably can be simplfied, the List is redundant\n+     */\n+    public static boolean isVersionInRange(EvergreenPackageVersion testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        List<EvergreenPackageVersion> versions = new ArrayList<>();\n+        versions.add(testVersion);\n+\n+        applyRangeToInput(versions, range);\n+        return !versions.isEmpty();\n+    }\n+\n+    /**\n+     * Apply provided range to a list of versions.\n+     * NOTE: The input list WILL BE mutated and contain the result of applying the provided range conditions.\n+     *\n+     */\n+    public static void applyRangeToInput(List<EvergreenPackageVersion> versions, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        // NOTE: Only supports major.minor.patch for the moment\n+        // NOTE: This is only for ONE SINGLE comparator set, we may not support multiple sets, TBD\n+        // Multiple comparator sets are range conditions separated by either whitespace or ||\n+        // https://www.npmjs.com/package/semver#ranges\n+\n+        // Apply Hyphen Ranges X.Y.Z - A.B.C\n+        final Matcher hyphenRangeMatcher = HYPHEN_RANGE_PATTERN.matcher(range);\n+        if (hyphenRangeMatcher.matches()) {\n+            // matched hyphen range pattern\n+            // Construct lower bound\n+            /*System.out.println(\"Full match: \" + hyphenRangeMatcher.group(0));", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxMzE3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381513173", "bodyText": "Is this a way to implement recipe schema versions or is it temporary until we finalize the format? It looks like there will be a bunch of changes whenever the format changes", "author": "shaguptashaikh", "createdAt": "2020-02-19T20:02:35Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfig {", "originalCommit": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMDA4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382300087", "bodyText": "Schema versions. This is intended to change every time we change the format as well as to maintain compatibility for existing formats as multiple people iterate on specific sections of the recipe.", "author": "chaurah", "createdAt": "2020-02-20T22:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxMzE3Mw=="}], "type": "inlineReview"}, {"oid": "c22347dd0d7e1634f38c667bc85ba9ee62f7ca39", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c22347dd0d7e1634f38c667bc85ba9ee62f7ca39", "message": "Add Package Model, Package Recipe schema model and Semver based versioning", "committedDate": "2020-02-20T22:31:33Z", "type": "forcePushed"}, {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b2d27eb73613a06f19ca3916d0878006ef4435c6", "message": "Add Package Model, Package Recipe schema model and Semver based versioning", "committedDate": "2020-02-21T02:13:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDQwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382364405", "bodyText": "What's the point of the math? Isn't the hashcode of that string good enough?", "author": "MikeDombo", "createdAt": "2020-02-21T02:19:21Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public PackageRecipe(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                         @JsonProperty(\"PackageName\") String packageName,\n+                         @JsonProperty(\"Version\") Semver packageVersion,\n+                         @JsonProperty(\"Description\") String description,\n+                         @JsonProperty(\"Publisher\") String publisher,\n+                         @JsonProperty(\"Config\") PackageConfigFormat config) throws SemverException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        //TODO: Figure out how to do this in deserialize (only option so far seems to be custom deserializer)\n+        this.packageVersion = new Semver(packageVersion.toString(), Semver.SemverType.NPM);\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.config =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return config.getArtifactProviders();\n+    }\n+\n+    public Map<String, String> getDependencies() {\n+        return config.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static PackageRecipe getPackageObject(String recipe)\n+            throws UnsupportedRecipeFormatException {\n+        PackageRecipe pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, PackageRecipe.class);\n+        } catch (IOException e) {\n+            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof PackageRecipe)) {\n+            return false;\n+        }\n+\n+        PackageRecipe pkg = (PackageRecipe) obj;\n+        boolean ret = true;\n+        if (!pkg.getPackageName().equals(getPackageName())) {\n+            ret = false;\n+        } else if (!pkg.getPackageVersion().equals((getPackageVersion()))) {\n+            ret = false;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        // TODO: Check against INT_MAX, maybe extend to include other fields and change to lombok?\n+        // TODO: See if this can be used for local override config as well\n+        String packageId = packageName + \"-\" + packageVersion.toString();\n+        result = prime * result", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NzM1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382757352", "bodyText": "Copy pasta, removing the math.", "author": "chaurah", "createdAt": "2020-02-21T19:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382364783", "bodyText": "Probably also needs method to perform cleanup or at least list all cached packages so you can determine what can be deleted.", "author": "MikeDombo", "createdAt": "2020-02-21T02:20:59Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NzI0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382757244", "bodyText": "Will be added later, seemed redundant to include it in this PR, it's already long enough :)", "author": "chaurah", "createdAt": "2020-02-21T19:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDk2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382364969", "bodyText": "The order should be (expected value, actual value). So I believe you need to flip this one and some others.", "author": "MikeDombo", "createdAt": "2020-02-21T02:21:56Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipeTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PackageRecipeTests {\n+\n+    @Test\n+    public void GIVEN_valid_package_recipe_WHEN_attempt_package_recipe_create_THEN_valid_package_recipe_created() {\n+        try {\n+            String recipeContents\n+                    = TestHelper.getPackageRecipeForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME,\n+                                                                \"1.0.0\");\n+            PackageRecipe testPkg = PackageRecipe.getPackageObject(recipeContents);\n+            assertEquals(testPkg.getPackageName(), TestHelper.MONITORING_SERVICE_PACKAGE_NAME);", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NjExOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382876119", "bodyText": "Done", "author": "chaurah", "createdAt": "2020-02-22T02:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTA1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382365055", "bodyText": "Remove this, just throw from the test case. Here and everywhere else too.", "author": "MikeDombo", "createdAt": "2020-02-21T02:22:18Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipeTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PackageRecipeTests {\n+\n+    @Test\n+    public void GIVEN_valid_package_recipe_WHEN_attempt_package_recipe_create_THEN_valid_package_recipe_created() {\n+        try {\n+            String recipeContents\n+                    = TestHelper.getPackageRecipeForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME,\n+                                                                \"1.0.0\");\n+            PackageRecipe testPkg = PackageRecipe.getPackageObject(recipeContents);\n+            assertEquals(testPkg.getPackageName(), TestHelper.MONITORING_SERVICE_PACKAGE_NAME);\n+            assertTrue(testPkg.getPackageVersion().isEqualTo(\"1.0.0\"));\n+            assertEquals(\"Me\", testPkg.getPublisher());\n+            assertEquals(testPkg.getRecipeTemplateVersion(), RecipeTemplateVersion.JAN_25_2020);\n+            assertEquals(testPkg.getRecipeTemplateVersion().getRecipeTemplateVersion(),\n+                         \"2020-01-25\");\n+            assertNotNull(testPkg.getConfig());\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTY5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382875694", "bodyText": "Done", "author": "chaurah", "createdAt": "2020-02-22T01:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTE0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382365144", "bodyText": "Use assertThrows here.", "author": "MikeDombo", "createdAt": "2020-02-21T02:22:47Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipeTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PackageRecipeTests {\n+\n+    @Test\n+    public void GIVEN_valid_package_recipe_WHEN_attempt_package_recipe_create_THEN_valid_package_recipe_created() {\n+        try {\n+            String recipeContents\n+                    = TestHelper.getPackageRecipeForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME,\n+                                                                \"1.0.0\");\n+            PackageRecipe testPkg = PackageRecipe.getPackageObject(recipeContents);\n+            assertEquals(testPkg.getPackageName(), TestHelper.MONITORING_SERVICE_PACKAGE_NAME);\n+            assertTrue(testPkg.getPackageVersion().isEqualTo(\"1.0.0\"));\n+            assertEquals(\"Me\", testPkg.getPublisher());\n+            assertEquals(testPkg.getRecipeTemplateVersion(), RecipeTemplateVersion.JAN_25_2020);\n+            assertEquals(testPkg.getRecipeTemplateVersion().getRecipeTemplateVersion(),\n+                         \"2020-01-25\");\n+            assertNotNull(testPkg.getConfig());\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_empty_package_recipe_WHEN_attempt_package_recipe_create_THEN_create_throws_exception() {\n+        try {", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTcyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382875723", "bodyText": "Fixed", "author": "chaurah", "createdAt": "2020-02-22T01:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5OTg3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382399876", "bodyText": "Is it data model? If it's data model, why does it mix with control logic? For example, PackageConfigFormat interface. The data model shouldn't decide artifact provider. The controlling logic decides what artifact provider to use in term of data model artifact type.", "author": "wikimonkey", "createdAt": "2020-02-21T05:08:26Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1OTIxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382759213", "bodyText": "Are you thinking of creating a separate class called PackageRecipeBuilder or something similar?", "author": "chaurah", "createdAt": "2020-02-21T19:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTc4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382875787", "bodyText": "As discussed, the initializer code has been removed from package model. The only remaining piece is the ArtifactProvider which will be moved in a follow up PR.", "author": "chaurah", "createdAt": "2020-02-22T01:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5OTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDMxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382400315", "bodyText": "Again, data model shouldn't control deserializing itself. We should separate control and data flows.", "author": "wikimonkey", "createdAt": "2020-02-21T05:10:52Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1OTI2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382759269", "bodyText": "See comment above", "author": "chaurah", "createdAt": "2020-02-21T19:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDU1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382400552", "bodyText": "Can you try to use lombok to generate equals and hashcode? why do we need to write ourselves?", "author": "wikimonkey", "createdAt": "2020-02-21T05:12:04Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public PackageRecipe(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                         @JsonProperty(\"PackageName\") String packageName,\n+                         @JsonProperty(\"Version\") Semver packageVersion,\n+                         @JsonProperty(\"Description\") String description,\n+                         @JsonProperty(\"Publisher\") String publisher,\n+                         @JsonProperty(\"Config\") PackageConfigFormat config) throws SemverException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        //TODO: Figure out how to do this in deserialize (only option so far seems to be custom deserializer)\n+        this.packageVersion = new Semver(packageVersion.toString(), Semver.SemverType.NPM);\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.config =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return config.getArtifactProviders();\n+    }\n+\n+    public Map<String, String> getDependencies() {\n+        return config.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static PackageRecipe getPackageObject(String recipe)\n+            throws UnsupportedRecipeFormatException {\n+        PackageRecipe pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, PackageRecipe.class);\n+        } catch (IOException e) {\n+            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTgwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382875806", "bodyText": "Done", "author": "chaurah", "createdAt": "2020-02-22T01:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjAzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382402037", "bodyText": "I understand the reasons behind versioned template. But my arguments are if name and version are fixed, why not artifacts and dependencies? Oppositely, are the package name and version ever fixed? for example, won't we decide to alter the name in the future? Also this creates another level indentation in recipe file.\nHave you thought different approach for this purpose? For example, use different recipe/package model to map to different template version completely?", "author": "wikimonkey", "createdAt": "2020-02-21T05:19:48Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNTg3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382405877", "bodyText": "Do we have to decide how we support recipe template version now? Can we add the support when we need to? I don't think it's one-way door.", "author": "wikimonkey", "createdAt": "2020-02-21T05:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MDk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382760991", "bodyText": "I don't quite understand this comment, if the package name/version have changed, it's not the same package. Why would we allow that to change in the code? And the recipe schema version to be used is defined by the Recipe file using the RecipeTemplateVersion variable. We don't force a mapping.\nWe did discuss earlier that adding schema versioning support is important. And well, at this point the code is already done so I don't think there's any reason to not merge it in?", "author": "chaurah", "createdAt": "2020-02-21T19:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTg0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382875840", "bodyText": "As discussed, we'll keep this for now and revisit the overall schema design if needed in a followup PR", "author": "chaurah", "createdAt": "2020-02-22T01:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjQwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382402407", "bodyText": "Why is it an interface? Isn't cache internal to package manager? Will we have different implementation of package cache? What's this store's relationship with package registry/database? Is it playing both roles of registry and cache?", "author": "wikimonkey", "createdAt": "2020-02-21T05:21:40Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {", "originalCommit": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MTU4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382761587", "bodyText": "This is playing both roles at the moment. But as we discussed, in my working model I didn't want to have a separate registry. Since that has changed, this can still be both roles but needs to have the code for registry added to implementation.\nAlso, this is an interface to allow for different types of Package Stores or different implementations. This same interface can be reused to interact with EPMS, S3 etc. The package manager PR will make this a little clearer. We can modify this interface as needed while working on that.", "author": "chaurah", "createdAt": "2020-02-21T19:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382878593", "bodyText": "Pull request with Local Store implementation - #68", "author": "chaurah", "createdAt": "2020-02-22T02:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NTY1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382795651", "bodyText": "We will need parameters section from the recipe in here as well, maybe an inner class of this with parameter name, default value and type. But if you are merging this soon, I can add that in my pull request", "author": "shaguptashaikh", "createdAt": "2020-02-21T20:41:26Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+", "originalCommit": "2d974c001e110bc0d2f311d2fcac0d2400b81344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTg2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382875860", "bodyText": "As discussed, this will be in a followup PR", "author": "chaurah", "createdAt": "2020-02-22T01:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NTY1MQ=="}], "type": "inlineReview"}, {"oid": "b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "message": "Add LocalArtifactProvider impl to avoid Covertura issues", "committedDate": "2020-02-22T02:06:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NzU5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382877596", "bodyText": "Get package/recipe implementation would be different based on the source, but I'm thinking cache and the copy location and hence the implementation should be the same for all package stores?  Should this be an abstract class instead of an interface so you could move these methods to a common place?", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:19:32Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {\n+    Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion);\n+\n+    void cachePackageArtifacts(PackageRecipe evgPackage) throws PackagingException;\n+\n+    void cachePackageRecipeAndArtifacts(PackageRecipe evgPackage, final String recipeContents)\n+            throws PackagingException;\n+\n+    void copyPackageArtifactsToPath(PackageRecipe curPackage, Path destPath) throws PackagingException;\n+", "originalCommit": "b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4OTM1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382889357", "bodyText": "Copy could also be different depending whether we choose to perform a direct copy from store to some location. Not sure if that's the best idea in terms of implementation but it's straightforward.\nIs it ok to refactor this in a follow up PR when we add more types of stores? Depending on the situation, this can always be updated to abstract class.", "author": "chaurah", "createdAt": "2020-02-22T05:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NzcyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382877728", "bodyText": "Is this temporary since we only have local artifact provider right now?", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:21:06Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,155 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfigFormat;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfigFormat {\n+    private final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException       Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms25Jan2020.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(Constants.DEFAULT_CONFIG_NOT_FOUND_EXCEPTION_MSG);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifactProviders();\n+    }\n+\n+    @Override\n+    public Map<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    @Getter\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<ArtifactProvider> artifactProviders;\n+\n+        private final Map<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle    Map of all lifecycle configurations\n+         * @param artifacts Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires     Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") HashMap<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifacts,\n+                                             @JsonProperty(\"dependencies\") HashMap<String, String> dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: This is temporary, Migrate to deserializing artifact providers directly\n+            if (artifacts == null) {\n+                this.artifactProviders = Collections.emptySet();\n+            } else {\n+                HashSet<ArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifacts) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }", "originalCommit": "b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4OTI1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382889259", "bodyText": "Yes, I didn't want to spend effort into coming up with keywords for this particular PR. This will likely move to it's own parser class in a follow up PR.", "author": "chaurah", "createdAt": "2020-02-22T05:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NzcyOA=="}], "type": "inlineReview"}, {"oid": "0526e84183a351199ecc1d79f8b5070fe2deaa8b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0526e84183a351199ecc1d79f8b5070fe2deaa8b", "message": "Add Package Model, Package Recipe schema model and Semver based versioning", "committedDate": "2020-02-23T18:59:19Z", "type": "commit"}, {"oid": "bde7133f31ef31550061f7a161c92a05042160a3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bde7133f31ef31550061f7a161c92a05042160a3", "message": "Upload coverage report first to debug failure", "committedDate": "2020-02-23T18:59:19Z", "type": "commit"}, {"oid": "9d37088b1a518fb49f55e31e745617bb60000676", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9d37088b1a518fb49f55e31e745617bb60000676", "message": "Add a test for Constants to get around cobertura issue", "committedDate": "2020-02-23T18:59:19Z", "type": "commit"}, {"oid": "68119a3357d78e294bdbfedc3783deb63615324e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/68119a3357d78e294bdbfedc3783deb63615324e", "message": "Add LocalArtifactProvider impl to avoid Covertura issues", "committedDate": "2020-02-23T18:59:19Z", "type": "commit"}, {"oid": "68119a3357d78e294bdbfedc3783deb63615324e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/68119a3357d78e294bdbfedc3783deb63615324e", "message": "Add LocalArtifactProvider impl to avoid Covertura issues", "committedDate": "2020-02-23T18:59:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzODY5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r383038696", "bodyText": "I think there are no strong reason to have another level of indentation now. The template versioning problem can be solved by the other way. Adding this config tab is especially not necessary when thinking from customer point of view.", "author": "wikimonkey", "createdAt": "2020-02-23T21:09:15Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+@EqualsAndHashCode(onlyExplicitlyIncluded = true)\n+public class PackageRecipe {\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @EqualsAndHashCode.Include\n+    private final String packageName;\n+\n+    @EqualsAndHashCode.Include\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;", "originalCommit": "68119a3357d78e294bdbfedc3783deb63615324e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1MDAzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r383050032", "bodyText": "Discussed offline, this will be addressed in followup PR, resolving", "author": "chaurah", "createdAt": "2020-02-23T23:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzODY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzODg0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r383038841", "bodyText": "Like we have discussed, model shouldn't decide handlers. Using applicable artifact provider to process artifact is controlling logic. Can we return artifacts instead of artifact provider?", "author": "wikimonkey", "createdAt": "2020-02-23T21:11:27Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+@EqualsAndHashCode(onlyExplicitlyIncluded = true)\n+public class PackageRecipe {\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @EqualsAndHashCode.Include\n+    private final String packageName;\n+\n+    @EqualsAndHashCode.Include\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public PackageRecipe(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                         @JsonProperty(\"PackageName\") String packageName,\n+                         @JsonProperty(\"Version\") Semver packageVersion,\n+                         @JsonProperty(\"Description\") String description,\n+                         @JsonProperty(\"Publisher\") String publisher,\n+                         @JsonProperty(\"Config\") PackageConfigFormat config) throws SemverException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        //TODO: Figure out how to do this in deserialize (only option so far seems to be custom deserializer)\n+        this.packageVersion = new Semver(packageVersion.toString(), Semver.SemverType.NPM);\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.config =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifactProviders() {", "originalCommit": "68119a3357d78e294bdbfedc3783deb63615324e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1MDA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r383050041", "bodyText": "Discussed offline, this will be addressed in followup PR, resolving", "author": "chaurah", "createdAt": "2020-02-23T23:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzODg0MQ=="}], "type": "inlineReview"}]}