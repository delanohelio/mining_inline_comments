{"pr_number": 339, "pr_title": "Set up Kernel alts and deployments directories", "pr_createdAt": "2020-07-30T05:41:33Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339", "timeline": [{"oid": "7a62a1eb58ea8f1743d3906e55ddc5f6d22d82da", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7a62a1eb58ea8f1743d3906e55ddc5f6d22d82da", "message": "Kernel can detect and resume persisted deployment on launch", "committedDate": "2020-07-30T18:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMzA4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463233086", "bodyText": "Do you need to move kernel state out of BOOTSTRAP? otherwise it will keep restarting kernel", "author": "ShirleyZheng92", "createdAt": "2020-07-30T19:50:12Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,8 +162,34 @@ public Kernel launch() {\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                BootstrapManager bootstrapManager = context.get(BootstrapManager.class);\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                        kernelAlts.prepareActivation();", "originalCommit": "7a62a1eb58ea8f1743d3906e55ddc5f6d22d82da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI0MDMzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463240333", "bodyText": "kernelAlts.prepareActivation() should update the directory layout which indicates the state", "author": "hui-yang", "createdAt": "2020-07-30T20:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMzA4Ng=="}], "type": "inlineReview"}, {"oid": "52d911ec07fa590e778c66ff6200b4f60ebcb97f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/52d911ec07fa590e778c66ff6200b4f60ebcb97f", "message": "Kernel can detect and resume persisted deployment on launch", "committedDate": "2020-07-30T21:51:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg2NTg2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463865860", "bodyText": "NIT: I feel we can have currentDeployment as a field of the DeploymentDirectoryManager, so that we don't need to pass Deployment around in Activator", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:03:45Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4OTAxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466089019", "bodyText": "Discussed offline. Will not make this change for now. Open for refactor later", "author": "hui-yang", "createdAt": "2020-08-06T01:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg2NTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg2NjM3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463866379", "bodyText": "I'd prefer rename to persistDeploymentFailureInPrevious()", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:05:37Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param deploymentId the last deployment ID\n+     */\n+    public void persistPreviousDeploymentFailure(String deploymentId) {", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3MTUxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463871515", "bodyText": "Can we put deploymentDirManager in deploymentStatusKeeper?", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:25:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -229,20 +232,20 @@ private void finishCurrentDeployment() throws InterruptedException {\n                         }\n                     });\n                     deploymentGroupTopics.replaceAndWait(deploymentGroupToRootPackages);\n-                    deploymentStatusKeeper\n-                            .persistAndPublishDeploymentStatus(currentDeploymentTaskMetadata.getDeploymentId(),\n-                                    currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.SUCCEEDED,\n-                                    statusDetails);\n+                    deploymentStatusKeeper.persistAndPublishDeploymentStatus(deploymentId,\n+                            currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.SUCCEEDED,\n+                            statusDetails);\n+                    deploymentDirectoryManager.persistPreviousDeploymentSuccess(deploymentId);\n                 } else {\n                     if (result.getFailureCause() != null) {\n                         statusDetails.put(\"deployment-failure-cause\", result.getFailureCause().toString());\n                     }\n                     //TODO: Update the groupToRootPackages mapping in config for the case where there is no rollback\n                     // and now the packages deployed for the current group are not the same as before starting\n                     // deployment\n-                    deploymentStatusKeeper\n-                            .persistAndPublishDeploymentStatus(currentDeploymentTaskMetadata.getDeploymentId(),\n-                                    currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.FAILED, statusDetails);\n+                    deploymentStatusKeeper.persistAndPublishDeploymentStatus(deploymentId,\n+                            currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.FAILED, statusDetails);\n+                    deploymentDirectoryManager.persistPreviousDeploymentFailure(deploymentId);", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4OTExOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466089118", "bodyText": "Discussed offline. Will not make this change for now. Open for refactor later", "author": "hui-yang", "createdAt": "2020-08-06T01:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3MTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3NDg3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463874870", "bodyText": "Maybe have deploymentId as a parameter? In this case you don't need to have the null check on path", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:39:19Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java", "diffHunk": "@@ -5,121 +5,97 @@\n \n package com.aws.iot.evergreen.deployment.activator;\n \n-import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelAlternatives;\n import com.aws.iot.evergreen.kernel.KernelLifecycle;\n \n import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n import javax.inject.Inject;\n \n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n \n /**\n  * Activation and rollback of Kernel update deployments.\n  */\n public class KernelUpdateActivator extends DeploymentActivator {\n     private final BootstrapManager bootstrapManager;\n+    private final KernelAlternatives kernelAlternatives;\n \n     @Inject\n     protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n         super(kernel);\n         this.bootstrapManager = bootstrapManager;\n+        this.kernelAlternatives = kernel.getContext().get(KernelAlternatives.class);\n     }\n \n     @Override\n     public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n-                         CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n+                         CompletableFuture<DeploymentResult> totallyCompleteFuture, Deployment deployment) {\n         String deploymentId = deploymentDocument.getDeploymentId();\n         if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n             return;\n         }\n \n         // Wait for all services to close\n-        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(30);\n         kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n         try {\n-            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n-            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n-                    deploymentId.replace(':', '.').replace('/', '+')));\n-            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n+            deploymentDirectoryManager.takeSnapshot(deploymentDirectoryManager.getTargetConfigFilePath(deploymentId));\n+            bootstrapManager.setPersistedTaskFilePath(\n+                    deploymentDirectoryManager.getBootstrapTaskFilePath(deploymentId));\n+            bootstrapManager.persistBootstrapTaskList();", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f514b89021436f7a8d5fe90092ae1bd5864cdab4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f514b89021436f7a8d5fe90092ae1bd5864cdab4", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-06T01:20:51Z", "type": "forcePushed"}, {"oid": "3b8741f936f219916cf14cb46fcc915506e4f881", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b8741f936f219916cf14cb46fcc915506e4f881", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-06T01:33:32Z", "type": "forcePushed"}, {"oid": "f131cdb878da07acfd3658f3c7952189f221869f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f131cdb878da07acfd3658f3c7952189f221869f", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-06T19:23:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3MzQyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466673421", "bodyText": "The function just follow the symlink delete the path recursively, and it's not referring to kernelAltPath. I'd prefer remove this function and have the logic in invoker.", "author": "ShirleyZheng92", "createdAt": "2020-08-06T20:39:58Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -111,36 +130,39 @@ public void prepareRollback() throws IOException {\n      */\n     public void rollbackCompletes() throws IOException {\n         cleanupAltDir(previousFailureDir);\n-        Files.move(brokenDir, previousFailureDir, ATOMIC_MOVE);\n+        Files.createSymbolicLink(previousFailureDir, Files.readSymbolicLink(brokenDir).toAbsolutePath());\n+        Files.deleteIfExists(brokenDir);\n     }\n \n     /**\n      * Set up files and directories in order to run bootstrap steps before activating new Kernel configuration.\n      *\n+     * @param deploymentId deployment ID which associates with the bootstrap task list\n      * @throws IOException if file or directory changes fail\n      */\n-    public void prepareBootstrap() throws IOException {\n-        Files.copy(currentDir, tmpDir);\n-        Files.move(tmpDir, newDir, ATOMIC_MOVE);\n+    public void prepareBootstrap(String deploymentId) throws IOException {\n+        logger.atInfo().log(\"Setting up launch directory for new Kernel\");\n+        Path newLaunchDir = altsDir.resolve(getSafeFileName(deploymentId)).toAbsolutePath();\n+        Path existingLaunchDir = Files.readSymbolicLink(currentDir).toAbsolutePath();\n+        copyFolderRecursively(existingLaunchDir, newLaunchDir, REPLACE_EXISTING, NOFOLLOW_LINKS, COPY_ATTRIBUTES);\n+        Files.deleteIfExists(oldDir);\n+        Files.createSymbolicLink(oldDir, existingLaunchDir);\n+        Files.deleteIfExists(currentDir);\n+        Files.createSymbolicLink(currentDir, newLaunchDir);\n+        logger.atInfo().log(\"Finish setup of launch directory for new Kernel\");\n     }\n \n     /**\n      * Clean up files and directories, and remove symlink references.\n      *\n      * @param path file path to cleanup\n+     * @throws IOException if unable to delete\n      */\n-    public void cleanupAltDir(Path path) {\n-        // TODO: delete files and symlinks and then remove dir\n-    }\n-\n-    /**\n-     * Load information of the deployment to resume.\n-     *\n-     * @return Deployment\n-     */\n-    public Deployment loadPersistedDeployment() {\n-        // TODO: read deployment directory\n-        // return new Deployment(DeploymentType deploymentType, String id, DeploymentStage stage)\n-        return null;\n+    public void cleanupAltDir(Path path) throws IOException {", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4OTQxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466689418", "bodyText": "I can update the method name and make it private. It still can be reused in a few places.", "author": "hui-yang", "createdAt": "2020-08-06T21:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3MzQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTMxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466675310", "bodyText": "Should previousSuccess be under deployments/ instead of alts/ dir ?", "author": "ShirleyZheng92", "createdAt": "2020-08-06T20:43:55Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,51 +5,68 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n     private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n     private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n     @Getter\n     private Path currentDir;\n-    @Getter\n-    private Path newDir;\n-    @Getter\n-    private Path tmpDir;\n+    // Symlink to the old launch directory during kernel update\n     @Getter\n     private Path oldDir;\n+    // Symlink to the broken new launch directory during kernel update\n     @Getter\n     private Path brokenDir;\n-\n+    // Symlink to the previous working launch directory after kernel update\n     private final Path previousSuccessDir;\n+    // Symlink to the broken new launch directory after rollback from kernel update\n     private final Path previousFailureDir;\n \n+    private final BootstrapManager bootstrapManager;\n+    private final DeploymentDirectoryManager deploymentDirectoryManager;\n+\n     /**\n      * Constructor for KernelAlternatives, which manages the alternative launch directory of Kernel.\n      *\n+     * @param bootstrapManager BootstrapManager instance to manage pending bootstrap tasks\n+     * @param deploymentDirectoryManager DeploymentDirectoryManager instance to manage persisted deployment information\n      * @param kernelAltsPath alternative launch directory of Kernel\n      */\n-    public KernelAlternatives(Path kernelAltsPath) {\n-        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR);\n-        this.newDir = kernelAltsPath.resolve(NEW_DIR);\n-        this.tmpDir = kernelAltsPath.resolve(TMP_DIR);\n-        this.oldDir = kernelAltsPath.resolve(OLD_DIR);\n-        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR);\n-        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR);\n-        this.previousFailureDir = kernelAltsPath.resolve(PREVIOUS_FAILURE_DIR);\n+    public KernelAlternatives(BootstrapManager bootstrapManager, DeploymentDirectoryManager deploymentDirectoryManager,\n+                              Path kernelAltsPath) {\n+        this.altsDir = kernelAltsPath.toAbsolutePath();\n+        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR).toAbsolutePath();\n+        this.oldDir = kernelAltsPath.resolve(OLD_DIR).toAbsolutePath();\n+        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR).toAbsolutePath();\n+        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR).toAbsolutePath();", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4ODU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466688593", "bodyText": "right now I have a previous pointer in both directory. The points are slightly different in that previous deployment cover all types of deployments. previous launch dir only points to the last deployment with bootstraps", "author": "hui-yang", "createdAt": "2020-08-06T21:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MjEyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466682125", "bodyText": "NIT: Add a log showing unable to roll back", "author": "ShirleyZheng92", "createdAt": "2020-08-06T20:57:28Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -96,12 +114,13 @@ public void activationSucceeds() throws IOException {\n      * @throws IOException if file or directory changes fail\n      */\n     public void prepareRollback() throws IOException {\n-        if (newDir.toFile().exists()) {\n-            Files.move(newDir, brokenDir, ATOMIC_MOVE);\n+        if (!Files.exists(oldDir)) {\n             return;", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4NDI5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466684297", "bodyText": "Is this trying to clean up the unpacked artifacts of previous kernel? If so this logic should be in DeploymentService", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:01:59Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -87,7 +104,8 @@ public void prepareActivation() throws IOException {\n     public void activationSucceeds() throws IOException {\n         cleanupAltDir(previousSuccessDir);", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTY3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466691679", "bodyText": "Replied above. Both deployments dir and alts dir have previous links. It might be confusing. I'm open to suggestions.", "author": "hui-yang", "createdAt": "2020-08-06T21:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4NDI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NTQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466695439", "bodyText": "symlink is a single file, Are we trying to follow down the symlink and delete the actual files? If not maybe just use File.delete?", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:26:42Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn the last deployment ID\n+     */\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n+    }\n+\n+    /**\n+     * Persist the directory for the last successful deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     */\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n+            if (Files.isSymbolicLink(symlink)) {\n+                Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n+            }\n+            Utils.deleteFileRecursively(symlink.toFile());", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMjY5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466702694", "bodyText": "Yes. I want to use this chance to clean up the actual files, before we have other mechanisms for cleanup.", "author": "hui-yang", "createdAt": "2020-08-06T21:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NTQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2MzgwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466763808", "bodyText": "I didn't understand the question earlier. Yes, this is just a symlink and this delete will follow the link, which is same as File.delete", "author": "hui-yang", "createdAt": "2020-08-07T01:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NTQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjM5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466696396", "bodyText": "Will this follow the ongoingDir symlink and remove files in the symlink?", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:28:55Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn the last deployment ID\n+     */\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n+    }\n+\n+    /**\n+     * Persist the directory for the last successful deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     */\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n+            if (Files.isSymbolicLink(symlink)) {\n+                Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n+            }\n+            Utils.deleteFileRecursively(symlink.toFile());\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atWarn().kv(\"fleetConfigArn\", fleetConfigArn).log(\n+                    \"Unable to preserve artifacts from the last deployment\");\n+        }\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(String fleetConfigArn, Deployment deployment) throws IOException {\n+        Path filePath = getDeploymentMetadataFilePath(fleetConfigArn);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(Deployment deployment) throws IOException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    private void writeDeploymentMetadata(Path filePath, Deployment deployment) throws IOException {\n+        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(filePath))) {\n+            out.writeObject(deployment);\n+        }\n+    }\n+\n+    /**\n+     * Read Deployment object from file.\n+     *\n+     * @return deployment object\n+     * @throws IOException on I/O error\n+     * @throws ClassNotFoundException when deserialization fails\n+     */\n+    public Deployment readDeploymentMetadata() throws IOException, ClassNotFoundException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(filePath))) {\n+            return (Deployment) in.readObject();\n+        }\n+    }\n+\n+    /**\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment.\n+     *\n+     * @param filepath File path to the config snapshot\n+     * @throws IOException if write fails\n+     */\n+    public void takeSnapshot(Path filepath) throws IOException {\n+        kernel.writeEffectiveConfigAsTransactionLog(filepath);\n+    }\n+\n+    /**\n+     * Resolve snapshot file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to snapshot file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getSnapshotFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(ROLLBACK_SNAPSHOT_FILE);\n+    }\n+\n+    /**\n+     * Resolve target config file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to target config file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getTargetConfigFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(TARGET_CONFIG_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list of an ongoing deployment.\n+     *\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath() throws IOException {\n+        return Files.readSymbolicLink(ongoingDir).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted deployment metadata.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getDeploymentMetadataFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(DEPLOYMENT_METADATA_FILE);\n+    }\n+\n+    private Path getDeploymentDirectoryPath(String fleetConfigArn) throws IOException {\n+        return createNewDeploymentDirectoryIfNotExists(fleetConfigArn);\n+    }\n+\n+    private Path createNewDeploymentDirectoryIfNotExists(String fleetConfigArn) throws IOException {\n+        Path path = deploymentsDir.resolve(getSafeFileName(fleetConfigArn));\n+        if (Files.exists(path) && Files.isDirectory(path)) {\n+            return path;\n+        }\n+        if (Files.isRegularFile(path)) {\n+            Files.delete(path);\n+        }\n+        Utils.createPaths(path);\n+        Utils.deleteFileRecursively(ongoingDir.toFile());", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMzE3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466703170", "bodyText": "Yes. If ongoing dir exists at this point, then something went wrong. Not sure what's the right thing to do.", "author": "hui-yang", "createdAt": "2020-08-06T21:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2NDAyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466764027", "bodyText": "regarding deleteFileRecursively on a symlink, same as above", "author": "hui-yang", "createdAt": "2020-08-07T01:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466700041", "bodyText": "This function always symlink the fleetConfigArn to 'ongoingDir' . It might be confusing. Eg: in persistLastSuccessfulDeployment(deploymentId) , the deployment is finished and the expected behavior is 'ongoingDir' will be deleted after a successful deployment. Also, in DefaultDeployment, this class is not used in creating/performing the deployment and thus the 'ongoingDir' is not created when the deployment is actually happening.\nI'd prefer separate out a function setCurrentDeploymentPath(deploymentId) , and have DeploymentService invoke that explicitly on construction.", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:37:34Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn the last deployment ID\n+     */\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n+    }\n+\n+    /**\n+     * Persist the directory for the last successful deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     */\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n+            if (Files.isSymbolicLink(symlink)) {\n+                Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n+            }\n+            Utils.deleteFileRecursively(symlink.toFile());\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atWarn().kv(\"fleetConfigArn\", fleetConfigArn).log(\n+                    \"Unable to preserve artifacts from the last deployment\");\n+        }\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(String fleetConfigArn, Deployment deployment) throws IOException {\n+        Path filePath = getDeploymentMetadataFilePath(fleetConfigArn);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(Deployment deployment) throws IOException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    private void writeDeploymentMetadata(Path filePath, Deployment deployment) throws IOException {\n+        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(filePath))) {\n+            out.writeObject(deployment);\n+        }\n+    }\n+\n+    /**\n+     * Read Deployment object from file.\n+     *\n+     * @return deployment object\n+     * @throws IOException on I/O error\n+     * @throws ClassNotFoundException when deserialization fails\n+     */\n+    public Deployment readDeploymentMetadata() throws IOException, ClassNotFoundException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(filePath))) {\n+            return (Deployment) in.readObject();\n+        }\n+    }\n+\n+    /**\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment.\n+     *\n+     * @param filepath File path to the config snapshot\n+     * @throws IOException if write fails\n+     */\n+    public void takeSnapshot(Path filepath) throws IOException {\n+        kernel.writeEffectiveConfigAsTransactionLog(filepath);\n+    }\n+\n+    /**\n+     * Resolve snapshot file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to snapshot file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getSnapshotFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(ROLLBACK_SNAPSHOT_FILE);\n+    }\n+\n+    /**\n+     * Resolve target config file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to target config file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getTargetConfigFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(TARGET_CONFIG_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list of an ongoing deployment.\n+     *\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath() throws IOException {\n+        return Files.readSymbolicLink(ongoingDir).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted deployment metadata.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getDeploymentMetadataFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(DEPLOYMENT_METADATA_FILE);\n+    }\n+\n+    private Path getDeploymentDirectoryPath(String fleetConfigArn) throws IOException {\n+        return createNewDeploymentDirectoryIfNotExists(fleetConfigArn);\n+    }\n+\n+    private Path createNewDeploymentDirectoryIfNotExists(String fleetConfigArn) throws IOException {\n+        Path path = deploymentsDir.resolve(getSafeFileName(fleetConfigArn));\n+        if (Files.exists(path) && Files.isDirectory(path)) {\n+            return path;\n+        }\n+        if (Files.isRegularFile(path)) {\n+            Files.delete(path);\n+        }\n+        Utils.createPaths(path);\n+        Utils.deleteFileRecursively(ongoingDir.toFile());\n+        Files.createSymbolicLink(ongoingDir, path);", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNDE5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466704197", "bodyText": "Right now it's implicitly created when a deployment requires the rollback tlog. For those disabling rollback, this directory is not set up.\nDo you suggest always create a deployment dir in the beginning of the process? Just note, sometimes there can be nothing in the directory", "author": "hui-yang", "createdAt": "2020-08-06T21:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDA0MQ=="}], "type": "inlineReview"}, {"oid": "0348cb960fb896687d80c64149626a5ab454a276", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0348cb960fb896687d80c64149626a5ab454a276", "message": "Add unit tests and address comments", "committedDate": "2020-08-07T02:19:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NzcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467257704", "bodyText": "Why need getter on these fields , they are already in context right?", "author": "ShirleyZheng92", "createdAt": "2020-08-07T20:37:44Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelCommandLine.java", "diffHunk": "@@ -39,6 +42,13 @@\n \n     private final Kernel kernel;\n \n+    @Getter(AccessLevel.PACKAGE)\n+    private DeploymentDirectoryManager deploymentDirectoryManager;\n+    @Getter(AccessLevel.PACKAGE)\n+    private KernelAlternatives kernelAlternatives;\n+    @Getter(AccessLevel.PACKAGE)\n+    private BootstrapManager bootstrapManager;\n+", "originalCommit": "ab0a2124f94f8f8b19d7aae2c394615de315ca38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MDI5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467260298", "bodyText": "Yeah. I'm using these to unit test kernel launch. It's possible to stub these out if they are fields here or in Kernel class", "author": "hui-yang", "createdAt": "2020-08-07T20:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NzcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1ODM4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467258380", "bodyText": "NIT: use setupLinkToDirectory() ?", "author": "ShirleyZheng92", "createdAt": "2020-08-07T20:39:20Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -110,37 +116,39 @@ public void prepareRollback() throws IOException {\n      * @throws IOException if file or directory changes fail\n      */\n     public void rollbackCompletes() throws IOException {\n-        cleanupAltDir(previousFailureDir);\n-        Files.move(brokenDir, previousFailureDir, ATOMIC_MOVE);\n+        if (!Files.exists(brokenDir)) {\n+            return;\n+        }\n+        Utils.deleteFileRecursively(Files.readSymbolicLink(brokenDir).toFile());\n+        Files.delete(brokenDir);\n     }\n \n     /**\n      * Set up files and directories in order to run bootstrap steps before activating new Kernel configuration.\n      *\n+     * @param deploymentId deployment ID which associates with the bootstrap task list\n      * @throws IOException if file or directory changes fail\n      */\n-    public void prepareBootstrap() throws IOException {\n-        Files.copy(currentDir, tmpDir);\n-        Files.move(tmpDir, newDir, ATOMIC_MOVE);\n-    }\n-\n-    /**\n-     * Clean up files and directories, and remove symlink references.\n-     *\n-     * @param path file path to cleanup\n-     */\n-    public void cleanupAltDir(Path path) {\n-        // TODO: delete files and symlinks and then remove dir\n+    public void prepareBootstrap(String deploymentId) throws IOException {\n+        logger.atInfo().log(\"Setting up launch directory for new Kernel\");\n+        Path newLaunchDir = altsDir.resolve(getSafeFileName(deploymentId)).toAbsolutePath();\n+        Path existingLaunchDir = Files.readSymbolicLink(currentDir).toAbsolutePath();\n+        copyFolderRecursively(existingLaunchDir, newLaunchDir, REPLACE_EXISTING, NOFOLLOW_LINKS, COPY_ATTRIBUTES);\n+        Files.deleteIfExists(oldDir);\n+        Files.createSymbolicLink(oldDir, existingLaunchDir);", "originalCommit": "ab0a2124f94f8f8b19d7aae2c394615de315ca38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1ODU1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467258551", "bodyText": "NIT: use setupLinkToDirectory()?", "author": "ShirleyZheng92", "createdAt": "2020-08-07T20:39:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -96,12 +100,14 @@ public void activationSucceeds() throws IOException {\n      * @throws IOException if file or directory changes fail\n      */\n     public void prepareRollback() throws IOException {\n-        if (newDir.toFile().exists()) {\n-            Files.move(newDir, brokenDir, ATOMIC_MOVE);\n+        if (!Files.exists(oldDir)) {\n+            logger.atWarn().log(\"Cannot find the old launch directory to rollback to.\");\n             return;\n         }\n-        Files.move(currentDir, brokenDir, ATOMIC_MOVE);\n-        Files.move(oldDir, currentDir, ATOMIC_MOVE);\n+        Files.deleteIfExists(brokenDir);\n+        Files.createSymbolicLink(brokenDir, Files.readSymbolicLink(currentDir).toAbsolutePath());", "originalCommit": "ab0a2124f94f8f8b19d7aae2c394615de315ca38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64dbb767604430a84606b3d42a79e883c565d0ff", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/64dbb767604430a84606b3d42a79e883c565d0ff", "message": "Address comments and rebase", "committedDate": "2020-08-07T20:53:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NDUzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468054536", "bodyText": "I still feel that deploymentService should handle the cleaning up of unused package artifacts", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:12:00Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,89 +5,93 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n-    private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n-    private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n-    @Getter\n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n+    @Getter(AccessLevel.MODULE)\n     private Path currentDir;\n-    @Getter\n-    private Path newDir;\n-    @Getter\n-    private Path tmpDir;\n-    @Getter\n+    // Symlink to the old launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path oldDir;\n-    @Getter\n+    // Symlink to the broken new launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path brokenDir;\n \n-    private final Path previousSuccessDir;\n-    private final Path previousFailureDir;\n-\n     /**\n      * Constructor for KernelAlternatives, which manages the alternative launch directory of Kernel.\n      *\n      * @param kernelAltsPath alternative launch directory of Kernel\n      */\n     public KernelAlternatives(Path kernelAltsPath) {\n-        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR);\n-        this.newDir = kernelAltsPath.resolve(NEW_DIR);\n-        this.tmpDir = kernelAltsPath.resolve(TMP_DIR);\n-        this.oldDir = kernelAltsPath.resolve(OLD_DIR);\n-        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR);\n-        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR);\n-        this.previousFailureDir = kernelAltsPath.resolve(PREVIOUS_FAILURE_DIR);\n+        this.altsDir = kernelAltsPath.toAbsolutePath();\n+        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR).toAbsolutePath();\n+        this.oldDir = kernelAltsPath.resolve(OLD_DIR).toAbsolutePath();\n+        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR).toAbsolutePath();\n     }\n \n     /**\n      * Determine if Kernel is in update workflow from deployments and return deployment stage.\n      *\n+     * @param bootstrapManager BootstrapManager instance to manage pending bootstrap tasks\n+     * @param deploymentDirectoryManager DeploymentDirectoryManager instance to manage persisted deployment information\n      * @return DeploymentStage\n      */\n-    public Deployment.DeploymentStage determineDeploymentStage() {\n+    public Deployment.DeploymentStage determineDeploymentStage(BootstrapManager bootstrapManager,\n+                                                               DeploymentDirectoryManager deploymentDirectoryManager) {\n         // TODO: validate if any directory is corrupted\n-        if (newDir.toFile().exists()) {\n-            return Deployment.DeploymentStage.BOOTSTRAP;\n-        } else if (oldDir.toFile().exists()) {\n+        if (oldDir.toFile().exists()) {\n+            try {\n+                Path persistedBootstrapTasks = deploymentDirectoryManager.getBootstrapTaskFilePath();\n+                if (!persistedBootstrapTasks.toFile().exists()) {\n+                    return Deployment.DeploymentStage.KERNEL_ACTIVATION;\n+                }\n+                bootstrapManager.loadBootstrapTaskList(persistedBootstrapTasks);\n+                if (bootstrapManager.hasNext()) {\n+                    return Deployment.DeploymentStage.BOOTSTRAP;\n+                }\n+            } catch (IOException | ClassNotFoundException e) {\n+                logger.atWarn().setCause(e).log(\"Bootstrap task list not found or unable to read the file\");\n+            }\n             return Deployment.DeploymentStage.KERNEL_ACTIVATION;\n         } else if (brokenDir.toFile().exists()) {\n             return Deployment.DeploymentStage.KERNEL_ROLLBACK;\n         }\n         return Deployment.DeploymentStage.DEFAULT;\n     }\n \n-    /**\n-     * Set up files and directories in order to flip Kernel to a new instance with new configuration.\n-     *\n-     * @throws IOException if file or directory changes fail\n-     */\n-    public void prepareActivation() throws IOException {\n-        Files.move(currentDir, oldDir, ATOMIC_MOVE);\n-        Files.move(newDir, currentDir, ATOMIC_MOVE);\n-    }\n-\n     /**\n      * Clean up files and directories if Kernel update deployments succeeds.\n      *\n      * @throws IOException if file or directory changes fail\n      */\n     public void activationSucceeds() throws IOException {\n-        cleanupAltDir(previousSuccessDir);\n-        cleanupAltDir(previousFailureDir);\n-        Files.move(oldDir, previousSuccessDir, ATOMIC_MOVE);\n+        Utils.deleteFileRecursively(Files.readSymbolicLink(oldDir).toFile());", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2OTYyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468069621", "bodyText": "I believe this should be handled by some logic in local component store. In the kernel case, it might be ok to clean up here as long as we can make sure current does not point to the same artifacts. But we cannot do that for other components here.", "author": "hui-yang", "createdAt": "2020-08-10T17:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NDUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NTQzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468055437", "bodyText": "Log error?", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:13:31Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,89 +5,93 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n-    private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n-    private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n-    @Getter\n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n+    @Getter(AccessLevel.MODULE)\n     private Path currentDir;\n-    @Getter\n-    private Path newDir;\n-    @Getter\n-    private Path tmpDir;\n-    @Getter\n+    // Symlink to the old launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path oldDir;\n-    @Getter\n+    // Symlink to the broken new launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path brokenDir;\n \n-    private final Path previousSuccessDir;\n-    private final Path previousFailureDir;\n-\n     /**\n      * Constructor for KernelAlternatives, which manages the alternative launch directory of Kernel.\n      *\n      * @param kernelAltsPath alternative launch directory of Kernel\n      */\n     public KernelAlternatives(Path kernelAltsPath) {\n-        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR);\n-        this.newDir = kernelAltsPath.resolve(NEW_DIR);\n-        this.tmpDir = kernelAltsPath.resolve(TMP_DIR);\n-        this.oldDir = kernelAltsPath.resolve(OLD_DIR);\n-        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR);\n-        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR);\n-        this.previousFailureDir = kernelAltsPath.resolve(PREVIOUS_FAILURE_DIR);\n+        this.altsDir = kernelAltsPath.toAbsolutePath();\n+        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR).toAbsolutePath();\n+        this.oldDir = kernelAltsPath.resolve(OLD_DIR).toAbsolutePath();\n+        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR).toAbsolutePath();\n     }\n \n     /**\n      * Determine if Kernel is in update workflow from deployments and return deployment stage.\n      *\n+     * @param bootstrapManager BootstrapManager instance to manage pending bootstrap tasks\n+     * @param deploymentDirectoryManager DeploymentDirectoryManager instance to manage persisted deployment information\n      * @return DeploymentStage\n      */\n-    public Deployment.DeploymentStage determineDeploymentStage() {\n+    public Deployment.DeploymentStage determineDeploymentStage(BootstrapManager bootstrapManager,\n+                                                               DeploymentDirectoryManager deploymentDirectoryManager) {\n         // TODO: validate if any directory is corrupted\n-        if (newDir.toFile().exists()) {\n-            return Deployment.DeploymentStage.BOOTSTRAP;\n-        } else if (oldDir.toFile().exists()) {\n+        if (oldDir.toFile().exists()) {\n+            try {\n+                Path persistedBootstrapTasks = deploymentDirectoryManager.getBootstrapTaskFilePath();\n+                if (!persistedBootstrapTasks.toFile().exists()) {\n+                    return Deployment.DeploymentStage.KERNEL_ACTIVATION;\n+                }\n+                bootstrapManager.loadBootstrapTaskList(persistedBootstrapTasks);\n+                if (bootstrapManager.hasNext()) {\n+                    return Deployment.DeploymentStage.BOOTSTRAP;\n+                }\n+            } catch (IOException | ClassNotFoundException e) {\n+                logger.atWarn().setCause(e).log(\"Bootstrap task list not found or unable to read the file\");", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NjIxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468056217", "bodyText": "Log error?", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:15:05Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -333,6 +339,12 @@ private void createNewDeployment(Deployment deployment) {\n         }\n         deploymentStatusKeeper.persistAndPublishDeploymentStatus(deployment.getId(), deployment.getDeploymentType(),\n                 JobStatus.IN_PROGRESS, new HashMap<>());\n+        try {\n+            deploymentDirectoryManager.createNewDeploymentDirectoryIfNotExists(\n+                    deployment.getDeploymentDocumentObj().getDeploymentId());\n+        } catch (IOException ioException) {\n+            logger.atWarn().log(\"Unable to create deployment directory\", ioException);", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NzI4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468057287", "bodyText": "Log error?", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:16:59Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {\n+        persistPointerToLastFinishedDeployment(previousFailureDir);\n+    }\n+\n+    /**\n+     * Persist the last successful deployment and clean up earlier deployments.\n+     */\n+    public void persistLastSuccessfulDeployment() {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath();\n+            cleanupPreviousDeployments(previousSuccessDir);\n+            cleanupPreviousDeployments(previousFailureDir);\n+\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atWarn().log(\"Unable to preserve artifacts from the last deployment\");", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-10T17:40:46Z", "type": "commit"}, {"oid": "5a9aa51ebb9ed6a29e351b433162c43310cc0e16", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5a9aa51ebb9ed6a29e351b433162c43310cc0e16", "message": "Add unit tests and address comments", "committedDate": "2020-08-10T17:40:46Z", "type": "commit"}, {"oid": "18a78f0097b622d1275b99d5017afee7fd8f7d89", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/18a78f0097b622d1275b99d5017afee7fd8f7d89", "message": "Address comments and rebase", "committedDate": "2020-08-10T17:40:46Z", "type": "commit"}, {"oid": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "message": "Rebase and address comments", "committedDate": "2020-08-10T17:42:24Z", "type": "commit"}, {"oid": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "message": "Rebase and address comments", "committedDate": "2020-08-10T17:42:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODQ0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468178446", "bodyText": "why are you changing this? \"Find or create\" is important.", "author": "MikeDombo", "createdAt": "2020-08-10T20:51:14Z", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -172,7 +172,7 @@ public Topic find(String... path) {\n      * exist, then it will return the default value provided.\n      *\n      * @param defaultV default value if the Topic was not found\n-     * @param path     String[] of node names to traverse to find or create the Topic\n+     * @param path     String[] of node names to traverse to find the Topic", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4NzM3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468187377", "bodyText": "lookup creates if missing. Find do not create if missing. Only the doc is being updated.", "author": "fahadmohammed01", "createdAt": "2020-08-10T21:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MzY0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468193648", "bodyText": "Yes. Only fixing the java doc here.", "author": "hui-yang", "createdAt": "2020-08-10T21:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODgzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468178839", "bodyText": "we don't have modules (Java 9). Use package.", "author": "MikeDombo", "createdAt": "2020-08-10T20:52:03Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTA2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468179065", "bodyText": "log the exception", "author": "MikeDombo", "createdAt": "2020-08-10T20:52:31Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {\n+        persistPointerToLastFinishedDeployment(previousFailureDir);\n+    }\n+\n+    /**\n+     * Persist the last successful deployment and clean up earlier deployments.\n+     */\n+    public void persistLastSuccessfulDeployment() {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath();\n+            cleanupPreviousDeployments(previousSuccessDir);\n+            cleanupPreviousDeployments(previousFailureDir);\n+\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468181530", "bodyText": "Why are we serializing using Java? Why not use jackson?", "author": "MikeDombo", "createdAt": "2020-08-10T20:57:17Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentDocument.java", "diffHunk": "@@ -28,7 +29,8 @@\n @ToString\n @EqualsAndHashCode\n // TODO: pull this class to a library to share with cloud services. SIM: https://sim.amazon.com/issues/P33788350\n-public class DeploymentDocument {\n+public class DeploymentDocument implements Serializable {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NTE4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468195187", "bodyText": "Will update", "author": "hui-yang", "createdAt": "2020-08-10T21:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTcyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468181729", "bodyText": "must this be public? Can it be at least package-private?", "author": "MikeDombo", "createdAt": "2020-08-10T20:57:41Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -254,8 +254,8 @@ public boolean isErrored() {\n      * @throws InterruptedException when the execution is interrupted.\n      * @throws TimeoutException     when the command execution times out.\n      */\n-    public Integer bootstrap() throws InterruptedException, TimeoutException {\n-        return null;\n+    public int bootstrap() throws InterruptedException, TimeoutException {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NTc3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468195770", "bodyText": "It's used in both Kernel.launch and deployment.bootstrap.BootstrapManager. Alternative is moving deployment.bootstrap.BootstrapManager to kernel pkg, if it's more appropriate.", "author": "hui-yang", "createdAt": "2020-08-10T21:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MjgxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468182819", "bodyText": "use PACKAGE", "author": "MikeDombo", "createdAt": "2020-08-10T20:59:54Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,89 +5,93 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n-    private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n-    private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n-    @Getter\n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n+    @Getter(AccessLevel.MODULE)", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mzc2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468183767", "bodyText": "you can use hamcrest anExistingFile, etc.", "author": "MikeDombo", "createdAt": "2020-08-10T21:01:51Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.BOOTSTRAP_TASK_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.DEPLOYMENT_METADATA_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.ROLLBACK_SNAPSHOT_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.TARGET_CONFIG_FILE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class DeploymentDirectoryManagerTest {\n+    private static final String mockArn = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:1\";\n+    private static final String expectedDirectoryName =\n+            \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.1\";\n+    @TempDir\n+    Path deploymentsDir;\n+    @Mock\n+    private Kernel kernel;\n+\n+    private DeploymentDirectoryManager deploymentDirectoryManager;\n+\n+    @BeforeEach\n+    public void beforeEach() {\n+        doReturn(deploymentsDir).when(kernel).getDeploymentsPath();\n+        deploymentDirectoryManager = new DeploymentDirectoryManager(kernel);\n+    }\n+\n+    @Test\n+    public Path WHEN_create_new_deployment_dir_THEN_setup_directory_and_symlink() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        assertTrue(Files.exists(actual));\n+        assertEquals(deploymentsDir.resolve(expectedDirectoryName), actual);\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getOngoingDir()));\n+        return actual;\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_succeeds_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousSuccessDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_fails_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousFailureDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousSuccessDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_previous_deployment_WHEN_new_deployment_finishes_THEN_cleanup_previous_deployment() throws Exception {\n+        Path actual1 = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+\n+        String mockArn2 = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:2\";\n+        String expectedDirectoryName2 =\n+                \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.2\";\n+        Path actual2 = createNewDeploymentDir(mockArn2);\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+\n+        assertFalse(Files.exists(actual1));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4NDA5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468184091", "bodyText": "What do we do when the deployment changes schema between an upgrade?", "author": "MikeDombo", "createdAt": "2020-08-10T21:02:30Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.BOOTSTRAP_TASK_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.DEPLOYMENT_METADATA_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.ROLLBACK_SNAPSHOT_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.TARGET_CONFIG_FILE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class DeploymentDirectoryManagerTest {\n+    private static final String mockArn = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:1\";\n+    private static final String expectedDirectoryName =\n+            \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.1\";\n+    @TempDir\n+    Path deploymentsDir;\n+    @Mock\n+    private Kernel kernel;\n+\n+    private DeploymentDirectoryManager deploymentDirectoryManager;\n+\n+    @BeforeEach\n+    public void beforeEach() {\n+        doReturn(deploymentsDir).when(kernel).getDeploymentsPath();\n+        deploymentDirectoryManager = new DeploymentDirectoryManager(kernel);\n+    }\n+\n+    @Test\n+    public Path WHEN_create_new_deployment_dir_THEN_setup_directory_and_symlink() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        assertTrue(Files.exists(actual));\n+        assertEquals(deploymentsDir.resolve(expectedDirectoryName), actual);\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getOngoingDir()));\n+        return actual;\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_succeeds_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousSuccessDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_fails_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousFailureDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousSuccessDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_previous_deployment_WHEN_new_deployment_finishes_THEN_cleanup_previous_deployment() throws Exception {\n+        Path actual1 = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+\n+        String mockArn2 = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:2\";\n+        String expectedDirectoryName2 =\n+                \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.2\";\n+        Path actual2 = createNewDeploymentDir(mockArn2);\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+\n+        assertFalse(Files.exists(actual1));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertEquals(actual2, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousSuccessDir()));\n+        assertEquals(deploymentsDir.resolve(expectedDirectoryName2), actual2);\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_WHEN_write_to_file_and_read_THEN_restore_deployment() throws Exception {\n+        Path actual1 = createNewDeploymentDir(mockArn);\n+        Deployment expected = new Deployment(\"mockDoc\", Deployment.DeploymentType.IOT_JOBS, \"mockId\");\n+        deploymentDirectoryManager.writeDeploymentMetadata(expected);\n+        assertTrue(Files.exists(actual1.resolve(DEPLOYMENT_METADATA_FILE)));\n+        Deployment actual = deploymentDirectoryManager.readDeploymentMetadata();\n+        assertEquals(expected, actual);", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMTgxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468201816", "bodyText": "Not handled yet. Deployment should be backward compatible. Will add to the backlog for corner cases.", "author": "hui-yang", "createdAt": "2020-08-10T21:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4NDA5MQ=="}], "type": "inlineReview"}, {"oid": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17bae15e7276a8c2452f12b4743361d53a0b5b7c", "message": "Address comments and refactor serdes", "committedDate": "2020-08-10T22:47:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjg4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468232887", "bodyText": "name persistLastFailedDeployment is kind of misleading, the funtion is actually cleaning up state of last failed deployment right?", "author": "fahadmohammed01", "createdAt": "2020-08-10T23:04:21Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0MjQ2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468242464", "bodyText": "It's cleaning up the earlier one, and mark the current (the one just finished) as lastFailed.", "author": "hui-yang", "createdAt": "2020-08-10T23:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468233674", "bodyText": "cleanupSymLinkedDirectory maybe?", "author": "fahadmohammed01", "createdAt": "2020-08-10T23:06:49Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {\n+        persistPointerToLastFinishedDeployment(previousFailureDir);\n+    }\n+\n+    /**\n+     * Persist the last successful deployment and clean up earlier deployments.\n+     */\n+    public void persistLastSuccessfulDeployment() {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath();\n+            cleanupPreviousDeployments(previousSuccessDir);\n+            cleanupPreviousDeployments(previousFailureDir);\n+\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atError().log(\"Unable to preserve artifacts from the last deployment\");\n+        }\n+    }\n+\n+    private void cleanupPreviousDeployments(Path symlink) {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}