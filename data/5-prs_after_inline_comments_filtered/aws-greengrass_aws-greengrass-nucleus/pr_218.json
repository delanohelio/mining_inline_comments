{"pr_number": 218, "pr_title": "Add safe update check into GenericExternalService", "pr_createdAt": "2020-04-29T04:08:42Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218", "timeline": [{"oid": "8e7b0be88c7d82a6018f59c9c3224698cf2589e5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8e7b0be88c7d82a6018f59c9c3224698cf2589e5", "message": "Add safe update check into GenericExternalService", "committedDate": "2020-04-29T04:14:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQxNzQyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417417426", "bodyText": "Not needed for the PR, but we need to start documenting these config names somewhere. A list of what is hardcoded at the moment and what can be configured via recipe/kernel context updates would help in the long run.", "author": "chaurah", "createdAt": "2020-04-29T15:43:28Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -37,6 +41,10 @@\n                     \"SIGIO\", \"SIGPWR\", \"SIGSYS\",};\n     private static final String SKIP_COMMAND_REGEX = \"(exists|onpath) +(.+)\";\n     private static final Pattern skipcmd = Pattern.compile(SKIP_COMMAND_REGEX);\n+    public static final String SAFE_UPDATE_TOPIC_NAME = \"safeToUpdate\";", "originalCommit": "8e7b0be88c7d82a6018f59c9c3224698cf2589e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a59f4cef186224c0ea3d8c2eefb57ac62513e12", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1a59f4cef186224c0ea3d8c2eefb57ac62513e12", "message": "Add safe update check into GenericExternalService", "committedDate": "2020-04-29T20:10:00Z", "type": "forcePushed"}, {"oid": "c6c7ff7a94da9310fda20409d11035c5bbe32003", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c6c7ff7a94da9310fda20409d11035c5bbe32003", "message": "Add safe update check into GenericExternalService", "committedDate": "2020-04-29T20:48:47Z", "type": "forcePushed"}, {"oid": "73269f56cf09035a48527085aad6c91f182e8508", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/73269f56cf09035a48527085aad6c91f182e8508", "message": "Add safe update check into GenericExternalService", "committedDate": "2020-04-29T22:51:21Z", "type": "commit"}, {"oid": "73269f56cf09035a48527085aad6c91f182e8508", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/73269f56cf09035a48527085aad6c91f182e8508", "message": "Add safe update check into GenericExternalService", "committedDate": "2020-04-29T22:51:21Z", "type": "forcePushed"}, {"oid": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ff9accd35db2b974e6d73c969bb1b56b603a37b3", "message": "Try to fix often flaky test by increasing timeout", "committedDate": "2020-04-30T00:15:37Z", "type": "commit"}, {"oid": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ff9accd35db2b974e6d73c969bb1b56b603a37b3", "message": "Try to fix often flaky test by increasing timeout", "committedDate": "2020-04-30T00:15:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2ODQ4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417768486", "bodyText": "A few questions\n\nThis is adding a single check for all of the services running, a deployment might deploy only a subset of them, why should we wait for all services to report that they are safe to update?\nIf we add a single disruption check for all services, it might effectively make the disruptionCompleted method useless? If I understand correctly it was intended to notify services that the disruption action has completed. Do we now think that there is no need to do that? Even if it is left for the future, will this change allow adding that later?\n\nLooking at the code and the deployment workflow I acknowledge that this might be difficult to do or may even be obsolete since this service was written before deployments were implemented, but have we given a thought to how this was intended to be used? My understanding was that each service can have the ability to register one disruption check and it can be removed when the service is stopped. When you want to update some set of services you can add those checks to the list in this class and the existing code will use them.", "author": "shaguptashaikh", "createdAt": "2020-04-30T05:51:32Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -36,8 +37,31 @@\n     private final Map<String, Crashable> pendingActions = new LinkedHashMap<>();\n     private final List<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n \n-    public UpdateSystemSafelyService(Topics c) {\n+    private final DisruptableCheck egServiceCheck = new DisruptableCheck() {\n+        @Override\n+        public long whenIsDisruptionOK() {\n+            return kernel.orderedDependencies().stream().mapToLong(EvergreenService::whenIsDisruptionOK).max()\n+                    .orElse(0L);\n+        }\n+\n+        @Override\n+        public void disruptionCompleted() {\n+        }\n+    };", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4ODE1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417788157", "bodyText": "Yes it is only a single check which looks through all the services. This is for 2 reasons, 1 is that the current interface of course doesn't support anything else. But the bigger reason is that until the merge is actively happening we don't actually know what services will be affected. Since the \"merge\" contains the entire config, even things that haven't changed. The other thing is that even if we did know what changed, we can't be sure than an update to 1 service won't affect another service.\n\n\nI don't see a use for the disruption completed, but if we do want it, then we can just do the same thing as the whenIsDisruptionOK; we just loop through the services and let them know that the update is done. Definitely a 2 way door.", "author": "MikeDombo", "createdAt": "2020-04-30T06:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2ODQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzMzI5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418333295", "bodyText": "Add and remove methods are public so anyone can query a service and add/remove disruption checks for services. So when we know what services are about to change during the merge, we can add disruption checks as well. But I'm fine checking all services like you have done. If that's what we want to go ahead we might as well clean up the old code and make it an individual check instead of creating a list of checks because it'll only ever be one check", "author": "shaguptashaikh", "createdAt": "2020-04-30T22:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2ODQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NjgwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418686806", "bodyText": "The problem is that we never know what services will be changing; we never have a diff, we only ever have a re-definition which goes through mergeMap. Only the config store knows what changes it makes, not what change it will make.", "author": "MikeDombo", "createdAt": "2020-05-01T18:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2ODQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc3NjI2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417776269", "bodyText": "Can we rename it to something that suggests what action it is performing? like checkIfSafeToUpdate?", "author": "shaguptashaikh", "createdAt": "2020-04-30T06:11:07Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -37,6 +40,10 @@\n                     \"SIGIO\", \"SIGPWR\", \"SIGSYS\",};\n     private static final String SKIP_COMMAND_REGEX = \"(exists|onpath) +(.+)\";\n     private static final Pattern skipcmd = Pattern.compile(SKIP_COMMAND_REGEX);\n+    public static final String SAFE_UPDATE_TOPIC_NAME = \"safeToUpdate\";", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc3NzA1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417777051", "bodyText": "This can be named better, this is part of the lifecycle config that customer needs to specify value for, so it should convey easily that this is how long kernel will wait before polling the service again to see if it safe to update", "author": "shaguptashaikh", "createdAt": "2020-04-30T06:13:20Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -37,6 +40,10 @@\n                     \"SIGIO\", \"SIGPWR\", \"SIGSYS\",};\n     private static final String SKIP_COMMAND_REGEX = \"(exists|onpath) +(.+)\";\n     private static final Pattern skipcmd = Pattern.compile(SKIP_COMMAND_REGEX);\n+    public static final String SAFE_UPDATE_TOPIC_NAME = \"safeToUpdate\";\n+    public static final int DEFAULT_SAFE_UPDATE_TIMEOUT = 5;\n+    public static final int DEFAULT_SAFE_UPDATE_RECHECK_TIME = 30;\n+    public static final String RECHECK_PERIOD_TOPIC_NAME = \"recheckPeriod\";", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NTYyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417785624", "bodyText": "This key is under \"safeToUpdate\" (or whatever it changes to), so it should be obvious what it applies to. Any naming suggestion would be appreciated.", "author": "MikeDombo", "createdAt": "2020-04-30T06:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc3NzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MTA4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417781084", "bodyText": "I think this may not be safe to assume, failure in running this script could be a bug in the customer's code which we wouldn't be safeguarding against and on top of that, not even reporting it. The only way they would find out would be if the deployment updates a service when it wasn't supposed to and then they dig the logs to see what went wrong. That defeats the purpose of having this safe update mechanism even when it's rare. I feel the same about timeout too. We should discuss this.", "author": "shaguptashaikh", "createdAt": "2020-04-30T06:24:41Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -180,6 +187,48 @@ public synchronized void shutdown() {\n         logger.atInfo().setEventType(\"generic-service-shutdown\").log();\n     }\n \n+    @Override\n+    protected long whenIsDisruptionOK() {\n+        AtomicInteger exitCode = new AtomicInteger();\n+        CountDownLatch doneRunning = new CountDownLatch(1);\n+        try {\n+            Pair<RunStatus, Exec> result = run(SAFE_UPDATE_TOPIC_NAME, (exit) -> {\n+                exitCode.set(exit);\n+                doneRunning.countDown();\n+            });\n+\n+            // If we didn't do anything or we were unable to run the check, then it is safe to update\n+            // since we cannot recover from being unable to run the check, we must assume it is safe\n+            // to go ahead", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NjIyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r417786220", "bodyText": "We can discuss, but I don't want to get into the state that a deployment can never proceed since the deployment may have the fix to the problem which is causing it to stop. I can add another key for what the default action will be, or add an extra field to a deployment to force it, but other than that I don't see what else we could do.", "author": "MikeDombo", "createdAt": "2020-04-30T06:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MTA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzMjAzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418332035", "bodyText": "That's a valid concern, my opinion is, if a safe update is to be bypassed, customer needs to be alerted first, and reporting errors in the safe-to-update action is important too, otherwise we leave it all to the customer to detect failure and fix it, evergreen just lets it go unnoticed. I wouldn't want a flying drone dropping on my head because it got updated not when it said it was ready for update but when the check failed and so we updated anyway.", "author": "shaguptashaikh", "createdAt": "2020-04-30T22:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MTA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzMzE4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418333187", "bodyText": "Let's have a post scrum discussion tomorrow.\nAs for logging errors, that already happens in the run method and she'll runner. I'll have another look tomorrow to see if anything is missed, but I believe we are properly logging already.", "author": "MikeDombo", "createdAt": "2020-04-30T22:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MTA4NA=="}], "type": "inlineReview"}, {"oid": "8d61287a48a1a961a2abb98693e75ef14fb452be", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8d61287a48a1a961a2abb98693e75ef14fb452be", "message": "Add disruptionCompleted implementation", "committedDate": "2020-04-30T20:25:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4NTM1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418285350", "bodyText": "In the case of timeout, Stop the Executor process before returning?", "author": "ShirleyZheng92", "createdAt": "2020-04-30T20:59:01Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -180,6 +187,48 @@ public synchronized void shutdown() {\n         logger.atInfo().setEventType(\"generic-service-shutdown\").log();\n     }\n \n+    @Override\n+    protected long whenIsDisruptionOK() {\n+        AtomicInteger exitCode = new AtomicInteger();\n+        CountDownLatch doneRunning = new CountDownLatch(1);\n+        try {\n+            Pair<RunStatus, Exec> result = run(SAFE_UPDATE_TOPIC_NAME, (exit) -> {\n+                exitCode.set(exit);\n+                doneRunning.countDown();\n+            });\n+\n+            // If we didn't do anything or we were unable to run the check, then it is safe to update\n+            // since we cannot recover from being unable to run the check, we must assume it is safe\n+            // to go ahead\n+            if (result.getLeft().equals(RunStatus.NothingDone) || result.getLeft().equals(RunStatus.Errored)) {\n+                return 0L;\n+            }\n+\n+            int timeout = Coerce.toInt(\n+                    config.findOrDefault(DEFAULT_SAFE_UPDATE_TIMEOUT, SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                            SAFE_UPDATE_TOPIC_NAME, TIMEOUT_NAMESPACE_TOPIC));\n+            if (doneRunning.await(timeout, TimeUnit.SECONDS)) {\n+                // Define exit code 0 means that it is safe to update right now\n+                if (exitCode.get() == 0) {\n+                    return 0L;\n+                }\n+                // Set the re-check time to some seconds in the future\n+                return Instant.now().plusSeconds(Coerce.toInt(\n+                        config.findOrDefault(DEFAULT_SAFE_UPDATE_RECHECK_TIME, SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                                SAFE_UPDATE_TOPIC_NAME, RECHECK_PERIOD_TOPIC_NAME))).toEpochMilli();\n+            } else {\n+                result.getRight().close();\n+            }\n+        } catch (InterruptedException ignore) {\n+        } catch (IOException e) {\n+            logger.atWarn().log(\"Error while running whenIsDisruptionOK\", e);\n+        }\n+\n+        // Similar to if there was an error while running the check, if we timed out we assume it is safe\n+        // to continue, otherwise we can get into a state where a deployment can never proceed\n+        return 0L;", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NDM2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418294369", "bodyText": "It does that on L224. In the case of timeout it calls close on the `Exec.", "author": "MikeDombo", "createdAt": "2020-04-30T21:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4NTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4Njg4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418286883", "bodyText": "Great! can you add a random suffix? In this case we can check that no two lifecycle thread running at the same time.", "author": "ShirleyZheng92", "createdAt": "2020-04-30T21:01:53Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -577,6 +577,7 @@ void initLifecycleThread() {\n         lifecycleFuture = evergreenService.getContext().get(ExecutorService.class).submit(() -> {\n             while (!isClosed.get()) {\n                 try {\n+                    Thread.currentThread().setName(evergreenService.getName() + \"-lifecycle\");", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NDc1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418294751", "bodyText": "How does a random suffix help? Looking in the list of running threads in the debugger will show 2 threads with the servicename-lifecycle.", "author": "MikeDombo", "createdAt": "2020-04-30T21:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4Njg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4NzkyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418287921", "bodyText": "Why we need to override with an empty method?", "author": "ShirleyZheng92", "createdAt": "2020-04-30T21:03:57Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -36,8 +37,31 @@\n     private final Map<String, Crashable> pendingActions = new LinkedHashMap<>();\n     private final List<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n \n-    public UpdateSystemSafelyService(Topics c) {\n+    private final DisruptableCheck egServiceCheck = new DisruptableCheck() {\n+        @Override\n+        public long whenIsDisruptionOK() {\n+            return kernel.orderedDependencies().stream().mapToLong(EvergreenService::whenIsDisruptionOK).max()\n+                    .orElse(0L);\n+        }\n+\n+        @Override\n+        public void disruptionCompleted() {", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NDk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418294993", "bodyText": "Because the interface has 2 methods. But it is no longer empty, I believe this comment is outdated.", "author": "MikeDombo", "createdAt": "2020-04-30T21:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4NzkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5MjA5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r418292097", "bodyText": "Can we find a way to verify safeToUpdate check is run and return non-zero?", "author": "ShirleyZheng92", "createdAt": "2020-04-30T21:12:32Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -411,6 +412,34 @@ void GIVEN_kernel_running_services_WHEN_merge_removes_service_THEN_removed_servi\n         assertEquals(Arrays.asList(\"sleeperB\", \"main\"), orderedDependencies);\n     }\n \n+    @Test\n+    void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_waits() throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-i\", getClass().getResource(\"non_disruptable_service.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainFinished = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (t.getOnce().equals(State.FINISHED)) {\n+                mainFinished.countDown();\n+            }\n+        });\n+\n+        // wait for main to finish\n+        assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        ((Map) currentConfig.get(SERVICES_NAMESPACE_TOPIC)).remove(\"nondisruptable\");\n+\n+        Future<DeploymentResult> future =\n+                deploymentConfigMerger.mergeInNewConfig(testDeploymentDocument(), currentConfig);", "originalCommit": "ff9accd35db2b974e6d73c969bb1b56b603a37b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a862296f7496f0fe397472a6485944bf0be7831d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a862296f7496f0fe397472a6485944bf0be7831d", "message": "Rework test, flip logic to assume it is not safe to update", "committedDate": "2020-05-01T17:21:22Z", "type": "commit"}, {"oid": "a862296f7496f0fe397472a6485944bf0be7831d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a862296f7496f0fe397472a6485944bf0be7831d", "message": "Rework test, flip logic to assume it is not safe to update", "committedDate": "2020-05-01T17:21:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NDA4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419644082", "bodyText": "NIT: I feel this 'run, wait for timeout, then stop Exec' logic can be extracted to a function. eg. 'runWithTimeout(ScriptNamespace, timeout, processesToTrack)'", "author": "ShirleyZheng92", "createdAt": "2020-05-04T18:36:13Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -171,17 +183,99 @@ private synchronized void handleRunScript() throws InterruptedException {\n     public synchronized void shutdown() {\n         logger.atInfo().log(\"Shutdown initiated\");\n         try {\n-            run(\"shutdown\", null);\n+            run(\"shutdown\", null, lifecycleProcesses);\n         } catch (InterruptedException ex) {\n             logger.atWarn(\"generic-service-shutdown\").log(\"Thread interrupted while shutting down service\");\n             return;\n         }\n-        stopAllProcesses();\n+        stopAllLifecycleProcesses();\n         logger.atInfo().setEventType(\"generic-service-shutdown\").log();\n     }\n \n+    @Override\n+    public long whenIsDisruptionOK() {\n+        stopAllSafeUpdateProcesses();\n+        try {\n+            CompletableFuture<Integer> exitFuture = new CompletableFuture<>();\n+            Pair<RunStatus, Exec> result = run(SAFE_UPDATE_TOPIC_NAME, exitFuture::complete, safeUpdateProcesses);\n+\n+            // If we didn't do anything then it is safe to update\n+            if (result.getLeft().equals(RunStatus.NothingDone)) {\n+                return 0L;\n+            }\n+\n+            // If it ran, then check the result or timeout\n+            if (result.getLeft().equals(RunStatus.OK)) {", "originalCommit": "a862296f7496f0fe397472a6485944bf0be7831d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3MjUwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419672509", "bodyText": "Yes, I did extract it, but I had to undo it because install, startup, run, and shutdown all have very different timeout needs which would make everything a lot more complicated.", "author": "MikeDombo", "createdAt": "2020-05-04T19:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4MDMxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419680318", "bodyText": "Why do we need to change this? If we don't need to wait, change the comment above and also change the rollback method below?", "author": "shaguptashaikh", "createdAt": "2020-05-04T19:38:35Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -96,7 +96,7 @@\n \n             kernel.getConfig().mergeMap(timestamp, newConfig);\n             // wait until topic listeners finished processing mergeMap changes.\n-            kernel.getContext().runOnPublishQueueAndWait(() -> {\n+            kernel.getContext().runOnPublishQueue(() -> {", "originalCommit": "a862296f7496f0fe397472a6485944bf0be7831d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcwMjM0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419702347", "bodyText": "We don't need to change it, but I changed it to be more clear that we're not actually waiting because the thing which is running in the publish queue isn't blocking (because it uses an Executor to run in another thread).", "author": "MikeDombo", "createdAt": "2020-05-04T20:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4MDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4MTczMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419681733", "bodyText": "Our internal services are not updated through deployment and logically don't need a safety check, so this can be implemented at the GenericExternalService?", "author": "shaguptashaikh", "createdAt": "2020-05-04T19:41:00Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -35,7 +35,7 @@\n \n import static com.aws.iot.evergreen.util.Utils.getUltimateCause;\n \n-public class EvergreenService implements InjectionActions {\n+public class EvergreenService implements InjectionActions, DisruptableCheck {", "originalCommit": "a862296f7496f0fe397472a6485944bf0be7831d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcwMzA0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419703043", "bodyText": "Any service can define a safe update check, including our internal services. They just choose not to at this point, but that's not guaranteed into the future. It makes life a lot easier if all of the service just fulfill the interface.", "author": "MikeDombo", "createdAt": "2020-05-04T20:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4MTczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcwMDQwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419700406", "bodyText": "Now that you're implementing DisruptableCheck interface at the service level, a service instance itself can function as a disruptable check instance, so this logic of going over services is duplicate, it was already being done at line 131-136", "author": "shaguptashaikh", "createdAt": "2020-05-04T20:15:01Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -36,8 +37,32 @@\n     private final Map<String, Crashable> pendingActions = new LinkedHashMap<>();\n     private final List<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n \n-    public UpdateSystemSafelyService(Topics c) {\n+    private final DisruptableCheck egServiceCheck = new DisruptableCheck() {\n+        @Override\n+        public long whenIsDisruptionOK() {\n+            return kernel.orderedDependencies().stream().mapToLong(EvergreenService::whenIsDisruptionOK).max()\n+                    .orElse(0L);", "originalCommit": "a862296f7496f0fe397472a6485944bf0be7831d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "00d1308bbbd858ca601bdaec75355c6009af7816", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/00d1308bbbd858ca601bdaec75355c6009af7816", "message": "Update for comments", "committedDate": "2020-05-04T20:49:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczODAyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419738023", "bodyText": "protected/private ?", "author": "ShirleyZheng92", "createdAt": "2020-05-04T21:24:56Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -36,8 +37,32 @@\n     private final Map<String, Crashable> pendingActions = new LinkedHashMap<>();\n     private final List<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n \n-    public UpdateSystemSafelyService(Topics c) {\n+    private final DisruptableCheck egServiceCheck = new DisruptableCheck() {\n+        @Override\n+        public long whenIsDisruptionOK() {\n+            return kernel.orderedDependencies().stream().mapToLong(EvergreenService::whenIsDisruptionOK).max()\n+                    .orElse(0L);\n+        }\n+\n+        @Override\n+        public void disruptionCompleted() {\n+            kernel.orderedDependencies().forEach(EvergreenService::disruptionCompleted);\n+        }\n+    };\n+\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param c topics root\n+     * @param k kernel\n+     */\n+    @Inject\n+    public UpdateSystemSafelyService(Topics c, Kernel k) {\n         super(c);\n+        this.kernel = k;\n+        addDisruptableCheck(egServiceCheck);\n     }\n \n     public void addDisruptableCheck(DisruptableCheck d) {", "originalCommit": "a862296f7496f0fe397472a6485944bf0be7831d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczOTI0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419739249", "bodyText": "You're out of date.", "author": "MikeDombo", "createdAt": "2020-05-04T21:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczODAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczOTU3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/218#discussion_r419739576", "bodyText": "Not in the scope of this PR. Given we already moving out disruptableCheck interface, I'm wondering if we need UpdateSystemSafelyService to be a service. InjectObject may be enough.", "author": "ShirleyZheng92", "createdAt": "2020-05-04T21:28:10Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -36,8 +37,32 @@\n     private final Map<String, Crashable> pendingActions = new LinkedHashMap<>();", "originalCommit": "a862296f7496f0fe397472a6485944bf0be7831d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}