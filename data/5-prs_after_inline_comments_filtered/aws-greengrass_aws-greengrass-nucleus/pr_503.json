{"pr_number": 503, "pr_title": "Device gets the default value from the recipe, gets update/patch request from deployment doc and perform interpolation", "pr_createdAt": "2020-10-06T17:25:27Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503", "timeline": [{"oid": "273e44804aa947abb3e4b7152c59d838382d5154", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/273e44804aa947abb3e4b7152c59d838382d5154", "message": "default value works", "committedDate": "2020-09-26T05:52:55Z", "type": "commit"}, {"oid": "b6c865937dbfe1b5e2c85a558c1e2c844d99e573", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6c865937dbfe1b5e2c85a558c1e2c844d99e573", "message": "insert doesn't really work with json node", "committedDate": "2020-09-28T06:33:01Z", "type": "commit"}, {"oid": "aff7b39bed911b337448bf5a777f657249902761", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aff7b39bed911b337448bf5a777f657249902761", "message": "working for demo", "committedDate": "2020-10-01T21:46:18Z", "type": "commit"}, {"oid": "c9e7810fd68d84f88d4b8763a75865e64ec63fa3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c9e7810fd68d84f88d4b8763a75865e64ec63fa3", "message": "working for demo", "committedDate": "2020-10-01T21:46:29Z", "type": "commit"}, {"oid": "707cee3775e2e77992cc8247c2862a19f7cb4190", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/707cee3775e2e77992cc8247c2862a19f7cb4190", "message": "done", "committedDate": "2020-10-02T23:11:27Z", "type": "commit"}, {"oid": "c39333af919b5a68125b444649f1b3e06814904a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c39333af919b5a68125b444649f1b3e06814904a", "message": "functionality all work. code cleaned. Nest step is to write integ test. Finally add unit", "committedDate": "2020-10-03T00:05:48Z", "type": "commit"}, {"oid": "8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c", "message": "Integ test working", "committedDate": "2020-10-06T17:24:50Z", "type": "commit"}, {"oid": "2434fa663d86653505a7c04e0a6e1a0e7374454e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2434fa663d86653505a7c04e0a6e1a0e7374454e", "message": "merged", "committedDate": "2020-10-06T18:46:24Z", "type": "commit"}, {"oid": "ec5a6f9726a003beb11bcab754395f7fd49e9df0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec5a6f9726a003beb11bcab754395f7fd49e9df0", "message": "merged working again", "committedDate": "2020-10-06T20:25:39Z", "type": "commit"}, {"oid": "df4add2b6309e4f87a9d1b3d5286d66ea6caf326", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/df4add2b6309e4f87a9d1b3d5286d66ea6caf326", "message": "Added list testing", "committedDate": "2020-10-06T21:05:44Z", "type": "commit"}, {"oid": "cad1771433ccb823bb45965bc43e5c57f91846f2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cad1771433ccb823bb45965bc43e5c57f91846f2", "message": "add comments for FCS", "committedDate": "2020-10-06T21:23:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNjUzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500606539", "bodyText": "Will this be deprecated? If so could you add @deprecated annotation?", "author": "ShirleyZheng92", "createdAt": "2020-10-06T21:28:13Z", "path": "src/main/java/com/aws/greengrass/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -40,4 +38,25 @@\n \n     @JsonProperty(\"Configuration\")\n     private Map<String, Object> configuration = new HashMap<>();", "originalCommit": "cad1771433ccb823bb45965bc43e5c57f91846f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEwNjk0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502106942", "bodyText": "done", "author": "leaf94", "createdAt": "2020-10-09T00:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNjUzOQ=="}], "type": "inlineReview"}, {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afa0b685f8e82278710848bb6dc135f87ef32269", "message": "service configuration could be null", "committedDate": "2020-10-06T22:34:58Z", "type": "commit"}, {"oid": "1cd62cc6a7b07715955a6961ff2e7b5499f88100", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1cd62cc6a7b07715955a6961ff2e7b5499f88100", "message": "half", "committedDate": "2020-10-07T01:13:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMTc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500711783", "bodyText": "Note: this can potentially merge a null value. Not sure if that's desired", "author": "philcali", "createdAt": "2020-10-07T03:07:50Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides.\n+                // This branch also handles the list with entire replacement.\n+                // Note: There is no support for list append or insert at index operations.\n+                original.put(key, newMap.get(key));", "originalCommit": "afa0b685f8e82278710848bb6dc135f87ef32269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NjE0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501146147", "bodyText": "Yep. That is desired. Initially I didn't want to differentiate an explicit null vs missing key - but @fengwa-aws mentioned that since the config will be eventually distributed to user, it's better to keep it as is. I'm also adding a test for the explicit null case.", "author": "leaf94", "createdAt": "2020-10-07T16:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMTc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMjIwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500712206", "bodyText": "What happens here if originalChild is null? What's supposed to happen?", "author": "philcali", "createdAt": "2020-10-07T03:09:39Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));", "originalCommit": "afa0b685f8e82278710848bb6dc135f87ef32269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1MTI4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501151283", "bodyText": "Great catch. It didn't really happen integ tests hit coz it's hard to get a null Map, although totally possible. If originalChild is null and newChild is not null, then originalChild should be merged with newChild (even for the case newChild is emptyMap). I will remove the @Nonnull assumption for original and handle it at the beginning - basically every level, both map could be null", "author": "leaf94", "createdAt": "2020-10-07T16:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxNDI1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500714257", "bodyText": "should the last } also be escaped for good measure? Also, can this be more strict? It'll basically match anything. It's actually less restrictive than other matchers in this file so I'm concerned about the config resolving to broken state.", "author": "philcali", "createdAt": "2020-10-07T03:17:58Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -55,12 +62,21 @@\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n     private static final Pattern SAME_INTERPOLATION_REGEX =\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n+\n+    // pattern matches {group1:group2}. Note char in both group can't be }, but can be special char like / and .\n+    private static final Pattern SAME_COMPONENT_INTERPOLATION_REGEX = Pattern.compile(\"\\\\{([^}]+):([^}]+)}\");", "originalCommit": "afa0b685f8e82278710848bb6dc135f87ef32269", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "afb2aea893f215ec7fc841dd342720ae53f1a242", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afb2aea893f215ec7fc841dd342720ae53f1a242", "message": "add unit tests for configuration update operations", "committedDate": "2020-10-07T05:49:59Z", "type": "commit"}, {"oid": "fd57935cba930e198bb38cc4893aa517da620778", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fd57935cba930e198bb38cc4893aa517da620778", "message": "new working", "committedDate": "2020-10-07T06:17:57Z", "type": "commit"}, {"oid": "d8335cfef5e78fe054c7f3d9c119a665dfe6d4e6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d8335cfef5e78fe054c7f3d9c119a665dfe6d4e6", "message": "Merge branch 'nested_config' of github.com:aws/aws-greengrass-kernel into nested_config", "committedDate": "2020-10-07T06:18:18Z", "type": "commit"}, {"oid": "e458ac8f58ff9cd0e4645d3c404f8fa23604c9f1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e458ac8f58ff9cd0e4645d3c404f8fa23604c9f1", "message": "done", "committedDate": "2020-10-07T06:47:56Z", "type": "commit"}, {"oid": "4b4156a5121ba490a9b9295a73bedef5f208a5e6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4b4156a5121ba490a9b9295a73bedef5f208a5e6", "message": "fix deepcopy", "committedDate": "2020-10-07T18:22:24Z", "type": "commit"}, {"oid": "33742eed032dc667f367a746a72ca369364b237d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33742eed032dc667f367a746a72ca369364b237d", "message": "add system namespace handling", "committedDate": "2020-10-07T21:15:23Z", "type": "commit"}, {"oid": "ac43895389e93bdeaad34c522d36dcbc74506f7a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac43895389e93bdeaad34c522d36dcbc74506f7a", "message": "fixed cross system", "committedDate": "2020-10-07T21:47:30Z", "type": "commit"}, {"oid": "9ec7d828be447b2cf0ecbbc6e8b038b0efb825f5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9ec7d828be447b2cf0ecbbc6e8b038b0efb825f5", "message": "clean up code", "committedDate": "2020-10-07T22:43:57Z", "type": "commit"}, {"oid": "86ea20a2aed88b0273bc93b021099b29d1066399", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/86ea20a2aed88b0273bc93b021099b29d1066399", "message": "clean up code", "committedDate": "2020-10-07T22:48:19Z", "type": "commit"}, {"oid": "3b5f7f65886a61ef760f44df023e7a074b53e618", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b5f7f65886a61ef760f44df023e7a074b53e618", "message": "system cross", "committedDate": "2020-10-07T22:55:36Z", "type": "commit"}, {"oid": "74c64109e2ce2fb00e4d47b9f5b29f744ad039d5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/74c64109e2ce2fb00e4d47b9f5b29f744ad039d5", "message": "add cross component reference test", "committedDate": "2020-10-07T22:55:49Z", "type": "commit"}, {"oid": "11a8f57c7c126ef5a46a10a15dacf292d56b4abf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11a8f57c7c126ef5a46a10a15dacf292d56b4abf", "message": "cleanup message", "committedDate": "2020-10-07T23:19:05Z", "type": "commit"}, {"oid": "acea077b897322e2f49a742c589ae84d6e3caf6b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/acea077b897322e2f49a742c589ae84d6e3caf6b", "message": "all works", "committedDate": "2020-10-08T00:50:10Z", "type": "commit"}, {"oid": "63e2fa9361604539320db0bef58a9ddad9636e57", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/63e2fa9361604539320db0bef58a9ddad9636e57", "message": "Merge branch 'nested_config' of github.com:aws/aws-greengrass-kernel into nested_config", "committedDate": "2020-10-08T00:50:18Z", "type": "commit"}, {"oid": "a5a8b20326ac0c5275f7e9368969c8211d7b4e19", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a5a8b20326ac0c5275f7e9368969c8211d7b4e19", "message": "all works", "committedDate": "2020-10-08T00:51:49Z", "type": "commit"}, {"oid": "33d28253249406553c7bb95cc85d7ddc6f5119ea", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33d28253249406553c7bb95cc85d7ddc6f5119ea", "message": "original tests passed", "committedDate": "2020-10-08T01:01:09Z", "type": "commit"}, {"oid": "1fed87f9ff89414e470353ed61945959bbdb9f79", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1fed87f9ff89414e470353ed61945959bbdb9f79", "message": "mvn verify works locally", "committedDate": "2020-10-08T03:13:17Z", "type": "commit"}, {"oid": "9166f8d1028d32599e4c9316c1288e5e2fa5109a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9166f8d1028d32599e4c9316c1288e5e2fa5109a", "message": "Updated README", "committedDate": "2020-10-08T06:12:19Z", "type": "commit"}, {"oid": "387705bb0f01dc6f9228751583e3e1a9efdb6484", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/387705bb0f01dc6f9228751583e3e1a9efdb6484", "message": "Updated README", "committedDate": "2020-10-08T06:14:41Z", "type": "commit"}, {"oid": "e14e1a2ce4c7acb1638bccd68ab741a2353326b6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e14e1a2ce4c7acb1638bccd68ab741a2353326b6", "message": "Updated README", "committedDate": "2020-10-08T06:15:35Z", "type": "commit"}, {"oid": "00cf23d461bd2fd9921362141dd1a9741491c3db", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/00cf23d461bd2fd9921362141dd1a9741491c3db", "message": "Update recipe reference", "committedDate": "2020-10-08T07:20:08Z", "type": "commit"}, {"oid": "771ff9e505fbfaa4d6ed5a46acd1f022b62bcd83", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/771ff9e505fbfaa4d6ed5a46acd1f022b62bcd83", "message": "Update recipe reference", "committedDate": "2020-10-08T07:22:22Z", "type": "commit"}, {"oid": "23ae406261e032cdce920523cdd9fb54c0015276", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/23ae406261e032cdce920523cdd9fb54c0015276", "message": "shirley's comment", "committedDate": "2020-10-08T07:25:00Z", "type": "commit"}, {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e8037676ac1b2ce0d71bad899758e4250c0bfbc6", "message": "Merge branch 'master' into nested_config", "committedDate": "2020-10-08T23:03:45Z", "type": "commit"}, {"oid": "f2d1d567f6eb864d3edda94721411214e9b6a9c4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f2d1d567f6eb864d3edda94721411214e9b6a9c4", "message": "half", "committedDate": "2020-10-08T23:04:21Z", "type": "commit"}, {"oid": "efea322745479890aa65a448072859f421019c14", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/efea322745479890aa65a448072859f421019c14", "message": "fix merging issues", "committedDate": "2020-10-08T23:25:42Z", "type": "commit"}, {"oid": "4608bb6a09e09790daee49ac5303dd98c2c70cbf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4608bb6a09e09790daee49ac5303dd98c2c70cbf", "message": "Merge branch 'master' into nested_config", "committedDate": "2020-10-09T00:56:26Z", "type": "commit"}, {"oid": "a5046c3ccfbc98ceb3d353bed35dcbcc1499185b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a5046c3ccfbc98ceb3d353bed35dcbcc1499185b", "message": "fix merge issues", "committedDate": "2020-10-09T01:05:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mjc3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502042779", "bodyText": "Configurations or configurations?", "author": "fengwang666", "createdAt": "2020-10-08T22:16:31Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -40,12 +46,15 @@\n \n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.Kernel.SERVICE_TYPE_TOPIC_KEY;\n \n public class KernelConfigResolver {\n     private static final Logger LOGGER = LogManager.getLogger(KernelConfigResolver.class);\n     public static final String VERSION_CONFIG_KEY = \"version\";\n     public static final String PARAMETERS_CONFIG_KEY = \"parameters\";\n+    public static final String CONFIGURATIONS_CONFIG_KEY = \"Configurations\";", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNjE2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502126169", "bodyText": "Good catch. Should be lower case.", "author": "leaf94", "createdAt": "2020-10-09T01:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mjc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mzk5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502043999", "bodyText": "Make this a static variable.", "author": "fengwang666", "createdAt": "2020-10-08T22:19:50Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -55,42 +64,68 @@\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n     private static final Pattern SAME_INTERPOLATION_REGEX =\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n+\n+    // pattern matches {group1:group2}. ex. {configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern SAME_COMPONENT_INTERPOLATION_REGEX = Pattern.compile(\"\\\\{([.\\\\w]+):([^:}]+)}\");\n+\n+\n+    // pattern matches {group1:group2:group3}.\n+    // ex. {aws.iot.aws.iot.gg.test.integ.ComponentConfigTestService:configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the component name.\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern CROSS_COMPONENT_INTERPOLATION_REGEX =\n+            Pattern.compile(\"\\\\{([.\\\\w]+):([.\\\\w]+):([^:}]+)}\");\n+\n     static final String PARAM_NAMESPACE = \"params\";\n+    static final String CONFIGURATION_NAMESPACE = \"configuration\";\n     static final String PARAM_VALUE_SUFFIX = \".value\";\n     static final String PATH_KEY = \"path\";\n     static final String DECOMPRESSED_PATH_KEY = \"decompressedPath\";\n \n     private static final String NO_RECIPE_ERROR_FORMAT = \"Failed to find component recipe for {}\";\n \n+    // https://tools.ietf.org/html/rfc6901#section-5\n+    private static final String JSON_POINTER_WHOLE_DOC = \"\";\n+\n     // Map from Namespace -> Key -> Function which returns the replacement value\n     private final Map<String, Map<String, CrashableFunction<ComponentIdentifier, String, PackageLoadingException>>>\n             systemParameters = new HashMap<>();\n \n     private final ComponentStore componentStore;\n     private final Kernel kernel;\n \n+    private final ObjectMapper mapper = new ObjectMapper();", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTQ2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125469", "bodyText": "done", "author": "leaf94", "createdAt": "2020-10-09T01:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mzk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTQ5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502045495", "bodyText": "nit: update the comment", "author": "fengwang666", "createdAt": "2020-10-08T22:23:39Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTQ4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125481", "bodyText": "done", "author": "leaf94", "createdAt": "2020-10-09T01:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTYyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502045626", "bodyText": "packagesToDeploy -> componentsToDeploy", "author": "fengwang666", "createdAt": "2020-10-08T22:24:05Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> packagesToDeploy,", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTU4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125580", "bodyText": "Done", "author": "leaf94", "createdAt": "2020-10-09T01:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NzA2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502047062", "bodyText": "Pull reset and deepMerge into a separate class. They are independent from kernel config and can be tested more thoroughly using unit tests. This KernelConfigResolver is getting too big.\nAlso I would make the method signature more consistent:\nJsonNode reset(JsonNode original, JsonNode defaultValue, List<String> paths)", "author": "fengwang666", "createdAt": "2020-10-08T22:27:55Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNjcxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502126712", "bodyText": "Yes. I'm hoping to do that after parameter cleanup.\nAbout the signature - I also thought about it but I didn't go with that because it kinda gives an impression the responsibility is to convert a \"JsonNode\". However, the responsibility for this method is to take a Map and return another Map. Hence I kept the Map", "author": "leaf94", "createdAt": "2020-10-09T01:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NzA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1NTE4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502055181", "bodyText": "Why allow nullable?", "author": "fengwang666", "createdAt": "2020-10-08T22:50:06Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNjg2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502126862", "bodyText": "Not really allow but just to be more robust.", "author": "leaf94", "createdAt": "2020-10-09T01:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1NTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502056771", "bodyText": "You'll end up having a lot of copies if the nesting is deep. I would be fine just mutating the map. Since the user of this method is only us, it's safe as long as the caller knows this is a mutating method.", "author": "fengwang666", "createdAt": "2020-10-08T22:54:45Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzQ2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502127462", "bodyText": "Initially I made it that way. But Jason convinced me with 2 points.\n\nPractically, we don't really foresee this map to be have deeply nested.\nThere are many several places mutating this map far away. If one of them accidentally use an immutable map in the future, it will break completely.\n\nHence, I decided to gain more robustness with the sacrifice. I'm open to discuss this a little bit more though", "author": "leaf94", "createdAt": "2020-10-09T01:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTUyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502129529", "bodyText": "That's the problem of this class. We're passing the references over all the place.", "author": "fengwang666", "createdAt": "2020-10-09T01:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NTk5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502555998", "bodyText": "Oh when I say far away - I mean not in this class. For example, when read out from kernel, it could give out a immutable map", "author": "leaf94", "createdAt": "2020-10-09T16:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2MDkwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502060909", "bodyText": "Is this supposed to replace the intepolate on line567 or they're separate? Can you rename it a bit differently? such as interpolateNew.", "author": "fengwang666", "createdAt": "2020-10-08T23:01:41Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,", "originalCommit": "23ae406261e032cdce920523cdd9fb54c0015276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzgwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502127801", "bodyText": "Yes. I intentionally kept them the same name coz they are the exact same step for two different paths - and soon when we delete the legacy path, it will be easy.", "author": "leaf94", "createdAt": "2020-10-09T01:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2MDkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2ODI3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502068272", "bodyText": "namespace can be null so reverse the comparison order to avoid NPE.", "author": "fengwang666", "createdAt": "2020-10-08T23:14:00Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {", "originalCommit": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzg5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502127894", "bodyText": "Done.", "author": "leaf94", "createdAt": "2020-10-09T01:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2ODI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3MTUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502071530", "bodyText": "Is this desirable? If the client is expecting the configuration value is a string, but the node the path points to is an object, apparently something is wrong.", "author": "fengwang666", "createdAt": "2020-10-08T23:19:15Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig.get(\n+                componentName)).containsKey(CONFIGURATIONS_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATIONS_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = mapper.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError()\n+                    .addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());", "originalCommit": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyODEyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502128122", "bodyText": "Can be discussed. I initially logged error and retain the interpolation placeholder, but then I thought there might be a use case for passing down a JSON string, so I changed it to provide the flexibility.", "author": "leaf94", "createdAt": "2020-10-09T01:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3MTUzMA=="}], "type": "inlineReview"}, {"oid": "9ceb9891abdc158deedc2d54907d1496e5c91e70", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9ceb9891abdc158deedc2d54907d1496e5c91e70", "message": "github CI", "committedDate": "2020-10-09T01:53:05Z", "type": "commit"}, {"oid": "a400c8707e11f214042e82105c8e0a0f47c89adc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a400c8707e11f214042e82105c8e0a0f47c89adc", "message": "merge shirley's change", "committedDate": "2020-10-09T06:51:22Z", "type": "commit"}, {"oid": "651240c4274990434cf6debccd91c0217b225339", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/651240c4274990434cf6debccd91c0217b225339", "message": "merge shirley's change fix", "committedDate": "2020-10-09T07:02:08Z", "type": "commit"}, {"oid": "28ece1751b9518489666cf5f7f076bef8a457e8e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/28ece1751b9518489666cf5f7f076bef8a457e8e", "message": "Fix for windows; address Feng's comments", "committedDate": "2020-10-09T17:09:45Z", "type": "commit"}, {"oid": "7f791177cb5f6f99846290c7b5534e6503cb60b4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7f791177cb5f6f99846290c7b5534e6503cb60b4", "message": "fix test", "committedDate": "2020-10-09T17:31:02Z", "type": "commit"}, {"oid": "4c0a8f6465038084ecb686867d21a7188e3cecd1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4c0a8f6465038084ecb686867d21a7188e3cecd1", "message": "test integration test on windows", "committedDate": "2020-10-09T18:53:40Z", "type": "commit"}, {"oid": "f1ddbd8eb7d4f046d8b120fac782d1b6832cd625", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f1ddbd8eb7d4f046d8b120fac782d1b6832cd625", "message": "test integration test on windows", "committedDate": "2020-10-09T19:02:09Z", "type": "commit"}, {"oid": "f0497273d12b912507f1f1dc2ed0132197c74c5f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f0497273d12b912507f1f1dc2ed0132197c74c5f", "message": "trial 3", "committedDate": "2020-10-09T20:38:31Z", "type": "commit"}, {"oid": "60f0300cdcc135434f584eac6c501b5b362accc5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/60f0300cdcc135434f584eac6c501b5b362accc5", "message": "trial 3", "committedDate": "2020-10-09T20:39:50Z", "type": "commit"}, {"oid": "d4b7155df6ea4e3dab0a00b70888971efc343411", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d4b7155df6ea4e3dab0a00b70888971efc343411", "message": "trial 3.1", "committedDate": "2020-10-09T20:41:33Z", "type": "commit"}, {"oid": "50ba3dfd9271dcde96bfb72e8db0f05a6f7b4c5f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/50ba3dfd9271dcde96bfb72e8db0f05a6f7b4c5f", "message": "single test for windows", "committedDate": "2020-10-09T22:29:25Z", "type": "commit"}, {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e9bcde9fc75f7404957220c0d37d3a002330259c", "message": "update readme", "committedDate": "2020-10-09T22:35:45Z", "type": "commit"}, {"oid": "6d9cfb7ac5d32457d7c49a0e468a23b38a8fa4b9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6d9cfb7ac5d32457d7c49a0e468a23b38a8fa4b9", "message": "single test for windows", "committedDate": "2020-10-09T22:39:33Z", "type": "commit"}, {"oid": "4942f0e7c31d4b290bfe1cc47826c98cb0f18128", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4942f0e7c31d4b290bfe1cc47826c98cb0f18128", "message": "single test for windows", "committedDate": "2020-10-09T22:48:54Z", "type": "commit"}, {"oid": "e1f1331a07d3421dff9b6247d472ac4e328794da", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e1f1331a07d3421dff9b6247d472ac4e328794da", "message": "single test for windows", "committedDate": "2020-10-09T22:59:14Z", "type": "commit"}, {"oid": "c323ff96415c387552f213fc7180db1e4fa7b240", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c323ff96415c387552f213fc7180db1e4fa7b240", "message": "fix flaky test for windows", "committedDate": "2020-10-09T23:21:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwMjk5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502702992", "bodyText": "Isn't array treated as object?", "author": "ShirleyZheng92", "createdAt": "2020-10-09T22:50:16Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;", "originalCommit": "e9bcde9fc75f7404957220c0d37d3a002330259c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNjc2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502716766", "bodyText": "Nah. I also learned from Jackson's node relationship this time. In short: JsonNode -> ContainerNode (ObjectNode  or ArrayNode) / ValueNode (NullNode, NumericNode, ...)", "author": "leaf94", "createdAt": "2020-10-09T23:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwMjk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNDI5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502704293", "bodyText": "'parent' or 'target' ? Also why it can't be a container node?", "author": "ShirleyZheng92", "createdAt": "2020-10-09T22:55:19Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.", "originalCommit": "e9bcde9fc75f7404957220c0d37d3a002330259c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNjE4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502716185", "bodyText": "parent. if you reset something say /parent/target then /parent must be a container, and it can't be a value like {\"parent\": \"I'm a value node\" }. This case, the reset is invalid and will be ignored.", "author": "leaf94", "createdAt": "2020-10-09T23:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNDI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMDAzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502710039", "bodyText": "You already interpolate config at L166. Why need to interpolate here before configs are resolved? Will this cause new service use old config from dependencies?", "author": "ShirleyZheng92", "createdAt": "2020-10-09T23:22:26Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -104,51 +135,80 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n      * retrieves its recipe, then merges the parameter values into the recipe, and last transform it to a kernel config\n      * key-value pair.\n      *\n-     * @param packagesToDeploy package identifiers for resolved packages that are to be deployed\n-     * @param document         deployment document\n-     * @param rootPackages     root level packages\n+     * @param componentsToDeploy package identifiers for resolved packages of complete dependency graph across groups\n+     * @param document           deployment document\n+     * @param rootPackages       root level packages\n      * @return a kernel config map\n      * @throws PackageLoadingException if any service package was unable to be loaded\n-     * @throws IOException for directory issues\n+     * @throws IOException             for directory issues\n      */\n-    public Map<String, Object> resolve(List<ComponentIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws PackageLoadingException, IOException {\n+\n+    public Map<String, Object> resolve(List<ComponentIdentifier> componentsToDeploy, DeploymentDocument document,\n+            List<String> rootPackages) throws PackageLoadingException, IOException {\n         Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache =\n                 new ConcurrentHashMap<>();\n         Map<String, Object> servicesConfig = new HashMap<>();\n-        for (ComponentIdentifier packageToDeploy : packagesToDeploy) {\n-            servicesConfig.put(packageToDeploy.getName(),\n-                    getServiceConfig(packageToDeploy, document, packagesToDeploy, parameterAndDependencyCache));\n+\n+        // resolve configuration\n+        for (ComponentIdentifier componentToDeploy : componentsToDeploy) {\n+            servicesConfig.put(componentToDeploy.getName(),\n+                               getServiceConfig(componentToDeploy, document, componentsToDeploy,\n+                                                parameterAndDependencyCache));\n         }\n+\n+        // Interpolate configurations\n+        for (ComponentIdentifier resolvedComponentsToDeploy : componentsToDeploy) {\n+            ComponentRecipe componentRecipe = componentStore.getPackageRecipe(resolvedComponentsToDeploy);\n+\n+            Object existingLifecycle = ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+\n+            Object interpolatedLifecycle = interpolate(existingLifecycle, resolvedComponentsToDeploy,\n+                                                       componentRecipe.getDependencies().keySet(), servicesConfig);\n+\n+            ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, interpolatedLifecycle);\n+        }\n+\n         servicesConfig.put(kernel.getMain().getName(), getMainConfig(rootPackages));\n \n         // Services need to be under the services namespace in kernel config\n         return Collections.singletonMap(SERVICES_NAMESPACE_TOPIC, servicesConfig);\n     }\n \n-    /*\n-     * Processes lifecycle section of each package and add it to the config.\n+    /**\n+     * Build the kernel config for a service/component by processing deployment document.\n+     *\n+     * @param componentIdentifier         target component id\n+     * @param document                    deployment doc for the current deployment\n+     * @param componentsToDeploy          the entire list of components that would be deployed to the device cross\n+     *                                    groups\n+     * @param parameterAndDependencyCache cache for processing parameter and dependency\n+     * @return a built map representing the kernel config under \"services\" key for a particular component\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n+     * @throws IOException             for directory issues\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> componentsToDeploy,\n+            Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache)\n             throws PackageLoadingException, IOException {\n+\n         ComponentRecipe componentRecipe = componentStore.getPackageRecipe(componentIdentifier);\n \n         Set<ComponentParameter> resolvedParams = resolveParameterValuesToUse(document, componentRecipe);\n         parameterAndDependencyCache\n                 .put(componentIdentifier, new Pair<>(resolvedParams, componentRecipe.getDependencies().keySet()));\n \n+\n         Map<String, Object> resolvedServiceConfig = new HashMap<>();\n \n         // Interpolate parameters\n-        resolvedServiceConfig.put(GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                interpolate(componentRecipe.getLifecycle(), componentIdentifier, packagesToDeploy, document,\n-                        parameterAndDependencyCache));\n+        resolvedServiceConfig.put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                                  interpolate(componentRecipe.getLifecycle(), componentIdentifier, componentsToDeploy,\n+                                              document, parameterAndDependencyCache));", "originalCommit": "e9bcde9fc75f7404957220c0d37d3a002330259c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNTkxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502715919", "bodyText": "That's the old one. Will it as deprecated", "author": "leaf94", "createdAt": "2020-10-09T23:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMDAzOQ=="}], "type": "inlineReview"}, {"oid": "5fb3654d9c7d3aed0fe577ad304614e5dab4a6a3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5fb3654d9c7d3aed0fe577ad304614e5dab4a6a3", "message": "put back maven", "committedDate": "2020-10-09T23:29:56Z", "type": "commit"}, {"oid": "92a8e9ed03654f2ab6b5fbef6b08e7ae62177511", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/92a8e9ed03654f2ab6b5fbef6b08e7ae62177511", "message": "Merge branch 'master' into nested_config", "committedDate": "2020-10-09T23:30:47Z", "type": "commit"}, {"oid": "ea5e3390db3eb816a0e41cc26cc040b23e29d05b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea5e3390db3eb816a0e41cc26cc040b23e29d05b", "message": "Merge branch 'nested_config' of github.com:aws/aws-greengrass-kernel into nested_config", "committedDate": "2020-10-09T23:31:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjg2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502712866", "bodyText": "add @deprecated", "author": "ShirleyZheng92", "createdAt": "2020-10-09T23:36:27Z", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return MAPPER.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws IOException for directory issues\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig\n+                .get(componentName)).containsKey(CONFIGURATION_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATION_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = MAPPER.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError().addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Nullable\n+    private String lookupSystemConfig(ComponentIdentifier component, String namespace, String key) throws IOException {\n+        // Handle system-wide configuration\n+        Map<String, CrashableFunction<ComponentIdentifier, String, IOException>> systemParams =\n+                systemParameters.getOrDefault(namespace, Collections.emptyMap());\n+        if (systemParams.containsKey(key)) {\n+            return systemParams.get(key).apply(component);\n+        }\n+        return null;\n+    }\n+\n+    /***************** end of new configuration code path. *******************/\n+\n     /*\n      * For each lifecycle key-value pair of a package, substitute parameter values.\n      */\n+    @SuppressWarnings(\"checkstyle:OverloadMethodsDeclarationOrder\")\n     private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier,", "originalCommit": "ea5e3390db3eb816a0e41cc26cc040b23e29d05b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxODE2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502718167", "bodyText": "done", "author": "leaf94", "createdAt": "2020-10-10T00:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjg2Ng=="}], "type": "inlineReview"}, {"oid": "09cb4bcf58b86c7284e9ef028ae2bc2b69b716f7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09cb4bcf58b86c7284e9ef028ae2bc2b69b716f7", "message": "test if new platform common works", "committedDate": "2020-10-10T00:09:33Z", "type": "commit"}, {"oid": "8204a102a9c2d25dc8c10467fff409589e9f2e10", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8204a102a9c2d25dc8c10467fff409589e9f2e10", "message": "final test before switching back common to mainline", "committedDate": "2020-10-10T00:27:42Z", "type": "commit"}, {"oid": "ceac7ca9042f520d468c000ccfd6a920932332d7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ceac7ca9042f520d468c000ccfd6a920932332d7", "message": "change common back to mainline. READY TO BE MERGED", "committedDate": "2020-10-10T02:02:50Z", "type": "commit"}]}