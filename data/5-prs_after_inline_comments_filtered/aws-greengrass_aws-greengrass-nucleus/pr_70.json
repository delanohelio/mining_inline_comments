{"pr_number": 70, "pr_title": "Deployments - Update Kernel config with changes from deployment", "pr_createdAt": "2020-02-21T23:32:27Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTM4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382855383", "bodyText": "Looks like this shouldn't be a builder, but just a constructor.", "author": "MikeDombo", "createdAt": "2020-02-21T23:40:27Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/DownloadedState.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.Map;\n+import java.util.function.BiPredicate;\n+\n+@AllArgsConstructor\n+public class DownloadedState implements State {\n+\n+    private final DeploymentProcess deploymentProcess;\n+\n+    private final Kernel kernel;\n+\n+    private final PackageManager packageManager;\n+\n+    Log log;\n+\n+    @Override\n+    public boolean canProceed() {\n+        log.log(Log.Level.Note, \"<Downloaded>: checking if deployment can proceed\");\n+        // check update kernel conditions\n+        DeploymentPacket packet = deploymentProcess.getDeploymentPacket();\n+        BiPredicate<Kernel, Map<String, Map<String, Parameter>>> updateCondition = packet.getUpdateCondition();\n+        if (updateCondition != null) {\n+            return updateCondition.test(kernel, packet.getTargetPackageConfigs());\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void proceed() {\n+        log.log(Log.Level.Note, \"<Downloaded>: proceed\");\n+        // resolve kernel config\n+        try {\n+            deploymentProcess.setResolvedKernelConfig(resolveKernelConfig());\n+            deploymentProcess.setCurrentState(deploymentProcess.getUpdatingKernelState());\n+        } catch (Exception e) {\n+            // TODO : Mark the deployment failed\n+            log.error(\"Error moving out of downlaoded state\");\n+        }\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        // TODO : Set state to Canceled, cleanup, revert package cache updates, etc\n+    }\n+\n+    private Map<Object, Object> resolveKernelConfig() throws Exception {\n+        Map<String, Map<String, Parameter>> targetPackageConfigs =\n+                deploymentProcess.getDeploymentPacket().getTargetPackageConfigs();\n+        ConfigResolver configResolver =\n+                ConfigResolver.builder().kernel(kernel).targetPackageConfigs(targetPackageConfigs)", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2ODEzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383468132", "bodyText": "Yeah, making this a builder is invitation to potential errors, right now there is no need for it anyway, making it a constructor instead", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTcyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382855725", "bodyText": "Probably this should be done at the last possible moment so that the \"updatedMainConfig\" is as close to accurate as it can be.", "author": "MikeDombo", "createdAt": "2020-02-21T23:41:58Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NzIxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383467214", "bodyText": "Sure, although actual config can still change after the update has been queued to wait for safe times, I'm moving it to the end of this method for now", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTkxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382855911", "bodyText": "Are we expecting Throwable? Can this be narrowed down at all?", "author": "MikeDombo", "createdAt": "2020-02-21T23:42:47Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NzMxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383467318", "bodyText": "I don't like it either but Throwable is the checked exception on most of the Kernel methods, if we refactor that this can be narrowed down too, not prioritizing that for the demo though", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUxMzI5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383513296", "bodyText": "Ah, right getMain can throw Throwable. I believe in my PR I've removed that, but if not I think we can safely remove it at some point.", "author": "MikeDombo", "createdAt": "2020-02-24T21:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4ODIyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384688221", "bodyText": "Since I merged my change, getMain() does not need to throw Throwable anymore, so you can remove this check.", "author": "MikeDombo", "createdAt": "2020-02-26T18:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjA0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856042", "bodyText": "just call get which will return null anyway if the key isn't in the map.", "author": "MikeDombo", "createdAt": "2020-02-21T23:43:27Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NzM5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383467399", "bodyText": "Right, for some reason I kept thinking there would be a key error", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjE4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856187", "bodyText": "[nit]\nUse method reference instead of lambda.", "author": "MikeDombo", "createdAt": "2020-02-21T23:44:08Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjQzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856434", "bodyText": "Instead of checking if it isn't a Map, why not check that it is a String since you cast it on the next line?", "author": "MikeDombo", "createdAt": "2020-02-21T23:45:28Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NzU0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383467541", "bodyText": "Sure, will change in the following update", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjgxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856817", "bodyText": "Only call put once you're done with the for loop and all replacements are done. I don't see any reason why it needs to be updated on each loop.", "author": "MikeDombo", "createdAt": "2020-02-21T23:47:14Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value.replaceAll(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+                lifecycle.put(lifecycleKey, value);", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2Nzc5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383467799", "bodyText": "Yes, I should have caught that, will update", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzUyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382857525", "bodyText": "Odd to have lifecycle as an output variable. Can you just make this method create and return the map?", "author": "MikeDombo", "createdAt": "2020-02-21T23:50:31Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value.replaceAll(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+                lifecycle.put(lifecycleKey, value);\n+            }\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {\n+                interpolate(lifecycleEntry.getKey(), childLifecycleMap, parametersFromDeployment, packageParameters);\n+            }\n+        }\n+    }\n+\n+    private Map<Object, Object> getUpdatedMainConfig(Map<String, Package> targetPackages) {\n+        Set<String> kernelDependencies =\n+                kernel.orderedDependencies().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(removedTopLevelPackages);\n+        kernelDependencies\n+                .addAll(targetPackages.values().stream().map(p -> p.getServiceName()).collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addServiceDependencies(mainLifecycleMap, kernelDependencies);\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    void addServiceDependencies(Map<Object, Object> lifecycle, final Set<String> dependencies) {", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2Nzk1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383467956", "bodyText": "This method is not intended to initialize the map but modify one that has already been initialized and is being updated, the only reason I even extracted it out is because both a regular service and the main service would need to do this", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3MzkwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384873903", "bodyText": "Maybe rename lifecycle to package will be better", "author": "ShirleyZheng92", "createdAt": "2020-02-27T01:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzgzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382857837", "bodyText": "The kernelDependencies you have here is a list of all services in the kernel, so I don't think that it is doing what you want it to. I believe you're trying to find the dependencies of main, right? If so, you can do kernel.getMain().dependencies.", "author": "MikeDombo", "createdAt": "2020-02-21T23:51:55Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value.replaceAll(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+                lifecycle.put(lifecycleKey, value);\n+            }\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {\n+                interpolate(lifecycleEntry.getKey(), childLifecycleMap, parametersFromDeployment, packageParameters);\n+            }\n+        }\n+    }\n+\n+    private Map<Object, Object> getUpdatedMainConfig(Map<String, Package> targetPackages) {\n+        Set<String> kernelDependencies =\n+                kernel.orderedDependencies().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(removedTopLevelPackages);\n+        kernelDependencies\n+                .addAll(targetPackages.values().stream().map(p -> p.getServiceName()).collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addServiceDependencies(mainLifecycleMap, kernelDependencies);", "originalCommit": "4a64d6d7d4b39dd467880cc66d0d98d418307be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2Nzg0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383467840", "bodyText": "Right, I didn't realize that before, updating it", "author": "shaguptashaikh", "createdAt": "2020-02-24T19:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUxNDQyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383514422", "bodyText": "Return the interface, not the implementation. This should just return a  Map<EvergreenService, State>.", "author": "MikeDombo", "createdAt": "2020-02-24T21:07:15Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -748,6 +748,10 @@ protected void addDependencies(HashSet<EvergreenService> deps) {\n         }\n     }\n \n+    public ConcurrentHashMap<EvergreenService, State> getDependencies() {", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Nzg2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384097867", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUxNDQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0Nzk3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383547972", "bodyText": "I think these should be parameters to the resolveConfig method. Also, do you plan to modify these as per the interface defined in #71", "author": "abanthiy", "createdAt": "2020-02-24T22:17:44Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NzIyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383587228", "bodyText": "That's how I had modeled it first, but it ends up being too many parameters with complex definitions, and there are recursive calls within the methods that make the code not too readable, so I remodeled it as a class so that it's much easier to pass around the context, it is not going to be a singleton", "author": "shaguptashaikh", "createdAt": "2020-02-25T00:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0Nzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDczOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383630739", "bodyText": "Can we not use recursive? I find it not very readable in general.", "author": "fengwang666", "createdAt": "2020-02-25T02:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0Nzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5ODI3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384098270", "bodyText": "We are working with a map of package dependency trees which is why recursion was chosen, the package tree and the lifecycle trees for every package are maps with unknown levels of nesting", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0Nzk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODU3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383548572", "bodyText": "It is not clear yet, how are we modeling the conditions so I would remove any code that uses these right now.", "author": "abanthiy", "createdAt": "2020-02-24T22:19:07Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.function.BiPredicate;\n+\n+@Getter\n+@Builder\n+public class DeploymentPacket {\n+\n+    private Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private BiPredicate<Kernel, Map<String, Map<String, Parameter>>> downloadCondition;\n+\n+    private BiPredicate<Kernel, Map<String, Map<String, Parameter>>> updateCondition;", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NzQxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383587412", "bodyText": "I took this directly from Jason's prototype, I know that it is not decided how exactly it'll be implemented but I thought it would be helpful in understanding the context of why deployments are implemented as a state machine and what things can be done inside the proceed and canProceed() methods of a state. I don't have a strong opinion though so I can remove it in the next update", "author": "shaguptashaikh", "createdAt": "2020-02-25T00:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTYyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383629627", "bodyText": "Agree with Amit. I would remove any code that is not used right now.", "author": "fengwang666", "createdAt": "2020-02-25T02:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5ODMxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384098318", "bodyText": "Removed conditions", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODgyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383548828", "bodyText": "The prototype for this should match with the interfaces defined in #71", "author": "abanthiy", "createdAt": "2020-02-24T22:19:39Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.function.BiPredicate;\n+\n+@Getter\n+@Builder\n+public class DeploymentPacket {\n+\n+    private Map<String, Map<String, Parameter>> targetPackageConfigs;", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NzQ1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383587456", "bodyText": "Talked with Jason and the agreed upon interface for this is a map of dependency trees of top level packages, and parameter values so there shouldn't be any change to the logic, naming can change but it should be trivial to fix in a follow up PR for integration", "author": "shaguptashaikh", "createdAt": "2020-02-25T00:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MjE5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383552191", "bodyText": "Why is this not in proceed() method? CanProceed() here should just verify if the kernel can be updated at this time. If there is not such check then this should just return true for now.", "author": "abanthiy", "createdAt": "2020-02-24T22:27:08Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/UpdatingKernelState.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+@RequiredArgsConstructor\n+public class UpdatingKernelState implements State {\n+\n+    private final DeploymentProcess deploymentProcess;\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private boolean updateFinished = false;\n+\n+    private static final String ROLLBACK_SNAPSHOT_PATH_FORMAT = \"rollback_snapshot_%s.tlog\";\n+\n+    @Override\n+    public boolean canProceed() {\n+        log.log(Log.Level.Note, \"<Updating>: updating kernel\");\n+\n+        // TODO : After taking this snapshot, deployment can wait for some time before performing a safe update\n+        // so consider moving this to Kernel\n+        String rollbackSnapshotPath =\n+                String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentProcess.getDeploymentPacket().getDeploymentId());\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(kernel.configPath.resolve(rollbackSnapshotPath));\n+        } catch (IOException e) {\n+            log.error(\"Error taking kernel snapshot\");\n+        }\n+\n+        // merge config\n+        Map<Object, Object> resolvedConfig = deploymentProcess.getResolvedKernelConfig();\n+        try {\n+            // TODO : Uncomment once following change to Kernel is merged\n+            // kernel.mergeInNewConfig(deploymentProcess.getDeploymentPacket().getDeploymentId(),\n+            // deploymentProcess.getDeploymentPacket().getDeploymentCreationTimestamp(),\n+            // resolvedConfig);\n+        } catch (Exception e) {\n+            log.error(\"Deployment failed, rolling back\");\n+            // TODO : Rollback handling should be more sophisticated, should it be its own state? Should it have retries?\n+            // Should revert changes to the local fleets-packages map/package registry as needed\n+            // All rolled back services should be restarted\n+\n+            // rollback to snapshot without waiting for a safe time\n+            try {\n+                kernel.read(kernel.configPath.resolve(rollbackSnapshotPath));\n+                // TODO : Set deployment status to RolledBack?\n+                log.log(Log.Level.Note, \"Deployment rolled back\");\n+            } catch (IOException re) {\n+                // TODO : Set deployment status to Failed_RolledBack?\n+                log.error(\"Failed to rollback deployment\");", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NzQ2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383587468", "bodyText": "Again, borrowed from the POC without giving too much thought since the state machine is anyway not the central point of focus for the demo, it has to be refactored with proper design no matter what. I didn't know the exact thought process behind writing implementation in proceed() for some states and canProceed() for the rest in the prototype, however, I can move the code around and put it into proceed method for this state", "author": "shaguptashaikh", "createdAt": "2020-02-25T00:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Nzc3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384097771", "bodyText": "Made this change", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNjkyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383626924", "bodyText": "You can use @Value annotation", "author": "fengwang666", "createdAt": "2020-02-25T02:30:17Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/Parameter.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+\n+@Getter\n+@AllArgsConstructor", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Nzc1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384097753", "bodyText": "Changed", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzIyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383627227", "bodyText": "Why do you need to use Map<String, Parameter>? What's the key of this map?", "author": "fengwang666", "createdAt": "2020-02-25T02:31:29Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAwOTU5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384009596", "bodyText": "+1 for adding a comment about what is in the map.", "author": "MikeDombo", "createdAt": "2020-02-25T17:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NzcyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384097720", "bodyText": "The key is parameter name for parameters set in deployment, for all parameters in a package, lookup this map for if any values were set in deployment, otherwise use default values. Naming and datastructure can slightly change when Jason's PR is merged and integrated with Rahul's code. Added comments to make things clear", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDQzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383630435", "bodyText": "Why is the value an Object?", "author": "fengwang666", "createdAt": "2020-02-25T02:45:07Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/model/Package.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.aws.iot.evergreen.packagemanager.model;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+@Getter\n+public class Package {\n+\n+    private final String serviceName;\n+\n+    private final String packageName;\n+\n+    private final String packageVersion;\n+\n+    private final Map<String, Object> lifecycle;", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxMjE0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384012148", "bodyText": "Because this represents the lifecycle key of the config store, the strings are the subkeys and the objects are the values. We don't know what the values will be since it can be strings, arrays, or further maps.", "author": "MikeDombo", "createdAt": "2020-02-25T17:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxMjMyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384012327", "bodyText": "Because this represents the lifecycle key of the config store, the strings are the subkeys and the objects are the values. We don't know what the values will be since it can be strings, arrays, or further maps.", "author": "MikeDombo", "createdAt": "2020-02-25T17:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxMjU5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384012590", "bodyText": "Because this represents the lifecycle key of the config store, the strings are the subkeys and the objects are the values. We don't know what the values will be since it can be strings, arrays, or further maps.", "author": "MikeDombo", "createdAt": "2020-02-25T17:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NzY4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384097688", "bodyText": "Also, the lifecycle is taken as it is after deserializing it from recipe, and the structure is already in alignment with what the kernel expects", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxMzIyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384013224", "bodyText": "Can you explain the packageName's @JsonProperty value of \" \"?", "author": "MikeDombo", "createdAt": "2020-02-25T17:18:08Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/model/Package.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.aws.iot.evergreen.packagemanager.model;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+@Getter\n+public class Package {\n+\n+    private final String serviceName;\n+\n+    private final String packageName;\n+\n+    private final String packageVersion;\n+\n+    private final Map<String, Object> lifecycle;\n+\n+    private final Set<String> artifactUrls;\n+\n+    private final Set<Dependency> dependencies;\n+\n+    private final Set<Parameter> parameters;\n+\n+    private final Map<String, Package> dependencyPackageMap;\n+\n+    @JsonCreator\n+    public Package(@JsonProperty(\"service\") String serviceName, @JsonProperty(\" \") String packageName,", "originalCommit": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NzYyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384097629", "bodyText": "That was a typo, corrected it", "author": "shaguptashaikh", "createdAt": "2020-02-25T20:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxMzIyNA=="}], "type": "inlineReview"}, {"oid": "20ca8d2a11289171a0734005e4fbcca5849b6f90", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/20ca8d2a11289171a0734005e4fbcca5849b6f90", "message": "Changes to update application layer protocol (#67)\n\n* Changes to update application layer protocol\r\n\r\n* removed * imports\r\n\r\n* addressed PR  comments\r\n\r\n* fixed check style issues\r\n\r\n* minor refactoring based on PR\r\n\r\n* Update pom.xml\r\n\r\nCo-authored-by: Michael Dombrowski <mikepi3.14@gmail.com>", "committedDate": "2020-02-25T19:59:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NzM2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384177369", "bodyText": "These lambdas can be changed to function references which should be more efficient since they won't create new objects for each run.\nex: convert p -> p.getServiceName() --> Package::getServiceName. IntelliJ can do this automatically.", "author": "MikeDombo", "createdAt": "2020-02-25T22:56:23Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values\n+     *\n+     * @param lifecycleKey key of the key value pair in lifecycle map\n+     * @param lifecycle lifecycle map\n+     * @param parametersFromDeployment parameters set in deployment for package\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {\n+                interpolate(lifecycleEntry.getKey(), childLifecycleMap, parametersFromDeployment, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment\n+     *\n+     * @param targetPackages top level packages\n+     * @return main service with updated dependencies\n+     * @throws Throwable\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Map<String, Package> targetPackages) throws Throwable {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(removedTopLevelPackages);\n+        kernelDependencies\n+                .addAll(targetPackages.values().stream().map(p -> p.getServiceName()).collect(Collectors.toSet()));", "originalCommit": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384201548", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T00:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NzM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODMyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384178320", "bodyText": "This can be Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle()); if I'm not mistaken.", "author": "MikeDombo", "createdAt": "2020-02-25T22:58:47Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());", "originalCommit": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTUyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384201527", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T00:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODU4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384178587", "bodyText": "Since this seems to only use the key, why not just use the keySet instead of entrySet?", "author": "MikeDombo", "createdAt": "2020-02-25T22:59:26Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }", "originalCommit": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTUxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384201510", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T00:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODk2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384178961", "bodyText": "Looks like this only uses the key here too, so maybe just use the keySet.", "author": "MikeDombo", "createdAt": "2020-02-25T23:00:19Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values\n+     *\n+     * @param lifecycleKey key of the key value pair in lifecycle map\n+     * @param lifecycle lifecycle map\n+     * @param parametersFromDeployment parameters set in deployment for package\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {", "originalCommit": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTQ4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384201489", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T00:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDMxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384180311", "bodyText": "Jason just merged, so I'm assuming that you'll bring in his things instead of defining your own, right?", "author": "MikeDombo", "createdAt": "2020-02-25T23:03:37Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -0,0 +1,18 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;", "originalCommit": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTQ0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384201445", "bodyText": "Merging that change into mine at the moment is a lot of work, I know I can't merge my change to master now that Jason's change is already in master. I'll spend some time working that out", "author": "shaguptashaikh", "createdAt": "2020-02-26T00:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDgwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384180800", "bodyText": "Technically I think this is part of the GIVEN since you're setting up what the mocks will do.\nThe \"WHEN\" should be the call to your code under test, which looks like like 79 to me.\nThen the \"THEN\" should be all your assertions.", "author": "MikeDombo", "createdAt": "2020-02-25T23:05:02Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/ConfigResolverTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class ConfigResolverTest {\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    EvergreenService mainService;\n+\n+    @Mock\n+    EvergreenService alreadyRunningService;\n+\n+    @Mock\n+    Log log;\n+\n+    private static final String LIFECYCLE_INSTALL_KEY = \"install\";\n+    private static final String LIFECYCLE_RUN_KEY = \"run\";\n+    private static final String LIFECYCLE_REQUIRES_KEY = \"requires\";\n+    private static final String LIFECYCLE_MOCK_INSTALL_COMMAND_FORMAT =\n+            \"echo installing service in Package %s with param {{params:%s_Param_1.value}}\";\n+    private static final String LIFECYCLE_MOCK_RUN_COMMAND_FORMAT =\n+            \"echo running service in Package %s with param {{params:%s_Param_2.value}}\";\n+\n+    private static final String TEST_INPUT_PACKAGE_A = \"PackageA\";\n+    private static final String TEST_INPUT_PACKAGE_B = \"PackageB\";\n+\n+    @Test\n+    public void GIVEN_deployment_for_package_WHEN_config_resolution_requested_THEN_add_service_and_dependency_service()\n+            throws Throwable {\n+        // GIVEN\n+        Map<String, Map<String, Parameter>> targetPackageConfigs = Collections.emptyMap();\n+\n+        Package topLevelPackage =\n+                getPackage(TEST_INPUT_PACKAGE_A, \"1.2\", Collections.singletonMap(TEST_INPUT_PACKAGE_B, \"2.3\"),\n+                        Collections.emptyMap());\n+        Package dependencyPackage =\n+                getPackage(TEST_INPUT_PACKAGE_B, \"2.3\", Collections.emptyMap(), Collections.emptyMap());\n+        topLevelPackage.getDependencyPackageMap().put(TEST_INPUT_PACKAGE_B, dependencyPackage);\n+        Map<String, Package> targetPackages = Collections.singletonMap(TEST_INPUT_PACKAGE_A, topLevelPackage);\n+\n+        Set<String> removedTopLevelPackages = Collections.emptySet();\n+\n+        ConfigResolver configResolver =\n+                new ConfigResolver(kernel, log, targetPackageConfigs, targetPackages, removedTopLevelPackages);\n+\n+        // WHEN\n+        when(kernel.getMain()).thenReturn(mainService);\n+        when(mainService.getName()).thenReturn(\"main\");\n+        when(mainService.getDependencies()).thenReturn(Collections.singletonMap(alreadyRunningService, State.Running));\n+        when(alreadyRunningService.getName()).thenReturn(\"IpcService\");", "originalCommit": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384200706", "bodyText": "Changed", "author": "shaguptashaikh", "createdAt": "2020-02-26T00:00:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDgwMA=="}], "type": "inlineReview"}, {"oid": "6c91ebc21c4a59eff49b0024e54ba2bd5122f2f4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c91ebc21c4a59eff49b0024e54ba2bd5122f2f4", "message": "Deployments - Update Kernel config with changes from depployment", "committedDate": "2020-02-25T23:10:07Z", "type": "forcePushed"}, {"oid": "f9d990bb3d354cf3ab801f74225ac07d16e6b981", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f9d990bb3d354cf3ab801f74225ac07d16e6b981", "message": "Deployments - Update Kernel config with changes from depployment", "committedDate": "2020-02-25T23:53:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4NzMxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384687315", "bodyText": "[nit]\nYou can make the logger static too.", "author": "MikeDombo", "createdAt": "2020-02-26T18:40:26Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs.\n+ */\n+@RequiredArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private final Set<String> removedTopLevelPackages;\n+\n+    private final Logger logger = LogManager.getLogger(getClass());", "originalCommit": "f9d990bb3d354cf3ab801f74225ac07d16e6b981", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDI5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384730291", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T19:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4NzMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4OTYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384689636", "bodyText": "If you were not aware, James added a templating system: https://github.com/aws/aws-greengrass-kernel/blob/3d6671737dbd585a09b685207a82a99d5933fef1/src/main/java/com/aws/iot/evergreen/kernel/EZTemplates.java#L27.\nSo we might want to use that if possible. But maybe it isn't possible and that's fine.", "author": "MikeDombo", "createdAt": "2020-02-26T18:44:57Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs.\n+ */\n+@RequiredArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private final Set<String> removedTopLevelPackages;\n+\n+    private final Logger logger = LogManager.getLogger(getClass());\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel.\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception when an error occurs while processing config or downstream\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            logger.atError().log(\"Error encountred while generating kernel config\");\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig   instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg         package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames =\n+                pkg.getDependencyPackageMap().values().stream().map(Package::getServiceName)\n+                        .collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey             key of the key value pair in lifecycle map\n+     * @param lifecycle                lifecycle map\n+     * @param parametersFromDeployment parameters set in deployment for package\n+     * @param packageParameters        all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,", "originalCommit": "f9d990bb3d354cf3ab801f74225ac07d16e6b981", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384731530", "bodyText": "Thanks for pointing that out. I will explore using this after the demo, config generation logic will need further changes to handle many more scenarios than the sprint goal. So there will be ongoing changes", "author": "shaguptashaikh", "createdAt": "2020-02-26T19:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4OTYzNg=="}], "type": "inlineReview"}, {"oid": "7e7704299e970229ab6afc148860107d7e0a428d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7e7704299e970229ab6afc148860107d7e0a428d", "message": "Deployments - Update Kernel config with changes from depployment", "committedDate": "2020-02-26T19:53:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDA0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384730040", "bodyText": "Log the error itself using setCause(e).", "author": "MikeDombo", "createdAt": "2020-02-26T19:56:07Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs.\n+ */\n+@RequiredArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Set<Package> packagesToDeploy;\n+\n+    private final Set<String> removedTopLevelPackages;\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel.\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception when an error occurs while processing config or downstream\n+     */\n+    public Map<Object, Object> resolveConfig() {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            packagesToDeploy.forEach(pkg -> processPackage(newConfig, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig());\n+\n+            return newConfig;\n+        } catch (Exception e) {\n+            logger.atError().log(\"Error encountred while generating kernel config\");", "originalCommit": "7e7704299e970229ab6afc148860107d7e0a428d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNjUwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384736504", "bodyText": "Not doing this now, it is being handled in the caller and logged, don't want to log and throw here", "author": "shaguptashaikh", "createdAt": "2020-02-26T20:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczOTE1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384739155", "bodyText": "In that case, why not just skip the catch and just have this method throw it without logging, since you say that the caller is handling it?", "author": "MikeDombo", "createdAt": "2020-02-26T20:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDUyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384764528", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T21:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDcwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384730703", "bodyText": "Update the year in your copyright notice.", "author": "MikeDombo", "createdAt": "2020-02-26T19:57:23Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/DownloadedState.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "originalCommit": "7e7704299e970229ab6afc148860107d7e0a428d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNjE5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384736193", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T20:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDcwMw=="}], "type": "inlineReview"}, {"oid": "8b48a12179910cfb6d2dd65a3aa0b266849c7050", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8b48a12179910cfb6d2dd65a3aa0b266849c7050", "message": "Deployments - Update Kernel config with changes from depployment", "committedDate": "2020-02-26T20:07:18Z", "type": "forcePushed"}, {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "message": "Deployments - Update Kernel config with changes from depployment", "committedDate": "2020-02-26T21:03:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2ODQzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384768438", "bodyText": "Nice!", "author": "leaf94", "createdAt": "2020-02-26T21:12:58Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/Package.java", "diffHunk": "@@ -66,11 +71,11 @@ public Package(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion reci\n                    @JsonProperty(\"Version\") Semver packageVersion,\n                    @JsonProperty(\"Description\") String description,\n                    @JsonProperty(\"Publisher\") String publisher,\n-                   @JsonProperty(\"Parameters\") HashSet<PackageParameter> packageParameters,\n-                   @JsonProperty(\"Lifecycle\") HashMap<String, Object> lifecycle,\n-                   @JsonProperty(\"Artifacts\") ArrayList<String> artifacts,\n-                   @JsonProperty(\"Dependencies\") HashMap<String, String> dependencies,\n-                   @JsonProperty(\"Requires\") ArrayList<String> requires) throws SemverException {\n+                   @JsonProperty(\"Parameters\") Set<PackageParameter> packageParameters,\n+                   @JsonProperty(\"Lifecycle\") Map<String, Object> lifecycle,\n+                   @JsonProperty(\"Artifacts\") List<String> artifacts,\n+                   @JsonProperty(\"Dependencies\") Map<String, String> dependencies,\n+                   @JsonProperty(\"Requires\") List<String> requires) throws SemverException {", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MDA5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384770098", "bodyText": "Could be long for now and I assume this is epoch milli second. But I'd prefer Instant instead.", "author": "leaf94", "createdAt": "2020-02-26T21:15:53Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -0,0 +1,17 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Getter\n+@Builder\n+public class DeploymentPacket {\n+\n+    private String deploymentId;\n+\n+    private long deploymentCreationTimestamp;", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDM2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830369", "bodyText": "This is expected to be passed as it is to kernel and since kernel expects long so I made this long as well.", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MDA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MTk3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384771976", "bodyText": "[nit] On the top?", "author": "leaf94", "createdAt": "2020-02-26T21:18:57Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDQ0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830447", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjU4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384772589", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<String> removedTopLevelPackages;\n          \n          \n            \n                private Set<String> removedTopLevelPackageNames; \n          \n      \n    \n    \n  \n\nmight be better since the type is Set<String> instead of Set<Package>", "author": "leaf94", "createdAt": "2020-02-26T21:20:05Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDQ2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830465", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mjg5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384772899", "bodyText": "[Optional] This feels like a DeploymentStateMachine even...", "author": "leaf94", "createdAt": "2020-02-26T21:20:44Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDQ3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830478", "bodyText": "Yes this is a state machine, however does not have a log of thought given to it, it needs redesign and optimizations. For now I've added TODOs for state machine related comments and things that should change, since addressing them now will take some time and I want to unblock other folks depending on this PR.", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mjg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDU2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384774561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int duration = 2;\n          \n          \n            \n                                Thread.sleep(TimeUnit.SECONDS.toMillis(2));\n          \n          \n            \n                                TimeUnit.MILLISECONDS.sleep(2);\n          \n      \n    \n    \n  \n\nAlso consider making 2 a class constant.", "author": "leaf94", "createdAt": "2020-02-26T21:23:51Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n+\n+    /**\n+     * Constructor to initialize deployment process.\n+     *\n+     * @param packet parsed deployment document\n+     * @param kernel running kernel instance\n+     */\n+    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n+        this.downloadedState = new DownloadedState(this, kernel);\n+        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n+\n+        // TODO : Change this to appropriate initial state when the initial state is implemented\n+        this.currentState = this.downloadedState;\n+        this.deploymentPacket = packet;\n+    }\n+\n+    /**\n+     * Execute deployment.\n+     */\n+    public void proceed() {\n+        while (!currentState.isFinalState()) {\n+            if (currentState.canProceed()) {\n+                currentState.proceed();\n+            } else {\n+                try {\n+                    int duration = 2;\n+                    Thread.sleep(TimeUnit.SECONDS.toMillis(2));", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDM4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830388", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDcyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384774721", "bodyText": "[nit] If this is indeed a state machine, then execute or run is better then proceed.", "author": "leaf94", "createdAt": "2020-02-26T21:24:11Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n+\n+    /**\n+     * Constructor to initialize deployment process.\n+     *\n+     * @param packet parsed deployment document\n+     * @param kernel running kernel instance\n+     */\n+    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n+        this.downloadedState = new DownloadedState(this, kernel);\n+        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n+\n+        // TODO : Change this to appropriate initial state when the initial state is implemented\n+        this.currentState = this.downloadedState;\n+        this.deploymentPacket = packet;\n+    }\n+\n+    /**\n+     * Execute deployment.\n+     */\n+    public void proceed() {", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDQzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830435", "bodyText": "Changed it to execute", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NzAwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384777001", "bodyText": "I think ConfigResolver could be singleton. Maybe put a TODO about we need to consider using DI here instead of creating it every time.", "author": "leaf94", "createdAt": "2020-02-26T21:28:32Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/DownloadedState.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.Map;\n+\n+/**\n+ * Deployment state after package dependencies have been resolved and packages have been downloaded.\n+ * Generates config to be merged when appropriate.\n+ */\n+@RequiredArgsConstructor\n+public class DownloadedState implements State {\n+\n+    private final DeploymentProcess deploymentProcess;\n+\n+    private final Kernel kernel;\n+\n+    private static final Logger logger = LogManager.getLogger(DownloadedState.class);\n+\n+    @Override\n+    public boolean canProceed() {\n+        logger.atInfo().log(\"<Downloaded>: checking if deployment can proceed\");\n+        // check update kernel conditions\n+        return true;\n+    }\n+\n+    @Override\n+    public void proceed() {\n+        logger.atInfo().log(\"<Downloaded>: proceed\");\n+        // resolve kernel config\n+        try {\n+            deploymentProcess.setResolvedKernelConfig(resolveKernelConfig());\n+            deploymentProcess.setCurrentState(deploymentProcess.getUpdatingKernelState());\n+        } catch (Exception e) {\n+            // TODO : Mark the deployment failed\n+            logger.atError().setEventType(\"donwloaded-state-error\").setCause(e).log(\"Error in downloaded state\");\n+        }\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        // TODO : Cleanup, revert package cache updates, etc\n+    }\n+\n+    private Map<Object, Object> resolveKernelConfig() {\n+        ConfigResolver configResolver = new ConfigResolver(kernel, deploymentProcess.getPackagesToDeploy(),", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDM0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830345", "bodyText": "Sure, adding a TODO since making this singleton and using DI will likely depend on whether the state machine itself and the states will be made singleton", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NzAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NjcyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384786723", "bodyText": "I think we should update the currentState here since we are handling the state.", "author": "leaf94", "createdAt": "2020-02-26T21:47:43Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n+\n+    /**\n+     * Constructor to initialize deployment process.\n+     *\n+     * @param packet parsed deployment document\n+     * @param kernel running kernel instance\n+     */\n+    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n+        this.downloadedState = new DownloadedState(this, kernel);\n+        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n+\n+        // TODO : Change this to appropriate initial state when the initial state is implemented\n+        this.currentState = this.downloadedState;\n+        this.deploymentPacket = packet;\n+    }\n+\n+    /**\n+     * Execute deployment.\n+     */\n+    public void proceed() {\n+        while (!currentState.isFinalState()) {\n+            if (currentState.canProceed()) {\n+                currentState.proceed();", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDQxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830417", "bodyText": "I agree, but as explained in my other reply, this can take some time to change so I've added TODOs for now", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NjcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjA0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384812048", "bodyText": "private", "author": "leaf94", "createdAt": "2020-02-26T22:41:23Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/ConfigResolverTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.aws.iot.evergreen.packagemanager.models.RecipeTemplateVersion;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class ConfigResolverTest {\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    EvergreenService mainService;\n+\n+    @Mock\n+    EvergreenService alreadyRunningService;", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDI4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830284", "bodyText": "Oops, done", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjEzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384812133", "bodyText": "On the top", "author": "leaf94", "createdAt": "2020-02-26T22:41:32Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/ConfigResolverTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.aws.iot.evergreen.packagemanager.models.RecipeTemplateVersion;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class ConfigResolverTest {\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    EvergreenService mainService;\n+\n+    @Mock\n+    EvergreenService alreadyRunningService;\n+\n+    private static final String LIFECYCLE_INSTALL_KEY = \"install\";\n+    private static final String LIFECYCLE_RUN_KEY = \"run\";\n+    private static final String LIFECYCLE_REQUIRES_KEY = \"requires\";\n+    private static final String LIFECYCLE_MOCK_INSTALL_COMMAND_FORMAT =\n+            \"echo installing service in Package %s with param {{params:%s_Param_1.value}}\";\n+    private static final String LIFECYCLE_MOCK_RUN_COMMAND_FORMAT =\n+            \"echo running service in Package %s with param {{params:%s_Param_2.value}}\";\n+\n+    private static final String TEST_INPUT_PACKAGE_A = \"PackageA\";\n+    private static final String TEST_INPUT_PACKAGE_B = \"PackageB\";", "originalCommit": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDI3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384830271", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-02-26T23:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjEzMw=="}], "type": "inlineReview"}, {"oid": "7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "message": "Deployments - Update Kernel config with changes from depployment", "committedDate": "2020-02-26T23:29:53Z", "type": "commit"}, {"oid": "7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "message": "Deployments - Update Kernel config with changes from depployment", "committedDate": "2020-02-26T23:29:53Z", "type": "forcePushed"}]}