{"pr_number": 460, "pr_title": "Add support for network proxies", "pr_createdAt": "2020-09-21T18:12:13Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460", "timeline": [{"oid": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "message": "Add support for network proxies", "committedDate": "2020-09-21T17:52:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTkxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492261914", "bodyText": "use kernel.getContext().get(DeviceConfiguration.class)", "author": "MikeDombo", "createdAt": "2020-09-21T18:26:42Z", "path": "src/main/java/com/aws/greengrass/lifecyclemanager/KernelLifecycle.java", "diffHunk": "@@ -104,6 +106,10 @@ public void launch() {\n         });\n \n         kernel.writeEffectiveConfig();\n+\n+        ProxyUtils.setSystemProxyProperties(kernel.getConfig().lookupTopics(DeviceConfiguration.SYSTEM_NAMESPACE_KEY,\n+                DeviceConfiguration.DEVICE_NETWORK_PROXY_NAMESPACE));", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MDk2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r493880960", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-09-23T20:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDUzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492264532", "bodyText": "none of this does anything AFAIK", "author": "MikeDombo", "createdAt": "2020-09-21T18:31:20Z", "path": "src/main/java/com/aws/greengrass/util/ProxyUtils.java", "diffHunk": "@@ -0,0 +1,341 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.Protocol;\n+import com.amazonaws.ProxyAuthenticationMethod;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.apache.ProxyConfiguration;\n+\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public final class ProxyUtils {\n+\n+    public static final String GREENGRASS_PROXY_URL_KEY = \"GREENGRASS_PROXY_URL\";\n+    public static final String GREENGRASS_PROXY_USERNAME_KEY = \"GREENGRASS_PROXY_USERNAME\";\n+    public static final String GREENGRASS_PROXY_PASSWORD_KEY = \"GREENGRASS_PROXY_PASSWORD\";\n+    public static final String GREENGRASS_PROXY_NOPROXYADDRESSES_KEY = \"GREENGRASS_PROXY_NOPROXYADDRESSES\";\n+\n+    private ProxyUtils() {\n+    }\n+\n+    /**\n+     * <p>Returns <code>scheme</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>scheme</code> is required and must be one of <code>http</code>, <code>https</code>, or\n+     * <code>socks5</code></p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>scheme</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getSchemeFromProxyUrl(String url) {\n+        return URI.create(url).getScheme();\n+    }\n+\n+    /**\n+     * <p>Returns <code>user:pass</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>user:pass</code> are optional</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>user:pass</code> in <code>scheme://user:pass@host:port</code> or <code>null</code> if absent\n+     */\n+    public static String getAuthFromProxyUrl(String url) {\n+        return URI.create(url).getUserInfo();\n+    }\n+\n+    /**\n+     * <p>Returns <code>host</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>host</code> is required</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>host</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getHostFromProxyUrl(String url) {\n+        return URI.create(url).getHost();\n+    }\n+\n+    private static int getDefaultPortForSchemeFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return 80;\n+            case \"https\":\n+                return 443;\n+            case \"socks5\":\n+                return 1080;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns <code>port</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>port</code> is optional. If not provided, returns 80 for http, 443 for https, 1080 for socks5, or -1\n+     * for any other scheme.</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>port</code> in <code>scheme://user:pass@host:port</code> or the default for the\n+     * <code>scheme</code>, -1 if <code>scheme</code> isn't recognized\n+     */\n+    public static int getPortFromProxyUrl(String url) {\n+        int userProvidedPort = URI.create(url).getPort();\n+        if (userProvidedPort != -1) {\n+            return userProvidedPort;\n+        }\n+        return getDefaultPortForSchemeFromProxyUrl(url);\n+    }\n+\n+    /**\n+     * <p>If the username is provided in the proxy url (i.e. <code>user</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the username is not provided in the proxy url, then the username config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyUsername User specified proxy username\n+     * @return Username field for proxy basic authentication or null if not found in url or username config topics\n+     */\n+    public static String getProxyUsername(String proxyUrl, String proxyUsername) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            return tokens[0];\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyUsername)) {\n+            return proxyUsername;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>If the password is provided in the proxy url (i.e. <code>pass</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the password is not provided in the proxy url, then the password config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyPassword User specified proxy password\n+     * @return Password field for proxy basic authentication or null if not found in url or password config topics\n+     */\n+    public static String getProxyPassword(String proxyUrl, String proxyPassword) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            if (tokens.length > 1) {\n+                return tokens[1];\n+            }\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyPassword)) {\n+            return proxyPassword;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Provides an software.amazon.awssdk.crt.http.HttpProxyOptions object that can be used when building various\n+     * CRT library clients (like mqtt and http)\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     * @return httpProxyOptions containing user proxy settings, if specified. If not, httpProxyOptions is null.\n+     */\n+    public static HttpProxyOptions getHttpProxyOptions(DeviceConfiguration deviceConfiguration) {\n+        HttpProxyOptions httpProxyOptions = null;\n+\n+        String proxyUrl = deviceConfiguration.getProxyUrl();\n+        String proxyUsername = getProxyUsername(deviceConfiguration.getProxyUrl(),\n+                deviceConfiguration.getProxyUsername());\n+\n+        if (StringUtils.isNotEmpty(proxyUrl)) {\n+            httpProxyOptions = new HttpProxyOptions();\n+            httpProxyOptions.setHost(ProxyUtils.getHostFromProxyUrl(proxyUrl));\n+            httpProxyOptions.setPort(ProxyUtils.getPortFromProxyUrl(proxyUrl));\n+\n+            if (StringUtils.isNotEmpty(proxyUsername)) {\n+                httpProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                httpProxyOptions.setAuthorizationUsername(proxyUsername);\n+                httpProxyOptions.setAuthorizationPassword(getProxyPassword(deviceConfiguration.getProxyUrl(),\n+                        deviceConfiguration.getProxyPassword()));\n+            }\n+        }\n+\n+        return httpProxyOptions;\n+    }\n+\n+    /**\n+     * <p>Sets the GREENGRASS_PROXY_* system properties with values from the networkProxy topic.</p>\n+     *\n+     * @param networkProxyNamespace networkProxy topic\n+     */\n+    public static void setSystemProxyProperties(Topics networkProxyNamespace) {\n+        if (networkProxyNamespace == null) {\n+            return;\n+        }\n+\n+        String noProxyAddresses = Coerce.toString(networkProxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_NO_PROXY_ADDRESSES));\n+        Topics proxyNamespace = networkProxyNamespace.lookupTopics(DeviceConfiguration.DEVICE_PROXY_NAMESPACE);\n+        String url = Coerce.toString(proxyNamespace.findOrDefault(\"\", DeviceConfiguration.DEVICE_PARAM_PROXY_URL));\n+        String username = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_USERNAME));\n+        String password = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_PASSWORD));\n+\n+        System.setProperty(GREENGRASS_PROXY_URL_KEY, url);\n+        System.setProperty(GREENGRASS_PROXY_USERNAME_KEY, username);\n+        System.setProperty(GREENGRASS_PROXY_PASSWORD_KEY, password);\n+        System.setProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY, noProxyAddresses);", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzMTYyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499031624", "bodyText": "Yup, moved to fields after moving the DeviceProvisioningHelper constructor call.", "author": "tomnagy-aws", "createdAt": "2020-10-02T20:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDk1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492264953", "bodyText": "using properties isn't really necessary, just store these as fields in this class", "author": "MikeDombo", "createdAt": "2020-09-21T18:32:08Z", "path": "src/main/java/com/aws/greengrass/util/ProxyUtils.java", "diffHunk": "@@ -0,0 +1,341 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.Protocol;\n+import com.amazonaws.ProxyAuthenticationMethod;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.apache.ProxyConfiguration;\n+\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public final class ProxyUtils {\n+\n+    public static final String GREENGRASS_PROXY_URL_KEY = \"GREENGRASS_PROXY_URL\";\n+    public static final String GREENGRASS_PROXY_USERNAME_KEY = \"GREENGRASS_PROXY_USERNAME\";\n+    public static final String GREENGRASS_PROXY_PASSWORD_KEY = \"GREENGRASS_PROXY_PASSWORD\";\n+    public static final String GREENGRASS_PROXY_NOPROXYADDRESSES_KEY = \"GREENGRASS_PROXY_NOPROXYADDRESSES\";\n+\n+    private ProxyUtils() {\n+    }\n+\n+    /**\n+     * <p>Returns <code>scheme</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>scheme</code> is required and must be one of <code>http</code>, <code>https</code>, or\n+     * <code>socks5</code></p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>scheme</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getSchemeFromProxyUrl(String url) {\n+        return URI.create(url).getScheme();\n+    }\n+\n+    /**\n+     * <p>Returns <code>user:pass</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>user:pass</code> are optional</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>user:pass</code> in <code>scheme://user:pass@host:port</code> or <code>null</code> if absent\n+     */\n+    public static String getAuthFromProxyUrl(String url) {\n+        return URI.create(url).getUserInfo();\n+    }\n+\n+    /**\n+     * <p>Returns <code>host</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>host</code> is required</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>host</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getHostFromProxyUrl(String url) {\n+        return URI.create(url).getHost();\n+    }\n+\n+    private static int getDefaultPortForSchemeFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return 80;\n+            case \"https\":\n+                return 443;\n+            case \"socks5\":\n+                return 1080;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns <code>port</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>port</code> is optional. If not provided, returns 80 for http, 443 for https, 1080 for socks5, or -1\n+     * for any other scheme.</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>port</code> in <code>scheme://user:pass@host:port</code> or the default for the\n+     * <code>scheme</code>, -1 if <code>scheme</code> isn't recognized\n+     */\n+    public static int getPortFromProxyUrl(String url) {\n+        int userProvidedPort = URI.create(url).getPort();\n+        if (userProvidedPort != -1) {\n+            return userProvidedPort;\n+        }\n+        return getDefaultPortForSchemeFromProxyUrl(url);\n+    }\n+\n+    /**\n+     * <p>If the username is provided in the proxy url (i.e. <code>user</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the username is not provided in the proxy url, then the username config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyUsername User specified proxy username\n+     * @return Username field for proxy basic authentication or null if not found in url or username config topics\n+     */\n+    public static String getProxyUsername(String proxyUrl, String proxyUsername) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            return tokens[0];\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyUsername)) {\n+            return proxyUsername;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>If the password is provided in the proxy url (i.e. <code>pass</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the password is not provided in the proxy url, then the password config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyPassword User specified proxy password\n+     * @return Password field for proxy basic authentication or null if not found in url or password config topics\n+     */\n+    public static String getProxyPassword(String proxyUrl, String proxyPassword) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            if (tokens.length > 1) {\n+                return tokens[1];\n+            }\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyPassword)) {\n+            return proxyPassword;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Provides an software.amazon.awssdk.crt.http.HttpProxyOptions object that can be used when building various\n+     * CRT library clients (like mqtt and http)\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     * @return httpProxyOptions containing user proxy settings, if specified. If not, httpProxyOptions is null.\n+     */\n+    public static HttpProxyOptions getHttpProxyOptions(DeviceConfiguration deviceConfiguration) {\n+        HttpProxyOptions httpProxyOptions = null;\n+\n+        String proxyUrl = deviceConfiguration.getProxyUrl();\n+        String proxyUsername = getProxyUsername(deviceConfiguration.getProxyUrl(),\n+                deviceConfiguration.getProxyUsername());\n+\n+        if (StringUtils.isNotEmpty(proxyUrl)) {\n+            httpProxyOptions = new HttpProxyOptions();\n+            httpProxyOptions.setHost(ProxyUtils.getHostFromProxyUrl(proxyUrl));\n+            httpProxyOptions.setPort(ProxyUtils.getPortFromProxyUrl(proxyUrl));\n+\n+            if (StringUtils.isNotEmpty(proxyUsername)) {\n+                httpProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                httpProxyOptions.setAuthorizationUsername(proxyUsername);\n+                httpProxyOptions.setAuthorizationPassword(getProxyPassword(deviceConfiguration.getProxyUrl(),\n+                        deviceConfiguration.getProxyPassword()));\n+            }\n+        }\n+\n+        return httpProxyOptions;\n+    }\n+\n+    /**\n+     * <p>Sets the GREENGRASS_PROXY_* system properties with values from the networkProxy topic.</p>\n+     *\n+     * @param networkProxyNamespace networkProxy topic\n+     */\n+    public static void setSystemProxyProperties(Topics networkProxyNamespace) {\n+        if (networkProxyNamespace == null) {\n+            return;\n+        }\n+\n+        String noProxyAddresses = Coerce.toString(networkProxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_NO_PROXY_ADDRESSES));\n+        Topics proxyNamespace = networkProxyNamespace.lookupTopics(DeviceConfiguration.DEVICE_PROXY_NAMESPACE);\n+        String url = Coerce.toString(proxyNamespace.findOrDefault(\"\", DeviceConfiguration.DEVICE_PARAM_PROXY_URL));\n+        String username = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_USERNAME));\n+        String password = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_PASSWORD));\n+\n+        System.setProperty(GREENGRASS_PROXY_URL_KEY, url);\n+        System.setProperty(GREENGRASS_PROXY_USERNAME_KEY, username);\n+        System.setProperty(GREENGRASS_PROXY_PASSWORD_KEY, password);\n+        System.setProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY, noProxyAddresses);\n+    }\n+\n+    /**\n+     * <p>Boilerplate for providing a proxy configured ApacheHttpClient to AWS SDK v2 client builders.</p>\n+     *\n+     * <p>If you need to customize the HttpClient, but still need proxy support, use <code>ProxyUtils\n+     * .getProxyConfiguration()</code></p>\n+     *\n+     * @return httpClient built with a ProxyConfiguration or null if no proxy is configured (null is ignored in AWS\n+     *     SDK clients)\n+     */\n+    public static SdkHttpClient getSdkHttpClient() {\n+        ProxyConfiguration proxyConfiguration = getProxyConfiguration();\n+        SdkHttpClient httpClient = null;\n+\n+        if (proxyConfiguration != null) {\n+            httpClient = ApacheHttpClient.builder()\n+                    .proxyConfiguration(proxyConfiguration)\n+                    .build();\n+        }\n+\n+        return httpClient;\n+    }\n+\n+    private static String removeAuthFromProxyUrl(String proxyUrl) {\n+        URI uri = URI.create(proxyUrl);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(uri.getScheme()).append(\"://\").append(uri.getHost());\n+\n+        if (uri.getPort() != -1) {\n+            sb.append(':').append(uri.getPort());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>Boilerplate for providing a <code>ProxyConfiguration</code> to AWS SDK v2 <code>ApacheHttpClient</code>s.</p>\n+     *\n+     * @return ProxyConfiguration built with user proxy values or null if no proxy is configured (null is ignored in\n+     *     the SDK)\n+     */\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")\n+    public static ProxyConfiguration getProxyConfiguration() {\n+        String url = System.getProperty(GREENGRASS_PROXY_URL_KEY);\n+        String usernameFromConfig = System.getProperty(GREENGRASS_PROXY_USERNAME_KEY);\n+        String passwordFromConfig = System.getProperty(GREENGRASS_PROXY_PASSWORD_KEY);\n+        String noProxyAddresses = System.getProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY);", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MDE5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r496080196", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-09-28T16:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTIwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492265204", "bodyText": "use !Utils.isEmpty from our own utils", "author": "MikeDombo", "createdAt": "2020-09-21T18:32:35Z", "path": "src/main/java/com/aws/greengrass/util/ProxyUtils.java", "diffHunk": "@@ -0,0 +1,341 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.Protocol;\n+import com.amazonaws.ProxyAuthenticationMethod;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.apache.ProxyConfiguration;\n+\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public final class ProxyUtils {\n+\n+    public static final String GREENGRASS_PROXY_URL_KEY = \"GREENGRASS_PROXY_URL\";\n+    public static final String GREENGRASS_PROXY_USERNAME_KEY = \"GREENGRASS_PROXY_USERNAME\";\n+    public static final String GREENGRASS_PROXY_PASSWORD_KEY = \"GREENGRASS_PROXY_PASSWORD\";\n+    public static final String GREENGRASS_PROXY_NOPROXYADDRESSES_KEY = \"GREENGRASS_PROXY_NOPROXYADDRESSES\";\n+\n+    private ProxyUtils() {\n+    }\n+\n+    /**\n+     * <p>Returns <code>scheme</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>scheme</code> is required and must be one of <code>http</code>, <code>https</code>, or\n+     * <code>socks5</code></p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>scheme</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getSchemeFromProxyUrl(String url) {\n+        return URI.create(url).getScheme();\n+    }\n+\n+    /**\n+     * <p>Returns <code>user:pass</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>user:pass</code> are optional</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>user:pass</code> in <code>scheme://user:pass@host:port</code> or <code>null</code> if absent\n+     */\n+    public static String getAuthFromProxyUrl(String url) {\n+        return URI.create(url).getUserInfo();\n+    }\n+\n+    /**\n+     * <p>Returns <code>host</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>host</code> is required</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>host</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getHostFromProxyUrl(String url) {\n+        return URI.create(url).getHost();\n+    }\n+\n+    private static int getDefaultPortForSchemeFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return 80;\n+            case \"https\":\n+                return 443;\n+            case \"socks5\":\n+                return 1080;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns <code>port</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>port</code> is optional. If not provided, returns 80 for http, 443 for https, 1080 for socks5, or -1\n+     * for any other scheme.</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>port</code> in <code>scheme://user:pass@host:port</code> or the default for the\n+     * <code>scheme</code>, -1 if <code>scheme</code> isn't recognized\n+     */\n+    public static int getPortFromProxyUrl(String url) {\n+        int userProvidedPort = URI.create(url).getPort();\n+        if (userProvidedPort != -1) {\n+            return userProvidedPort;\n+        }\n+        return getDefaultPortForSchemeFromProxyUrl(url);\n+    }\n+\n+    /**\n+     * <p>If the username is provided in the proxy url (i.e. <code>user</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the username is not provided in the proxy url, then the username config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyUsername User specified proxy username\n+     * @return Username field for proxy basic authentication or null if not found in url or username config topics\n+     */\n+    public static String getProxyUsername(String proxyUrl, String proxyUsername) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            return tokens[0];\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyUsername)) {\n+            return proxyUsername;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>If the password is provided in the proxy url (i.e. <code>pass</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the password is not provided in the proxy url, then the password config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyPassword User specified proxy password\n+     * @return Password field for proxy basic authentication or null if not found in url or password config topics\n+     */\n+    public static String getProxyPassword(String proxyUrl, String proxyPassword) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            if (tokens.length > 1) {\n+                return tokens[1];\n+            }\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyPassword)) {\n+            return proxyPassword;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Provides an software.amazon.awssdk.crt.http.HttpProxyOptions object that can be used when building various\n+     * CRT library clients (like mqtt and http)\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     * @return httpProxyOptions containing user proxy settings, if specified. If not, httpProxyOptions is null.\n+     */\n+    public static HttpProxyOptions getHttpProxyOptions(DeviceConfiguration deviceConfiguration) {\n+        HttpProxyOptions httpProxyOptions = null;\n+\n+        String proxyUrl = deviceConfiguration.getProxyUrl();\n+        String proxyUsername = getProxyUsername(deviceConfiguration.getProxyUrl(),\n+                deviceConfiguration.getProxyUsername());\n+\n+        if (StringUtils.isNotEmpty(proxyUrl)) {\n+            httpProxyOptions = new HttpProxyOptions();\n+            httpProxyOptions.setHost(ProxyUtils.getHostFromProxyUrl(proxyUrl));\n+            httpProxyOptions.setPort(ProxyUtils.getPortFromProxyUrl(proxyUrl));\n+\n+            if (StringUtils.isNotEmpty(proxyUsername)) {\n+                httpProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                httpProxyOptions.setAuthorizationUsername(proxyUsername);\n+                httpProxyOptions.setAuthorizationPassword(getProxyPassword(deviceConfiguration.getProxyUrl(),\n+                        deviceConfiguration.getProxyPassword()));\n+            }\n+        }\n+\n+        return httpProxyOptions;\n+    }\n+\n+    /**\n+     * <p>Sets the GREENGRASS_PROXY_* system properties with values from the networkProxy topic.</p>\n+     *\n+     * @param networkProxyNamespace networkProxy topic\n+     */\n+    public static void setSystemProxyProperties(Topics networkProxyNamespace) {\n+        if (networkProxyNamespace == null) {\n+            return;\n+        }\n+\n+        String noProxyAddresses = Coerce.toString(networkProxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_NO_PROXY_ADDRESSES));\n+        Topics proxyNamespace = networkProxyNamespace.lookupTopics(DeviceConfiguration.DEVICE_PROXY_NAMESPACE);\n+        String url = Coerce.toString(proxyNamespace.findOrDefault(\"\", DeviceConfiguration.DEVICE_PARAM_PROXY_URL));\n+        String username = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_USERNAME));\n+        String password = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_PASSWORD));\n+\n+        System.setProperty(GREENGRASS_PROXY_URL_KEY, url);\n+        System.setProperty(GREENGRASS_PROXY_USERNAME_KEY, username);\n+        System.setProperty(GREENGRASS_PROXY_PASSWORD_KEY, password);\n+        System.setProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY, noProxyAddresses);\n+    }\n+\n+    /**\n+     * <p>Boilerplate for providing a proxy configured ApacheHttpClient to AWS SDK v2 client builders.</p>\n+     *\n+     * <p>If you need to customize the HttpClient, but still need proxy support, use <code>ProxyUtils\n+     * .getProxyConfiguration()</code></p>\n+     *\n+     * @return httpClient built with a ProxyConfiguration or null if no proxy is configured (null is ignored in AWS\n+     *     SDK clients)\n+     */\n+    public static SdkHttpClient getSdkHttpClient() {\n+        ProxyConfiguration proxyConfiguration = getProxyConfiguration();\n+        SdkHttpClient httpClient = null;\n+\n+        if (proxyConfiguration != null) {\n+            httpClient = ApacheHttpClient.builder()\n+                    .proxyConfiguration(proxyConfiguration)\n+                    .build();\n+        }\n+\n+        return httpClient;\n+    }\n+\n+    private static String removeAuthFromProxyUrl(String proxyUrl) {\n+        URI uri = URI.create(proxyUrl);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(uri.getScheme()).append(\"://\").append(uri.getHost());\n+\n+        if (uri.getPort() != -1) {\n+            sb.append(':').append(uri.getPort());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>Boilerplate for providing a <code>ProxyConfiguration</code> to AWS SDK v2 <code>ApacheHttpClient</code>s.</p>\n+     *\n+     * @return ProxyConfiguration built with user proxy values or null if no proxy is configured (null is ignored in\n+     *     the SDK)\n+     */\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")\n+    public static ProxyConfiguration getProxyConfiguration() {\n+        String url = System.getProperty(GREENGRASS_PROXY_URL_KEY);\n+        String usernameFromConfig = System.getProperty(GREENGRASS_PROXY_USERNAME_KEY);\n+        String passwordFromConfig = System.getProperty(GREENGRASS_PROXY_PASSWORD_KEY);\n+        String noProxyAddresses = System.getProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY);\n+\n+        if (StringUtils.isEmpty(url)) {\n+            return null;\n+        }\n+\n+        // ProxyConfiguration throws an error if auth data is included in the url\n+        String urlWithoutAuth = removeAuthFromProxyUrl(url);\n+\n+        String username = getProxyUsername(url, usernameFromConfig);\n+        String password = getProxyPassword(url, passwordFromConfig);\n+\n+        Set<String> nonProxyHosts = Collections.emptySet();\n+        if (StringUtils.isNotEmpty(noProxyAddresses)) {\n+            nonProxyHosts = Arrays.stream(noProxyAddresses.split(\",\")).collect(Collectors.toSet());\n+        }\n+\n+        return ProxyConfiguration.builder()\n+                .endpoint(URI.create(urlWithoutAuth))\n+                .username(username)\n+                .password(password)\n+                .nonProxyHosts(nonProxyHosts)\n+                .build();\n+    }\n+\n+    /**\n+     * <p>Returns a <code>com.amazonaws.Protocol</code> for configuring a proxy in v1 of the AWS SDK.</p>\n+     *\n+     * <p>SOCKS is not supported (SDK limitation)</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return Protocol, either HTTP or HTTPS or null for all other values\n+     */\n+    public static Protocol getProtocolFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return Protocol.HTTP;\n+            case \"https\":\n+                return Protocol.HTTPS;\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    /**\n+     * <p>Boilerplate for providing a <code>ClientConfiguration</code> with proxy values to AWS SDK v1 client\n+     * builders.</p>\n+     *\n+     * <p>SOCKS is not supported (SDK limitation)</p>\n+     *\n+     * @return ClientConfiguration built with proxy values, if present\n+     */\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")\n+    public static ClientConfiguration getClientConfiguration() {\n+        final String url = System.getProperty(GREENGRASS_PROXY_URL_KEY);\n+        final String usernameFromConfig = System.getProperty(GREENGRASS_PROXY_USERNAME_KEY);\n+        final String passwordFromConfig = System.getProperty(GREENGRASS_PROXY_PASSWORD_KEY);\n+        final String noProxyAddresses = System.getProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY);\n+\n+        ClientConfiguration clientConfiguration = new ClientConfiguration();\n+\n+        if (StringUtils.isEmpty(url)) {\n+            return clientConfiguration;\n+        }\n+\n+        clientConfiguration.setProxyProtocol(getProtocolFromProxyUrl(url));\n+        clientConfiguration.setProxyHost(getHostFromProxyUrl(url));\n+        clientConfiguration.setProxyPort(getPortFromProxyUrl(url));\n+\n+        String username = getProxyUsername(url, usernameFromConfig);\n+        if (StringUtils.isNotEmpty(username)) {\n+            clientConfiguration.setProxyAuthenticationMethods(Arrays.asList(ProxyAuthenticationMethod.BASIC));\n+            clientConfiguration.setProxyUsername(username);\n+            clientConfiguration.setProxyPassword(getProxyPassword(url, passwordFromConfig));\n+        }\n+\n+        if (StringUtils.isNotEmpty(noProxyAddresses)) {", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTExNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r493881116", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-09-23T20:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTUwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492265503", "bodyText": "no * imports. Import codestyle/IntelliJ.xml to setup your IDE", "author": "MikeDombo", "createdAt": "2020-09-21T18:33:08Z", "path": "src/test/java/com/aws/greengrass/util/ProxyUtilsTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.mockito.Mockito.*;", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r493881163", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-09-23T20:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MTk3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492281978", "bodyText": "We have our own credentials provider which is \"TES\". Extend the CredentialsProvider and implement that using our own LazyCredentialProvider and use our dependency injection to create all these objects.", "author": "MikeDombo", "createdAt": "2020-09-21T19:03:24Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -95,20 +102,62 @@\n      * @param executorService     executor service\n      */\n     @Inject\n+    @SuppressWarnings(\"PMD.ConfusingTernary\")\n     public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n         this(deviceConfiguration, null, executorService);\n-        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n-                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n-                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n-                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n-                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n-                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n-                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n-                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n-                .withPingTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n-                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        if (httpProxyOptions != null) {\n+            try (TlsContextOptions x509TlsOptions = TlsContextOptions.createWithMtlsFromPath(\n+                    Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                    Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))) {\n+\n+                x509TlsOptions.withCertificateAuthorityFromPath(null,\n+                        Coerce.toString(deviceConfiguration.getRootCAFilePath()));\n+\n+                try (ClientTlsContext x509TlsContext = new ClientTlsContext(x509TlsOptions)) {\n+                    this.credentialsProvider = new X509CredentialsProvider.X509CredentialsProviderBuilder()\n+                            .withClientBootstrap(clientBootstrap)\n+                            .withTlsContext(x509TlsContext)\n+                            .withEndpoint(Coerce.toString(deviceConfiguration.getIotCredentialEndpoint()))\n+                            .withRoleAlias(Coerce.toString(mqttTopics.find(MQTT_CREDENTIAL_ROLE_ALIAS_KEY)))\n+                            .withThingName(Coerce.toString(deviceConfiguration.getThingName()))\n+                            .withProxyOptions(httpProxyOptions)\n+                            .build();", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzMjE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499032140", "bodyText": "Current SDK functionality doesn't allow this. Using X509CredentialsProvider for now and will work on getting proper proxy support included in the device SDK.", "author": "tomnagy-aws", "createdAt": "2020-10-02T20:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyODgyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492428824", "bodyText": "Do we really need to create a new HTTP client for every SDK client? I'd be interested in see how a shared client impact the service.", "author": "philcali", "createdAt": "2020-09-22T01:15:59Z", "path": "src/main/java/com/aws/greengrass/util/IotSdkClientFactory.java", "diffHunk": "@@ -88,8 +92,9 @@ public static IotClient getIotClient(String awsRegion, EnvironmentStage stage,\n         Set<Class<? extends Exception>> allExceptionsToRetryOn = new HashSet<>();\n         allExceptionsToRetryOn.addAll(retryableIoTExceptions);\n         allExceptionsToRetryOn.addAll(additionalRetryableExceptions);\n-        IotClientBuilder iotClientBuilder = IotClient.builder().region(Region.of(awsRegion)).overrideConfiguration(\n-                ClientOverrideConfiguration.builder().retryPolicy(\n+        IotClientBuilder iotClientBuilder = IotClient.builder().region(Region.of(awsRegion))\n+                .httpClient(ProxyUtils.getSdkHttpClient())", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NjExMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r494576112", "bodyText": "Similar to the netty discussion: The current SDK behavior (I believe) is to build a new http client for each service client. This should be researched and considered in a new issue.", "author": "tomnagy-aws", "createdAt": "2020-09-24T19:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyODgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyOTgwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492429809", "bodyText": "Since we convert down to | later on, should we replace both in case the customer copy/pastes their SDK proxy config in other places? ,|\\\\|", "author": "philcali", "createdAt": "2020-09-22T01:20:23Z", "path": "src/main/java/com/aws/greengrass/util/ProxyUtils.java", "diffHunk": "@@ -0,0 +1,341 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.Protocol;\n+import com.amazonaws.ProxyAuthenticationMethod;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.apache.ProxyConfiguration;\n+\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public final class ProxyUtils {\n+\n+    public static final String GREENGRASS_PROXY_URL_KEY = \"GREENGRASS_PROXY_URL\";\n+    public static final String GREENGRASS_PROXY_USERNAME_KEY = \"GREENGRASS_PROXY_USERNAME\";\n+    public static final String GREENGRASS_PROXY_PASSWORD_KEY = \"GREENGRASS_PROXY_PASSWORD\";\n+    public static final String GREENGRASS_PROXY_NOPROXYADDRESSES_KEY = \"GREENGRASS_PROXY_NOPROXYADDRESSES\";\n+\n+    private ProxyUtils() {\n+    }\n+\n+    /**\n+     * <p>Returns <code>scheme</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>scheme</code> is required and must be one of <code>http</code>, <code>https</code>, or\n+     * <code>socks5</code></p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>scheme</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getSchemeFromProxyUrl(String url) {\n+        return URI.create(url).getScheme();\n+    }\n+\n+    /**\n+     * <p>Returns <code>user:pass</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>user:pass</code> are optional</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>user:pass</code> in <code>scheme://user:pass@host:port</code> or <code>null</code> if absent\n+     */\n+    public static String getAuthFromProxyUrl(String url) {\n+        return URI.create(url).getUserInfo();\n+    }\n+\n+    /**\n+     * <p>Returns <code>host</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>host</code> is required</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>host</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getHostFromProxyUrl(String url) {\n+        return URI.create(url).getHost();\n+    }\n+\n+    private static int getDefaultPortForSchemeFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return 80;\n+            case \"https\":\n+                return 443;\n+            case \"socks5\":\n+                return 1080;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns <code>port</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>port</code> is optional. If not provided, returns 80 for http, 443 for https, 1080 for socks5, or -1\n+     * for any other scheme.</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>port</code> in <code>scheme://user:pass@host:port</code> or the default for the\n+     * <code>scheme</code>, -1 if <code>scheme</code> isn't recognized\n+     */\n+    public static int getPortFromProxyUrl(String url) {\n+        int userProvidedPort = URI.create(url).getPort();\n+        if (userProvidedPort != -1) {\n+            return userProvidedPort;\n+        }\n+        return getDefaultPortForSchemeFromProxyUrl(url);\n+    }\n+\n+    /**\n+     * <p>If the username is provided in the proxy url (i.e. <code>user</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the username is not provided in the proxy url, then the username config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyUsername User specified proxy username\n+     * @return Username field for proxy basic authentication or null if not found in url or username config topics\n+     */\n+    public static String getProxyUsername(String proxyUrl, String proxyUsername) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            return tokens[0];\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyUsername)) {\n+            return proxyUsername;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>If the password is provided in the proxy url (i.e. <code>pass</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the password is not provided in the proxy url, then the password config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyPassword User specified proxy password\n+     * @return Password field for proxy basic authentication or null if not found in url or password config topics\n+     */\n+    public static String getProxyPassword(String proxyUrl, String proxyPassword) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (StringUtils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            if (tokens.length > 1) {\n+                return tokens[1];\n+            }\n+        }\n+\n+        if (StringUtils.isNotEmpty(proxyPassword)) {\n+            return proxyPassword;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Provides an software.amazon.awssdk.crt.http.HttpProxyOptions object that can be used when building various\n+     * CRT library clients (like mqtt and http)\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     * @return httpProxyOptions containing user proxy settings, if specified. If not, httpProxyOptions is null.\n+     */\n+    public static HttpProxyOptions getHttpProxyOptions(DeviceConfiguration deviceConfiguration) {\n+        HttpProxyOptions httpProxyOptions = null;\n+\n+        String proxyUrl = deviceConfiguration.getProxyUrl();\n+        String proxyUsername = getProxyUsername(deviceConfiguration.getProxyUrl(),\n+                deviceConfiguration.getProxyUsername());\n+\n+        if (StringUtils.isNotEmpty(proxyUrl)) {\n+            httpProxyOptions = new HttpProxyOptions();\n+            httpProxyOptions.setHost(ProxyUtils.getHostFromProxyUrl(proxyUrl));\n+            httpProxyOptions.setPort(ProxyUtils.getPortFromProxyUrl(proxyUrl));\n+\n+            if (StringUtils.isNotEmpty(proxyUsername)) {\n+                httpProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                httpProxyOptions.setAuthorizationUsername(proxyUsername);\n+                httpProxyOptions.setAuthorizationPassword(getProxyPassword(deviceConfiguration.getProxyUrl(),\n+                        deviceConfiguration.getProxyPassword()));\n+            }\n+        }\n+\n+        return httpProxyOptions;\n+    }\n+\n+    /**\n+     * <p>Sets the GREENGRASS_PROXY_* system properties with values from the networkProxy topic.</p>\n+     *\n+     * @param networkProxyNamespace networkProxy topic\n+     */\n+    public static void setSystemProxyProperties(Topics networkProxyNamespace) {\n+        if (networkProxyNamespace == null) {\n+            return;\n+        }\n+\n+        String noProxyAddresses = Coerce.toString(networkProxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_NO_PROXY_ADDRESSES));\n+        Topics proxyNamespace = networkProxyNamespace.lookupTopics(DeviceConfiguration.DEVICE_PROXY_NAMESPACE);\n+        String url = Coerce.toString(proxyNamespace.findOrDefault(\"\", DeviceConfiguration.DEVICE_PARAM_PROXY_URL));\n+        String username = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_USERNAME));\n+        String password = Coerce.toString(proxyNamespace.findOrDefault(\"\",\n+                DeviceConfiguration.DEVICE_PARAM_PROXY_PASSWORD));\n+\n+        System.setProperty(GREENGRASS_PROXY_URL_KEY, url);\n+        System.setProperty(GREENGRASS_PROXY_USERNAME_KEY, username);\n+        System.setProperty(GREENGRASS_PROXY_PASSWORD_KEY, password);\n+        System.setProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY, noProxyAddresses);\n+    }\n+\n+    /**\n+     * <p>Boilerplate for providing a proxy configured ApacheHttpClient to AWS SDK v2 client builders.</p>\n+     *\n+     * <p>If you need to customize the HttpClient, but still need proxy support, use <code>ProxyUtils\n+     * .getProxyConfiguration()</code></p>\n+     *\n+     * @return httpClient built with a ProxyConfiguration or null if no proxy is configured (null is ignored in AWS\n+     *     SDK clients)\n+     */\n+    public static SdkHttpClient getSdkHttpClient() {\n+        ProxyConfiguration proxyConfiguration = getProxyConfiguration();\n+        SdkHttpClient httpClient = null;\n+\n+        if (proxyConfiguration != null) {\n+            httpClient = ApacheHttpClient.builder()\n+                    .proxyConfiguration(proxyConfiguration)\n+                    .build();\n+        }\n+\n+        return httpClient;\n+    }\n+\n+    private static String removeAuthFromProxyUrl(String proxyUrl) {\n+        URI uri = URI.create(proxyUrl);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(uri.getScheme()).append(\"://\").append(uri.getHost());\n+\n+        if (uri.getPort() != -1) {\n+            sb.append(':').append(uri.getPort());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>Boilerplate for providing a <code>ProxyConfiguration</code> to AWS SDK v2 <code>ApacheHttpClient</code>s.</p>\n+     *\n+     * @return ProxyConfiguration built with user proxy values or null if no proxy is configured (null is ignored in\n+     *     the SDK)\n+     */\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")\n+    public static ProxyConfiguration getProxyConfiguration() {\n+        String url = System.getProperty(GREENGRASS_PROXY_URL_KEY);\n+        String usernameFromConfig = System.getProperty(GREENGRASS_PROXY_USERNAME_KEY);\n+        String passwordFromConfig = System.getProperty(GREENGRASS_PROXY_PASSWORD_KEY);\n+        String noProxyAddresses = System.getProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY);\n+\n+        if (StringUtils.isEmpty(url)) {\n+            return null;\n+        }\n+\n+        // ProxyConfiguration throws an error if auth data is included in the url\n+        String urlWithoutAuth = removeAuthFromProxyUrl(url);\n+\n+        String username = getProxyUsername(url, usernameFromConfig);\n+        String password = getProxyPassword(url, passwordFromConfig);\n+\n+        Set<String> nonProxyHosts = Collections.emptySet();\n+        if (StringUtils.isNotEmpty(noProxyAddresses)) {\n+            nonProxyHosts = Arrays.stream(noProxyAddresses.split(\",\")).collect(Collectors.toSet());", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NjIyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r494576226", "bodyText": "The value from the user config should always be comma delimited. These proxy configuration helper functions should always convert from the user value to whatever the underlying library requires. The customer/end user shouldn't ever see or know about the | delimiter requirement of the v1 sdk. Covering for the potential error might cause more confusion about what the value should be.", "author": "tomnagy-aws", "createdAt": "2020-09-24T19:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyOTgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzMTQ5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r492431493", "bodyText": "Should be marked as @Nullable, I think.", "author": "philcali", "createdAt": "2020-09-22T01:27:45Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -85,10 +87,12 @@ public void onConnectionResumed(boolean sessionPresent) {\n     private final Map<String, QualityOfService> subscriptionTopics = new ConcurrentHashMap<>();\n \n     AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n+                     X509CredentialsProvider credentialsProvider,", "originalCommit": "ab58c0fc534bfbb840b107595b2a5c2d8deab3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTI2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r493881269", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-09-23T20:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzMTQ5Mw=="}], "type": "inlineReview"}, {"oid": "ef4cd6a6eb3239fadc4fa8ec8156bb09fc42948d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ef4cd6a6eb3239fadc4fa8ec8156bb09fc42948d", "message": "Remove wildcard import", "committedDate": "2020-09-23T20:29:06Z", "type": "commit"}, {"oid": "fecb80d4873d2053ea72d046b0cc2951da999ae0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fecb80d4873d2053ea72d046b0cc2951da999ae0", "message": "Replace StringUtils with Utils", "committedDate": "2020-09-23T20:29:52Z", "type": "commit"}, {"oid": "7414016d47eb98b14118cdcb88b2f5b13c89af62", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7414016d47eb98b14118cdcb88b2f5b13c89af62", "message": "Get DeviceConfiguration from context", "committedDate": "2020-09-23T20:30:42Z", "type": "commit"}, {"oid": "274cb5a232baa3595e4bc839140dcdaf12503e9e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/274cb5a232baa3595e4bc839140dcdaf12503e9e", "message": "Replace X509CredentialsProvider with LazyCredentialProvider", "committedDate": "2020-09-23T20:31:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MjkwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r493882906", "bodyText": "this will fail pretty quickly because TES credentials expire after at most one hour, so you can't use a static provider.", "author": "MikeDombo", "createdAt": "2020-09-23T20:43:00Z", "path": "src/main/java/com/aws/greengrass/tes/LazyCredentialProvider.java", "diffHunk": "@@ -59,6 +61,25 @@ public AWSCredentials getCredentials() {\n         }\n     }\n \n+    /**\n+     * Provides a StaticCredentialsProvider containing credentials obtained from TES.\n+     *\n+     * @return StaticCredentialsProvider containing TES credentials\n+     * @throws AmazonClientException if there was a problem fetching credentials from TES\n+     */\n+    public StaticCredentialsProvider getFreshStaticCredentialsProvider() {", "originalCommit": "274cb5a232baa3595e4bc839140dcdaf12503e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NzgxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r496077816", "bodyText": "Will revert back to X509CredentialsProvider for now and will work on getting proper proxy support included in the device sdk", "author": "tomnagy-aws", "createdAt": "2020-09-28T16:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MzMxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r493883319", "bodyText": "what are these properties for?", "author": "MikeDombo", "createdAt": "2020-09-23T20:43:51Z", "path": "src/main/java/com/aws/greengrass/util/ProxyUtils.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.Protocol;\n+import com.amazonaws.ProxyAuthenticationMethod;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.apache.ProxyConfiguration;\n+\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public final class ProxyUtils {\n+\n+    public static final String GREENGRASS_PROXY_URL_KEY = \"GREENGRASS_PROXY_URL\";\n+    public static final String GREENGRASS_PROXY_USERNAME_KEY = \"GREENGRASS_PROXY_USERNAME\";\n+    public static final String GREENGRASS_PROXY_PASSWORD_KEY = \"GREENGRASS_PROXY_PASSWORD\";\n+    public static final String GREENGRASS_PROXY_NOPROXYADDRESSES_KEY = \"GREENGRASS_PROXY_NOPROXYADDRESSES\";\n+\n+    private ProxyUtils() {\n+    }\n+\n+    /**\n+     * <p>Returns <code>scheme</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>scheme</code> is required and must be one of <code>http</code>, <code>https</code>, or\n+     * <code>socks5</code></p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>scheme</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getSchemeFromProxyUrl(String url) {\n+        return URI.create(url).getScheme();\n+    }\n+\n+    /**\n+     * <p>Returns <code>user:pass</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>user:pass</code> are optional</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>user:pass</code> in <code>scheme://user:pass@host:port</code> or <code>null</code> if absent\n+     */\n+    public static String getAuthFromProxyUrl(String url) {\n+        return URI.create(url).getUserInfo();\n+    }\n+\n+    /**\n+     * <p>Returns <code>host</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>host</code> is required</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>host</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getHostFromProxyUrl(String url) {\n+        return URI.create(url).getHost();\n+    }\n+\n+    private static int getDefaultPortForSchemeFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return 80;\n+            case \"https\":\n+                return 443;\n+            case \"socks5\":\n+                return 1080;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns <code>port</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>port</code> is optional. If not provided, returns 80 for http, 443 for https, 1080 for socks5, or -1\n+     * for any other scheme.</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>port</code> in <code>scheme://user:pass@host:port</code> or the default for the\n+     * <code>scheme</code>, -1 if <code>scheme</code> isn't recognized\n+     */\n+    public static int getPortFromProxyUrl(String url) {\n+        int userProvidedPort = URI.create(url).getPort();\n+        if (userProvidedPort != -1) {\n+            return userProvidedPort;\n+        }\n+        return getDefaultPortForSchemeFromProxyUrl(url);\n+    }\n+\n+    /**\n+     * <p>If the username is provided in the proxy url (i.e. <code>user</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the username is not provided in the proxy url, then the username config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyUsername User specified proxy username\n+     * @return Username field for proxy basic authentication or null if not found in url or username config topics\n+     */\n+    public static String getProxyUsername(String proxyUrl, String proxyUsername) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (Utils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            return tokens[0];\n+        }\n+\n+        if (Utils.isNotEmpty(proxyUsername)) {\n+            return proxyUsername;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>If the password is provided in the proxy url (i.e. <code>pass</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the password is not provided in the proxy url, then the password config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyPassword User specified proxy password\n+     * @return Password field for proxy basic authentication or null if not found in url or password config topics\n+     */\n+    public static String getProxyPassword(String proxyUrl, String proxyPassword) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (Utils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            if (tokens.length > 1) {\n+                return tokens[1];\n+            }\n+        }\n+\n+        if (Utils.isNotEmpty(proxyPassword)) {\n+            return proxyPassword;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Provides an software.amazon.awssdk.crt.http.HttpProxyOptions object that can be used when building various\n+     * CRT library clients (like mqtt and http)\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     * @return httpProxyOptions containing user proxy settings, if specified. If not, httpProxyOptions is null.\n+     */\n+    public static HttpProxyOptions getHttpProxyOptions(DeviceConfiguration deviceConfiguration) {\n+        HttpProxyOptions httpProxyOptions = null;\n+\n+        String proxyUrl = deviceConfiguration.getProxyUrl();\n+        String proxyUsername = getProxyUsername(deviceConfiguration.getProxyUrl(),\n+                deviceConfiguration.getProxyUsername());\n+\n+        if (Utils.isNotEmpty(proxyUrl)) {\n+            httpProxyOptions = new HttpProxyOptions();\n+            httpProxyOptions.setHost(ProxyUtils.getHostFromProxyUrl(proxyUrl));\n+            httpProxyOptions.setPort(ProxyUtils.getPortFromProxyUrl(proxyUrl));\n+\n+            if (Utils.isNotEmpty(proxyUsername)) {\n+                httpProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                httpProxyOptions.setAuthorizationUsername(proxyUsername);\n+                httpProxyOptions.setAuthorizationPassword(getProxyPassword(deviceConfiguration.getProxyUrl(),\n+                        deviceConfiguration.getProxyPassword()));\n+            }\n+        }\n+\n+        return httpProxyOptions;\n+    }\n+\n+    /**\n+     * <p>Sets the GREENGRASS_PROXY_* system properties with values from the device configuration.</p>\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     */\n+    public static void setSystemProxyProperties(DeviceConfiguration deviceConfiguration) {", "originalCommit": "274cb5a232baa3595e4bc839140dcdaf12503e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3ODU5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r496078591", "bodyText": "Removing in favor of fields", "author": "tomnagy-aws", "createdAt": "2020-09-28T16:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MzMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4MTE4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r495181183", "bodyText": "Is it just using websocket credentials, or does this switch iot mqtt client to use websockets?", "author": "prateek-y", "createdAt": "2020-09-25T19:09:41Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -135,6 +140,9 @@ void reconnect() throws TimeoutException, ExecutionException, InterruptedExcepti\n         // Always use the builder provider here so that the builder is updated with whatever\n         // the latest device config is\n         try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+            if (lazyCredentialProvider != null) {\n+                builder.withWebsocketCredentialsProvider(lazyCredentialProvider.getFreshStaticCredentialsProvider());", "originalCommit": "274cb5a232baa3595e4bc839140dcdaf12503e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NjYxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r496076614", "bodyText": "Both the client and credential provider will use websockets when using a proxy", "author": "tomnagy-aws", "createdAt": "2020-09-28T16:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4MTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4MzY5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r495183698", "bodyText": "Is device configuration best place for proxy settings to live? What is the customer expectation if they want to update proxy url for example, are they expected to restart kernel.", "author": "prateek-y", "createdAt": "2020-09-25T19:15:10Z", "path": "src/main/java/com/aws/greengrass/util/ProxyUtils.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.Protocol;\n+import com.amazonaws.ProxyAuthenticationMethod;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.apache.ProxyConfiguration;\n+\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public final class ProxyUtils {\n+\n+    public static final String GREENGRASS_PROXY_URL_KEY = \"GREENGRASS_PROXY_URL\";\n+    public static final String GREENGRASS_PROXY_USERNAME_KEY = \"GREENGRASS_PROXY_USERNAME\";\n+    public static final String GREENGRASS_PROXY_PASSWORD_KEY = \"GREENGRASS_PROXY_PASSWORD\";\n+    public static final String GREENGRASS_PROXY_NOPROXYADDRESSES_KEY = \"GREENGRASS_PROXY_NOPROXYADDRESSES\";\n+\n+    private ProxyUtils() {\n+    }\n+\n+    /**\n+     * <p>Returns <code>scheme</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>scheme</code> is required and must be one of <code>http</code>, <code>https</code>, or\n+     * <code>socks5</code></p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>scheme</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getSchemeFromProxyUrl(String url) {\n+        return URI.create(url).getScheme();\n+    }\n+\n+    /**\n+     * <p>Returns <code>user:pass</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>user:pass</code> are optional</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>user:pass</code> in <code>scheme://user:pass@host:port</code> or <code>null</code> if absent\n+     */\n+    public static String getAuthFromProxyUrl(String url) {\n+        return URI.create(url).getUserInfo();\n+    }\n+\n+    /**\n+     * <p>Returns <code>host</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>host</code> is required</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>host</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getHostFromProxyUrl(String url) {\n+        return URI.create(url).getHost();\n+    }\n+\n+    private static int getDefaultPortForSchemeFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return 80;\n+            case \"https\":\n+                return 443;\n+            case \"socks5\":\n+                return 1080;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns <code>port</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>port</code> is optional. If not provided, returns 80 for http, 443 for https, 1080 for socks5, or -1\n+     * for any other scheme.</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>port</code> in <code>scheme://user:pass@host:port</code> or the default for the\n+     * <code>scheme</code>, -1 if <code>scheme</code> isn't recognized\n+     */\n+    public static int getPortFromProxyUrl(String url) {\n+        int userProvidedPort = URI.create(url).getPort();\n+        if (userProvidedPort != -1) {\n+            return userProvidedPort;\n+        }\n+        return getDefaultPortForSchemeFromProxyUrl(url);\n+    }\n+\n+    /**\n+     * <p>If the username is provided in the proxy url (i.e. <code>user</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the username is not provided in the proxy url, then the username config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyUsername User specified proxy username\n+     * @return Username field for proxy basic authentication or null if not found in url or username config topics\n+     */\n+    public static String getProxyUsername(String proxyUrl, String proxyUsername) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (Utils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            return tokens[0];\n+        }\n+\n+        if (Utils.isNotEmpty(proxyUsername)) {\n+            return proxyUsername;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>If the password is provided in the proxy url (i.e. <code>pass</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the password is not provided in the proxy url, then the password config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyPassword User specified proxy password\n+     * @return Password field for proxy basic authentication or null if not found in url or password config topics\n+     */\n+    public static String getProxyPassword(String proxyUrl, String proxyPassword) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (Utils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            if (tokens.length > 1) {\n+                return tokens[1];\n+            }\n+        }\n+\n+        if (Utils.isNotEmpty(proxyPassword)) {\n+            return proxyPassword;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Provides an software.amazon.awssdk.crt.http.HttpProxyOptions object that can be used when building various\n+     * CRT library clients (like mqtt and http)\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     * @return httpProxyOptions containing user proxy settings, if specified. If not, httpProxyOptions is null.\n+     */\n+    public static HttpProxyOptions getHttpProxyOptions(DeviceConfiguration deviceConfiguration) {\n+        HttpProxyOptions httpProxyOptions = null;\n+\n+        String proxyUrl = deviceConfiguration.getProxyUrl();\n+        String proxyUsername = getProxyUsername(deviceConfiguration.getProxyUrl(),\n+                deviceConfiguration.getProxyUsername());\n+\n+        if (Utils.isNotEmpty(proxyUrl)) {\n+            httpProxyOptions = new HttpProxyOptions();\n+            httpProxyOptions.setHost(ProxyUtils.getHostFromProxyUrl(proxyUrl));\n+            httpProxyOptions.setPort(ProxyUtils.getPortFromProxyUrl(proxyUrl));\n+\n+            if (Utils.isNotEmpty(proxyUsername)) {\n+                httpProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                httpProxyOptions.setAuthorizationUsername(proxyUsername);\n+                httpProxyOptions.setAuthorizationPassword(getProxyPassword(deviceConfiguration.getProxyUrl(),\n+                        deviceConfiguration.getProxyPassword()));\n+            }\n+        }\n+\n+        return httpProxyOptions;\n+    }\n+\n+    /**\n+     * <p>Sets the GREENGRASS_PROXY_* system properties with values from the device configuration.</p>\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     */\n+    public static void setSystemProxyProperties(DeviceConfiguration deviceConfiguration) {\n+        if (deviceConfiguration == null) {\n+            return;\n+        }\n+\n+        System.setProperty(GREENGRASS_PROXY_URL_KEY, deviceConfiguration.getProxyUrl());", "originalCommit": "274cb5a232baa3595e4bc839140dcdaf12503e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3OTY3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r496079670", "bodyText": "The expectation for now is a restart is required. Once these are updated via deployment, additional checks need to be done to ensure new proxy values don't brick the device.", "author": "tomnagy-aws", "createdAt": "2020-09-28T16:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4MzY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NDAxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r495184018", "bodyText": "You would also need to set some proxy env vars for lambdas/components to work with proxy?", "author": "prateek-y", "createdAt": "2020-09-25T19:15:55Z", "path": "src/main/java/com/aws/greengrass/util/ProxyUtils.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.Protocol;\n+import com.amazonaws.ProxyAuthenticationMethod;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.apache.ProxyConfiguration;\n+\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public final class ProxyUtils {\n+\n+    public static final String GREENGRASS_PROXY_URL_KEY = \"GREENGRASS_PROXY_URL\";\n+    public static final String GREENGRASS_PROXY_USERNAME_KEY = \"GREENGRASS_PROXY_USERNAME\";\n+    public static final String GREENGRASS_PROXY_PASSWORD_KEY = \"GREENGRASS_PROXY_PASSWORD\";\n+    public static final String GREENGRASS_PROXY_NOPROXYADDRESSES_KEY = \"GREENGRASS_PROXY_NOPROXYADDRESSES\";\n+\n+    private ProxyUtils() {\n+    }\n+\n+    /**\n+     * <p>Returns <code>scheme</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>scheme</code> is required and must be one of <code>http</code>, <code>https</code>, or\n+     * <code>socks5</code></p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>scheme</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getSchemeFromProxyUrl(String url) {\n+        return URI.create(url).getScheme();\n+    }\n+\n+    /**\n+     * <p>Returns <code>user:pass</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>user:pass</code> are optional</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>user:pass</code> in <code>scheme://user:pass@host:port</code> or <code>null</code> if absent\n+     */\n+    public static String getAuthFromProxyUrl(String url) {\n+        return URI.create(url).getUserInfo();\n+    }\n+\n+    /**\n+     * <p>Returns <code>host</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>host</code> is required</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>host</code> in <code>scheme://user:pass@host:port</code>\n+     */\n+    public static String getHostFromProxyUrl(String url) {\n+        return URI.create(url).getHost();\n+    }\n+\n+    private static int getDefaultPortForSchemeFromProxyUrl(String url) {\n+        String scheme = getSchemeFromProxyUrl(url);\n+        switch (scheme) {\n+            case \"http\":\n+                return 80;\n+            case \"https\":\n+                return 443;\n+            case \"socks5\":\n+                return 1080;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns <code>port</code> from the user provided proxy url of the format\n+     * <code>scheme://user:pass@host:port</code>.</p>\n+     *\n+     * <p><code>port</code> is optional. If not provided, returns 80 for http, 443 for https, 1080 for socks5, or -1\n+     * for any other scheme.</p>\n+     *\n+     * @param url User provided URL value from config\n+     * @return <code>port</code> in <code>scheme://user:pass@host:port</code> or the default for the\n+     * <code>scheme</code>, -1 if <code>scheme</code> isn't recognized\n+     */\n+    public static int getPortFromProxyUrl(String url) {\n+        int userProvidedPort = URI.create(url).getPort();\n+        if (userProvidedPort != -1) {\n+            return userProvidedPort;\n+        }\n+        return getDefaultPortForSchemeFromProxyUrl(url);\n+    }\n+\n+    /**\n+     * <p>If the username is provided in the proxy url (i.e. <code>user</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the username is not provided in the proxy url, then the username config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyUsername User specified proxy username\n+     * @return Username field for proxy basic authentication or null if not found in url or username config topics\n+     */\n+    public static String getProxyUsername(String proxyUrl, String proxyUsername) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (Utils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            return tokens[0];\n+        }\n+\n+        if (Utils.isNotEmpty(proxyUsername)) {\n+            return proxyUsername;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>If the password is provided in the proxy url (i.e. <code>pass</code> in\n+     * <code>scheme://user:pass@host:port</code>), it is always returned.</p>\n+     *\n+     * <p>If the password is not provided in the proxy url, then the password config property is returned.</p>\n+     *\n+     * @param proxyUrl User specified proxy url\n+     * @param proxyPassword User specified proxy password\n+     * @return Password field for proxy basic authentication or null if not found in url or password config topics\n+     */\n+    public static String getProxyPassword(String proxyUrl, String proxyPassword) {\n+        String auth = getAuthFromProxyUrl(proxyUrl);\n+        if (Utils.isNotEmpty(auth)) {\n+            String[] tokens = auth.split(\":\");\n+            if (tokens.length > 1) {\n+                return tokens[1];\n+            }\n+        }\n+\n+        if (Utils.isNotEmpty(proxyPassword)) {\n+            return proxyPassword;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Provides an software.amazon.awssdk.crt.http.HttpProxyOptions object that can be used when building various\n+     * CRT library clients (like mqtt and http)\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     * @return httpProxyOptions containing user proxy settings, if specified. If not, httpProxyOptions is null.\n+     */\n+    public static HttpProxyOptions getHttpProxyOptions(DeviceConfiguration deviceConfiguration) {\n+        HttpProxyOptions httpProxyOptions = null;\n+\n+        String proxyUrl = deviceConfiguration.getProxyUrl();\n+        String proxyUsername = getProxyUsername(deviceConfiguration.getProxyUrl(),\n+                deviceConfiguration.getProxyUsername());\n+\n+        if (Utils.isNotEmpty(proxyUrl)) {\n+            httpProxyOptions = new HttpProxyOptions();\n+            httpProxyOptions.setHost(ProxyUtils.getHostFromProxyUrl(proxyUrl));\n+            httpProxyOptions.setPort(ProxyUtils.getPortFromProxyUrl(proxyUrl));\n+\n+            if (Utils.isNotEmpty(proxyUsername)) {\n+                httpProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                httpProxyOptions.setAuthorizationUsername(proxyUsername);\n+                httpProxyOptions.setAuthorizationPassword(getProxyPassword(deviceConfiguration.getProxyUrl(),\n+                        deviceConfiguration.getProxyPassword()));\n+            }\n+        }\n+\n+        return httpProxyOptions;\n+    }\n+\n+    /**\n+     * <p>Sets the GREENGRASS_PROXY_* system properties with values from the device configuration.</p>\n+     *\n+     * @param deviceConfiguration contains user specified system proxy values\n+     */\n+    public static void setSystemProxyProperties(DeviceConfiguration deviceConfiguration) {\n+        if (deviceConfiguration == null) {\n+            return;\n+        }\n+\n+        System.setProperty(GREENGRASS_PROXY_URL_KEY, deviceConfiguration.getProxyUrl());\n+        System.setProperty(GREENGRASS_PROXY_USERNAME_KEY, deviceConfiguration.getProxyUsername());\n+        System.setProperty(GREENGRASS_PROXY_PASSWORD_KEY, deviceConfiguration.getProxyPassword());\n+        System.setProperty(GREENGRASS_PROXY_NOPROXYADDRESSES_KEY, deviceConfiguration.getNoProxyAddresses());", "originalCommit": "274cb5a232baa3595e4bc839140dcdaf12503e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MDEzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r496080131", "bodyText": "Yes this is included in the next commit", "author": "tomnagy-aws", "createdAt": "2020-09-28T16:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NDAxOA=="}], "type": "inlineReview"}, {"oid": "e42fabfac211d40d1168c024a29137da3eb55771", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e42fabfac211d40d1168c024a29137da3eb55771", "message": "Update device sdk version", "committedDate": "2020-09-28T15:57:16Z", "type": "commit"}, {"oid": "1b5bd3338834ddd50b64ebdbe7aa0245d7f7b720", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1b5bd3338834ddd50b64ebdbe7aa0245d7f7b720", "message": "Switch MQTT client back to X509CredentialsProvider", "committedDate": "2020-09-28T16:00:01Z", "type": "commit"}, {"oid": "fa62d1fb4da3db5c9d41e5ec82c54a1baac19952", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fa62d1fb4da3db5c9d41e5ec82c54a1baac19952", "message": "Swap system properties with fields for device provisioning", "committedDate": "2020-09-28T16:10:20Z", "type": "commit"}, {"oid": "a500a09b461a6aae24e04c71a36874b8ce917b65", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a500a09b461a6aae24e04c71a36874b8ce917b65", "message": "Set proxy environment variables in shell runner", "committedDate": "2020-09-28T16:13:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzODQxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499038416", "bodyText": "do we need both upper and lowercase?", "author": "MikeDombo", "createdAt": "2020-10-02T20:35:36Z", "path": "src/main/java/com/aws/greengrass/lifecyclemanager/ShellRunner.java", "diffHunk": "@@ -55,6 +58,14 @@ public synchronized Exec setup(String note, String command, GreengrassService on\n                         .setenv(TES_AUTH_HEADER,\n                                 String.valueOf(onBehalfOf.getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n                                         .getOnce()))\n+                        .setenv(\"HTTP_PROXY\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration))\n+                        .setenv(\"http_proxy\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration))\n+                        .setenv(\"HTTPS_PROXY\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration))\n+                        .setenv(\"https_proxy\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration))\n+                        .setenv(\"ALL_PROXY\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration))", "originalCommit": "a500a09b461a6aae24e04c71a36874b8ce917b65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDE5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499870196", "bodyText": "Yeah. This is what V1 does and certain programs notoriously only look for the uppercase or lowercase variant (wget, for example)", "author": "tomnagy-aws", "createdAt": "2020-10-05T21:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzODQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzODg4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499038889", "bodyText": "don't you need to update the x509 provider inside this callback?", "author": "MikeDombo", "createdAt": "2020-10-02T20:36:51Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -91,24 +103,73 @@\n     /**\n      * Constructor for injection.\n      *\n+     * @param kernel              kernel for tes role alias\n      * @param deviceConfiguration device configuration\n      * @param executorService     executor service\n      */\n     @Inject\n-    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+    @SuppressWarnings(\"PMD.ConfusingTernary\")\n+    public MqttClient(Kernel kernel, DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n         this(deviceConfiguration, null, executorService);\n-        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n-                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n-                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n-                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n-                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n-                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n-                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n-                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n-                .withPingTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n-                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        if (httpProxyOptions != null) {\n+            kernel.getConfig().lookupTopics(SERVICES_NAMESPACE_TOPIC, TOKEN_EXCHANGE_SERVICE_TOPICS)\n+                    .lookup(PARAMETERS_CONFIG_KEY, IOT_ROLE_ALIAS_TOPIC).subscribe((why, newv) -> {\n+                tesRoleAlias = Coerce.toString(newv);", "originalCommit": "a500a09b461a6aae24e04c71a36874b8ce917b65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNTUxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499105515", "bodyText": "+1. Additionally do we need to monitor proxy config changes and update accordingly?", "author": "philcali", "createdAt": "2020-10-03T01:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzODg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzMzQwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r503533404", "bodyText": "After a lot of testing, the device sdk is very buggy and doesn't handle dynamic reloading of the credential provider without crashing. Had a meeting with Jamie and we're going to proceed for now with a kernel restart whenever proxy settings change. As an aside, I noticed the non-proxy mqtt client also does not use new device configuration values after a deployment.", "author": "tomnagy-aws", "createdAt": "2020-10-12T21:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzODg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTU4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499039589", "bodyText": "can we refactor the builder building at all to deduplicate calls between proxy and non-proxy?", "author": "MikeDombo", "createdAt": "2020-10-02T20:38:35Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -91,24 +103,73 @@\n     /**\n      * Constructor for injection.\n      *\n+     * @param kernel              kernel for tes role alias\n      * @param deviceConfiguration device configuration\n      * @param executorService     executor service\n      */\n     @Inject\n-    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+    @SuppressWarnings(\"PMD.ConfusingTernary\")\n+    public MqttClient(Kernel kernel, DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n         this(deviceConfiguration, null, executorService);\n-        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n-                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n-                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n-                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n-                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n-                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n-                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n-                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n-                .withPingTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n-                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        if (httpProxyOptions != null) {\n+            kernel.getConfig().lookupTopics(SERVICES_NAMESPACE_TOPIC, TOKEN_EXCHANGE_SERVICE_TOPICS)\n+                    .lookup(PARAMETERS_CONFIG_KEY, IOT_ROLE_ALIAS_TOPIC).subscribe((why, newv) -> {\n+                tesRoleAlias = Coerce.toString(newv);\n+            });\n+\n+            try (TlsContextOptions x509TlsOptions = TlsContextOptions.createWithMtlsFromPath(\n+                    Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                    Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))) {\n+\n+                x509TlsOptions.withCertificateAuthorityFromPath(null,\n+                        Coerce.toString(deviceConfiguration.getRootCAFilePath()));\n+\n+                try (ClientTlsContext x509TlsContext = new ClientTlsContext(x509TlsOptions)) {\n+                    this.credentialsProvider = new X509CredentialsProvider.X509CredentialsProviderBuilder()\n+                            .withClientBootstrap(clientBootstrap)\n+                            .withTlsContext(x509TlsContext)\n+                            .withEndpoint(Coerce.toString(deviceConfiguration.getIotCredentialEndpoint()))\n+                            .withRoleAlias(tesRoleAlias)\n+                            .withThingName(Coerce.toString(deviceConfiguration.getThingName()))\n+                            .withProxyOptions(httpProxyOptions)\n+                            .build();\n+                }\n+\n+                this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                        .newMtlsBuilderFromPath(null, null)\n+                        .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                        .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                        .withCleanSession(false)", "originalCommit": "a500a09b461a6aae24e04c71a36874b8ce917b65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNzc3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r503537776", "bodyText": "Unfortunately, the order of the builder functions matter (withWebsockets must be after withPort) so you end up with something that I don't think makes the code any easier to read. At least this way it is obvious that there are two separate clients. And in the long run, we should eventually have just one proxy friendly client.", "author": "tomnagy-aws", "createdAt": "2020-10-12T21:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MDk0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499040941", "bodyText": "remove the public from all of these", "author": "MikeDombo", "createdAt": "2020-10-02T20:41:48Z", "path": "src/test/java/com/aws/greengrass/util/ProxyUtilsTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class ProxyUtilsTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    @Test\n+    public void testGetSchemeFromProxyUrl() {\n+        assertEquals(\"https\", ProxyUtils.getSchemeFromProxyUrl(\"https://localhost\"));\n+        assertEquals(\"http\", ProxyUtils.getSchemeFromProxyUrl(\"http://localhost\"));\n+        assertEquals(\"socks5\", ProxyUtils.getSchemeFromProxyUrl(\"socks5://localhost\"));\n+    }\n+\n+    @Test\n+    public void testGetAuthFromProxyUrl() {\n+        assertNull(ProxyUtils.getAuthFromProxyUrl(\"https://myproxy:8080\"));\n+        assertEquals(\"user:password\", ProxyUtils.getAuthFromProxyUrl(\"https://user:password@localhost:8080\"));\n+        assertEquals(\"usernameOnly\", ProxyUtils.getAuthFromProxyUrl(\"https://usernameOnly@localhost:8080\"));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    public void testGetHostFromProxyUrl() {\n+        assertEquals(\"localhost\", ProxyUtils.getHostFromProxyUrl(\"https://localhost\"));\n+        assertEquals(\"192.168.0.1\", ProxyUtils.getHostFromProxyUrl(\"https://192.168.0.1\"));\n+        assertEquals(\"myproxy\", ProxyUtils.getHostFromProxyUrl(\"https://myproxy:8080\"));\n+        assertEquals(\"localhost\", ProxyUtils.getHostFromProxyUrl(\"https://user:password@localhost:8080\"));\n+        assertEquals(\"localhost\", ProxyUtils.getHostFromProxyUrl(\"https://localhost/\"));\n+    }\n+\n+    @Test\n+    public void testGetPortFromProxyUrl() {\n+        assertEquals(443, ProxyUtils.getPortFromProxyUrl(\"https://localhost\"));\n+        assertEquals(80, ProxyUtils.getPortFromProxyUrl(\"http://localhost\"));\n+        assertEquals(1080, ProxyUtils.getPortFromProxyUrl(\"socks5://localhost\"));\n+        assertEquals(8080, ProxyUtils.getPortFromProxyUrl(\"https://myproxy:8080\"));\n+        assertEquals(8080, ProxyUtils.getPortFromProxyUrl(\"https://user:password@localhost:8080\"));\n+        assertEquals(8080, ProxyUtils.getPortFromProxyUrl(\"https://myproxy:8080/\"));\n+    }\n+\n+    @Test\n+    public void testGetProxyUsername() {\n+        assertEquals(\"user\", ProxyUtils.getProxyUsername(\"https://user:password@localhost:8080\", \"test-user\"));\n+        assertEquals(\"usernameOnly\", ProxyUtils.getProxyUsername(\"https://usernameOnly@localhost:8080\", \"test-user\"));\n+        assertEquals(\"test-user\", ProxyUtils.getProxyUsername(\"https://myproxy:8080\", \"test-user\"));\n+        assertNull(ProxyUtils.getProxyUsername(\"https://myproxy:8080\", \"\"));\n+    }\n+\n+    @Test\n+    public void testGetProxyPassword() {\n+        assertEquals(\"password\", ProxyUtils.getProxyPassword(\"https://user:password@localhost:8080\", \"itsasecret\"));\n+        assertEquals(\"itsasecret\", ProxyUtils.getProxyPassword(\"https://usernameOnly@localhost:8080\", \"itsasecret\"));\n+        assertEquals(\"itsasecret\", ProxyUtils.getProxyPassword(\"https://myproxy:8080\", \"itsasecret\"));\n+        assertNull(ProxyUtils.getProxyPassword(\"https://myproxy:8080\", \"\"));\n+    }\n+\n+    @Test\n+    public void testGetHttpProxyOptions() {\n+        when(deviceConfiguration.getProxyUrl()).thenReturn(\"https://myproxy:8080\");\n+        when(deviceConfiguration.getProxyUsername()).thenReturn(\"test-user\");\n+        when(deviceConfiguration.getProxyPassword()).thenReturn(\"itsasecret\");\n+\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        assertEquals(\"myproxy\", httpProxyOptions.getHost());\n+        assertEquals(8080, httpProxyOptions.getPort());\n+        assertEquals(HttpProxyOptions.HttpProxyAuthorizationType.Basic, httpProxyOptions.getAuthorizationType());\n+        assertEquals(\"test-user\", httpProxyOptions.getAuthorizationUsername());\n+        assertEquals(\"itsasecret\", httpProxyOptions.getAuthorizationPassword());\n+    }\n+\n+    @Test\n+    public void testGetProxyEnvVarValue_passthroughWithAuth() {\n+        when(deviceConfiguration.getProxyUrl()).thenReturn(\"https://test-user:itsasecret@myproxy:8080\");\n+        assertEquals(\"https://test-user:itsasecret@myproxy:8080\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration));\n+    }\n+\n+    @Test\n+    public void testGetProxyEnvVarValue_passthroughWithoutAuth() {\n+        when(deviceConfiguration.getProxyUrl()).thenReturn(\"https://myproxy:8080\");\n+        assertEquals(\"https://myproxy:8080\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration));\n+    }\n+\n+    @Test\n+    public void testGetProxyEnvVarValue_authInfoAddedToUrl() {\n+        when(deviceConfiguration.getProxyUrl()).thenReturn(\"https://myproxy:8080\");\n+        when(deviceConfiguration.getProxyUsername()).thenReturn(\"test-user\");\n+        when(deviceConfiguration.getProxyPassword()).thenReturn(\"itsasecret\");\n+        assertEquals(\"https://test-user:itsasecret@myproxy:8080\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration));\n+    }\n+\n+    @Test\n+    public void testGetProxyEnvVarValue_authInfoNoOverride() {\n+        when(deviceConfiguration.getProxyUrl()).thenReturn(\"https://test-user:itsasecret@myproxy:8080\");\n+        when(deviceConfiguration.getProxyUsername()).thenReturn(\"different-test-user\");\n+        assertEquals(\"https://test-user:itsasecret@myproxy:8080\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration));\n+    }\n+\n+    @Test\n+    public void testGetProxyEnvVarValue_noProxyConfigured() {\n+        when(deviceConfiguration.getProxyUrl()).thenReturn(null);\n+        assertEquals(\"\", ProxyUtils.getProxyEnvVarValue(deviceConfiguration));\n+    }\n+\n+    @Test\n+    public void testGetNoProxyEnvVarValue_customValue() {\n+        when(deviceConfiguration.getProxyUrl()).thenReturn(\"https://myproxy:8080\");\n+        when(deviceConfiguration.getNoProxyAddresses()).thenReturn(\"other-local-domain,example.com\");\n+        assertEquals(\"localhost,other-local-domain,example.com\", ProxyUtils.getNoProxyEnvVarValue(deviceConfiguration));\n+    }\n+\n+    @Test\n+    public void testGetNoProxyEnvVarValue_noValue() {", "originalCommit": "a500a09b461a6aae24e04c71a36874b8ce917b65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNzkzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r503537934", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-10-12T21:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MDk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MDk4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499040984", "bodyText": "remove public", "author": "MikeDombo", "createdAt": "2020-10-02T20:41:56Z", "path": "src/test/java/com/aws/greengrass/util/ProxyUtilsTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class ProxyUtilsTest {", "originalCommit": "a500a09b461a6aae24e04c71a36874b8ce917b65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNzg4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r503537889", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-10-12T21:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MDk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNDk5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r499104997", "bodyText": "Seems like you can hit a race condition here with tesRoleAlias being unset since tesRoleAlias is lazily initialized.", "author": "philcali", "createdAt": "2020-10-03T01:48:46Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -91,24 +103,73 @@\n     /**\n      * Constructor for injection.\n      *\n+     * @param kernel              kernel for tes role alias\n      * @param deviceConfiguration device configuration\n      * @param executorService     executor service\n      */\n     @Inject\n-    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+    @SuppressWarnings(\"PMD.ConfusingTernary\")\n+    public MqttClient(Kernel kernel, DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n         this(deviceConfiguration, null, executorService);\n-        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n-                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n-                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n-                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n-                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n-                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n-                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n-                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n-                .withPingTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n-                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        if (httpProxyOptions != null) {\n+            kernel.getConfig().lookupTopics(SERVICES_NAMESPACE_TOPIC, TOKEN_EXCHANGE_SERVICE_TOPICS)\n+                    .lookup(PARAMETERS_CONFIG_KEY, IOT_ROLE_ALIAS_TOPIC).subscribe((why, newv) -> {\n+                tesRoleAlias = Coerce.toString(newv);\n+            });\n+\n+            try (TlsContextOptions x509TlsOptions = TlsContextOptions.createWithMtlsFromPath(\n+                    Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                    Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))) {\n+\n+                x509TlsOptions.withCertificateAuthorityFromPath(null,\n+                        Coerce.toString(deviceConfiguration.getRootCAFilePath()));\n+\n+                try (ClientTlsContext x509TlsContext = new ClientTlsContext(x509TlsOptions)) {\n+                    this.credentialsProvider = new X509CredentialsProvider.X509CredentialsProviderBuilder()\n+                            .withClientBootstrap(clientBootstrap)\n+                            .withTlsContext(x509TlsContext)\n+                            .withEndpoint(Coerce.toString(deviceConfiguration.getIotCredentialEndpoint()))\n+                            .withRoleAlias(tesRoleAlias)", "originalCommit": "a500a09b461a6aae24e04c71a36874b8ce917b65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNDE1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r503534159", "bodyText": "Changed tesRoleAlias to use getOnce to avoid this and to reflect the need for a restart should the value change.", "author": "tomnagy-aws", "createdAt": "2020-10-12T21:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNDk5Nw=="}], "type": "inlineReview"}, {"oid": "a6103837d4a31f325137a348366d2125b6766dcc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a6103837d4a31f325137a348366d2125b6766dcc", "message": "Merge from master", "committedDate": "2020-10-05T16:25:06Z", "type": "commit"}, {"oid": "494a78ac7df3c9a831675b08135f1745ac605db2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/494a78ac7df3c9a831675b08135f1745ac605db2", "message": "Merge branch 'master' into network-proxy-support", "committedDate": "2020-10-05T16:28:16Z", "type": "commit"}, {"oid": "a1b517582b34330ccfef9cbe84616d7207afa5de", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a1b517582b34330ccfef9cbe84616d7207afa5de", "message": "Merge from master", "committedDate": "2020-10-13T15:09:23Z", "type": "commit"}, {"oid": "e995d9f563ddf487e12eeddab9be1bcda462ba4c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e995d9f563ddf487e12eeddab9be1bcda462ba4c", "message": "tesRoleAlias should use getOnce", "committedDate": "2020-10-13T15:19:35Z", "type": "commit"}, {"oid": "aff46487834f090693e4e811a2166226e3bd62d8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aff46487834f090693e4e811a2166226e3bd62d8", "message": "Remove public modifier", "committedDate": "2020-10-13T15:19:47Z", "type": "commit"}, {"oid": "4a06d3e4d08a56d03b926c83515f6d9a9166ffee", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4a06d3e4d08a56d03b926c83515f6d9a9166ffee", "message": "Removed unused import", "committedDate": "2020-10-13T15:25:32Z", "type": "commit"}, {"oid": "f148d22f81cd3e57c067ad3ab955bddeabd64578", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f148d22f81cd3e57c067ad3ab955bddeabd64578", "message": "Merge branch 'master' into network-proxy-support", "committedDate": "2020-10-13T16:52:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNDMwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504114300", "bodyText": "Inject DeviceConfiguration itself instead of injecting the kernel, getting context, then getting device config", "author": "MikeDombo", "createdAt": "2020-10-13T16:56:40Z", "path": "src/main/java/com/aws/greengrass/lifecyclemanager/ShellRunner.java", "diffHunk": "@@ -30,10 +32,14 @@ boolean successful(Exec e, String note, IntConsumer background, GreengrassServic\n         @Inject\n         NucleusPaths nucleusPaths;\n \n+        @Inject\n+        Kernel config;", "originalCommit": "f148d22f81cd3e57c067ad3ab955bddeabd64578", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzYyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504133629", "bodyText": "Fixed", "author": "tomnagy-aws", "createdAt": "2020-10-13T17:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNDMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNDgxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504114816", "bodyText": "use kernel.findServiceTopics(TOKEN_EXHCNAGE)", "author": "MikeDombo", "createdAt": "2020-10-13T16:57:31Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -93,24 +104,71 @@\n     /**\n      * Constructor for injection.\n      *\n+     * @param kernel              kernel for tes role alias\n      * @param deviceConfiguration device configuration\n      * @param executorService     executor service\n      */\n     @Inject\n-    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+    @SuppressWarnings(\"PMD.ConfusingTernary\")\n+    public MqttClient(Kernel kernel, DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n         this(deviceConfiguration, null, executorService);\n-        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n-                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n-                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n-                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n-                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n-                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n-                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n-                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n-                .withPingTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n-                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        if (httpProxyOptions != null) {\n+            String tesRoleAlias = Coerce.toString(kernel.getConfig().lookupTopics(SERVICES_NAMESPACE_TOPIC,", "originalCommit": "f148d22f81cd3e57c067ad3ab955bddeabd64578", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504133706", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-10-13T17:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNDgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNTAxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504115016", "bodyText": "don't call getOnce(). Coerce methods already call it for you.", "author": "MikeDombo", "createdAt": "2020-10-13T16:57:49Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -93,24 +104,71 @@\n     /**\n      * Constructor for injection.\n      *\n+     * @param kernel              kernel for tes role alias\n      * @param deviceConfiguration device configuration\n      * @param executorService     executor service\n      */\n     @Inject\n-    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+    @SuppressWarnings(\"PMD.ConfusingTernary\")\n+    public MqttClient(Kernel kernel, DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n         this(deviceConfiguration, null, executorService);\n-        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n-                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n-                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n-                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n-                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n-                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n-                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n-                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n-                .withPingTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n-                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        if (httpProxyOptions != null) {\n+            String tesRoleAlias = Coerce.toString(kernel.getConfig().lookupTopics(SERVICES_NAMESPACE_TOPIC,\n+                    TOKEN_EXCHANGE_SERVICE_TOPICS).lookup(PARAMETERS_CONFIG_KEY, IOT_ROLE_ALIAS_TOPIC).getOnce());\n+", "originalCommit": "f148d22f81cd3e57c067ad3ab955bddeabd64578", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504133783", "bodyText": "Fixed", "author": "tomnagy-aws", "createdAt": "2020-10-13T17:28:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNTAxNg=="}], "type": "inlineReview"}, {"oid": "4f413e1c447fafcb7b1de602576c993d9e2545d2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4f413e1c447fafcb7b1de602576c993d9e2545d2", "message": "Fix DeviceConfiguration injection", "committedDate": "2020-10-13T17:27:18Z", "type": "commit"}, {"oid": "102e782da0b63150411d7cb89b7f45db6e0668e9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/102e782da0b63150411d7cb89b7f45db6e0668e9", "message": "Fix tes role alias lookup", "committedDate": "2020-10-13T17:28:15Z", "type": "commit"}, {"oid": "ccf4c9e9354f8b7e02f8bd8beb53743d9fc71ccf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ccf4c9e9354f8b7e02f8bd8beb53743d9fc71ccf", "message": "Merge branch 'master' into network-proxy-support", "committedDate": "2020-10-13T17:30:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzQ3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504137477", "bodyText": "swap the order of this if-else, then you can remove the pmd suppression", "author": "MikeDombo", "createdAt": "2020-10-13T17:35:40Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -93,24 +103,71 @@\n     /**\n      * Constructor for injection.\n      *\n+     * @param kernel              kernel for tes role alias\n      * @param deviceConfiguration device configuration\n      * @param executorService     executor service\n      */\n     @Inject\n-    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+    @SuppressWarnings(\"PMD.ConfusingTernary\")\n+    public MqttClient(Kernel kernel, DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n         this(deviceConfiguration, null, executorService);\n-        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n-                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n-                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n-                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n-                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n-                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n-                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n-                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n-                .withPingTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n-                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n-                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+\n+        HttpProxyOptions httpProxyOptions = ProxyUtils.getHttpProxyOptions(deviceConfiguration);\n+\n+        if (httpProxyOptions != null) {", "originalCommit": "ccf4c9e9354f8b7e02f8bd8beb53743d9fc71ccf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2OTc1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/460#discussion_r504169752", "bodyText": "Done", "author": "tomnagy-aws", "createdAt": "2020-10-13T18:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzQ3Nw=="}], "type": "inlineReview"}, {"oid": "327394e0100929bd8de090e550ec53679d00e543", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/327394e0100929bd8de090e550ec53679d00e543", "message": "Remove ConfusingTernary", "committedDate": "2020-10-13T18:26:05Z", "type": "commit"}, {"oid": "7a2d9a01fc070b2b89610c0f2cedce8975e4aa94", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7a2d9a01fc070b2b89610c0f2cedce8975e4aa94", "message": "Merge branch 'master' into network-proxy-support", "committedDate": "2020-10-13T23:44:55Z", "type": "commit"}, {"oid": "e5317db609126184e56c077942bd90e511f59554", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e5317db609126184e56c077942bd90e511f59554", "message": "Merge branch 'master' into network-proxy-support", "committedDate": "2020-10-14T12:43:34Z", "type": "commit"}]}