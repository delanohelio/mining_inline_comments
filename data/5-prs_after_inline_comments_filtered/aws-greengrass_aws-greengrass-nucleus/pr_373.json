{"pr_number": 373, "pr_title": "Cli APIs over IPC", "pr_createdAt": "2020-08-19T00:41:26Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQyNTA5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473425098", "bodyText": "Use PackageStore.RECIPE_DIRECTORY", "author": "fahadmohammed01", "createdAt": "2020-08-19T23:19:36Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQyNTU3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473425572", "bodyText": "Use PackageStore.ARTIFACT_DIRECTORY", "author": "fahadmohammed01", "createdAt": "2020-08-19T23:20:15Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMjk2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473432966", "bodyText": "why not use Utils.copyFolderRecursively()", "author": "fahadmohammed01", "createdAt": "2020-08-19T23:30:36Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID);\n+        Topic localDeploymentDetails = localDeployments.lookup(deploymentId);\n+        localDeploymentDetails.withValue(deploymentDetails);\n+        DeploymentStatus status = (DeploymentStatus) deploymentDetails.get(\n+                PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    private void validateGetLocalDeploymentStatusRequest(GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError {\n+        try {\n+            UUID.fromString(request.getDeploymentId());\n+        } catch (IllegalArgumentException e) {\n+            throw new InvalidArgumentsError(\"Invalid deploymentId format received. DeploymentId is a UUID\");\n+        }\n+    }\n+\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2OTI0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474369246", "bodyText": "Din know that existed. Thanks!", "author": "abanthiy", "createdAt": "2020-08-21T02:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMjk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMzIwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473433200", "bodyText": "Does this need to be public?", "author": "fahadmohammed01", "createdAt": "2020-08-19T23:30:55Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4MDY0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474380641", "bodyText": "Yes, this is being called by the CLIService to be invoked when deploymentStatusKeeper wants to persist the status of local deployment", "author": "abanthiy", "createdAt": "2020-08-21T02:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTc1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474825751", "bodyText": "Does orderedDependencies also have main? do we need to filter it since it's not a component? Also internal services?", "author": "shaguptashaikh", "createdAt": "2020-08-21T17:16:26Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNjI1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474826259", "bodyText": "Yes, it includes main. IMO, don't filter it.", "author": "MikeDombo", "createdAt": "2020-08-21T17:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2OTc2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476969764", "bodyText": "I filtered main but not internal services. This is how it was in the existing CLI implementation", "author": "abanthiy", "createdAt": "2020-08-26T01:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNzIwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474827205", "bodyText": "Should this wait and check if the state transition actually happens before returning success?", "author": "shaguptashaikh", "createdAt": "2020-08-21T17:19:30Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2OTI4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476969289", "bodyText": "Same as below", "author": "abanthiy", "createdAt": "2020-08-26T01:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNzIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyODIzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474828235", "bodyText": "Same here, do we need to wait and validate if the request actually went through?", "author": "shaguptashaikh", "createdAt": "2020-08-21T17:21:34Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2OTEyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476969123", "bodyText": "Client can verify that by calling getComponentDetails API. We do not know how long it is going to take to perform the operation.", "author": "abanthiy", "createdAt": "2020-08-26T01:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyODIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzMjcyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474832729", "bodyText": "Since this agent is directly interacting with deployments queue now, we should not need LocalDeploymentListener.java anymore right?", "author": "shaguptashaikh", "createdAt": "2020-08-21T17:30:47Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest", "originalCommit": "1cf3548202fe08dab86f4584506cc11088b02b56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2NzAwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476967002", "bodyText": "Yes, I will remove LocalDeploymentListener after the CLI agent has been moved to IPC communication.", "author": "abanthiy", "createdAt": "2020-08-26T01:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzMjcyOQ=="}], "type": "inlineReview"}, {"oid": "645f879244d34ae21681b30d3694573ba0bdf8e8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/645f879244d34ae21681b30d3694573ba0bdf8e8", "message": "Cli APIs over IPC", "committedDate": "2020-08-26T01:37:42Z", "type": "forcePushed"}, {"oid": "cdbf6a377525d6e4cfa6b54841af9eada6f88929", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cdbf6a377525d6e4cfa6b54841af9eada6f88929", "message": "Cli APIs over IPC", "committedDate": "2020-08-26T01:45:54Z", "type": "forcePushed"}, {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1875a06a41948ece5b6e60f04c2c1497597582d2", "message": "Cli APIs over IPC", "committedDate": "2020-08-26T02:15:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzOTExMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478639112", "bodyText": "Remove commented code?", "author": "shaguptashaikh", "createdAt": "2020-08-27T19:14:50Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -279,8 +280,12 @@ public IotJobsClient getIotJobsClient(MqttClientConnection connection) {\n     }\n \n     private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n-        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n-        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        DeploymentDetailsIotJobs deploymentDetailsIotJobs = OBJECT_MAPPER.convertValue(deploymentDetails,\n+                DeploymentDetailsIotJobs.class);\n+        //        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();", "originalCommit": "1875a06a41948ece5b6e60f04c2c1497597582d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNTY3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478725676", "bodyText": "This can result in index out of bound exception if the client has an opcode > the CliClientOpCodes.values()", "author": "fahadmohammed01", "createdAt": "2020-08-27T22:15:30Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/CLIService.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package com.aws.iot.evergreen.ipc.modules;\n+\n+import com.aws.iot.evergreen.builtin.services.cli.CLIServiceAgent;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.ipc.services.cli.CliClientOpCodes;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.GenericCliIpcServerException;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CliGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n+import lombok.Data;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+@ImplementsService(name = CLIService.CLI_SERVICE, autostart = true)\n+public class CLIService extends EvergreenService {\n+\n+    private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+\n+    public static final String CLI_SERVICE = \"aws.greengrass.ipc.cli\";\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+\n+    @Inject\n+    CLIServiceAgent agent;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    public CLIService(Topics topics) {\n+        super(topics);\n+    }\n+\n+    /**\n+     * Constructor for unit testing.\n+     * @param topics Service config\n+     * @param router {@link IPCRouter}\n+     * @param agent {@link CLIServiceAgent}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     */\n+    public CLIService(Topics topics, IPCRouter router, CLIServiceAgent agent,\n+                      DeploymentStatusKeeper deploymentStatusKeeper) {\n+        super(topics);\n+        this.router = router;\n+        this.agent = agent;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.CLI;\n+        super.postInject();\n+        try {\n+            router.registerServiceCallback(destination.getValue(), this::handleMessage);\n+            logger.atInfo().setEventType(\"ipc-register-request-handler\").addKeyValue(\"destination\", destination.name())\n+                    .log();\n+            deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                    this::deploymentStatusChanged, CLIService.class.getName());\n+        } catch (IPCException e) {\n+            logger.atError().setEventType(\"ipc-register-request-handler-error\").setCause(e)\n+                    .addKeyValue(\"destination\", destination.name())\n+                    .log(\"Failed to register service callback to destination\");\n+        }\n+    }\n+\n+    @Data\n+    public static class LocalDeploymentDetails {\n+        String deploymentId;\n+        DeploymentStatus status;\n+    }\n+\n+    @SuppressWarnings(\"PMD.EmptyIfStmt\")\n+    protected Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        agent.persistLocalDeployment(config, deploymentDetails);\n+        return true;\n+    }\n+\n+    /**\n+     * Handle all requests for CLI from the CLI client.\n+     *\n+     * @param message incoming request\n+     * @param context Context identifying the client and the channel\n+     */\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    public Future<FrameReader.Message> handleMessage(FrameReader.Message message, ConnectionContext context) {\n+        CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+\n+        ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n+        try {\n+            //TODO: add version compatibility check\n+            CliClientOpCodes opCode = CliClientOpCodes.values()[applicationMessage.getOpCode()];", "originalCommit": "1875a06a41948ece5b6e60f04c2c1497597582d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNjI1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478726254", "bodyText": "Didn't we agree to have component configuration in the getComponentDetails or is that covered by another API", "author": "fahadmohammed01", "createdAt": "2020-08-27T22:17:12Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,376 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageStore;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class CLIServiceAgent {\n+\n+    public static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+    public static final String LOCAL_DEPLOYMENT_RESOURCE = \"LocalDeployment\";\n+    private static ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n+            .configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())", "originalCommit": "1875a06a41948ece5b6e60f04c2c1497597582d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a4ab07a528bb00d94e96081457e0be6bbe8fb2af", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a4ab07a528bb00d94e96081457e0be6bbe8fb2af", "message": "Cli APIs over IPC", "committedDate": "2020-08-29T01:18:23Z", "type": "forcePushed"}, {"oid": "b4452930db935c86f220fa45409181ca1ee4dbb0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b4452930db935c86f220fa45409181ca1ee4dbb0", "message": "Cli APIs over IPC", "committedDate": "2020-08-29T01:30:34Z", "type": "forcePushed"}, {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4b8114e9e230173401d1d0767c6a3b57072e1739", "message": "Changing test recipes format as per new format", "committedDate": "2020-08-31T20:23:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r480904243", "bodyText": "This feels weird, creating an object and then storing as a map. Can we just store it as the object and change the call back functions?", "author": "fahadmohammed01", "createdAt": "2020-09-01T07:11:40Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -44,44 +49,52 @@\n      * @param serviceName subscribing service name\n      * @return true if call back is registered.\n      */\n-    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n-            Boolean> consumer, String serviceName) {\n-        Map<String, Function<Map<String, Object>, Boolean>> map =\n-                deploymentStatusConsumerMap.getOrDefault(type, new ConcurrentHashMap<>());\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type,\n+                                                    Function<Map<String, Object>, Boolean> consumer,\n+                                                    String serviceName) {\n+        Map<String, Function<Map<String, Object>, Boolean>> map = deploymentStatusConsumerMap\n+                .getOrDefault(type, new ConcurrentHashMap<>());\n         map.putIfAbsent(serviceName, consumer);\n         return deploymentStatusConsumerMap.put(type, map) == null;\n     }\n \n     /**\n      * Persist deployment status in kernel config.\n      *\n-     * @param jobId          id for the deployment.\n+     * @param deploymentId   id for the deployment.\n      * @param deploymentType type of deployment.\n      * @param status         status of deployment.\n      * @param statusDetails  other details of deployment status.\n      */\n-    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n-                                                  JobStatus status, Map<String, String> statusDetails) {\n-        // no need to persist status for local deployment\n-        if (deploymentType.equals(DeploymentType.LOCAL)) {\n-            return;\n-        }\n+    public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentType deploymentType, String status,\n+                                                  Map<String, String> statusDetails) {\n \n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            Map<String, Object> deploymentDetails = new HashMap<>();\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = null;\n+            if (deploymentType == DeploymentType.IOT_JOBS) {\n+                IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n+                        new IotJobsHelper.DeploymentDetailsIotJobs();\n+                deploymentDetailsIotJobs.setJobId(deploymentId);", "originalCommit": "4b8114e9e230173401d1d0767c6a3b57072e1739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1ODA4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r481458083", "bodyText": "Things like deployment type needs to be stored agnostic of the object type. So we will need to store map. I wanted to have a model for whatever we are storing since it makes it more readable.", "author": "abanthiy", "createdAt": "2020-09-01T22:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzcyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r481467724", "bodyText": "I agree, having a model makes it more readable.  we can model the values which are agnostic to type using inheritance", "author": "fahadmohammed01", "createdAt": "2020-09-01T22:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMDU5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r482210594", "bodyText": "Is there a TODO/task for the desired improvement you're discussing here?", "author": "shaguptashaikh", "createdAt": "2020-09-02T16:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxOTYzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r483719635", "bodyText": "Added a TODO to evaluate this approach", "author": "abanthiy", "createdAt": "2020-09-04T16:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDk3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r480904974", "bodyText": "same as above, can we avoid the serialization and de-serialization ?", "author": "fahadmohammed01", "createdAt": "2020-09-01T07:12:40Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -279,15 +282,15 @@ public IotJobsClient getIotJobsClient(MqttClientConnection connection) {\n     }\n \n     private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n-        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n-        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        DeploymentDetailsIotJobs deploymentDetailsIotJobs = OBJECT_MAPPER.convertValue(deploymentDetails,", "originalCommit": "4b8114e9e230173401d1d0767c6a3b57072e1739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a2ac3d72f374ca77b404f7652801a38c73bb275e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2ac3d72f374ca77b404f7652801a38c73bb275e", "message": "Changing test recipes format as per new format", "committedDate": "2020-09-03T01:17:08Z", "type": "forcePushed"}, {"oid": "65bc91608224ac7d7b2c202a6eee43bfa03cd515", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65bc91608224ac7d7b2c202a6eee43bfa03cd515", "message": "Fixing directory path in intergration tests", "committedDate": "2020-09-03T19:44:28Z", "type": "forcePushed"}, {"oid": "c3f4a3ae12fcdd92201c206af5f690d7c0c44a55", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3f4a3ae12fcdd92201c206af5f690d7c0c44a55", "message": "Fixing directory path in intergration tests", "committedDate": "2020-09-03T23:30:44Z", "type": "forcePushed"}, {"oid": "fdd81bb37ef1483bdb1a1b40d9ecf8428ae3a2a3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fdd81bb37ef1483bdb1a1b40d9ecf8428ae3a2a3", "message": "Cli APIs over IPC", "committedDate": "2020-09-04T00:34:35Z", "type": "commit"}, {"oid": "b6b7b3064124d3d049cacfd3830eb96494607c88", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6b7b3064124d3d049cacfd3830eb96494607c88", "message": "Changing test recipes format as per new format", "committedDate": "2020-09-04T00:34:35Z", "type": "commit"}, {"oid": "0f57ab1fde9668fdb4b02a45e19bb371bd8a5eb1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0f57ab1fde9668fdb4b02a45e19bb371bd8a5eb1", "message": "Fixing directory path in intergration tests", "committedDate": "2020-09-04T00:35:22Z", "type": "forcePushed"}, {"oid": "ad2d9f6336aa6ee50433f469f913bb2e4849d4d2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ad2d9f6336aa6ee50433f469f913bb2e4849d4d2", "message": "Fixing directory path in intergration tests", "committedDate": "2020-09-04T00:36:50Z", "type": "forcePushed"}, {"oid": "4082074183275c50caeae7b01c3573073d331de7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4082074183275c50caeae7b01c3573073d331de7", "message": "Fixing directory path in intergration tests", "committedDate": "2020-09-04T01:20:13Z", "type": "forcePushed"}, {"oid": "ec7d54e263cf34b441c4f0ab895d2801a8a84706", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec7d54e263cf34b441c4f0ab895d2801a8a84706", "message": "Fixing directory path in intergration tests", "committedDate": "2020-09-04T16:11:51Z", "type": "commit"}, {"oid": "ec7d54e263cf34b441c4f0ab895d2801a8a84706", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec7d54e263cf34b441c4f0ab895d2801a8a84706", "message": "Fixing directory path in intergration tests", "committedDate": "2020-09-04T16:11:51Z", "type": "forcePushed"}]}