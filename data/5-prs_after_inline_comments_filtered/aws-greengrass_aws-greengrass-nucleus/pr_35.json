{"pr_number": 35, "pr_title": "POC implementation of service discovery", "pr_createdAt": "2020-01-18T00:33:43Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3MzY0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368773641", "bodyText": "Missing Java docs. We should have java doc for all public classes and methods.", "author": "fengwang666", "createdAt": "2020-01-21T01:14:12Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+\n+public class SDAResource {", "originalCommit": "25270eac0d9f5e1858f269d51e2def815ea128a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxNzU4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368817582", "bodyText": "This one is internal to service discovery, but for everything yes, yeah.", "author": "MikeDombo", "createdAt": "2020-01-21T05:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3MzY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3OTI2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368779267", "bodyText": "so it seems the path might not be unique for two different resources if there are overlapping values across the different fields:\nFor example,\nResource A: {\"name\": \"A\", \"serviceSubtype\": foo, \"domain\": \"bar\"}\nResource B: {\"name\": \"A\", \"serviceType\": foo, \"domain\": \"bar\"}\nthey're different resources but will be resolved into the same path.\nAlso are we sure \".\"  is not part of character set of the field values?", "author": "fengwang666", "createdAt": "2020-01-21T01:47:19Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    private final static Map<String, Set<String>> serviceSubtypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> serviceTypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> nameResourceNamesMap = new ConcurrentHashMap<>();\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();\n+        sdaResource.resource = request.resource;\n+        sdaResource.publishedToDNSSD = request.publishToDNSSD;\n+        sdaResource.owningService = serviceName;\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        BiFunction<? super String, ? super Set<String>, ? extends Set<String>> addOrCreate =\n+                (key, old) -> {\n+                    if (old == null) {\n+                        old = new HashSet<>();\n+                    }\n+                    old.add(resourcePath);\n+                    return old;\n+                };\n+        if (sdaResource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.compute(sdaResource.resource.serviceSubtype, addOrCreate);\n+        if (sdaResource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.compute(sdaResource.resource.serviceType, addOrCreate);\n+        if (sdaResource.resource.name != null)\n+            nameResourceNamesMap.compute(sdaResource.resource.name, addOrCreate);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        response.response = request.resource;\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.resource.txtRecords = request.resource.txtRecords;\n+        resource.resource.uri = request.resource.uri;\n+        resource.publishedToDNSSD = request.publishToDNSSD;\n+        config.find(REGISTERED_RESOURCES, resourcePath).fire(WhatHappened.changed);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> removeResource(RemoveResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to remove %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // Remove from quick lookup tables\n+        if (resource.resource.name != null)\n+            nameResourceNamesMap.get(resource.resource.name).remove(resourcePath);\n+        if (resource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.get(resource.resource.serviceSubtype).remove(resourcePath);\n+        if (resource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.get(resource.resource.serviceType).remove(resourcePath);\n+\n+        // Remove from master list\n+        config.find(REGISTERED_RESOURCES, resourcePath).remove();\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> lookupResources(LookupResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO: input validation\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        List<Resource> matchingResources = new ArrayList<>();\n+\n+        // Try a direct lookup\n+        response.response = matchingResources;\n+        if (isRegistered(resourcePath)) {\n+            matchingResources.add(((SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce()).resource);\n+            return response;\n+        }\n+\n+        // Exact match not found, try a fuzzy search\n+        if (request.resource.name != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, nameResourceNamesMap, request.resource.name));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceSubtype != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceSubtypeResourceNamesMap, request.resource.serviceSubtype));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceType != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceTypeResourceNamesMap, request.resource.serviceType));\n+        }\n+\n+        return response;\n+    }\n+\n+    private List<Resource> findMatchingResourcesInMap(LookupResourceRequest request, Map<String, Set<String>> map, String fieldValue) {\n+        return map.\n+                get(fieldValue).stream()\n+                .map(s -> ((SDAResource) config.find(REGISTERED_RESOURCES, s).getOnce()).resource)\n+                .filter(r -> matchResourceFields(request.resource, r))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static String resourceToPath(Resource r) {", "originalCommit": "25270eac0d9f5e1858f269d51e2def815ea128a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxNzc4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368817784", "bodyText": "\".\" is a valid character for DNS-SD and you're right that A and B will overlap, therefore we don't allow duplicate registration. We can discuss with Fahad if we want to completely change it so they're totally unique.", "author": "MikeDombo", "createdAt": "2020-01-21T05:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3OTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMTU3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369211573", "bodyText": "I looked at this snippet from the rfc for the fully qualified name\nRFC: https://tools.ietf.org/html/rfc6763#section-5\nA fully qualified domain name may be up to 255 bytes long, plus one\nbyte for the final terminating root label at the end.  Domain names\nused by DNS-SD take the following forms:\n               <sn>._tcp . <servicedomain> . <parentdomain>.\n  <Instance> . <sn>._tcp . <servicedomain> . <parentdomain>.\n  <sub>._sub . <sn>._tcp . <servicedomain> . <parentdomain>.\n\nThe first example shows the name used for PTR queries.  The second\nshows a Service Instance Name, i.e., the name of the service's SRV\nand TXT records.", "author": "fahadmohammed01", "createdAt": "2020-01-21T19:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3OTI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3OTQ2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368779465", "bodyText": "Maybe changing the method name to \"nullOrEqual\" is better?", "author": "fengwang666", "createdAt": "2020-01-21T01:48:20Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    private final static Map<String, Set<String>> serviceSubtypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> serviceTypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> nameResourceNamesMap = new ConcurrentHashMap<>();\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();\n+        sdaResource.resource = request.resource;\n+        sdaResource.publishedToDNSSD = request.publishToDNSSD;\n+        sdaResource.owningService = serviceName;\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        BiFunction<? super String, ? super Set<String>, ? extends Set<String>> addOrCreate =\n+                (key, old) -> {\n+                    if (old == null) {\n+                        old = new HashSet<>();\n+                    }\n+                    old.add(resourcePath);\n+                    return old;\n+                };\n+        if (sdaResource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.compute(sdaResource.resource.serviceSubtype, addOrCreate);\n+        if (sdaResource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.compute(sdaResource.resource.serviceType, addOrCreate);\n+        if (sdaResource.resource.name != null)\n+            nameResourceNamesMap.compute(sdaResource.resource.name, addOrCreate);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        response.response = request.resource;\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.resource.txtRecords = request.resource.txtRecords;\n+        resource.resource.uri = request.resource.uri;\n+        resource.publishedToDNSSD = request.publishToDNSSD;\n+        config.find(REGISTERED_RESOURCES, resourcePath).fire(WhatHappened.changed);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> removeResource(RemoveResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to remove %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // Remove from quick lookup tables\n+        if (resource.resource.name != null)\n+            nameResourceNamesMap.get(resource.resource.name).remove(resourcePath);\n+        if (resource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.get(resource.resource.serviceSubtype).remove(resourcePath);\n+        if (resource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.get(resource.resource.serviceType).remove(resourcePath);\n+\n+        // Remove from master list\n+        config.find(REGISTERED_RESOURCES, resourcePath).remove();\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> lookupResources(LookupResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO: input validation\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        List<Resource> matchingResources = new ArrayList<>();\n+\n+        // Try a direct lookup\n+        response.response = matchingResources;\n+        if (isRegistered(resourcePath)) {\n+            matchingResources.add(((SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce()).resource);\n+            return response;\n+        }\n+\n+        // Exact match not found, try a fuzzy search\n+        if (request.resource.name != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, nameResourceNamesMap, request.resource.name));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceSubtype != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceSubtypeResourceNamesMap, request.resource.serviceSubtype));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceType != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceTypeResourceNamesMap, request.resource.serviceType));\n+        }\n+\n+        return response;\n+    }\n+\n+    private List<Resource> findMatchingResourcesInMap(LookupResourceRequest request, Map<String, Set<String>> map, String fieldValue) {\n+        return map.\n+                get(fieldValue).stream()\n+                .map(s -> ((SDAResource) config.find(REGISTERED_RESOURCES, s).getOnce()).resource)\n+                .filter(r -> matchResourceFields(request.resource, r))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static String resourceToPath(Resource r) {\n+        return Stream.of(r.name, r.serviceSubtype, r.serviceType, r.domain)\n+                .filter(s -> s != null && !s.isEmpty())\n+                .collect(Collectors.joining(\".\"));\n+    }\n+\n+    private static boolean matchResourceFields(Resource input, Resource validateAgainst) {\n+        return equalOrNull(input.name, validateAgainst.name)\n+                && equalOrNull(input.serviceType, validateAgainst.serviceType)\n+                && equalOrNull(input.serviceSubtype, validateAgainst.serviceSubtype)\n+                && equalOrNull(input.domain, validateAgainst.domain);\n+    }\n+\n+    private static boolean equalOrNull(String input, String validateAgainst) {", "originalCommit": "25270eac0d9f5e1858f269d51e2def815ea128a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgwNzA1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368807056", "bodyText": "Why not return RequestContext object instead? Then you can get rid of clientIdToServiceMap.", "author": "fengwang666", "createdAt": "2020-01-21T04:29:41Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+\n+        // Ideally we would get called when a new service is added\n+        config.getRoot().subscribe((w, c) -> {\n+            if (!w.equals(WhatHappened.childAdded)) {\n+                return;\n+            }\n+            if (c.parent != config.getRoot()) {\n+                return;\n+            }\n+            kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+        });\n+    }\n+\n+    private void generateAuthTokenForService(String serviceName) {\n+        // 256 bits of secure randomness should be enough, though we can always increase this\n+        byte[] secureBytes = new byte[32];\n+        random.nextBytes(secureBytes);\n+        String authToken = Base64.getEncoder().encodeToString(secureBytes);\n+        config.lookup(serviceName, \"setenv\", AUTH_TOKEN_ENV_VAR)\n+                .setValue(authToken);\n+        tokenTopic.createLeafChild(serviceName).setValue(authToken);\n+    }\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public String doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {", "originalCommit": "25270eac0d9f5e1858f269d51e2def815ea128a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxNzk4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368817988", "bodyText": "I'll look into it, though one reason to keep it as-is though, is that I'm expecting to add some more to the RequestContext which is unique per-request instead of per-client, such as the sequence number.", "author": "MikeDombo", "createdAt": "2020-01-21T05:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgwNzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyNDIzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369124238", "bodyText": "After looking at the code some more I want to keep it because we'll need a way to map from service name back to client id, so we do need a central map that any service can access. If I just stored the information in the ConnectionReader object, then we wouldn't be able to do that association. The reason we need the association is so that the kernel can send a message to a service by service name and not just client id.", "author": "MikeDombo", "createdAt": "2020-01-21T16:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgwNzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxNDAwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368814002", "bodyText": "These maps are not synchronized with the \"master\" config. It's possible there can be race conditions between lookupResources() and registerResource() method. Why not just use a trie to store the whole thing?", "author": "fengwang666", "createdAt": "2020-01-21T05:11:38Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    private final static Map<String, Set<String>> serviceSubtypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> serviceTypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> nameResourceNamesMap = new ConcurrentHashMap<>();", "originalCommit": "25270eac0d9f5e1858f269d51e2def815ea128a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxODEyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368818129", "bodyText": "This is what Fahad had in the design, so let's discuss together tomorrow. You're right that they could be out of sync, and of course we wouldn't want that.", "author": "MikeDombo", "createdAt": "2020-01-21T05:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxNDAwMg=="}], "type": "inlineReview"}, {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/57c57018e618808acf8e44bb47fc51b04f9f1f16", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-21T17:51:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwOTEyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369209126", "bodyText": "Do we have any use case for this?", "author": "fahadmohammed01", "createdAt": "2020-01-21T19:51:13Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();\n+        sdaResource.resource = request.resource;\n+        sdaResource.publishedToDNSSD = request.publishToDNSSD;\n+        sdaResource.owningService = serviceName;\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        response.response = request.resource;\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.resource.txtRecords = request.resource.txtRecords;\n+        resource.resource.uri = request.resource.uri;\n+        resource.publishedToDNSSD = request.publishToDNSSD;\n+        config.find(REGISTERED_RESOURCES, resourcePath).fire(WhatHappened.changed);", "originalCommit": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMDE1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369210156", "bodyText": "What do you mean? This is how someone updates, yes we definitely have a use case for updating info.", "author": "MikeDombo", "createdAt": "2020-01-21T19:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwOTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1NDkwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369254900", "bodyText": "I meant do we need to fire a WhatHappened.changed event", "author": "fahadmohammed01", "createdAt": "2020-01-21T21:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwOTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1NzY5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369257698", "bodyText": "Oh, I see. No, there's no use case currently. But I believe that it more correct, but again there's no need at this time.", "author": "MikeDombo", "createdAt": "2020-01-21T21:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwOTEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwOTM0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369209341", "bodyText": "If two requests reach this line concurrently, then both would succeed. Can we add locks around register/update/delete requests.", "author": "fahadmohammed01", "createdAt": "2020-01-21T19:51:37Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();", "originalCommit": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMzAyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369213020", "bodyText": "Going forward can we have separate cr's for bug fixes not logically related to what the cr is addressing.", "author": "fahadmohammed01", "createdAt": "2020-01-21T19:58:41Z", "path": "src/main/java/com/aws/iot/evergreen/config/WhatHappened.java", "diffHunk": "@@ -3,5 +3,5 @@\n package com.aws.iot.evergreen.config;\n \n public enum WhatHappened {", "originalCommit": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxNTgzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369215836", "bodyText": "This isn't a bug fix, this is letting me listen for newly added service which auth requires which service discovery requires. If we do auth differently as you suggest, then this won't be needed.", "author": "MikeDombo", "createdAt": "2020-01-21T20:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMzAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMzY3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369213675", "bodyText": "Kernel already inject two tokens via env variables to every external process created using shell runner.  Can we use those instead of injecting another token. I am not sure we need a token for service that are running inside the kernel process space", "author": "fahadmohammed01", "createdAt": "2020-01-21T20:00:03Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));", "originalCommit": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxNjk4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369216980", "bodyText": "If the only place this will be called is when creating the connection reader, can we return the service name/client id when auth method is called instead of storing it in a map.", "author": "fahadmohammed01", "createdAt": "2020-01-21T20:07:18Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+\n+        // Ideally we would get called when a new service is added\n+        config.getRoot().subscribe((w, c) -> {\n+            if (!w.equals(WhatHappened.childAdded)) {\n+                return;\n+            }\n+            if (c.parent != config.getRoot()) {\n+                return;\n+            }\n+            kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+        });\n+    }\n+\n+    private void generateAuthTokenForService(String serviceName) {\n+        // 256 bits of secure randomness should be enough, though we can always increase this\n+        byte[] secureBytes = new byte[32];\n+        random.nextBytes(secureBytes);\n+        String authToken = Base64.getEncoder().encodeToString(secureBytes);\n+        config.lookup(serviceName, \"setenv\", AUTH_TOKEN_ENV_VAR)\n+                .setValue(authToken);\n+        tokenTopic.createLeafChild(serviceName).setValue(authToken);\n+    }\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public String doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        String serviceName = null;\n+        for (Map.Entry<String, Object> entry : tokenTopic.toPOJO().entrySet()) {\n+            String value = (String) entry.getValue();\n+            if (value.equals(authToken)) {\n+                serviceName = entry.getKey();\n+            }\n         }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        if (serviceName == null) {\n+            throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n+\n+        clientIdToServiceMap.put(clientId, serviceName);\n         return clientId;\n     }\n \n+    public String getServiceNameFromClientId(String clientId) {", "originalCommit": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODA1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369218058", "bodyText": "Is the intent in using a separate UUID for client ID to support multiple connections from the same service? Is there any other concern in using the auth token as the clientId", "author": "fahadmohammed01", "createdAt": "2020-01-21T20:09:39Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+\n+        // Ideally we would get called when a new service is added\n+        config.getRoot().subscribe((w, c) -> {\n+            if (!w.equals(WhatHappened.childAdded)) {\n+                return;\n+            }\n+            if (c.parent != config.getRoot()) {\n+                return;\n+            }\n+            kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+        });\n+    }\n+\n+    private void generateAuthTokenForService(String serviceName) {\n+        // 256 bits of secure randomness should be enough, though we can always increase this\n+        byte[] secureBytes = new byte[32];\n+        random.nextBytes(secureBytes);\n+        String authToken = Base64.getEncoder().encodeToString(secureBytes);\n+        config.lookup(serviceName, \"setenv\", AUTH_TOKEN_ENV_VAR)\n+                .setValue(authToken);\n+        tokenTopic.createLeafChild(serviceName).setValue(authToken);\n+    }\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public String doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();", "originalCommit": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODcwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369218708", "bodyText": "Yes, it is so that we associate a single socket connection with a service name and a service may have multiple clients connected for it. Therefore, they do need unique IDs of some sort.", "author": "MikeDombo", "createdAt": "2020-01-21T20:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODA1OA=="}], "type": "inlineReview"}, {"oid": "6fb8b1939a8b7c3730c96b25383c9a6e22e1d47c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6fb8b1939a8b7c3730c96b25383c9a6e22e1d47c", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-22T01:03:26Z", "type": "forcePushed"}, {"oid": "13887c33eb07123b4cbd410c894e9aa5ed893f7a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/13887c33eb07123b4cbd410c894e9aa5ed893f7a", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-22T03:39:29Z", "type": "forcePushed"}, {"oid": "2fd20672a2a78a4d3054af0f9ab3a52744cddaf8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2fd20672a2a78a4d3054af0f9ab3a52744cddaf8", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-22T17:37:27Z", "type": "forcePushed"}, {"oid": "ed6819e4f7b0642f8857e015c91b89485ec7e62b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ed6819e4f7b0642f8857e015c91b89485ec7e62b", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-22T18:33:20Z", "type": "forcePushed"}, {"oid": "6c7b3cdf041a2819a91426f45199c32053a0ca86", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c7b3cdf041a2819a91426f45199c32053a0ca86", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-22T19:21:36Z", "type": "commit"}, {"oid": "6c7b3cdf041a2819a91426f45199c32053a0ca86", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c7b3cdf041a2819a91426f45199c32053a0ca86", "message": "POC implementation of service discovery. Implement auth for IPC connections", "committedDate": "2020-01-22T19:21:36Z", "type": "forcePushed"}]}