{"pr_number": 164, "pr_title": "Package store happy path", "pr_createdAt": "2020-04-07T20:22:08Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTQ5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405135492", "bodyText": "How does this work for completing with an error? Does that count as a completion? We really don't want to be get()ing with no timeout since it obviously blocks forever.", "author": "MikeDombo", "createdAt": "2020-04-07T21:52:25Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentTask.java", "diffHunk": "@@ -45,11 +46,11 @@ public Void call() throws NonRetryableDeploymentTaskFailureException, RetryableD\n             //  of all groups, when multi group support is added.\n             List<String> rootPackages = new ArrayList<>(document.getRootPackages());\n \n-            List<PackageIdentifier> desiredPackages = dependencyResolver\n-                    .resolveDependencies(document, rootPackages);\n+            List<PackageIdentifier> desiredPackages = dependencyResolver.resolveDependencies(document, rootPackages);\n             // Block this without timeout because a device can be offline and it can take quite a long time\n             // to download a package.\n-            packageStore.preparePackages(desiredPackages).get();\n+            List<CompletableFuture<Boolean>> preparePackageFutures = packageStore.preparePackages(desiredPackages);\n+            CompletableFuture.allOf(preparePackageFutures.toArray(new CompletableFuture[0])).get();", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNjk5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405226997", "bodyText": "I'm fine with get() blocking as long as DeploymentTask can cancel this when the deployment is being cancelled. My reasoning is, even if deploymentTask put a timeout on the get() call, how would it handle the timeout? fail the deployment? It's undesired because we expect the deployment can be hanging for a long time if the network is off; retry on the timeout? My preference is inside preparePackages() method, we should retry on the download packages.", "author": "fengwang666", "createdAt": "2020-04-08T02:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTYyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405135622", "bodyText": "If possible, remove these suppressions as well.", "author": "MikeDombo", "createdAt": "2020-04-07T21:52:44Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,21 +35,34 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MjEwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405642101", "bodyText": "sure, they can be removed now.", "author": "wikimonkey", "createdAt": "2020-04-08T16:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3Njg3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405776877", "bodyText": "Sorry, I notice we can't remove it now, it still has legacy methods using it. I will remove them once we delete the legacy methods in the next round.", "author": "wikimonkey", "createdAt": "2020-04-08T19:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjQxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405136410", "bodyText": "should this all be encapsulated into findPackageRecipe? Seems that all of these go together.", "author": "MikeDombo", "createdAt": "2020-04-07T21:54:23Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0Mzg5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405643894", "bodyText": "My intention is to separate elementary CRUD operations with business logic. CRUD operations can be further refactor to a separate class, and the unit tests can be more efficient.", "author": "wikimonkey", "createdAt": "2020-04-08T16:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjc1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405136756", "bodyText": "Please rename e to something more meaningful.", "author": "MikeDombo", "createdAt": "2020-04-07T21:55:10Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MjMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405642308", "bodyText": "sure", "author": "wikimonkey", "createdAt": "2020-04-08T16:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzExNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405137117", "bodyText": "Shouldn't this exception be caught in the outside of this lambda? Since you expect that it can be thrown, I think you should rewrap it in one of your package exceptions.", "author": "MikeDombo", "createdAt": "2020-04-07T21:56:05Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NjU1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405646558", "bodyText": "It doesn't expect URI syntax error. The recipe syntax should be validated on the cloud. So here I say if it's syntax error, fail the task.", "author": "wikimonkey", "createdAt": "2020-04-08T16:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3NzIwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405677202", "bodyText": "We don't want to propagate errors as runtime errors, so I'd suggest to catch it outside of the lambda and then rethrow as a checked exception.", "author": "MikeDombo", "createdAt": "2020-04-08T17:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczMzgzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405733832", "bodyText": "In the current logic as you can see, checked exception will be handled instead of failing the preparePackage task. I throw RuntimeException is intentional for failing the task because URL format is not expected to be wrong, the task can't be retried/resumed given format error.", "author": "wikimonkey", "createdAt": "2020-04-08T18:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405137543", "bodyText": "This can never return a meaningful error message, right? All it can tell you is that if failed? I don't think that's a very good interface. We want the user to get the error all the way back up in the console when possible.", "author": "MikeDombo", "createdAt": "2020-04-07T21:56:58Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MTM4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405671387", "bodyText": "From the caller perspective, does it care what errors of preparing a package? Or it only cares whether it succeeds or not.\nYou are right, the error should surface to the customer when possible. I am thinking package store should report its error like kernel does. Kernel doesn't need to report its errors to DA, right?", "author": "wikimonkey", "createdAt": "2020-04-08T16:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3NzcxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405677712", "bodyText": "Without an exception or returned error, how can the caller learn what went wrong? Yes, kernel does need to report errors to DA if the errors will cause the deployment to fail.", "author": "MikeDombo", "createdAt": "2020-04-08T17:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczNzE0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405737142", "bodyText": "Can you explain what DA will do given preparePacakge checked exceptions? Does it expect multiple states return in order to drive different error handling strategies or it only expect bi-states - prepared or not? If bi-states, I think boolean return can represent it.", "author": "wikimonkey", "createdAt": "2020-04-08T18:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczOTUwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405739507", "bodyText": "No, it needs much more information. We need to know what went wrong. \"Unable to download package Stream Manager due to corrupted checksum\" or whatever.", "author": "MikeDombo", "createdAt": "2020-04-08T18:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTE3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405749178", "bodyText": "What actions will DA do per exception? Can you give a few concrete strategies examples?", "author": "wikimonkey", "createdAt": "2020-04-08T19:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MTc3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405751776", "bodyText": "It depends on the exception. But broadly there are 2 classes: retryable and non-retryable. If it is retryable, then it should retry a certain number of times before giving up. If it is non-retryable then it should give up immediately and report back the exception all the way to the customer through the console.", "author": "MikeDombo", "createdAt": "2020-04-08T19:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgzOTQxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405839418", "bodyText": "Checked exception usually described method return state that shouldn't fail the program, in most case the program can retry on the task. Package store checked exceptions are in such case, mostly retryable. Unchecked exception, such as artifact URI syntax error, are given up immediately and report to the caller the program can't proceed. In terms of the caller DA, I don't think it needs to distinguish different checked exception types now, it only cares about whether package is prepared or not after possible retry inside package store.", "author": "wikimonkey", "createdAt": "2020-04-08T21:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0MTU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405941593", "bodyText": "Feng raised a good point on DA reporting deployment failure. In such situation, it needs exception info. So I change to populate the exceptions.", "author": "wikimonkey", "createdAt": "2020-04-09T03:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzY5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405137697", "bodyText": "Prefer Optional instead of returning null.", "author": "MikeDombo", "createdAt": "2020-04-07T21:57:22Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MjIwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405662200", "bodyText": "I am fine with optional. The intention is to distinguish between 'get' and 'find' cases. We can have a convention on query method naming, for example:\nget - throw exception if not exist\nfind - return empty if not exist\nIn the find returning empty case, do we need to distinguish null with empty? If we do, it's a good reason to use optional.", "author": "wikimonkey", "createdAt": "2020-04-08T16:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzODY0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405138648", "bodyText": "LOCAL_CACHE_PATH needs to be a variable, doesn't it?", "author": "MikeDombo", "createdAt": "2020-04-07T21:59:23Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {\n+        if (!Files.exists(packageRecipe) || !Files.isRegularFile(packageRecipe)) {\n+            return new byte[0];\n+        }\n+\n+        try {\n+            return Files.readAllBytes(packageRecipe);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private Package downloadPackageRecipe(PackageIdentifier packageIdentifier) throws PackageDownloadException {\n+        logger.atInfo().setEventType(\"downloading-package-recipe\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).log();\n+        //TODO retrieve package recipe from cloud\n+        //load from local now to pretend it working\n+        try {\n+            return findPackageRecipe(LOCAL_CACHE_PATH.resolve(packageIdentifier.getName())", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NzgzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405647832", "bodyText": "It's actually mocked repository location. It will be deleted once connecting to cloud. So I leave it there now.", "author": "wikimonkey", "createdAt": "2020-04-08T16:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzODY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3ODcyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405678724", "bodyText": "Why would this be removed? You will always need a location to store the package recipes. Some of our tests set this path to something different, so please keep it as a variable so those tests/benchmarks don't break.", "author": "MikeDombo", "createdAt": "2020-04-08T17:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzODY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNzU0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405727546", "bodyText": "It's static final, I didn't change it. You said we are setting it in unit tests, are we doing through reflection? And why do we need it? If talking about recipes for testing, it can be placed into test resource folder.", "author": "wikimonkey", "createdAt": "2020-04-08T18:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzODY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzOTE0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405139148", "bodyText": "Use Path.toFile()?", "author": "MikeDombo", "createdAt": "2020-04-07T22:00:33Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {\n+        if (!Files.exists(packageRecipe) || !Files.isRegularFile(packageRecipe)) {\n+            return new byte[0];\n+        }\n+\n+        try {\n+            return Files.readAllBytes(packageRecipe);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private Package downloadPackageRecipe(PackageIdentifier packageIdentifier) throws PackageDownloadException {\n+        logger.atInfo().setEventType(\"downloading-package-recipe\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).log();\n+        //TODO retrieve package recipe from cloud\n+        //load from local now to pretend it working\n+        try {\n+            return findPackageRecipe(LOCAL_CACHE_PATH.resolve(packageIdentifier.getName())\n+                    .resolve(packageIdentifier.getVersion().getValue()).resolve(\"recipe.yaml\"));\n+        } catch (PackageLoadingException e) {\n+            throw new PackageDownloadException(String.format(\"Failed to download package %s recipe\", packageIdentifier),\n+                    e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {\n+        try {\n+            OBJECT_MAPPER.writeValue(new File(saveToFile.toString()), pkg);", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0OTI4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405649288", "bodyText": "sure, thanks", "author": "wikimonkey", "createdAt": "2020-04-08T16:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzOTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405141481", "bodyText": "This can be greatly simplified.\nFiles.copy(\n      inputStream, \n      saveToPath.resolve(filename),\n      StandardCopyOption.REPLACE_EXISTING);", "author": "MikeDombo", "createdAt": "2020-04-07T22:06:06Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MTAwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405661004", "bodyText": "Yeah, it's much better. Thanks", "author": "wikimonkey", "createdAt": "2020-04-08T16:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405142129", "bodyText": "extract filename= to a variable and then use .length() on it instead of hardcoding the 10. Also, are we positive we want to read all the way to the end? I believe headers like this may be comma or semicolon separated.", "author": "MikeDombo", "createdAt": "2020-04-07T22:07:44Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+        }\n+    }\n+\n+    HttpURLConnection create(URL url) throws IOException {\n+        return (HttpURLConnection) url.openConnection();\n+    }\n+\n+    String getArtifactDownloadURL(String packageArn, String artifactName) {\n+        //TODO retrieve artifact presigned download URL from cloud as redirection\n+        return \"placeholder\";\n+    }\n+\n+    String extractFilename(String preSignedUrl, String contentDisposition) {\n+        if (contentDisposition != null) {\n+            int index = contentDisposition.indexOf(\"filename=\");\n+            if (index > 0) {\n+                return contentDisposition.substring(index + 10, contentDisposition.length() - 1);", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1OTYxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405659613", "bodyText": "Disposition header has protocol on the content, so I think we can read to the end.\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\nYeah, I will remove hard-coded 10 though.", "author": "wikimonkey", "createdAt": "2020-04-08T16:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405142941", "bodyText": "This is assuming too much about the format of the URL. Try something like\nx = uri.getPath().split(\"/\");\nlastPath = x[x.length - 1];", "author": "MikeDombo", "createdAt": "2020-04-07T22:09:40Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+        }\n+    }\n+\n+    HttpURLConnection create(URL url) throws IOException {\n+        return (HttpURLConnection) url.openConnection();\n+    }\n+\n+    String getArtifactDownloadURL(String packageArn, String artifactName) {\n+        //TODO retrieve artifact presigned download URL from cloud as redirection\n+        return \"placeholder\";\n+    }\n+\n+    String extractFilename(String preSignedUrl, String contentDisposition) {\n+        if (contentDisposition != null) {\n+            int index = contentDisposition.indexOf(\"filename=\");\n+            if (index > 0) {\n+                return contentDisposition.substring(index + 10, contentDisposition.length() - 1);\n+            }\n+        }\n+        int startIndex = preSignedUrl.lastIndexOf('/') + 1;\n+        int endIndex = preSignedUrl.indexOf('?');\n+        return endIndex == -1 ? preSignedUrl.substring(startIndex) : preSignedUrl.substring(startIndex, endIndex);", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMzI4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405203281", "bodyText": "What case are we handling here? I'm assuming url with query string? Something like /filename.txt?sessionId=value so that we still extract filename.txt.\nAdd an example in the comment would be very helpful!", "author": "leaf94", "createdAt": "2020-04-08T01:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1NjM1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405656352", "bodyText": "Yeah, Ethan gives a good example, the URL can contain parameters. I will add some comments.", "author": "wikimonkey", "createdAt": "2020-04-08T16:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4Mjg0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406482845", "bodyText": "You're manipulating a URL as a string, but Java has builtins to do this for you which will work properly when given a malformed string. Try the solution I gave in my first comment.", "author": "MikeDombo", "createdAt": "2020-04-09T21:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4MTc2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406581769", "bodyText": "updated", "author": "wikimonkey", "createdAt": "2020-04-10T03:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405143989", "bodyText": "This can be simplified.\nFiles.walk(pathToBeDeleted)\n      .sorted(Comparator.reverseOrder())\n      .map(Path::toFile)\n      .forEach(File::delete);", "author": "MikeDombo", "createdAt": "2020-04-07T22:12:14Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/TestHelper.java", "diffHunk": "@@ -75,4 +78,22 @@ public static String getPackageRecipeFromMockRepository(String testPackageName,\n         String recipeFmt = new String(Files.readAllBytes(path));\n         return String.format(recipeFmt, rootPath.toString());\n     }\n+\n+    public static void cleanDirectory(Path pathToDirectory) throws IOException {", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MjQ2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405652461", "bodyText": "The directory will contain sub-directories. Will the above method recursively clean sub-directories?", "author": "wikimonkey", "createdAt": "2020-04-08T16:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4MDUyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405680527", "bodyText": "I think you can switch it to walkFileTree https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.nio.file.FileVisitor-", "author": "MikeDombo", "createdAt": "2020-04-08T17:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNDY4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405724689", "bodyText": "Yeah, it's what I am using.", "author": "wikimonkey", "createdAt": "2020-04-08T18:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTI4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405145287", "bodyText": "typo: filename", "author": "MikeDombo", "createdAt": "2020-04-07T22:15:22Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloaderTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class GreengrassRepositoryDownloaderTest {\n+\n+    @Spy\n+    private GreengrassRepositoryDownloader downloader;\n+\n+    @Mock\n+    private HttpURLConnection connection;\n+\n+    @Test\n+    void GIVEN_artifact_url_WHEN_attempt_download_THEN_task_succeed() throws Exception {\n+        doReturn(\"https://www.amazon.com/artifact.txt\").when(downloader)\n+                .getArtifactDownloadURL(anyString(), anyString());\n+        doReturn(connection).when(downloader).create(any());\n+        when(connection.getResponseCode()).thenReturn(HttpURLConnection.HTTP_OK);\n+        Path mockArtifactPath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.0.0\")\n+                .resolve(\"monitor_artifact_100.txt\");\n+        when(connection.getInputStream()).thenReturn(new FileInputStream(mockArtifactPath.toString()));\n+\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+        Path testCache = TestHelper.getPathForLocalTestCache();\n+        Path saveToPath = testCache.resolve(\"CoolService\").resolve(\"1.0.0\");\n+        Files.createDirectories(saveToPath);\n+        downloader.downloadArtifactToPath(pkgId, new URI(\"greengrass:binary\"), saveToPath);\n+\n+        byte[] originalFile = Files.readAllBytes(mockArtifactPath);\n+        byte[] downloadFile = Files.readAllBytes(saveToPath.resolve(\"artifact.txt\"));\n+        assertThat(Arrays.equals(originalFile, downloadFile), is(true));\n+\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_http_connection_error_WHEN_attempt_download_THEN_return_exception() throws Exception {\n+        doReturn(\"https://www.amazon.com/artifact.txt\").when(downloader)\n+                .getArtifactDownloadURL(anyString(), anyString());\n+        doReturn(connection).when(downloader).create(any());\n+        when(connection.getResponseCode()).thenThrow(IOException.class);\n+\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+        assertThrows(IOException.class,\n+                () -> downloader.downloadArtifactToPath(pkgId, new URI(\"greengrass:binary\"), null));\n+    }\n+\n+    @Test\n+    void GIVEN_filename_in_disposition_WHEN_attempt_resolve_filename_THEN_parse_filename() {\n+        String filename = downloader\n+                .extractFilename(\"https://www.amazon.com/artifact.txt\", \"attachment; \" + \"filename=\\\"filename.jpg\\\"\");\n+\n+        assertThat(filename, is(\"filename.jpg\"));\n+    }\n+\n+    @Test\n+    void GIVEN_filename_in_url_WHEN_attempt_resolve_filenmae_THEN_parse_filename() {", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MjU4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405652587", "bodyText": "Thanks!", "author": "wikimonkey", "createdAt": "2020-04-08T16:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MzcwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405193709", "bodyText": "remove +", "author": "leaf94", "createdAt": "2020-04-08T00:40:00Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.lang.reflect.Field;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsNull.notNullValue;\n+import static org.hamcrest.core.IsNull.nullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private PackageStore packageStore;\n+\n+    private Path testCache;\n+\n+    @Mock\n+    private static ArtifactDownloader artifactDownloader;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, testCache);\n+\n+        Field downloaderField = PackageStore.ArtifactProvider.class.getDeclaredField(\"artifactDownloader\");\n+        downloaderField.setAccessible(true);\n+        for (PackageStore.ArtifactProvider artifactProvider : PackageStore.ArtifactProvider.values()) {\n+            downloaderField.set(artifactProvider, artifactDownloader);\n+        }\n+    }\n+\n+    @AfterEach\n+    void cleanTestCache() throws Exception {\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_valid_package_recipe_WHEN_attempt_find_package_THEN_package_model_is_returned()\n+            throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe\" + \".yaml\");", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MTk2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405671968", "bodyText": "Thanks", "author": "wikimonkey", "createdAt": "2020-04-08T16:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MzcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5NDQzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405194438", "bodyText": "I will simplify to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n          \n          \n            \n                void downloadToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)", "author": "leaf94", "createdAt": "2020-04-08T00:42:43Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Path;\n+\n+public interface ArtifactDownloader {\n+\n+    void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MjA2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405672063", "bodyText": "will rename", "author": "wikimonkey", "createdAt": "2020-04-08T16:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5NDQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5NTYxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405195610", "bodyText": "connect might be better than create", "author": "leaf94", "createdAt": "2020-04-08T00:47:19Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MjEzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405672137", "bodyText": "yeah", "author": "wikimonkey", "createdAt": "2020-04-08T16:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5NTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMTgwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405201807", "bodyText": "nit - I know we probably don't have and don't want to have guava lib - so \"Content-Dispsoition\" probably deserve a constant...", "author": "leaf94", "createdAt": "2020-04-08T01:10:33Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MzIxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405673215", "bodyText": "Yes", "author": "wikimonkey", "createdAt": "2020-04-08T16:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMTgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwNzExMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405207112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n          \n          \n            \n                Package findPackageRecipe(Path recipePath) throws PackageLoadingException {", "author": "leaf94", "createdAt": "2020-04-08T01:30:18Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MzEyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405673121", "bodyText": "yeah", "author": "wikimonkey", "createdAt": "2020-04-08T16:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwNzExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405141449", "bodyText": "Why do you return a list of futures instead of one future? The caller of this method shouldn't be concerned about which package is prepared or not.", "author": "fengwang666", "createdAt": "2020-04-07T22:06:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NDUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405684530", "bodyText": "I am thinking the opposite. If the caller gives the method a list of package id, it probably want to know whether they are prepared or not, and when they are done. The caller can choose to wait all of them finished before proceeding like we are doing now.", "author": "wikimonkey", "createdAt": "2020-04-08T17:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNTQwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405725406", "bodyText": "What would the caller do if some of them are not completed? The retry is handled in preaparePackages(). The caller cannot do anything except waiting (with the current design).", "author": "fengwang666", "createdAt": "2020-04-08T18:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1Njk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405756993", "bodyText": "Yes, they need to wait them finished before proceeding. But returning individual future can given the caller control of individual tasks, and deployment can try to re-prepare the packages not prepared successfully if the deployment choose to retry in a later time (of course, preparePackage itself can retry on error as well).", "author": "wikimonkey", "createdAt": "2020-04-08T19:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0MTE1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405941151", "bodyText": "Discussed offline, there is no strong reason to have packages preparation running in parallel, so keep it simple as running sequentially and one fail as the whole task fail.", "author": "wikimonkey", "createdAt": "2020-04-09T03:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTgzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405141839", "bodyText": "Instead of taking two paths as input, why not just take one path as the package root path and create recipe and artifact sub directories?", "author": "fengwang666", "createdAt": "2020-04-07T22:06:58Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,21 +35,34 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n \n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    public PackageStore(@Named(\"RecipeDirectory\") Path recipeDirectory,\n+                        @Named(\"ArtifactDirectory\") Path artifactDirectory) {", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NTc2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405685766", "bodyText": "The thought is just to give more flexibility. Although I am not sure whether it's valid case to place recipe and artifact caches in the different volumes, having kernel initializer decided it is my intention. The initializer can initialize them to be the sub-directories of the same directory.", "author": "wikimonkey", "createdAt": "2020-04-08T17:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNDMxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405724317", "bodyText": "I cannot think of a reason that customers would want to have recipe and artifact in separate volumes. My concern is the two parameters are of the type and it's error-prone that the caller can initialize this object with the parameters reversed and cause runtime error.", "author": "fengwang666", "createdAt": "2020-04-08T18:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MjYwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405752607", "bodyText": "Ok, there is no need to do things we are not sure. I will combine them.", "author": "wikimonkey", "createdAt": "2020-04-08T19:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjcxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405142711", "bodyText": "I would rather throw a PackageLoadingException if the package does not exist instead of returning null. Here you're forcing the caller to both check the exception and null.", "author": "fengwang666", "createdAt": "2020-04-07T22:09:03Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4ODI5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405688299", "bodyText": "As stated in the Michael's comment, I would suggest to distinguish method throw exception with method return null for retrieving item. It's usually through a conventional naming pattern, such as 'get' vs 'find'. So the lib caller can choose the one for its use case.", "author": "wikimonkey", "createdAt": "2020-04-08T17:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxNTMyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405715322", "bodyText": "This is the place I prefer consistency. In the code base, we already use optional at a number of places.", "author": "fengwang666", "createdAt": "2020-04-08T18:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczMDg0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405730846", "bodyText": "Sure, I will follow the convention. Find return Optional.", "author": "wikimonkey", "createdAt": "2020-04-08T18:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzU1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405217551", "bodyText": "This private method seems unnecessary. You merge it back to findPackageRecipe method.", "author": "fengwang666", "createdAt": "2020-04-08T02:10:00Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4ODQzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405688438", "bodyText": "Yeah, it can be merged.", "author": "wikimonkey", "createdAt": "2020-04-08T17:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyMzAzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405223038", "bodyText": "Why break these two lines to two methods?", "author": "fengwang666", "createdAt": "2020-04-08T02:30:21Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5MTAzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405691030", "bodyText": "As stated in Michael's comment, I tries to separate storage CRUD methods with business logic, so we can further refactor them to another layer of encapsulations. I recommend we do that, because it will make unit test easier and we have multiple places using these CRUD methods.", "author": "wikimonkey", "createdAt": "2020-04-08T17:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyMzAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzQ0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405227448", "bodyText": "I don't think we should handle these exceptions together. This whole try catch block can be better organized. I agree with Michael that we can have findPackageRecipe() encapsulate the logic of reading and downloading package recipes.\nPackage findPackageRecipe() throws PackageRecipeUnavailableException {\n     // find the package on the device;\n     // if not found or encounter exception;\n     //      then download from the cloud and save on device;\n     //      if encounter exception again\n     //      retry or populate the exception up\n}", "author": "fengwang666", "createdAt": "2020-04-08T02:47:51Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMTkyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405701929", "bodyText": "Agree, this find-download-if-not-exist logic can be encapsulated into one function. But I would still keep elementary CRUD methods separated for reusability. And I like the proposal of download-if-find-encounter-exception, I thought about it, forget why I didn't do that way.", "author": "wikimonkey", "createdAt": "2020-04-08T17:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzc1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405227757", "bodyText": "Can you have a stub cloud client instead of just calling \"findPackageRecipe\"?", "author": "fengwang666", "createdAt": "2020-04-08T02:49:04Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {\n+        if (!Files.exists(packageRecipe) || !Files.isRegularFile(packageRecipe)) {\n+            return new byte[0];\n+        }\n+\n+        try {\n+            return Files.readAllBytes(packageRecipe);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private Package downloadPackageRecipe(PackageIdentifier packageIdentifier) throws PackageDownloadException {\n+        logger.atInfo().setEventType(\"downloading-package-recipe\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).log();\n+        //TODO retrieve package recipe from cloud\n+        //load from local now to pretend it working", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4OTQxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405689419", "bodyText": "Can you clarify it a bit? It will be replaced by client from SDK to call cloud. But I am not sure what to put there given SDK is not there yet.", "author": "wikimonkey", "createdAt": "2020-04-08T17:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMjM0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405722349", "bodyText": "We can have a stub wrapper that wraps the future client, such as GreengrassPackageServiceHelper.", "author": "fengwang666", "createdAt": "2020-04-08T18:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1NDA3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405754079", "bodyText": "sure", "author": "wikimonkey", "createdAt": "2020-04-08T19:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyOTI5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405229292", "bodyText": "This seems a code smell to me. Why do we need to use reflection for unit test? How can we refactor the code so that we can properly mock dependencies?", "author": "fengwang666", "createdAt": "2020-04-08T02:55:13Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.lang.reflect.Field;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsNull.notNullValue;\n+import static org.hamcrest.core.IsNull.nullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private PackageStore packageStore;\n+\n+    private Path testCache;\n+\n+    @Mock\n+    private static ArtifactDownloader artifactDownloader;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, testCache);\n+\n+        Field downloaderField = PackageStore.ArtifactProvider.class.getDeclaredField(\"artifactDownloader\");\n+        downloaderField.setAccessible(true);\n+        for (PackageStore.ArtifactProvider artifactProvider : PackageStore.ArtifactProvider.values()) {\n+            downloaderField.set(artifactProvider, artifactDownloader);\n+        }\n+    }", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxNTE2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405715164", "bodyText": "I think we want to encapsulate downloader(s) inside package store, downloaders are not necessarily injected into package store, so downloaders could be private fields, then unit tests mocking them have to use reflection, it's a bit smell, but I think it has a good reason to justify it.", "author": "wikimonkey", "createdAt": "2020-04-08T18:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyOTI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMTM0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405721342", "bodyText": "I disagree. Downloader bridges to the external remote services and should be injected. For example, we might want to reuse the same HTTP client for all the HTTP traffic and apply the same configuration (e.g. retry, cred, etc). It's much cleaner to inject the client instead of initialize it inside PackageStore.", "author": "fengwang666", "createdAt": "2020-04-08T18:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyOTI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MzM4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405753381", "bodyText": "Good point, downloaders might be same. I will do simplest thing, having just one downloader now.", "author": "wikimonkey", "createdAt": "2020-04-08T19:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyOTI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMDQxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405230414", "bodyText": "Why do we need this? Can't we assume the majority of the respository endpoint is HTTP based? How would the Greengrass repository be different from a docker repository in terms of downloading?", "author": "fengwang666", "createdAt": "2020-04-08T02:59:31Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -167,4 +314,18 @@ private static Path getPackageVersionStorageRoot(final String packageName, final\n                                                      final Path cacheFolder) {\n         return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n     }\n+\n+    enum ArtifactProvider {", "originalCommit": "8fa440347feb757342db7dbcaf4e688fb206387d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NTE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405695163", "bodyText": "I assume processing logic for different registries/repos are more or less different. For example, greengrass artifact repo URI will look like 'greengrass:artifact.bin', docker's may/may not have image URL. Also in terms of downloading, for our repo we utilize s3 presigned URL, I am not sure whether it will be same for docker/github/CodeArtifact.\nIf they turn out to be the same, we definitely should make this simpler. But IMO can be refactored later.", "author": "wikimonkey", "createdAt": "2020-04-08T17:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMDQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxNjgwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405716807", "bodyText": "I prefer we start simple and refactor later to accommodate different cases.", "author": "fengwang666", "createdAt": "2020-04-08T18:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMDQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0NzIxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405747216", "bodyText": "I can go with simple approach now.", "author": "wikimonkey", "createdAt": "2020-04-08T19:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMDQxNA=="}], "type": "inlineReview"}, {"oid": "a395f136bf2047b1bba5efa5ad6a83366a0dda2d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a395f136bf2047b1bba5efa5ad6a83366a0dda2d", "message": "resolve merge conflicts", "committedDate": "2020-04-09T18:34:44Z", "type": "forcePushed"}, {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5b04c91702627047e23b2b100a2aec7ecba56cd7", "message": "supply package store path to context for DI", "committedDate": "2020-04-09T20:30:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NTExOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406475118", "bodyText": "nit\nI'd prefer packages", "author": "MikeDombo", "createdAt": "2020-04-09T21:01:42Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -81,9 +81,11 @@\n     public Path configPath;\n     public Path clitoolPath;\n     public Path workPath;\n+    public Path packageStorePath;\n     public String configPathName = \"~root/config\";\n     public String clitoolPathName = \"~root/bin\";\n     public String workPathName = \"~root/work\";\n+    public String packageStorePathName = \"~root/package\";", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwODA4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406508082", "bodyText": "Try to be same as the others, so use package", "author": "wikimonkey", "createdAt": "2020-04-09T22:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NTExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NTc3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406475775", "bodyText": "Can we get rid of this? Shouldn't this be under the package directory that you setup in the Kernel?", "author": "MikeDombo", "createdAt": "2020-04-09T21:03:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/GreengrassPackageServiceHelper.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalPackageStoreDeprecated;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class GreengrassPackageServiceHelper {\n+    private static final Path LOCAL_CACHE_PATH =", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwOTI1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406509251", "bodyText": "This class will be used to integrate with cloud. For now, mock retrieving packages from a local pre-loaded directory for integration tests. It will connect to cloud next sprint.", "author": "wikimonkey", "createdAt": "2020-04-09T22:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NTc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjUzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406476539", "bodyText": "unused now? Get rid of it if so.", "author": "MikeDombo", "createdAt": "2020-04-09T21:04:35Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwOTY0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406509640", "bodyText": "No, still in use. E2E test uses this path as package store cache. That is what I said, we need to consolidate them.", "author": "wikimonkey", "createdAt": "2020-04-09T22:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzAxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406477015", "bodyText": "is this constructor only for testing? If so, make it package-private and say in the comment that it is only for testing.", "author": "MikeDombo", "createdAt": "2020-04-09T21:05:37Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;\n+\n+    @Inject\n+    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+\n+    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n+    @Inject\n+    @Named(\"packageStoreDirectory\")\n+    private Path packageStoreDirectory;\n+\n+    /**\n+     * PackageStore constructor.\n+     * @param packageStoreDirectory directory for caching package recipes and artifacts\n+     * @param packageServiceHelper  greengrass package service client helper\n+     * @param artifactDownloader    artifact downloader\n+     */\n+    public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMDMzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406510339", "bodyText": "I'd like to have this constructor as the only constructor which can be used in kernel DI as well as unit test. But kernel DI doesn't support named constructor injection, so I give it a no args one. Will be cleaned up.", "author": "wikimonkey", "createdAt": "2020-04-09T22:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406477706", "bodyText": "Why are we doing this? If we can't create the directories we can't do anything. It needs to quit, but this exception should be handled by the caller so it doesn't take down the whole thread.", "author": "MikeDombo", "createdAt": "2020-04-09T21:07:00Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;\n+\n+    @Inject\n+    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+\n+    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n+    @Inject\n+    @Named(\"packageStoreDirectory\")\n+    private Path packageStoreDirectory;\n+\n+    /**\n+     * PackageStore constructor.\n+     * @param packageStoreDirectory directory for caching package recipes and artifacts\n+     * @param packageServiceHelper  greengrass package service client helper\n+     * @param artifactDownloader    artifact downloader\n+     */\n+    public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,\n+                        GreengrassRepositoryDownloader artifactDownloader) {\n+        initializeSubDirectories(packageStoreDirectory);\n+        this.greengrassPackageServiceHelper = packageServiceHelper;\n+        this.greenGrassArtifactDownloader = artifactDownloader;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        initializeSubDirectories(packageStoreDirectory);\n     }\n \n-    public PackageStore(Path packageStorePath) {\n-        this.packageStorePath = packageStorePath;\n+    private void initializeSubDirectories(Path packageStoreDirectory) {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxNDE5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406514191", "bodyText": "Yeah, it's unexpected error. The initialization happens at the start of the kernel, the kernel should handle the initialization error and properly shutdown or transit the service to the error state.", "author": "wikimonkey", "createdAt": "2020-04-09T22:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMTc5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406521794", "bodyText": "Please propagate the error as a checked IOException. We always prefer checked exceptions.", "author": "MikeDombo", "createdAt": "2020-04-09T22:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MDA4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406540087", "bodyText": "I need to use InjectionActions::postInject for initializing the directory before we have DI working with constructor named parameter. postInject doesn't define checked exception, so if I throw checked exception here, I have to convert to runtime exception over there, so the outcome to DI is same. And the current DI handles exception generically, so either one will be handled properly.", "author": "wikimonkey", "createdAt": "2020-04-10T00:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTMyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406479325", "bodyText": "This can be a lambda", "author": "MikeDombo", "createdAt": "2020-04-09T21:10:19Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMTA5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406511098", "bodyText": "Lambda doesn't like checked exception. So I use lombok @SneakyThrows to work with it. But it needs to declare this runnable.", "author": "wikimonkey", "createdAt": "2020-04-09T22:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMjAwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406522006", "bodyText": "Don't use sneaky throws. If you need to wrap with a runtime exception just use a lambda and perform the wrapping yourself.", "author": "MikeDombo", "createdAt": "2020-04-09T22:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4MTYxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406581611", "bodyText": "updated", "author": "wikimonkey", "createdAt": "2020-04-10T03:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTkyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406479922", "bodyText": "This runs the task in the ForkJoin common pool. Please use our own threadpool from the Context.", "author": "MikeDombo", "createdAt": "2020-04-09T21:11:38Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzODgwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406538809", "bodyText": "will use executor service in context", "author": "wikimonkey", "createdAt": "2020-04-10T00:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MDI4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406480283", "bodyText": "This is a big code smell to me. Let's be explicit about what we're throwing.", "author": "MikeDombo", "createdAt": "2020-04-09T21:12:20Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MTMwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406481304", "bodyText": "remove the concatenation since this string is on a single line.", "author": "MikeDombo", "createdAt": "2020-04-09T21:14:19Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(OBJECT_MAPPER.readValue(recipeContent, Package.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {\n+        try {\n+            OBJECT_MAPPER.writeValue(saveToFile.toFile(), pkg);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", saveToFile), e);\n+        }\n+    }\n+\n+    private Path resolveRecipePath(String packageName, Semver packageVersion) {\n+        return recipeDirectory.resolve(String.format(\"%s-%s.yaml\", packageName, packageVersion.getValue()));\n+    }\n+\n+    void downloadArtifactsIfNecessary(PackageIdentifier packageIdentifier, List<URI> artifactList)\n+            throws PackageLoadingException, PackageDownloadException {\n+        Path packageArtifactDirectory =\n+                resolveArtifactDirectoryPath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        if (!Files.exists(packageArtifactDirectory) || !Files.isDirectory(packageArtifactDirectory)) {\n+            try {\n+                Files.createDirectories(packageArtifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackageLoadingException(\n+                        String.format(\"Failed to create package artifact cache directory \" + \"%s\",", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMTMxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406511315", "bodyText": "sure", "author": "wikimonkey", "createdAt": "2020-04-09T22:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MTkzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406481938", "bodyText": "Why aren't these using the variable path?", "author": "MikeDombo", "createdAt": "2020-04-09T21:15:37Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -93,11 +287,9 @@ public Package getRecipe(PackageIdentifier pkg) {\n \n     /**\n      * Get package from cache if it exists.\n-     *\n-     *\n      */\n     List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n-        Path srcPkgRoot = getPackageStorageRoot(packageName, packageStorePath);\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, LOCAL_CACHE_PATH);", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMjM4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406512385", "bodyText": "This is to work with the existing tests. Package store directory structure is changed. Will remove this implementation once we refactored the client.", "author": "wikimonkey", "createdAt": "2020-04-09T22:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MTkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5OTgxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406499814", "bodyText": "Maybe add a TODO for dealing with unhappy response code?", "author": "leaf94", "createdAt": "2020-04-09T21:55:05Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final String CONTENT_DISPOSITION = \"Content-Disposition\";\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\")\n+                .addKeyValue(\"packageIdentifier\", packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = connect(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(CONTENT_DISPOSITION);\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream()) {\n+                    Files.copy(inputStream, saveToPath.resolve(filename), StandardCopyOption.REPLACE_EXISTING);\n+                }\n+            }", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwNjkxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406506915", "bodyText": "Yeah.", "author": "wikimonkey", "createdAt": "2020-04-09T22:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5OTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMTAwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406501000", "bodyText": "Just FYI, I'm creating a new test root folder and I was just initializing the path inside the test. We could consolidate these two later.", "author": "leaf94", "createdAt": "2020-04-09T21:58:02Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.GreengrassRepositoryDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private Path testCache;\n+\n+    private PackageStore packageStore;\n+\n+    @Mock\n+    private GreengrassRepositoryDownloader artifactDownloader;\n+\n+    @Mock\n+    private GreengrassPackageServiceHelper packageServiceHelper;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        testCache = TestHelper.getPathForLocalTestCache();", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMjEyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406502126", "bodyText": "I think this could be removed now with the proper DI?", "author": "leaf94", "createdAt": "2020-04-09T22:00:49Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "diffHunk": "@@ -221,6 +221,6 @@ private void setupIotResourcesAndInjectIntoKernel() throws IOException {\n \n     private void injectKernelPackageManagementDependencies() {\n         kernel.context.getv(DependencyResolver.class)\n-                .put(new DependencyResolver(new PackageStore(LOCAL_CACHE_PATH), kernel));\n+                .put(new DependencyResolver(new PackageStore(), kernel));", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwNjg2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406506864", "bodyText": "Can't yet. Because the e2e test assumes package existed in a pre-loaded folder in working directory.", "author": "wikimonkey", "createdAt": "2020-04-09T22:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMjEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwNzY2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406507665", "bodyText": "Why not have the e2e test inject/set the proper values?", "author": "MikeDombo", "createdAt": "2020-04-09T22:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMjEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzODQ3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406538476", "bodyText": "Yeah, once we switch to use new directory structure. It will be injectable. This is just to have e2e still running. Will refactor it shortly", "author": "wikimonkey", "createdAt": "2020-04-09T23:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMjEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDE5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406470190", "bodyText": "nit: use plural, package -> packages.", "author": "fengwang666", "createdAt": "2020-04-09T20:52:09Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -81,9 +81,11 @@\n     public Path configPath;\n     public Path clitoolPath;\n     public Path workPath;\n+    public Path packageStorePath;\n     public String configPathName = \"~root/config\";\n     public String clitoolPathName = \"~root/bin\";\n     public String workPathName = \"~root/work\";\n+    public String packageStorePathName = \"~root/package\";", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxOTkxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406519912", "bodyText": "Ok, as both of you prefer plural. Meant to be same as the others, such as ~root/config", "author": "wikimonkey", "createdAt": "2020-04-09T22:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMDc4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406520782", "bodyText": "there isn't just one package, so it should be plural. There is only 1 config, and bin and work don't make any sense as bins and works.", "author": "MikeDombo", "createdAt": "2020-04-09T22:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDc4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406470785", "bodyText": "I suppose this should be packageStorePath?", "author": "fengwang666", "createdAt": "2020-04-09T20:53:11Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/GreengrassPackageServiceHelper.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalPackageStoreDeprecated;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class GreengrassPackageServiceHelper {\n+    private static final Path LOCAL_CACHE_PATH =", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxODg4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406518881", "bodyText": "Hard-coded a pre-loaded local folder as the source for downloading package now. Will remove once connect to cloud.", "author": "wikimonkey", "createdAt": "2020-04-09T22:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNDE4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406524188", "bodyText": "This should be removed together as the E2E and Integration test change. But now they are relying on it....", "author": "leaf94", "createdAt": "2020-04-09T23:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MjAzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406472032", "bodyText": "greenGrassArtifactDownloader -> greengrassArtifactDownloader", "author": "fengwang666", "createdAt": "2020-04-09T20:55:38Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxODkzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406518936", "bodyText": "sure", "author": "wikimonkey", "createdAt": "2020-04-09T22:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MjAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjAwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406476001", "bodyText": "How would this RuntimeException be handled?", "author": "fengwang666", "createdAt": "2020-04-09T21:03:28Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;\n+\n+    @Inject\n+    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+\n+    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n+    @Inject\n+    @Named(\"packageStoreDirectory\")\n+    private Path packageStoreDirectory;\n+\n+    /**\n+     * PackageStore constructor.\n+     * @param packageStoreDirectory directory for caching package recipes and artifacts\n+     * @param packageServiceHelper  greengrass package service client helper\n+     * @param artifactDownloader    artifact downloader\n+     */\n+    public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,\n+                        GreengrassRepositoryDownloader artifactDownloader) {\n+        initializeSubDirectories(packageStoreDirectory);\n+        this.greengrassPackageServiceHelper = packageServiceHelper;\n+        this.greenGrassArtifactDownloader = artifactDownloader;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        initializeSubDirectories(packageStoreDirectory);\n     }\n \n-    public PackageStore(Path packageStorePath) {\n-        this.packageStorePath = packageStorePath;\n+    private void initializeSubDirectories(Path packageStoreDirectory) {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new RuntimeException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMDY4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406520686", "bodyText": "DI would catch the exception, report as service error I believe.", "author": "wikimonkey", "createdAt": "2020-04-09T22:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0ODQ1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406548451", "bodyText": "Only if it's a service. Since PackageStore is not a service, the exception is logged and swallowed.\nSince later you uses Files.createDirectories(), which automatically creates missing directories. I think you can just remove the initializeSubDirectories() method.", "author": "fengwang666", "createdAt": "2020-04-10T00:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NjgyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406556826", "bodyText": "I think it works for service dependency class too.\nFor artifacts, it will create its sub-folder subsequently. But for recipe, it's better to create its folder if not existed in constructor.", "author": "wikimonkey", "createdAt": "2020-04-10T01:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTA1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406485057", "bodyText": "setCause in the log?", "author": "fengwang666", "createdAt": "2020-04-09T21:22:26Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxOTQ2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406519467", "bodyText": "sure", "author": "wikimonkey", "createdAt": "2020-04-09T22:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTM0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406485344", "bodyText": "also setCause", "author": "fengwang666", "createdAt": "2020-04-09T21:22:58Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxOTQ0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406519447", "bodyText": "sure", "author": "wikimonkey", "createdAt": "2020-04-09T22:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMDA0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406520047", "bodyText": "Error as last argument to .log() will set the cause for you just like Log4j.", "author": "MikeDombo", "createdAt": "2020-04-09T22:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNDU5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406524597", "bodyText": "Error as last argument to .log() will set the cause for you just like Log4j.\n\nSo which way do we prefer to be consistent? I've seen both are used in the code.", "author": "leaf94", "createdAt": "2020-04-09T23:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NjkzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406486932", "bodyText": "Info level is too high, I would set it to Debug.", "author": "fengwang666", "createdAt": "2020-04-09T21:26:23Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();", "originalCommit": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxOTA4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406519082", "bodyText": "ok", "author": "wikimonkey", "createdAt": "2020-04-09T22:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NjkzMg=="}], "type": "inlineReview"}, {"oid": "4af1dad8171e3bf82a92f914bfa4b2b213bd5123", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4af1dad8171e3bf82a92f914bfa4b2b213bd5123", "message": "remove unused import", "committedDate": "2020-04-10T00:53:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0OTMzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406549334", "bodyText": "No need to wrap. Just throw URISyntaxException so that the caller of preparePackages() can unwrap the ExecutionException and see what's the cause.", "author": "fengwang666", "createdAt": "2020-04-10T00:41:00Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);", "originalCommit": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NzgxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406557819", "bodyText": "I would think we should be more careful on declaring checked exception, and decide whether we need to convert lib threw checked exception to our defined checked exception.\nI will schedule sometime to discuss.", "author": "wikimonkey", "createdAt": "2020-04-10T01:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0OTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0OTg3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406549872", "bodyText": "saveRecipeToFile or savePackageRecipeToFile is better.", "author": "fengwang666", "createdAt": "2020-04-10T00:43:19Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().setCause(e).log(String.format(\"Failed to prepare package %s\", packageIdentifier));\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(OBJECT_MAPPER.readValue(recipeContent, Package.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {", "originalCommit": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MDExNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406550114", "bodyText": "Log at debug level.", "author": "fengwang666", "createdAt": "2020-04-10T00:44:19Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().setCause(e).log(String.format(\"Failed to prepare package %s\", packageIdentifier));\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(OBJECT_MAPPER.readValue(recipeContent, Package.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {\n+        try {\n+            OBJECT_MAPPER.writeValue(saveToFile.toFile(), pkg);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", saveToFile), e);\n+        }\n+    }\n+\n+    private Path resolveRecipePath(String packageName, Semver packageVersion) {\n+        return recipeDirectory.resolve(String.format(\"%s-%s.yaml\", packageName, packageVersion.getValue()));\n+    }\n+\n+    void downloadArtifactsIfNecessary(PackageIdentifier packageIdentifier, List<URI> artifactList)\n+            throws PackageLoadingException, PackageDownloadException {\n+        Path packageArtifactDirectory =\n+                resolveArtifactDirectoryPath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        if (!Files.exists(packageArtifactDirectory) || !Files.isDirectory(packageArtifactDirectory)) {\n+            try {\n+                Files.createDirectories(packageArtifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackageLoadingException(\n+                        String.format(\"Failed to create package artifact cache directory %s\", packageArtifactDirectory),\n+                        e);\n+            }\n+        }\n+\n+        List<URI> artifactsNeedToDownload = determineArtifactsNeedToDownload(packageArtifactDirectory, artifactList);\n+        logger.atInfo().setEventType(\"downloading-package-artifacts\")", "originalCommit": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTI5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406551296", "bodyText": "Can you also assert the exception message? There are a number of places throwing PackageLoadingException.", "author": "fengwang666", "createdAt": "2020-04-10T00:49:32Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.GreengrassRepositoryDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private Path testCache;\n+\n+    private PackageStore packageStore;\n+\n+    @Mock\n+    private GreengrassRepositoryDownloader artifactDownloader;\n+\n+    @Mock\n+    private GreengrassPackageServiceHelper packageServiceHelper;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, packageServiceHelper, artifactDownloader,\n+                Executors.newSingleThreadExecutor());\n+    }\n+\n+    @AfterEach\n+    void cleanTestCache() throws Exception {\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_valid_package_recipe_WHEN_attempt_find_package_THEN_package_model_is_returned()\n+            throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe.yaml\");\n+        Optional<Package> pkg = packageStore.findPackageRecipe(recipePath);\n+        assertThat(pkg.isPresent(), is(true));\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_invalid_package_recipe_WHEN_attempt_find_package_THEN_get_loading_exception() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"bad_recipe.yaml\");\n+\n+        assertThrows(PackageLoadingException.class, () -> packageStore.findPackageRecipe(recipePath));", "originalCommit": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MjcxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406552717", "bodyText": "The test coverage is a bit thin. I would like to see a few more unit tests on preparePackages() method that hits all the branches.", "author": "fengwang666", "createdAt": "2020-04-10T00:55:40Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.GreengrassRepositoryDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private Path testCache;\n+\n+    private PackageStore packageStore;\n+\n+    @Mock\n+    private GreengrassRepositoryDownloader artifactDownloader;\n+\n+    @Mock\n+    private GreengrassPackageServiceHelper packageServiceHelper;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, packageServiceHelper, artifactDownloader,\n+                Executors.newSingleThreadExecutor());\n+    }\n+\n+    @AfterEach\n+    void cleanTestCache() throws Exception {\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_valid_package_recipe_WHEN_attempt_find_package_THEN_package_model_is_returned()\n+            throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe.yaml\");\n+        Optional<Package> pkg = packageStore.findPackageRecipe(recipePath);\n+        assertThat(pkg.isPresent(), is(true));\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_invalid_package_recipe_WHEN_attempt_find_package_THEN_get_loading_exception() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"bad_recipe.yaml\");\n+\n+        assertThrows(PackageLoadingException.class, () -> packageStore.findPackageRecipe(recipePath));\n+    }\n+\n+    @Test\n+    void GIVEN_invalid_path_to_package_recipe_WHEN_attempt_find_package_THEN_null_is_returned() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"not_exist_recipe.yaml\");\n+\n+        Optional<Package> pkg = packageStore.findPackageRecipe(recipePath);\n+        assertThat(pkg.isPresent(), is(false));\n+    }\n+\n+    @Test\n+    void GIVEN_package_in_memory_WHEN_attempt_save_package_THEN_successfully_save_to_file() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe.yaml\");\n+        Package pkg = packageStore.findPackageRecipe(recipePath).get();\n+\n+        Path saveToFile =\n+                testCache.resolve(String.format(\"%s-%s.yaml\", TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\"));\n+        packageStore.savePackageToFile(pkg, saveToFile);\n+\n+        Package savedPackage = packageStore.findPackageRecipe(saveToFile).get();\n+        assertThat(savedPackage, is(pkg));\n+    }\n+\n+    @Test\n+    void GIVEN_artifact_list_empty_WHEN_attempt_download_artifact_THEN_do_nothing() throws Exception {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+\n+        packageStore.downloadArtifactsIfNecessary(pkgId, Collections.emptyList());\n+\n+        verify(artifactDownloader, never()).downloadToPath(any(), any(), any());\n+    }\n+\n+    @Test\n+    void GIVEN_artifact_list_WHEN_attempt_download_artifact_THEN_invoke_downloader() throws Exception {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+\n+        packageStore.downloadArtifactsIfNecessary(pkgId,\n+                Arrays.asList(new URI(\"greengrass:binary1\"), new URI(\"greengrass:binary2\")));\n+\n+        ArgumentCaptor<URI> uriArgumentCaptor = ArgumentCaptor.forClass(URI.class);\n+        verify(artifactDownloader, times(2)).downloadToPath(eq(pkgId), uriArgumentCaptor.capture(),\n+                eq(testCache.resolve(\"artifact\").resolve(\"CoolService\").resolve(\"1.0.0\")));\n+        List<URI> uriList = uriArgumentCaptor.getAllValues();\n+        assertThat(uriList.size(), is(2));\n+        assertThat(uriList.get(0).getSchemeSpecificPart(), is(\"binary1\"));\n+        assertThat(uriList.get(1).getSchemeSpecificPart(), is(\"binary2\"));\n+    }\n+\n+\n+    @Test\n+    void GIVEN_artifact_provider_not_supported_WHEN_attempt_download_THEN_throw_package_exception() {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+\n+        assertThrows(PackageLoadingException.class, () -> packageStore\n+                .downloadArtifactsIfNecessary(pkgId, Collections.singletonList(new URI(\"docker:image1\"))));\n+    }\n+\n+    @Test\n+    void GIVEN_artifact_url_no_scheme_WHEN_attempt_download_THEN_throw_package_exception() {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0\" + \".0\"), \"CoolServiceARN\");\n+\n+        assertThrows(PackageLoadingException.class,\n+                () -> packageStore.downloadArtifactsIfNecessary(pkgId, Collections.singletonList(new URI(\"binary1\"))));\n+    }\n+\n+    @Test", "originalCommit": "4af1dad8171e3bf82a92f914bfa4b2b213bd5123", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU2MTMzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406561336", "bodyText": "will add more during refactoring.", "author": "wikimonkey", "createdAt": "2020-04-10T01:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MjcxNw=="}], "type": "inlineReview"}, {"oid": "be9f8e15da57b718ad3a48986e7e22d4b2deb58f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/be9f8e15da57b718ad3a48986e7e22d4b2deb58f", "message": "package store download with s3 presigned url", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "737b796ec3a24f58dbbe937172c8982f44470e50", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/737b796ec3a24f58dbbe937172c8982f44470e50", "message": "add unit tests", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "4662b4588947187c9334d0a62fe9a8f09a6a4a02", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4662b4588947187c9334d0a62fe9a8f09a6a4a02", "message": "fix typo", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "0527ae27459f3a7cdfa2fb28dff17ceeef3cb651", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0527ae27459f3a7cdfa2fb28dff17ceeef3cb651", "message": "handling comments", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "c543f114ee8c6e767c0e86db1a7d42bf31eaaebb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c543f114ee8c6e767c0e86db1a7d42bf31eaaebb", "message": "renaming", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "6eba791d6cc5864b7f0b247910502503a79e58cb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6eba791d6cc5864b7f0b247910502503a79e58cb", "message": "add some comment", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "cb673ea16547331544af6486ffc216e18d3a75dc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb673ea16547331544af6486ffc216e18d3a75dc", "message": "simplify the prepare package task to be sequential", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "8744e30c0b1ebd116ba5a8a924370e3a79dbfee4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8744e30c0b1ebd116ba5a8a924370e3a79dbfee4", "message": "remove import", "committedDate": "2020-04-10T01:27:33Z", "type": "commit"}, {"oid": "783e4f11870096e8bb0adb61f2a7ebf9543ee77a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/783e4f11870096e8bb0adb61f2a7ebf9543ee77a", "message": "fix javadoc", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "9495e61fa1d77cb470553ca239518b9430ee0520", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9495e61fa1d77cb470553ca239518b9430ee0520", "message": "fix PMD", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "c32b8156a971e619d5c269deeb8dfa413ecbc10e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c32b8156a971e619d5c269deeb8dfa413ecbc10e", "message": "make integ test pass", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "ffd1c214df7a34dff811fe8f944738c8e7e4ee23", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ffd1c214df7a34dff811fe8f944738c8e7e4ee23", "message": "resolve merge conflicts", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "fa289bd6dbac8a8cc9a238e44f6a9f989849085e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fa289bd6dbac8a8cc9a238e44f6a9f989849085e", "message": "remove package store deprecated constructor", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "c2278a3f33382b104ab4bc948cb1eda9f1cdcc8a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c2278a3f33382b104ab4bc948cb1eda9f1cdcc8a", "message": "fix PMD violation", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "42ca33cc983e87c8da2b63c444f3375e239cfa72", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/42ca33cc983e87c8da2b63c444f3375e239cfa72", "message": "supply package store path to context for DI", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "18e08dc820947516cf7b6cf284d68d338ad8ee7a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/18e08dc820947516cf7b6cf284d68d338ad8ee7a", "message": "add TODO", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "cbc869360590131a98da1dfbc92dc46a7aab89a6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbc869360590131a98da1dfbc92dc46a7aab89a6", "message": "handle comments", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "21d04a2b9b44b1a622d3198407d05fd4413065ad", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21d04a2b9b44b1a622d3198407d05fd4413065ad", "message": "clean up", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "cd0bd69f748c5f0f906c391d17d018772bddda3b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cd0bd69f748c5f0f906c391d17d018772bddda3b", "message": "remove unused import", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "b1323ea52dfd4555ce205817d0415eb7c42b853f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b1323ea52dfd4555ce205817d0415eb7c42b853f", "message": "a few renaming", "committedDate": "2020-04-10T01:27:34Z", "type": "commit"}, {"oid": "b1323ea52dfd4555ce205817d0415eb7c42b853f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b1323ea52dfd4555ce205817d0415eb7c42b853f", "message": "a few renaming", "committedDate": "2020-04-10T01:27:34Z", "type": "forcePushed"}, {"oid": "13af016555afcee5a8836855ed1cb7d2c93877e1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/13af016555afcee5a8836855ed1cb7d2c93877e1", "message": "fix PMD", "committedDate": "2020-04-10T01:32:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4NDE4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406584181", "bodyText": "Generally we should not be both logging and throwing within the same catch.", "author": "MikeDombo", "createdAt": "2020-04-10T03:17:11Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);", "originalCommit": "13af016555afcee5a8836855ed1cb7d2c93877e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4NDMzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406584331", "bodyText": "Same here, to prevent duplicate logging, our standard is to only log when the exception is handled.", "author": "MikeDombo", "createdAt": "2020-04-10T03:17:53Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().setCause(e).log(String.format(\"Failed to prepare package %s\", packageIdentifier));\n+            throw e;", "originalCommit": "13af016555afcee5a8836855ed1cb7d2c93877e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}