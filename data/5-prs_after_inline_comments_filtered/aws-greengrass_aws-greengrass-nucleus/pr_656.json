{"pr_number": 656, "pr_title": "Fix retries in shadow, update subscribe error handling", "pr_createdAt": "2020-11-11T03:43:04Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/656", "timeline": [{"oid": "63ca2df1607839f5b3ffcb0cd026abc7f34f201d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/63ca2df1607839f5b3ffcb0cd026abc7f34f201d", "message": "Fix retries in shadow, update subscribe error handling", "committedDate": "2020-11-11T03:42:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyODM1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/656#discussion_r521128350", "bodyText": "Should the code instead handle TimeoutException thrown from get? remove the request from the subscriptions map. If CompletableFuture.get() times out, the whenComplete action is not run.", "author": "fengwang666", "createdAt": "2020-11-11T05:53:42Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -273,42 +273,36 @@ protected MqttClient(DeviceConfiguration deviceConfiguration, Spool spool, Sched\n     @SuppressWarnings(\"PMD.CloseResource\")\n     public synchronized void subscribe(SubscribeRequest request)\n             throws ExecutionException, InterruptedException, TimeoutException {\n-        try {\n-            AwsIotMqttClient connection = null;\n-            // Use the write scope when identifying the subscriptionTopics that exist\n-            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n-                // TODO: [P41214973] Handle subscriptions with differing QoS (Upgrade 0->1->2)\n-\n-                // If none of our existing subscriptions include (through wildcards) the new topic, then\n-                // go ahead and subscribe to it\n-                Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> existingConnection =\n-                        findExistingSubscriberForTopic(request.getTopic());\n-                if (existingConnection.isPresent()) {\n-                    subscriptions.put(request, existingConnection.get().getValue());\n-                } else {\n-                    connection = getConnection(true);\n-                    subscriptions.put(request, connection);\n-                }\n+        AwsIotMqttClient connection = null;\n+        // Use the write scope when identifying the subscriptionTopics that exist\n+        try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+            // TODO: [P41214973] Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+            // If none of our existing subscriptions include (through wildcards) the new topic, then\n+            // go ahead and subscribe to it\n+            Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> existingConnection =\n+                    findExistingSubscriberForTopic(request.getTopic());\n+            if (existingConnection.isPresent()) {\n+                subscriptions.put(request, existingConnection.get().getValue());\n+            } else {\n+                connection = getConnection(true);\n+                subscriptions.put(request, connection);\n             }\n+        }\n \n-            try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n-                // Connection isn't null, so we should subscribe to the topic\n-                if (connection != null) {\n-                    AwsIotMqttClient finalConnection = connection;\n-                    connection.subscribe(request.getTopic(), request.getQos()).whenComplete((i, t) -> {\n-                        if (t == null) {\n-                            subscriptionTopics.put(new MqttTopic(request.getTopic()), finalConnection);\n-                        } else {\n-                            subscriptions.remove(request);\n-                            logger.atError().kv(TOPIC_KEY, request.getTopic()).log(\"Error subscribing\", t);\n-                        }\n-                    }).get(connection.getTimeout(), TimeUnit.MILLISECONDS);\n-                }\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                AwsIotMqttClient finalConnection = connection;\n+                connection.subscribe(request.getTopic(), request.getQos()).whenComplete((i, t) -> {\n+                    if (t == null) {\n+                        subscriptionTopics.put(new MqttTopic(request.getTopic()), finalConnection);\n+                    } else {\n+                        subscriptions.remove(request);\n+                        logger.atError().kv(TOPIC_KEY, request.getTopic()).log(\"Error subscribing\", t);\n+                    }\n+                }).get(connection.getTimeout(), TimeUnit.MILLISECONDS);\n             }\n-        } catch (ExecutionException e) {\n-            // If subscribing failed, then clean up the failed subscription callback\n-            subscriptions.remove(request);\n-            throw e;", "originalCommit": "63ca2df1607839f5b3ffcb0cd026abc7f34f201d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyODYwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/656#discussion_r521128601", "bodyText": "No, not necessarily. If it times out, then the whenComplete will still run in the event that it does finish at some later point.", "author": "MikeDombo", "createdAt": "2020-11-11T05:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyODkzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/656#discussion_r521128933", "bodyText": "If subscribe is retried, then it will still retry because the subscription hasn't been added to subscriptionTopics yet (even though it is in subscriptions, subscriptionTopics is what is used to prevent further subscribe requests).", "author": "MikeDombo", "createdAt": "2020-11-11T05:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyODM1MA=="}], "type": "inlineReview"}, {"oid": "d6a6a3d4a4127df31459cbd9920f907b05c7871b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d6a6a3d4a4127df31459cbd9920f907b05c7871b", "message": "Merge branch 'master' into fix-retries", "committedDate": "2020-11-11T06:05:01Z", "type": "commit"}, {"oid": "7a54e1213cf61fa7e5e0f0d51f224e73d5ca80a2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7a54e1213cf61fa7e5e0f0d51f224e73d5ca80a2", "message": "Merge branch 'master' into fix-retries", "committedDate": "2020-11-11T06:18:19Z", "type": "commit"}]}