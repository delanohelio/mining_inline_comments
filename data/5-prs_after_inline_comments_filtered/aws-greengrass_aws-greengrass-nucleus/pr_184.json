{"pr_number": 184, "pr_title": "Refactor DI code; add @Named support for constructor injection; Change PackageStore to use it.", "pr_createdAt": "2020-04-15T17:42:59Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184", "timeline": [{"oid": "e7c4d860dbf914fe831a1e32cf6afa0bc4c05d50", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e7c4d860dbf914fe831a1e32cf6afa0bc4c05d50", "message": "WIP; Add @Named support for constructor injection", "committedDate": "2020-04-15T17:41:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyMzMyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r409023329", "bodyText": "I wouldn't change this name since it mirrors the Map interface.", "author": "MikeDombo", "createdAt": "2020-04-15T17:47:03Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -316,119 +317,142 @@ private boolean onPublishThread() {\n \n     public class Value<T> implements Provider<T> {\n         final Class<T> targetClass;\n-        public volatile T targetValue;\n+        public volatile T targetObject;\n         @SuppressFBWarnings(value = \"IS2_INCONSISTENT_SYNC\", justification = \"No need to be sync\")\n         private boolean injectionCompleted;\n \n-        Value(Class<T> c, T v) {\n-            targetClass = c;\n-            put(v);\n+        Value(Class<T> clazz, T object) {\n+            targetClass = clazz;\n+            put(object);\n         }\n \n         @Override\n         public final T get() {\n-            T v = targetValue;\n-            if (v != null && injectionCompleted) {\n-                return v;\n+            if (targetObject != null && injectionCompleted) {\n+                return targetObject;\n             }\n-            return get0();\n+            return constructObject();\n         }\n \n         @SuppressWarnings({\"PMD.AvoidCatchingThrowable\"})\n-        private synchronized T get0() {\n-            T v = targetValue;\n-            if (v != null) {\n-                return v;\n+        private synchronized T constructObject() {\n+            T object = targetObject;\n+            if (object != null) {\n+                return object;\n             }\n             try {\n-                Class<T> ccl = targetClass.isInterface() ? (Class<T>) targetClass.getClassLoader()\n+                Class<T> clazz = targetClass.isInterface() ? (Class<T>) targetClass.getClassLoader()\n                         .loadClass(targetClass.getName() + \"$Default\") : targetClass;\n                 //                System.out.println(ccl+\"  \"+deepToString(ccl.getConstructors()));\n-                Constructor<T> cons = null;\n-                for (Constructor<T> c : (Constructor<T>[]) ccl.getConstructors()) {\n+                Constructor<T> pickedConstructor = null;\n+                for (Constructor<T> constructor : (Constructor<T>[]) clazz.getConstructors()) {\n                     //                    System.out.println(\"Examine \"+c.getParameterCount()+\" \"+c.toGenericString());\n-                    if (c.getParameterCount() == 0) {\n-                        cons = c;\n-                    } else if (c.isAnnotationPresent(Inject.class)) {\n-                        cons = c;\n+                    if (constructor.getParameterCount() == 0) {\n+                        pickedConstructor = constructor;\n+                    } else if (constructor.isAnnotationPresent(Inject.class)) {\n+                        pickedConstructor = constructor;\n                         break;\n                     }\n                 }\n-                if (cons == null) {\n-                    throw new NoSuchMethodException(\"No usable injection constructor for \" + ccl);\n+                if (pickedConstructor == null) {\n+                    throw new NoSuchMethodException(\"No usable injection constructor for \" + clazz);\n                 }\n-                cons.setAccessible(true);\n-                int np = cons.getParameterCount();\n+                pickedConstructor.setAccessible(true);\n+                int np = pickedConstructor.getParameterCount();\n                 if (np == 0) {\n-                    return put(cons.newInstance());\n+                    return put(pickedConstructor.newInstance());\n                 }\n                 //                System.out.println(\"Injecting args into \"+cons.toGenericString());\n                 Object[] args = new Object[np];\n-                Class[] types = cons.getParameterTypes();\n+                Class[] types = pickedConstructor.getParameterTypes();\n+\n+                Annotation[][] argAnnotations = pickedConstructor.getParameterAnnotations();\n+\n                 for (int i = 0; i < np; i++) {\n                     Class type = types[i];\n                     if (type == Topics.class) {\n-                        ImplementsService svc = ccl.getAnnotation(ImplementsService.class);\n-                        if (svc != null) {\n-                            String nm = svc.name();\n-                            args[i] = Context.this.get(Configuration.class).lookupTopics(nm);\n+                        ImplementsService service = clazz.getAnnotation(ImplementsService.class);\n+                        if (service != null) {\n+                            String serviceName = service.name();\n+                            args[i] = Context.this.get(Configuration.class).lookupTopics(serviceName);\n                             continue;\n                         }\n                         args[i] = Topics.errorNode(Context.this, \"message\", \"Synthetic args\");\n                     } else {\n-                        args[i] = Context.this.get(type);\n+\n+                        String name = null;\n+\n+                        for (Annotation annotation: argAnnotations[i]) {\n+                            if (annotation instanceof Named) {\n+                                name = nullEmpty(((Named) annotation).value());\n+                            }\n+                        }\n+\n+                        if (name != null) {\n+                            args[i] = Context.this.get(type, name);\n+                        } else {\n+                            args[i] = Context.this.get(type);\n+                        }\n                     }\n                 }\n                 //                System.out.println(\"**Construct \"+utils.deepToString(cons, 90)+\" \"+utils\n                 //                .deepToString(args, 90));\n-                return put(cons.newInstance(args));\n+                return put(pickedConstructor.newInstance(args));\n             } catch (Throwable ex) {\n                 throw new IllegalArgumentException(\"Can't create instance of \" + targetClass.getName(), ex);\n             }\n         }\n \n         /**\n-         * Put a new value.\n+         * Put a new object instance and perform injection actions.\n          *\n-         * @param v new value\n+         * @param object the object instance\n          * @return new value\n          */\n-        public final synchronized T put(T v) {\n-            if (Objects.equals(v, targetValue)) {\n-                return v;\n+        public final synchronized T put(T object) {\n+            if (Objects.equals(object, targetObject)) {\n+                return object;\n             }\n-            if (v == null || targetClass.isAssignableFrom(v.getClass())) {\n+            if (object == null || targetClass.isAssignableFrom(object.getClass())) {\n                 injectionCompleted = false;\n-                targetValue = v;\n-                doInjection(v);\n+                targetObject = object;\n+                doInjection(object);\n                 injectionCompleted = true;\n-                return v; // only assign after injection is complete\n+                return object; // only assign after injection is complete\n             } else {\n-                throw new IllegalArgumentException(v + \" is not assignable to \" + targetClass.getSimpleName());\n+                throw new IllegalArgumentException(object + \" is not assignable to \" + targetClass.getSimpleName());\n             }\n         }\n \n-        public final synchronized <E extends Exception> T computeIfEmpty(CrashableFunction<Value, T, E> s) throws E {\n-            T v = targetValue;\n-            return v == null ? put(s.apply(this)) : v;\n+        /**\n+         * Computes and return T if object instance is null\n+         * @param mappingFunction maps from Value to T\n+         * @return the current (existing or computed) object instance\n+         */\n+        public final synchronized <E extends Exception> T computeObjectIfEmpty(CrashableFunction<Value, T, E> mappingFunction) throws E {", "originalCommit": "e7c4d860dbf914fe831a1e32cf6afa0bc4c05d50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MTM1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r410441352", "bodyText": "Well. The thing is I thought it mirrors the Map interface and then I got totally confused. The mapping function is from a Value<T> to a T, instead of key to value . This is super confusing. That's why I added computeObject, because it is not computing Value as the Map interface.\nAlso I checked the only usage for this mapping function in the locate, is not really to \"map\". We just used the \"Key\" here as a way to to access Value<T> in the lambda function, which is also confusing.\nMy plan is to discuss about and improve the locate together as separating the EG service logic from DI, as discussed below.", "author": "leaf94", "createdAt": "2020-04-17T19:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyMzMyOQ=="}], "type": "inlineReview"}, {"oid": "e49da2e82a4db2327bc41dcca46adc7f08d78b8a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e49da2e82a4db2327bc41dcca46adc7f08d78b8a", "message": "working", "committedDate": "2020-04-16T06:09:22Z", "type": "commit"}, {"oid": "97f534f29dcef896e61378fe10fbb5ca89cafec7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/97f534f29dcef896e61378fe10fbb5ca89cafec7", "message": "change benchmark", "committedDate": "2020-04-16T06:17:55Z", "type": "commit"}, {"oid": "0ee6998cdec218b83a3c8b3c420dd3724c7bf772", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0ee6998cdec218b83a3c8b3c420dd3724c7bf772", "message": "done", "committedDate": "2020-04-16T06:30:07Z", "type": "commit"}, {"oid": "f5eca05ae15c9328c5ccd4a5a5ca0d5f7247291a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f5eca05ae15c9328c5ccd4a5a5ca0d5f7247291a", "message": "fix benchmark", "committedDate": "2020-04-16T16:48:26Z", "type": "commit"}, {"oid": "43445c84c8a8815ec74ceb331825a63049865b47", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/43445c84c8a8815ec74ceb331825a63049865b47", "message": "done", "committedDate": "2020-04-16T16:49:20Z", "type": "commit"}, {"oid": "5b8ad25ccb43612390c4cf282c32e03cb69ca4b8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5b8ad25ccb43612390c4cf282c32e03cb69ca4b8", "message": "Merge branch 'master' into di", "committedDate": "2020-04-16T16:49:37Z", "type": "commit"}, {"oid": "84451ff7b7480c14cd334bd9a4c6ca317bf08e04", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/84451ff7b7480c14cd334bd9a4c6ca317bf08e04", "message": "done", "committedDate": "2020-04-16T16:51:01Z", "type": "commit"}, {"oid": "67ebb39a31f15be6ee4e9c4e6154374a92c0622f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/67ebb39a31f15be6ee4e9c4e6154374a92c0622f", "message": "Merge branch 'master' into di", "committedDate": "2020-04-16T17:10:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NTAyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r410365029", "bodyText": "Why revisit? Can you explain more in your comment about what you don't like or what needs to be changed?", "author": "MikeDombo", "createdAt": "2020-04-17T17:24:55Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -316,119 +314,163 @@ private boolean onPublishThread() {\n \n     public class Value<T> implements Provider<T> {\n         final Class<T> targetClass;\n-        public volatile T targetValue;\n+        public volatile T object;\n         @SuppressFBWarnings(value = \"IS2_INCONSISTENT_SYNC\", justification = \"No need to be sync\")\n         private boolean injectionCompleted;\n \n-        Value(Class<T> c, T v) {\n-            targetClass = c;\n-            put(v);\n+        Value(Class<T> clazz, T object) {\n+            targetClass = clazz;\n+            putAndInjectFields(object);\n         }\n \n         @Override\n         public final T get() {\n-            T v = targetValue;\n-            if (v != null && injectionCompleted) {\n-                return v;\n+            if (object != null && injectionCompleted) {\n+                return object;\n             }\n-            return get0();\n+            return constructObjectWithInjection();\n         }\n \n-        @SuppressWarnings({\"PMD.AvoidCatchingThrowable\"})\n-        private synchronized T get0() {\n-            T v = targetValue;\n-            if (v != null) {\n-                return v;\n+\n+        /**\n+         * Put a new object instance and inject fields with pre and post actions, if the new object is not equal\n+         * to current one.\n+         *\n+         * @param newObject the new object instance\n+         * @return new object with fields injected\n+         */\n+        final synchronized T putAndInjectFields(T newObject) {\n+            if (Objects.equals(newObject, object)) {\n+                return newObject;\n+            }\n+            if (newObject == null || targetClass.isAssignableFrom(newObject.getClass())) {\n+                injectionCompleted = false;\n+                object = newObject;\n+                injectFields(newObject);\n+                injectionCompleted = true;\n+                return newObject; // only assign after injection is complete\n+\n+            } else {\n+                throw new IllegalArgumentException(newObject + \" is not assignable to \" + targetClass.getSimpleName());\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        private synchronized T constructObjectWithInjection() {\n+            if (object != null) {\n+                return object;\n             }\n+\n             try {\n-                Class<T> ccl = targetClass.isInterface() ? (Class<T>) targetClass.getClassLoader()\n-                        .loadClass(targetClass.getName() + \"$Default\") : targetClass;\n-                //                System.out.println(ccl+\"  \"+deepToString(ccl.getConstructors()));\n-                Constructor<T> cons = null;\n-                for (Constructor<T> c : (Constructor<T>[]) ccl.getConstructors()) {\n-                    //                    System.out.println(\"Examine \"+c.getParameterCount()+\" \"+c.toGenericString());\n-                    if (c.getParameterCount() == 0) {\n-                        cons = c;\n-                    } else if (c.isAnnotationPresent(Inject.class)) {\n-                        cons = c;\n-                        break;\n-                    }\n-                }\n-                if (cons == null) {\n-                    throw new NoSuchMethodException(\"No usable injection constructor for \" + ccl);\n+                Class<T> clazz = targetClass;\n+\n+                if (targetClass.isInterface()) {\n+                    // For interface, we only support binding the inner \"Default\" class as implementation class for now\n+                    clazz = (Class<T>) targetClass.getClassLoader().loadClass(targetClass.getName() + \"$Default\");\n                 }\n-                cons.setAccessible(true);\n-                int np = cons.getParameterCount();\n-                if (np == 0) {\n-                    return put(cons.newInstance());\n+\n+                Constructor<T> pickedConstructor = pickConstructor(clazz);\n+                pickedConstructor.setAccessible(true);\n+\n+                int paramCount = pickedConstructor.getParameterCount();\n+                if (paramCount == 0) {\n+                    // no arg constructor\n+                    return putAndInjectFields(pickedConstructor.newInstance());\n                 }\n-                //                System.out.println(\"Injecting args into \"+cons.toGenericString());\n-                Object[] args = new Object[np];\n-                Class[] types = cons.getParameterTypes();\n-                for (int i = 0; i < np; i++) {\n-                    Class type = types[i];\n-                    if (type == Topics.class) {\n-                        ImplementsService svc = ccl.getAnnotation(ImplementsService.class);\n-                        if (svc != null) {\n-                            String nm = svc.name();\n-                            args[i] = Context.this.get(Configuration.class).lookupTopics(nm);\n-                            continue;\n+\n+                Object[] args = getOrCreateArgInstances(clazz, pickedConstructor, paramCount);\n+                return putAndInjectFields(pickedConstructor.newInstance(args));\n+            } catch (Throwable ex) {\n+                throw new IllegalArgumentException(\"Can't create instance of \" + targetClass.getName(), ex);\n+            }\n+        }\n+\n+        private Object[] getOrCreateArgInstances(Class<T> clazz, Constructor<T> pickedConstructor, int argCount) {\n+            Object[] args = new Object[argCount];\n+            Class[] argTypes = pickedConstructor.getParameterTypes();\n+            Annotation[][] argAnnotations = pickedConstructor.getParameterAnnotations();\n+\n+            for (int i = 0; i < argCount; i++) {\n+                Class argClazz = argTypes[i];\n+\n+                if (argClazz == Topics.class) {\n+                    // TODO Revisit EvergreenService injection and see if we can remove this branch\n+                    ImplementsService service = clazz.getAnnotation(ImplementsService.class);\n+                    if (service != null) {\n+                        String serviceName = service.name();\n+                        args[i] = Context.this.get(Configuration.class).lookupTopics(serviceName);\n+                        continue;\n+                    }\n+                    args[i] = Topics.errorNode(Context.this, \"message\", \"Synthetic args\");\n+                } else {\n+                    String name = null;\n+\n+                    for (Annotation annotation : argAnnotations[i]) {\n+                        if (annotation instanceof Named) {\n+                            name = nullEmpty(((Named) annotation).value());\n                         }\n-                        args[i] = Topics.errorNode(Context.this, \"message\", \"Synthetic args\");\n+                    }\n+\n+                    if (name == null) {\n+                        args[i] = Context.this.get(argClazz);\n                     } else {\n-                        args[i] = Context.this.get(type);\n+                        args[i] = Context.this.get(argClazz, name);\n                     }\n                 }\n-                //                System.out.println(\"**Construct \"+utils.deepToString(cons, 90)+\" \"+utils\n-                //                .deepToString(args, 90));\n-                return put(cons.newInstance(args));\n-            } catch (Throwable ex) {\n-                throw new IllegalArgumentException(\"Can't create instance of \" + targetClass.getName(), ex);\n             }\n+            return args;\n+        }\n+\n+        private Constructor<T> pickConstructor(Class<T> clazz) throws NoSuchMethodException {\n+            for (Constructor<T> constructor : (Constructor<T>[]) clazz.getDeclaredConstructors()) {\n+                // Use constructor with @Inject if exists\n+                if (constructor.isAnnotationPresent(Inject.class)) {\n+                    return constructor;\n+                }\n+\n+                // fall back to default constructor\n+                if (constructor.getParameterCount() == 0) {\n+                    return constructor;\n+                }\n+            }\n+\n+            throw new NoSuchMethodException(\"No usable injection constructor for \" + clazz);\n         }\n \n         /**\n-         * Put a new value.\n+         * Computes and return T if object instance is null.\n+         * TODO revisit to see if there is a better way because the mapping function usage is weird.\n          *\n-         * @param v new value\n-         * @return new value\n+         * @param mappingFunction maps from Value to T\n+         * @param <E> CheckedException\n+         * @return the current (existing or computed) object instance\n+         * @throws E when mapping function throws checked exception\n          */\n-        public final synchronized T put(T v) {\n-            if (Objects.equals(v, targetValue)) {\n-                return v;\n+        public final synchronized <E extends Exception> T computeObjectIfEmpty(\n+                CrashableFunction<Value, T, E> mappingFunction) throws E {\n+            if (object != null) {\n+                return object;\n             }\n-            if (v == null || targetClass.isAssignableFrom(v.getClass())) {\n-                injectionCompleted = false;\n-                targetValue = v;\n-                doInjection(v);\n-                injectionCompleted = true;\n-                return v; // only assign after injection is complete\n-            } else {\n-                throw new IllegalArgumentException(v + \" is not assignable to \" + targetClass.getSimpleName());\n-            }\n-        }\n \n-        public final synchronized <E extends Exception> T computeIfEmpty(CrashableFunction<Value, T, E> s) throws E {\n-            T v = targetValue;\n-            return v == null ? put(s.apply(this)) : v;\n+            return putAndInjectFields(mappingFunction.apply(this));\n         }\n \n         public boolean isEmpty() {\n-            return targetValue == null;\n+            return object == null;\n         }\n \n         @SuppressWarnings({\"PMD.AvoidCatchingThrowable\"})\n-        private void doInjection(Object lvalue) {\n-            //            System.out.println(\"requestInject \" + lvalue);\n-            if (lvalue == null) {\n+        private void injectFields(Object object) {\n+            // TODO Revisit this method.", "originalCommit": "67ebb39a31f15be6ee4e9c4e6154374a92c0622f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjcwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r410432702", "bodyText": "Good suggestion. I did have many thoughts when I wrote this TODO, so I should capture those.\nFor this method, I basically didn't look into it in this PR. Need to do the same for single-letter vars and possible re-structuring.\nAnother big thing to revisit is that I really feel we should remove/move out some special business logic for EvergreenService in the Context, for example addOrUpdateDependency.\nMy early feeling is that Context.java should handle the general DI (don't get me wrong, it will be aware of EvergreenService type), but the specific EG business logic like addOrUpdateDependency, and even methods specifically for locate, should be separated out so that it's more independent and therefore maintainable. I remember you once spent some effort fixing a EG service dependency initialization bug so hopefully when we need to deal with it next time, we don't need to go through the entire DI's code.\nI really want to get your and team's thoughts after we have more readable DI code, after this PR gets merged in. That's why I left the TODO.", "author": "leaf94", "createdAt": "2020-04-17T19:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2ODM1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r410368351", "bodyText": "Can we get rid of all the commented out code in this file?", "author": "MikeDombo", "createdAt": "2020-04-17T17:30:52Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -473,13 +516,13 @@ private void doInjection(Object lvalue) {\n                                 // the context tagged with its service name so that EvergreenService.locate\n                                 // will be able to find it when it looks for it by name (and not by class)\n                                 if (v instanceof EvergreenService) {\n-                                    Context.this.getv(EvergreenService.class, ((EvergreenService) v).getName())\n-                                            .put((EvergreenService) v);\n+                                    Context.this.getValue(EvergreenService.class, ((EvergreenService) v).getName())\n+                                            .putAndInjectFields((EvergreenService) v);\n                                 }\n                             }\n                             StartWhen startWhen = f.getAnnotation(StartWhen.class);\n                             f.setAccessible(true);\n-                            f.set(lvalue, v);\n+                            f.set(object, v);\n                             //                            System.out.println(\"   \"+cl.getSimpleName() + \".\" + f", "originalCommit": "67ebb39a31f15be6ee4e9c4e6154374a92c0622f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMjgxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r410422815", "bodyText": "Yeah. Most of them should be. I just need to quickly double check with James.", "author": "leaf94", "createdAt": "2020-04-17T19:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2ODM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NjE0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r412396141", "bodyText": "nit: I believe this renaming is not intentional", "author": "hui-yang", "createdAt": "2020-04-21T18:33:23Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "diffHunk": "@@ -116,7 +116,7 @@ void GIVEN_list_of_version_range_with_conflicts_WHEN_get_union_THEN_get_no_versi\n         private static final String pkgA = \"A\";\n         private static final String pkgB1 = \"B1\";\n         private static final String pkgB2 = \"B2\";\n-        private static final String pkgC1 = \"C1\";\n+        private static final String pkgC1 = \"c1\";", "originalCommit": "67ebb39a31f15be6ee4e9c4e6154374a92c0622f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwOTc3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r412409775", "bodyText": "Good catch. They are not. Fixing them...", "author": "leaf94", "createdAt": "2020-04-21T18:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwMDk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r412400991", "bodyText": "This doesn't seem right to me. Either we need 2 loops here, or keep track of the first match of default constructor till the end of loop and only return then.", "author": "hui-yang", "createdAt": "2020-04-21T18:40:49Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -316,119 +314,163 @@ private boolean onPublishThread() {\n \n     public class Value<T> implements Provider<T> {\n         final Class<T> targetClass;\n-        public volatile T targetValue;\n+        public volatile T object;\n         @SuppressFBWarnings(value = \"IS2_INCONSISTENT_SYNC\", justification = \"No need to be sync\")\n         private boolean injectionCompleted;\n \n-        Value(Class<T> c, T v) {\n-            targetClass = c;\n-            put(v);\n+        Value(Class<T> clazz, T object) {\n+            targetClass = clazz;\n+            putAndInjectFields(object);\n         }\n \n         @Override\n         public final T get() {\n-            T v = targetValue;\n-            if (v != null && injectionCompleted) {\n-                return v;\n+            if (object != null && injectionCompleted) {\n+                return object;\n             }\n-            return get0();\n+            return constructObjectWithInjection();\n         }\n \n-        @SuppressWarnings({\"PMD.AvoidCatchingThrowable\"})\n-        private synchronized T get0() {\n-            T v = targetValue;\n-            if (v != null) {\n-                return v;\n+\n+        /**\n+         * Put a new object instance and inject fields with pre and post actions, if the new object is not equal\n+         * to current one.\n+         *\n+         * @param newObject the new object instance\n+         * @return new object with fields injected\n+         */\n+        final synchronized T putAndInjectFields(T newObject) {\n+            if (Objects.equals(newObject, object)) {\n+                return newObject;\n+            }\n+            if (newObject == null || targetClass.isAssignableFrom(newObject.getClass())) {\n+                injectionCompleted = false;\n+                object = newObject;\n+                injectFields(newObject);\n+                injectionCompleted = true;\n+                return newObject; // only assign after injection is complete\n+\n+            } else {\n+                throw new IllegalArgumentException(newObject + \" is not assignable to \" + targetClass.getSimpleName());\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        private synchronized T constructObjectWithInjection() {\n+            if (object != null) {\n+                return object;\n             }\n+\n             try {\n-                Class<T> ccl = targetClass.isInterface() ? (Class<T>) targetClass.getClassLoader()\n-                        .loadClass(targetClass.getName() + \"$Default\") : targetClass;\n-                //                System.out.println(ccl+\"  \"+deepToString(ccl.getConstructors()));\n-                Constructor<T> cons = null;\n-                for (Constructor<T> c : (Constructor<T>[]) ccl.getConstructors()) {\n-                    //                    System.out.println(\"Examine \"+c.getParameterCount()+\" \"+c.toGenericString());\n-                    if (c.getParameterCount() == 0) {\n-                        cons = c;\n-                    } else if (c.isAnnotationPresent(Inject.class)) {\n-                        cons = c;\n-                        break;\n-                    }\n-                }\n-                if (cons == null) {\n-                    throw new NoSuchMethodException(\"No usable injection constructor for \" + ccl);\n+                Class<T> clazz = targetClass;\n+\n+                if (targetClass.isInterface()) {\n+                    // For interface, we only support binding the inner \"Default\" class as implementation class for now\n+                    clazz = (Class<T>) targetClass.getClassLoader().loadClass(targetClass.getName() + \"$Default\");\n                 }\n-                cons.setAccessible(true);\n-                int np = cons.getParameterCount();\n-                if (np == 0) {\n-                    return put(cons.newInstance());\n+\n+                Constructor<T> pickedConstructor = pickConstructor(clazz);\n+                pickedConstructor.setAccessible(true);\n+\n+                int paramCount = pickedConstructor.getParameterCount();\n+                if (paramCount == 0) {\n+                    // no arg constructor\n+                    return putAndInjectFields(pickedConstructor.newInstance());\n                 }\n-                //                System.out.println(\"Injecting args into \"+cons.toGenericString());\n-                Object[] args = new Object[np];\n-                Class[] types = cons.getParameterTypes();\n-                for (int i = 0; i < np; i++) {\n-                    Class type = types[i];\n-                    if (type == Topics.class) {\n-                        ImplementsService svc = ccl.getAnnotation(ImplementsService.class);\n-                        if (svc != null) {\n-                            String nm = svc.name();\n-                            args[i] = Context.this.get(Configuration.class).lookupTopics(nm);\n-                            continue;\n+\n+                Object[] args = getOrCreateArgInstances(clazz, pickedConstructor, paramCount);\n+                return putAndInjectFields(pickedConstructor.newInstance(args));\n+            } catch (Throwable ex) {\n+                throw new IllegalArgumentException(\"Can't create instance of \" + targetClass.getName(), ex);\n+            }\n+        }\n+\n+        private Object[] getOrCreateArgInstances(Class<T> clazz, Constructor<T> pickedConstructor, int argCount) {\n+            Object[] args = new Object[argCount];\n+            Class[] argTypes = pickedConstructor.getParameterTypes();\n+            Annotation[][] argAnnotations = pickedConstructor.getParameterAnnotations();\n+\n+            for (int i = 0; i < argCount; i++) {\n+                Class argClazz = argTypes[i];\n+\n+                if (argClazz == Topics.class) {\n+                    // TODO Revisit EvergreenService injection and see if we can remove this branch\n+                    ImplementsService service = clazz.getAnnotation(ImplementsService.class);\n+                    if (service != null) {\n+                        String serviceName = service.name();\n+                        args[i] = Context.this.get(Configuration.class).lookupTopics(serviceName);\n+                        continue;\n+                    }\n+                    args[i] = Topics.errorNode(Context.this, \"message\", \"Synthetic args\");\n+                } else {\n+                    String name = null;\n+\n+                    for (Annotation annotation : argAnnotations[i]) {\n+                        if (annotation instanceof Named) {\n+                            name = nullEmpty(((Named) annotation).value());\n                         }\n-                        args[i] = Topics.errorNode(Context.this, \"message\", \"Synthetic args\");\n+                    }\n+\n+                    if (name == null) {\n+                        args[i] = Context.this.get(argClazz);\n                     } else {\n-                        args[i] = Context.this.get(type);\n+                        args[i] = Context.this.get(argClazz, name);\n                     }\n                 }\n-                //                System.out.println(\"**Construct \"+utils.deepToString(cons, 90)+\" \"+utils\n-                //                .deepToString(args, 90));\n-                return put(cons.newInstance(args));\n-            } catch (Throwable ex) {\n-                throw new IllegalArgumentException(\"Can't create instance of \" + targetClass.getName(), ex);\n             }\n+            return args;\n+        }\n+\n+        private Constructor<T> pickConstructor(Class<T> clazz) throws NoSuchMethodException {\n+            for (Constructor<T> constructor : (Constructor<T>[]) clazz.getDeclaredConstructors()) {\n+                // Use constructor with @Inject if exists\n+                if (constructor.isAnnotationPresent(Inject.class)) {\n+                    return constructor;\n+                }\n+\n+                // fall back to default constructor\n+                if (constructor.getParameterCount() == 0) {\n+                    return constructor;\n+                }\n+            }", "originalCommit": "67ebb39a31f15be6ee4e9c4e6154374a92c0622f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQxODU1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r412418551", "bodyText": "Great catch! Fixing it.", "author": "leaf94", "createdAt": "2020-04-21T19:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwMDk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwNTkzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r412405936", "bodyText": "nit: duplicate null check at Ln328 public final T get()", "author": "hui-yang", "createdAt": "2020-04-21T18:48:18Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -316,119 +314,163 @@ private boolean onPublishThread() {\n \n     public class Value<T> implements Provider<T> {\n         final Class<T> targetClass;\n-        public volatile T targetValue;\n+        public volatile T object;\n         @SuppressFBWarnings(value = \"IS2_INCONSISTENT_SYNC\", justification = \"No need to be sync\")\n         private boolean injectionCompleted;\n \n-        Value(Class<T> c, T v) {\n-            targetClass = c;\n-            put(v);\n+        Value(Class<T> clazz, T object) {\n+            targetClass = clazz;\n+            putAndInjectFields(object);\n         }\n \n         @Override\n         public final T get() {\n-            T v = targetValue;\n-            if (v != null && injectionCompleted) {\n-                return v;\n+            if (object != null && injectionCompleted) {\n+                return object;\n             }\n-            return get0();\n+            return constructObjectWithInjection();\n         }\n \n-        @SuppressWarnings({\"PMD.AvoidCatchingThrowable\"})\n-        private synchronized T get0() {\n-            T v = targetValue;\n-            if (v != null) {\n-                return v;\n+\n+        /**\n+         * Put a new object instance and inject fields with pre and post actions, if the new object is not equal\n+         * to current one.\n+         *\n+         * @param newObject the new object instance\n+         * @return new object with fields injected\n+         */\n+        final synchronized T putAndInjectFields(T newObject) {\n+            if (Objects.equals(newObject, object)) {\n+                return newObject;\n+            }\n+            if (newObject == null || targetClass.isAssignableFrom(newObject.getClass())) {\n+                injectionCompleted = false;\n+                object = newObject;\n+                injectFields(newObject);\n+                injectionCompleted = true;\n+                return newObject; // only assign after injection is complete\n+\n+            } else {\n+                throw new IllegalArgumentException(newObject + \" is not assignable to \" + targetClass.getSimpleName());\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        private synchronized T constructObjectWithInjection() {\n+            if (object != null) {\n+                return object;\n             }", "originalCommit": "67ebb39a31f15be6ee4e9c4e6154374a92c0622f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b16d2298b4e8c132c018c905be447cc78b09c87", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4b16d2298b4e8c132c018c905be447cc78b09c87", "message": "Merge branch 'master' into di", "committedDate": "2020-04-21T19:01:09Z", "type": "commit"}, {"oid": "a21d29e92dd06158cbcd1628b6077536eeffc2f7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a21d29e92dd06158cbcd1628b6077536eeffc2f7", "message": "Address PR comments", "committedDate": "2020-04-21T19:46:02Z", "type": "commit"}, {"oid": "6ab39c0f8b336030792fd9bf912279b223dd108c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6ab39c0f8b336030792fd9bf912279b223dd108c", "message": "Address PR comments", "committedDate": "2020-04-21T22:42:26Z", "type": "commit"}, {"oid": "3f061a9abe054bd17b7237d83c4a2dacc1e7ea98", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3f061a9abe054bd17b7237d83c4a2dacc1e7ea98", "message": "Address PR comments", "committedDate": "2020-04-21T22:47:56Z", "type": "commit"}, {"oid": "64ba9a4c0df7415e662180c0ec42992a3a61c8b2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/64ba9a4c0df7415e662180c0ec42992a3a61c8b2", "message": "Merge branch 'master' into di", "committedDate": "2020-04-21T22:50:46Z", "type": "commit"}, {"oid": "dc3b3ccc11ea02d309835c67be5683b0fcaa26a0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc3b3ccc11ea02d309835c67be5683b0fcaa26a0", "message": "Address PR comments", "committedDate": "2020-04-21T23:10:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjE3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r412566178", "bodyText": "We probably can remove this path. I don't think it's needed any more.", "author": "wikimonkey", "createdAt": "2020-04-21T23:43:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -60,21 +57,15 @@\n \n     private Path artifactDirectory;\n \n-    @Inject\n-    private GreengrassRepositoryDownloader greengrassArtifactDownloader;\n+    private final GreengrassRepositoryDownloader greengrassArtifactDownloader;\n \n-    @Inject\n-    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+    private final GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n \n-    @Inject\n-    private ExecutorService executorService;\n+    private final ExecutorService executorService;\n \n-    @Inject\n-    @Named(\"packageStoreDirectory\")\n-    private Path packageStoreDirectory;\n+    private final Path packageStoreDirectory;", "originalCommit": "dc3b3ccc11ea02d309835c67be5683b0fcaa26a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI0MzM3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r413243379", "bodyText": "Good point! I will add this change in my next PR!", "author": "leaf94", "createdAt": "2020-04-22T19:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzU0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r412587541", "bodyText": "I think it's still needed: it prevents injection from going infinitely recursive when there are circular references.", "author": "JamesGosling", "createdAt": "2020-04-22T00:43:33Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -316,119 +310,167 @@ private boolean onPublishThread() {\n \n     public class Value<T> implements Provider<T> {\n         final Class<T> targetClass;\n-        public volatile T targetValue;\n+        public volatile T object;\n+        // TODO Review with James if we still need injectionCompleted", "originalCommit": "64ba9a4c0df7415e662180c0ec42992a3a61c8b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI0Nzc5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/184#discussion_r413247794", "bodyText": "Thanks, James!\nI noticed we are able to inject self, and even parent. I just had some detailed question about the way we achieve it. Not something worth more attention now. I will sync with you offline later when you have time...", "author": "leaf94", "createdAt": "2020-04-22T19:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzU0MQ=="}], "type": "inlineReview"}, {"oid": "a2f20365502157367ad948c54198ce43303def1c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2f20365502157367ad948c54198ce43303def1c", "message": "Merge branch 'master' into di", "committedDate": "2020-04-22T17:32:32Z", "type": "commit"}, {"oid": "5e7b8166488390c1a9e95455d133883ee67b6197", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5e7b8166488390c1a9e95455d133883ee67b6197", "message": "fix benchmark", "committedDate": "2020-04-22T18:15:19Z", "type": "commit"}]}