{"pr_number": 36, "pr_title": "Add error recovery", "pr_createdAt": "2020-01-21T03:24:02Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36", "timeline": [{"oid": "3e82e9b29e950d73e769dd2cdc355a275e0a7050", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3e82e9b29e950d73e769dd2cdc355a275e0a7050", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n  1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n  1. Rename Shutdown to Broken.", "committedDate": "2020-01-21T03:53:26Z", "type": "forcePushed"}, {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afce75047644ef9b1250bf3366e87c65ca768f9b", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n    1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n    1. Rename Shutdown to Broken.", "committedDate": "2020-01-21T19:17:35Z", "type": "commit"}, {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afce75047644ef9b1250bf3366e87c65ca768f9b", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n    1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n    1. Rename Shutdown to Broken.", "committedDate": "2020-01-21T19:17:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4ODczMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369688732", "bodyText": "In general, it's best to use the thread pool context.get(ExecutorService.class).submit(r), unless it's a long lived thread whose parameters you want to change (like priority or name).", "author": "JamesGosling", "createdAt": "2020-01-22T17:08:23Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,42 +46,93 @@ public boolean isRunningInternally() {\n     public boolean isPeriodic() { return periodicityInformation!=null; }\n     private boolean errorHandlerErrored; // cheezy hack to avoid repeating error handlers\n     public void setState(State s) {\n-        State was = (State) state.getOnce();\n+        final State was = (State) state.getOnce();\n+\n+\n         if(s!=was) {\n             context.getLog().note(getName(),was,\"=>\",s);\n-            state.setValue(Long.MAX_VALUE, s);\n-            context.globalNotifyStateChanged(this, was);\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (state) {\n+                state.setValue(Long.MAX_VALUE, s);\n+                context.globalNotifyStateChanged(this, was);\n+            }\n         }\n     }\n     private State activeState = State.New;\n+    CountDownLatch shutdownLatch = new CountDownLatch(0);\n     @Override // for listening to state changes\n     public void published(final WhatHappened what, final Topic topic) {\n         final State newState = (State) topic.getOnce();\n         if(activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n+            shutdownLatch = new CountDownLatch(1);\n+            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until shutdown task complete.\n+            // May consider just merge shutdown() into other state's handling.\n             setBackingTask(() -> {\n                 try {\n                     shutdown();\n                 } catch (Throwable t) {\n-                    errored(\"Failed shutting down\", t);\n+                    if (activeState != State.Errored) {\n+                        errored(\"Failed shutting down\", t);\n+                    } else {\n+                        context.getLog().error(this,\"Failed shutting down\", t);\n+                    }\n+                } finally {\n+                    shutdownLatch.countDown();\n                 }\n+                backingTask = null;\n             }, getName() + \"=>\" + newState);\n+\n+            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch() here.\n+            // However, this caused the global configuration publish queue being blocked.\n         }\n+\n         try {\n             switch(newState) {\n                 case Installing:\n-                    setBackingTask(() -> {\n+                    new Thread(() -> {", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyMjMzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369722339", "bodyText": "The problem of using setBackingThread() here is it might cancel the 'shutdown()' task that's going on.", "author": "ShirleyZheng92", "createdAt": "2020-01-22T18:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4ODczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTczMDE1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369730154", "bodyText": "Also, since this Thread is merely waiting , I'm worried that using threadPool may block other service's tasks", "author": "ShirleyZheng92", "createdAt": "2020-01-22T18:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4ODczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5Nzk3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369697972", "bodyText": "It would probably be good to add something like:\n// TODO Improve error restarts by collecting statistics on errors.  eg. If it error's often, start adding backoff waits.\n//  Maybe doing a little inspection of exceptions to be smarter.  eg. file system full messages could trigger a disk\n//  cleanup before the restart,  Or network errors could look at the network state and not restart until the network\n//  reconnects.\n\nWhich should end up as backlog SIMs", "author": "JamesGosling", "createdAt": "2020-01-22T17:26:10Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -192,11 +246,31 @@ public void startup() {\n     protected void run() {\n         setState(State.Finished);\n     }\n+\n     /**\n      * Called when a running service encounters an error.\n      */\n     protected void handleError() {\n+        if (error != null) {\n+            context.getLog().error(\"Handle error\", error);\n+            error = null;\n+        }\n+", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3MDg2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369270866", "bodyText": "why did you change this to final?", "author": "rbattle", "createdAt": "2020-01-21T22:11:40Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -118,7 +118,7 @@ public synchronized void removeGlobalStateChangeListener(EvergreenService.Global\n             if(listeners.isEmpty()) listeners = null;\n         }\n     }\n-    public void globalNotifyStateChanged(EvergreenService l, State was) {\n+    public void globalNotifyStateChanged(EvergreenService l, final State was) {", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyNzc1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369727752", "bodyText": "I was debugging this function and want to make sure that State isn't changed in the function.", "author": "ShirleyZheng92", "createdAt": "2020-01-22T18:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3MDg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTA1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699052", "bodyText": "should waitForDependencyReady() throw InterruptedException instead of swallowing it so that we can move into an errored state if we are interrupted while waiting for dependencies?", "author": "rbattle", "createdAt": "2020-01-22T17:28:20Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,42 +46,93 @@ public boolean isRunningInternally() {\n     public boolean isPeriodic() { return periodicityInformation!=null; }\n     private boolean errorHandlerErrored; // cheezy hack to avoid repeating error handlers\n     public void setState(State s) {\n-        State was = (State) state.getOnce();\n+        final State was = (State) state.getOnce();\n+\n+\n         if(s!=was) {\n             context.getLog().note(getName(),was,\"=>\",s);\n-            state.setValue(Long.MAX_VALUE, s);\n-            context.globalNotifyStateChanged(this, was);\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (state) {\n+                state.setValue(Long.MAX_VALUE, s);\n+                context.globalNotifyStateChanged(this, was);\n+            }\n         }\n     }\n     private State activeState = State.New;\n+    CountDownLatch shutdownLatch = new CountDownLatch(0);\n     @Override // for listening to state changes\n     public void published(final WhatHappened what, final Topic topic) {\n         final State newState = (State) topic.getOnce();\n         if(activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n+            shutdownLatch = new CountDownLatch(1);\n+            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until shutdown task complete.\n+            // May consider just merge shutdown() into other state's handling.\n             setBackingTask(() -> {\n                 try {\n                     shutdown();\n                 } catch (Throwable t) {\n-                    errored(\"Failed shutting down\", t);\n+                    if (activeState != State.Errored) {\n+                        errored(\"Failed shutting down\", t);\n+                    } else {\n+                        context.getLog().error(this,\"Failed shutting down\", t);\n+                    }\n+                } finally {\n+                    shutdownLatch.countDown();\n                 }\n+                backingTask = null;\n             }, getName() + \"=>\" + newState);\n+\n+            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch() here.\n+            // However, this caused the global configuration publish queue being blocked.\n         }\n+\n         try {\n             switch(newState) {\n                 case Installing:\n-                    setBackingTask(() -> {\n+                    new Thread(() -> {\n+                        // wait until shutdown finished.\n+                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n                         try {\n-                            install();\n-                            setState(State.AwaitingStartup);\n-                        } catch (Throwable t) {\n-                            errored(\"Failed installing\", t);\n+                            shutdownLatch.await();\n+                        } catch (InterruptedException e) {\n+                            errored(\"waiting for shutdown complete\", e);\n+                            return;\n                         }\n-                        backingTask = null;\n-                    }, getName()+\" => \"+newState);\n+                        if (!errored() && getState() == State.Installing) {\n+                            setBackingTask(() -> {\n+                                try {\n+                                    install();\n+                                    if (!errored()) {\n+                                        setState(State.AwaitingStartup);\n+                                    }\n+                                } catch (Throwable t) {\n+                                    errored(\"Failed installing\", t);\n+                                }\n+                                backingTask = null;\n+                            }, getName() + \" => \" + newState);\n+                        }\n+                    }).start();\n+\n                     break;\n                 case AwaitingStartup:\n                     awaitingStartup();\n-                    if(!hasDependencies() && !errored()) setState(State.Starting);\n+                    new Thread(() -> {\n+                        // wait until shutdown finished.\n+                        try {\n+                            shutdownLatch.await();\n+                        } catch (InterruptedException e) {\n+                            errored(\"waiting for shutdown complete\", e);\n+                            return;\n+                        }\n+                        if (dependencies != null) {\n+                            waitForDependencyReady();", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyMjcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369722704", "bodyText": "Good catch", "author": "ShirleyZheng92", "createdAt": "2020-01-22T18:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTI2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699268", "bodyText": "Do we want to print the stack when we are interrupted?\nIf it is interrupted, is that the same as all the dependencies being ready?", "author": "rbattle", "createdAt": "2020-01-22T17:28:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();\n+            }\n+        });\n     }\n-    private boolean hasDependencies() {\n-        return dependencies != null\n-                && (dependencies.entrySet().stream().anyMatch(ls -> ls.getKey().getState().preceeds(ls.getValue())));\n+\n+    private boolean dependencyReady() {\n+        if (dependencies == null) {\n+            return true;\n+        }\n+        return dependencies.entrySet().stream().allMatch(ls -> dependencyReady(ls.getKey()));\n     }\n-    public void forAllDependencies(Consumer<? super EvergreenService> f) {\n-        if(dependencies!=null) dependencies.keySet().forEach(f);\n+\n+    private boolean dependencyReady(EvergreenService v) {\n+        State state = v.getState();\n+        State startWhenState = dependencies.get(v);\n+        return (state.isHappy()) && startWhenState.preceedsOrEqual(state);\n     }\n-    private void recheckOthersDependencies() {\n-        if (context != null) {\n-            final AtomicBoolean changed = new AtomicBoolean(true);\n-            while (changed.get()) {\n-                changed.set(false);\n-                context.forEach(v -> {\n-                    Object vv = v.value;\n-                    if(vv instanceof EvergreenService) {\n-                        EvergreenService l = (EvergreenService) vv;\n-                        if (l.inState(State.AwaitingStartup)) {\n-                            if (!l.hasDependencies()) {\n-                                l.setState(State.Starting);\n-                                changed.set(true);\n-                            }\n-                        }\n-                    }\n-                });\n-            }\n+\n+    private void waitForDependencyReady() {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+\n+        try {\n+            dependencyReadyLatch.await();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MzYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369693636", "bodyText": "Why convert to a linked list? Just use the List given by Arrays.asList.", "author": "MikeDombo", "createdAt": "2020-01-22T17:17:46Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelTest.java", "diffHunk": "@@ -2,16 +2,102 @@\n  * SPDX-License-Identifier: Apache-2.0 */\n package com.aws.iot.evergreen.kernel;\n \n+import java.util.Arrays;\n+import java.util.LinkedList;\n import java.util.concurrent.*;\n \n+import com.aws.iot.evergreen.dependency.State;\n import org.junit.jupiter.api.Test;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \n public class KernelTest {\n-//    boolean seenDocker, seenShell;\n+//    boolean seenDocker, seenShell\n //    int seenTickTock = 4;\n //    long lastTickTock = 0;\n+    @Test\n+    public void testErrorRetry() throws InterruptedException {\n+            String tdir = System.getProperty(\"user.home\") + \"/kernelTest\";\n+            Kernel kernel = new Kernel();\n+            kernel.parseArgs(\"-r\", tdir,\n+                    \"-log\", \"stdout\",\n+                    \"-i\", Kernel.class.getResource(\"config_broken.yaml\").toString()\n+            );\n+\n+        LinkedList<ExpectedStateTransition> expectedStateTransitionList = new LinkedList<>(Arrays.asList(", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2Mzk4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369763982", "bodyText": "This is to bypass the final variable restriction inside lambda function. This test is asserting on a list of state events happen in sequence. The assertion is done by comparing state event to the head of linklist, and removing the head after state event matches.", "author": "ShirleyZheng92", "createdAt": "2020-01-22T19:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MzYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NjE2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369696167", "bodyText": "Looks like you never check this ok.\nFor these async assertions, I think we may want to try maybe a CompletableFuture which we can wait to complete or error, and then calling .get() on the future will cause it to throw the exception if there was any.", "author": "MikeDombo", "createdAt": "2020-01-22T17:22:46Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelTest.java", "diffHunk": "@@ -2,16 +2,102 @@\n  * SPDX-License-Identifier: Apache-2.0 */\n package com.aws.iot.evergreen.kernel;\n \n+import java.util.Arrays;\n+import java.util.LinkedList;\n import java.util.concurrent.*;\n \n+import com.aws.iot.evergreen.dependency.State;\n import org.junit.jupiter.api.Test;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \n public class KernelTest {\n-//    boolean seenDocker, seenShell;\n+//    boolean seenDocker, seenShell\n //    int seenTickTock = 4;\n //    long lastTickTock = 0;\n+    @Test\n+    public void testErrorRetry() throws InterruptedException {\n+            String tdir = System.getProperty(\"user.home\") + \"/kernelTest\";\n+            Kernel kernel = new Kernel();\n+            kernel.parseArgs(\"-r\", tdir,\n+                    \"-log\", \"stdout\",\n+                    \"-i\", Kernel.class.getResource(\"config_broken.yaml\").toString()\n+            );\n+\n+        LinkedList<ExpectedStateTransition> expectedStateTransitionList = new LinkedList<>(Arrays.asList(\n+                new ExpectedStateTransition(\"installErrorRetry\", State.New, State.Installing),\n+                new ExpectedStateTransition(\"installErrorRetry\", State.Installing, State.Errored),\n+                new ExpectedStateTransition(\"installErrorRetry\", State.Errored, State.Installing),\n+                new ExpectedStateTransition(\"installErrorRetry\", State.Installing, State.AwaitingStartup),\n+\n+                // main service doesn't start until dependency ready\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Starting, State.Running),\n+                new ExpectedStateTransition(\"main\", State.AwaitingStartup, State.Starting),\n+                new ExpectedStateTransition(\"main\", State.Starting, State.Running),\n+\n+                // runErrorRetry restart on error\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Running, State.Errored),\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Errored, State.AwaitingStartup),\n+\n+                // main service restart on dependency error\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Running, State.Errored),\n+                new ExpectedStateTransition(\"main\", State.Running, State.AwaitingStartup),\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Starting, State.Running),\n+                new ExpectedStateTransition(\"main\", State.AwaitingStartup, State.Starting)\n+            ));\n+\n+        CountDownLatch assertionLatch = new CountDownLatch(1);\n+\n+        kernel.context.addGlobalStateChangeListener((EvergreenService service, State was) -> {\n+            if (expectedStateTransitionList.size() == 0) {\n+                return;\n+            }\n+\n+            ExpectedStateTransition expected = expectedStateTransitionList.peek();\n+\n+            if (service.getName().equals(expected.serviceName) &&\n+                was.equals(expected.was) &&\n+                service.getState().equals(expected.current)) {\n+                System.out.println(String.format(\"Just saw state event for service %s: %s=> %s\",\n+                        expected.serviceName,\n+                        expected.was,\n+                        expected.current\n+                        ));\n+\n+                expectedStateTransitionList.pollFirst();\n+                if (expectedStateTransitionList.size() == 0) {\n+                    // all assersion done.\n+                    assertionLatch.countDown();\n+                }\n+            }\n+\n+        });\n+        kernel.launch();\n+        boolean ok = assertionLatch.await(60, TimeUnit.SECONDS);", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTczMzM0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369733344", "bodyText": "Removed 'ok', I copied from below.\nThis test is asserting on expected state transition is seen in sequence, no error/exception is thrown in the task", "author": "ShirleyZheng92", "createdAt": "2020-01-22T18:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MTczNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369751736", "bodyText": "But you need to assert on the ok, otherwise you don't know if that latch never counted down.", "author": "MikeDombo", "createdAt": "2020-01-22T19:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NjE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NzIwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369697201", "bodyText": "I'd probably let this throw to the caller instead of trying to handle it in here.", "author": "MikeDombo", "createdAt": "2020-01-22T17:24:45Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();\n+            }\n+        });\n     }\n-    private boolean hasDependencies() {\n-        return dependencies != null\n-                && (dependencies.entrySet().stream().anyMatch(ls -> ls.getKey().getState().preceeds(ls.getValue())));\n+\n+    private boolean dependencyReady() {\n+        if (dependencies == null) {\n+            return true;\n+        }\n+        return dependencies.entrySet().stream().allMatch(ls -> dependencyReady(ls.getKey()));\n     }\n-    public void forAllDependencies(Consumer<? super EvergreenService> f) {\n-        if(dependencies!=null) dependencies.keySet().forEach(f);\n+\n+    private boolean dependencyReady(EvergreenService v) {\n+        State state = v.getState();\n+        State startWhenState = dependencies.get(v);\n+        return (state.isHappy()) && startWhenState.preceedsOrEqual(state);\n     }\n-    private void recheckOthersDependencies() {\n-        if (context != null) {\n-            final AtomicBoolean changed = new AtomicBoolean(true);\n-            while (changed.get()) {\n-                changed.set(false);\n-                context.forEach(v -> {\n-                    Object vv = v.value;\n-                    if(vv instanceof EvergreenService) {\n-                        EvergreenService l = (EvergreenService) vv;\n-                        if (l.inState(State.AwaitingStartup)) {\n-                            if (!l.hasDependencies()) {\n-                                l.setState(State.Starting);\n-                                changed.set(true);\n-                            }\n-                        }\n-                    }\n-                });\n-            }\n+\n+    private void waitForDependencyReady() {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+\n+        try {\n+            dependencyReadyLatch.await();\n+        } catch (InterruptedException e) {", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NzYzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369697634", "bodyText": "Since you're only using the key, you can use the keySet instead of entries.", "author": "MikeDombo", "createdAt": "2020-01-22T17:25:34Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();\n+            }\n+        });\n     }\n-    private boolean hasDependencies() {\n-        return dependencies != null\n-                && (dependencies.entrySet().stream().anyMatch(ls -> ls.getKey().getState().preceeds(ls.getValue())));\n+\n+    private boolean dependencyReady() {\n+        if (dependencies == null) {\n+            return true;\n+        }\n+        return dependencies.entrySet().stream().allMatch(ls -> dependencyReady(ls.getKey()));", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyMzI5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369723293", "bodyText": "ok", "author": "ShirleyZheng92", "createdAt": "2020-01-22T18:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NzYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTE1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699156", "bodyText": "This doesn't look threadsafe to me. A different thread could be waiting on a latch which you then set to a different instance of a latch. I'm pretty sure this won't work properly, especially with multiple dependencies that we're waiting for.", "author": "MikeDombo", "createdAt": "2020-01-22T17:28:33Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyNDM3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369724378", "bodyText": "I haven't think of a better way to prevent this. So far the only place to wait on dependencyReadyLatch is in waitForDependencyReady() , where the code checks dependencyReady() before. I'll try to better synchronize this", "author": "ShirleyZheng92", "createdAt": "2020-01-22T18:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTczMTg3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369731877", "bodyText": "You could just have a list readyLatches, that way you're not overwriting the latches, and only move on once all the latches have counted down. Or similarly, have a count down latch where the initial number is the number of dependencies.", "author": "MikeDombo", "createdAt": "2020-01-22T18:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MzQwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369753406", "bodyText": "CountdownLatch doesn't let your reset number. Looking at other solutions now", "author": "ShirleyZheng92", "createdAt": "2020-01-22T19:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTY0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699648", "bodyText": "This latch that you're counting down isn't necessarily the same latch that some other thread is waiting for, so the waiting thread might get stuck waiting forever.", "author": "MikeDombo", "createdAt": "2020-01-22T17:29:35Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();", "originalCommit": "afce75047644ef9b1250bf3366e87c65ca768f9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b83f3c8daa016cb9a6cc52de0699566982782e08", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b83f3c8daa016cb9a6cc52de0699566982782e08", "message": "remove InstallOnly mode.", "committedDate": "2020-01-22T19:37:20Z", "type": "commit"}, {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f202bdded7c353543d5138d8e62cb64558ae54e7", "message": "Use object lock&notify in waitForDependencyReady()", "committedDate": "2020-01-22T22:26:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2OTQ5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369869496", "bodyText": "if you are switching to wait/notifyAll, then this doesn't need to be a latch at all. You could just use new Object()\nYou could rename this as final Object dependencyLock = new Object() and use that instead", "author": "rbattle", "createdAt": "2020-01-22T23:55:12Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -287,7 +299,7 @@ public void close() {\n \n     public Context getContext() { return context; }\n \n-    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n+    final CountDownLatch dependencyReadyLatch = new CountDownLatch(1);", "originalCommit": "f202bdded7c353543d5138d8e62cb64558ae54e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxNjYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370316636", "bodyText": "Ok.", "author": "ShirleyZheng92", "createdAt": "2020-01-23T19:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2OTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MDkyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370250922", "bodyText": "Do you ever reset this value to be false?", "author": "MikeDombo", "createdAt": "2020-01-23T17:20:20Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -113,25 +170,30 @@ public void published(final WhatHappened what, final Topic topic) {\n                     }\n                     break;\n                 case Errored:\n-                    try {\n-                        if(!errorHandlerErrored) handleError();\n-                    } catch (Throwable t) {\n-                        errorHandlerErrored = true;\n-                        errored(\"Error handler failed\", t);\n-                    }\n+                    if (activeState != State.Errored) // already in the process of error handling\n+                        try {\n+                            if(!errorHandlerErrored) handleError();\n+                        } catch (Throwable t) {\n+                            errorHandlerErrored = true;", "originalCommit": "f202bdded7c353543d5138d8e62cb64558ae54e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyMDQ4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370320489", "bodyText": "Seems not. This part of logic isn't changed. Let me see if I can improve it, if not I'll add a TODO", "author": "ShirleyZheng92", "createdAt": "2020-01-23T19:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MDkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MjA0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370252042", "bodyText": "I thought we were going to have some different behavior here, like a service that can handle its dependencies being down. It's fine not to have right now, but please add a TODO here if I'm remembering correctly.", "author": "MikeDombo", "createdAt": "2020-01-23T17:22:32Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +291,63 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    final CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);", "originalCommit": "f202bdded7c353543d5138d8e62cb64558ae54e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNTA0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370305044", "bodyText": "Ok.", "author": "ShirleyZheng92", "createdAt": "2020-01-23T19:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1NDYzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370254635", "bodyText": "Since the state machine just runs, maybe this should be renamed. Maybe \"startupAllServices\"? Or anything else really, since installEverything doesn't really cover the whole scope of what will result from calling it.", "author": "MikeDombo", "createdAt": "2020-01-23T17:27:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -224,8 +220,6 @@ public Kernel launch() {\n         writeEffectiveConfig();\n         try {\n             installEverything();", "originalCommit": "f202bdded7c353543d5138d8e62cb64558ae54e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1NTA1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370255051", "bodyText": "May need a timer and then a shutdown(true) to force it to stop.", "author": "MikeDombo", "createdAt": "2020-01-23T17:28:36Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -368,13 +352,23 @@ public void shutdown() {\n         try {\n             log.significant(\"Shutting everything down\", getMain());\n             EvergreenService[] d = orderedDependencies().toArray(new EvergreenService[0]);\n-            for (int i = d.length; --i >= 0;) // shutdown in reverse order\n+            for (int i = d.length; --i >= 0;) { // shutdown in reverse order\n                 if (d[i].inState(State.Running))\n                     try {\n                         d[i].close();\n                     } catch (Throwable t) {\n                         log.error(d[i], \"Failed to shutdown\", t);\n                     }\n+            }\n+\n+            // Wait for tasks in the executor to end.\n+            ExecutorService executorService = context.get(ExecutorService.class);\n+            this.context.runOnPublishQueueAndWait(() -> {\n+                executorService.shutdown();", "originalCommit": "f202bdded7c353543d5138d8e62cb64558ae54e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNzI3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370307279", "bodyText": "runOnPublishQueueAndwait will queue the executorService.shutdown() after other state change events. executorService.shutdown() will stop the executorService accepting new tasks, but will still run the existing tasks.\nawaitTermination() waits for existing tasks to finish within a timeout before process exits.", "author": "ShirleyZheng92", "createdAt": "2020-01-23T19:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1NTA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNzk1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370307953", "bodyText": "OK, so you don't want to force it to die? If not, then what you have is certainly fine.", "author": "MikeDombo", "createdAt": "2020-01-23T19:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1NTA1MQ=="}], "type": "inlineReview"}, {"oid": "efbbeefd35425797d037ebeca3997af9c6614695", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/efbbeefd35425797d037ebeca3997af9c6614695", "message": "address comments", "committedDate": "2020-01-23T20:23:18Z", "type": "commit"}, {"oid": "4553af4bef0bad8e819560298fb504d13f39a6da", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4553af4bef0bad8e819560298fb504d13f39a6da", "message": "Merge branch 'master' into errHandle", "committedDate": "2020-01-23T20:59:20Z", "type": "commit"}, {"oid": "7b2e3f195af88733e91d80a4227f2957d53a916f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7b2e3f195af88733e91d80a4227f2957d53a916f", "message": "Merge branch 'master' into errHandle", "committedDate": "2020-01-23T21:33:00Z", "type": "commit"}]}