{"pr_number": 759, "pr_title": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "pr_createdAt": "2020-06-15T12:11:50Z", "pr_url": "https://github.com/apache/jena/pull/759", "timeline": [{"oid": "1d553248e493ab00c88468c51328d22f3df1de17", "url": "https://github.com/apache/jena/commit/1d553248e493ab00c88468c51328d22f3df1de17", "message": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "committedDate": "2020-06-15T13:33:26Z", "type": "forcePushed"}, {"oid": "e367d0247eec57c7466adef3a31601548a420ed6", "url": "https://github.com/apache/jena/commit/e367d0247eec57c7466adef3a31601548a420ed6", "message": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "committedDate": "2020-06-15T21:21:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NjAzOA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440596038", "bodyText": "Oh, the list used to be on Yahoo! Groups? That was probably a long time ago?", "author": "kinow", "createdAt": "2020-06-16T05:34:23Z", "path": "jena-core/src/main/java/org/apache/jena/ontology/OntDocumentManager.java", "diffHunk": "@@ -54,16 +54,14 @@\n  * example:\n  * </p>\n  * <pre>OntDocumentManager dm = OntDocumentManager.getInstance();\n- * dm.setFileManager( FileManager.get() );</pre>\n- * <p>Note that in Jena 2.3, we have deprecated the capability of the document manager\n- * to store a table of known prefixes, and a table mapping document URI's to ontology language\n- * types. <strong>The intention is to remove both of these capabilities from\n- * Jena 2.4 onwards</strong>. If this change would be problematic, please send email to the\n- * <a href=\"http://groups.yahoo.com/group/jena-dev\">Jena support", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NjUzOA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440596538", "bodyText": "I think the only difference now is that writerName.equals(n3WriterPrettyPrinter) used to work, and now it won't? But probably no harm I guess?", "author": "kinow", "createdAt": "2020-06-16T05:36:06Z", "path": "jena-core/src/main/java/org/apache/jena/n3/N3JenaWriter.java", "diffHunk": "@@ -105,16 +80,20 @@ N3JenaWriterCommon chooseWriter()\n     {\n         // Choose the writer\n         String writerName = JenaRuntime.getSystemProperty(propWriterName) ;\n-        if ( writerName == null ||\n-             writerName.equals(\"N3\") || writerName.equals(n3WriterPrettyPrinter) )\n+        if ( writerName == null )\n+            return new N3JenaWriterPP() ;\n+        if ( writerName.equals(\"N3\") )\n             return new N3JenaWriterPP() ;\n         \n-        if ( writerName.equalsIgnoreCase(n3WriterPlain) )\n-            return new N3JenaWriterCommon() ;\n-        \n-        if ( writerName.equalsIgnoreCase(n3WriterTriples) ||\n-             writerName.equalsIgnoreCase(n3WriterTriplesAlt) )\n-            return new N3JenaWriterTriples() ;\n+//        if ( writerName.equals(n3WriterPrettyPrinter) )", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzE1Mw==", "url": "https://github.com/apache/jena/pull/759#discussion_r440597153", "bodyText": "s/FileManger/FileManager", "author": "kinow", "createdAt": "2020-06-16T05:38:12Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzIxMw==", "url": "https://github.com/apache/jena/pull/759#discussion_r440597213", "bodyText": "Extra *", "author": "kinow", "createdAt": "2020-06-16T05:38:27Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n+ * one {@link LocatorURL}\n+ * \n+ * Main operations:\n+ *  * <ul>", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5ODA0MA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440598040", "bodyText": "Should this method be made synchronized, or should we tell users of this code that it is not thread-safe? (I think it's not, but my Java-fu is getting utterly confused due to writing more JS & Python at $work)", "author": "kinow", "createdAt": "2020-06-16T05:41:23Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n+ * one {@link LocatorURL}\n+ * \n+ * Main operations:\n+ *  * <ul>\n+ * <li>loadModel, readModel : URI to model</li>\n+ * <li>open, openNoMap : URI to input stream</li>\n+ * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n+ * </ul>\n+ * \n+ * Utilities:\n+ * <ul>\n+ * <li>readWholeFileAsUTF8</li>\n+ * <li>optional caching of models<li>\n+ * </ul>\n+ * \n+ * A FileManager works in conjunction with a LocationMapper.\n+ * A {@link LocationMapper} is a set of alternative locations for system\n+ * resources and a set of alternative prefix locations.  For example, a local\n+ * copy of a common RDF dataset may be used whenever the usual URL is used by\n+ * the application.\n+ *\n+ * The {@link LocatorFile} also supports the idea of \"current directory\".\n+ * \n+ * @see LocationMapper\n+ * @see FileUtils\n+ */\n+ \n+public class FileManagerImpl implements FileManager\n+{\n+    // The case of the FileManager used first.\n+    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n+    \n+    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n+\n+    static FileManager fmInstance = null ;\n+\n+    protected List<Locator> fmHandlers = new ArrayList<>() ;\n+    protected LocationMapper fmMapper = null ;\n+    \n+    static { JenaSystem.init(); }\n+\n+    /** Get the global file manager.\n+     * @return the global file manager\n+     */\n+    public static FileManager get()\n+    {\n+        // Singleton pattern adopted in case we later have several file managers.\n+        if ( fmInstance == null )", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5OTc2NQ==", "url": "https://github.com/apache/jena/pull/759#discussion_r440599765", "bodyText": "\ud83d\ude04", "author": "kinow", "createdAt": "2020-06-16T05:47:33Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n+ * one {@link LocatorURL}\n+ * \n+ * Main operations:\n+ *  * <ul>\n+ * <li>loadModel, readModel : URI to model</li>\n+ * <li>open, openNoMap : URI to input stream</li>\n+ * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n+ * </ul>\n+ * \n+ * Utilities:\n+ * <ul>\n+ * <li>readWholeFileAsUTF8</li>\n+ * <li>optional caching of models<li>\n+ * </ul>\n+ * \n+ * A FileManager works in conjunction with a LocationMapper.\n+ * A {@link LocationMapper} is a set of alternative locations for system\n+ * resources and a set of alternative prefix locations.  For example, a local\n+ * copy of a common RDF dataset may be used whenever the usual URL is used by\n+ * the application.\n+ *\n+ * The {@link LocatorFile} also supports the idea of \"current directory\".\n+ * \n+ * @see LocationMapper\n+ * @see FileUtils\n+ */\n+ \n+public class FileManagerImpl implements FileManager\n+{\n+    // The case of the FileManager used first.\n+    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n+    \n+    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n+\n+    static FileManager fmInstance = null ;\n+\n+    protected List<Locator> fmHandlers = new ArrayList<>() ;\n+    protected LocationMapper fmMapper = null ;\n+    \n+    static { JenaSystem.init(); }\n+\n+    /** Get the global file manager.\n+     * @return the global file manager\n+     */\n+    public static FileManager get()\n+    {\n+        // Singleton pattern adopted in case we later have several file managers.\n+        if ( fmInstance == null )\n+            fmInstance = makeGlobal() ;\n+        return fmInstance ;\n+    }\n+    \n+    /** Set the global file manager (as returned by get())\n+     * If called before any call to get(), then the usual default filemanager is not created \n+     * @param globalFileManager\n+     */\n+    public static void setGlobalFileManager(FileManager globalFileManager)\n+    {\n+        fmInstance = globalFileManager ;\n+    }\n+    \n+    /** Create an uninitialized FileManager */\n+\n+    protected FileManagerImpl() {}\n+    \n+    protected static FileManager makeStd() {\n+        FileManagerImpl fm = new FileManagerImpl();\n+        setStdLocators(fm);\n+        return fm;\n+    }\n+    \n+    /** Create with the given location mapper */\n+    protected FileManagerImpl(LocationMapper _mapper)    { setLocationMapper(_mapper) ; }\n+\n+    @Override\n+    public FileManager clone() { return clone(this) ; } \n+ \n+    // Isolate to help avoid copy errors.\n+    private static FileManager clone(FileManagerImpl filemanager) {\n+        FileManagerImpl newFm = new FileManagerImpl() ;\n+        newFm.fmHandlers.addAll(filemanager.fmHandlers) ;\n+        newFm.fmMapper = null ;\n+        if ( filemanager.getLocationMapper() != null )\n+            newFm.fmMapper = new LocationMapper(filemanager.getLocationMapper()) ;\n+        newFm.cacheModelLoads = false ;\n+        newFm.modelCache = null ;\n+        return newFm ;\n+    }\n+\n+    /** Create a \"standard\" FileManager. */\n+    public static FileManager makeGlobal()\n+    {\n+        FileManagerImpl fMgr = new FileManagerImpl(LocationMapper.get()) ;\n+        setStdLocators(fMgr) ;\n+        return fMgr ;\n+    }\n+    \n+    /** Force a file handler to have the default configuration. */\n+    private static void setStdLocators(FileManagerImpl fMgr)\n+    {\n+        fMgr.fmHandlers.clear() ;\n+        fMgr.addLocatorFile() ;\n+        fMgr.addLocatorURL() ;\n+        fMgr.addLocatorClassLoader(fMgr.getClass().getClassLoader()) ;\n+    }\n+    /** Set the location mapping */\n+    @Override\n+    public void setLocationMapper(LocationMapper _mapper) { fmMapper = _mapper ; }\n+    \n+    /** Get the location mapping */\n+    @Override\n+    public LocationMapper getLocationMapper() { return fmMapper ; }\n+    \n+    /** Return an iterator over all the handlers */\n+    @Override\n+    public Iterator<Locator> locators() { return fmHandlers.listIterator() ; }\n+\n+    /** Add a locator to the end of the locators list */ \n+    @Override\n+    public void addLocator(Locator loc)\n+    {\n+        log.debug(\"Add location: \"+loc.getName()) ;\n+        fmHandlers.add(loc) ; }\n+\n+    /** Add a file locator */ \n+    @Override\n+    public void addLocatorFile() { addLocatorFile(null) ; } \n+\n+    /** Add a file locator which uses dir as its working directory */ \n+    @Override\n+    public void addLocatorFile(String dir)\n+    {\n+        LocatorFile fLoc = new LocatorFile(dir) ;\n+        addLocator(fLoc) ;\n+    }\n+    \n+    /** Add a class loader locator */ \n+    @Override\n+    public void addLocatorClassLoader(ClassLoader cLoad)\n+    {\n+        LocatorClassLoader cLoc = new LocatorClassLoader(cLoad) ;\n+        addLocator(cLoc) ;\n+    }\n+\n+    /** Add a URL locator */\n+    @Override\n+    public void addLocatorURL()\n+    {\n+        Locator loc = new LocatorURL() ;\n+        addLocator(loc) ;\n+    }\n+\n+    /** Add a zip file locator */\n+    @Override\n+    public void addLocatorZip(String zfn)\n+    {\n+        Locator loc = new LocatorZip(zfn) ;\n+        addLocator(loc) ;\n+    }\n+\n+    \n+    /** Remove a locator */ \n+    @Override\n+    public void remove(Locator loc) { fmHandlers.remove(loc) ; }\n+\n+    // -------- Cache operations\n+    boolean cacheModelLoads = false ;\n+    Map<String, Model> modelCache = null ;\n+    \n+    /** Reset the model cache */\n+    @Override\n+    public void resetCache()\n+    {\n+        if ( modelCache != null )\n+            modelCache.clear() ;\n+    }\n+    \n+    /** Change the state of model cache : does not clear the cache */ \n+    @Override\n+    public void setModelCaching(boolean state)\n+    {\n+        cacheModelLoads = state ;\n+        if ( cacheModelLoads && modelCache == null )\n+            modelCache = new HashMap<String, Model>() ;\n+    }\n+\n+    /** return whether caching is on of off */\n+    @Override\n+    public boolean isCachingModels() { return cacheModelLoads ; }\n+    \n+    /** Read out of the cache - return null if not in the cache */ \n+    @Override\n+    public Model getFromCache(String filenameOrURI)\n+    { \n+        if ( ! isCachingModels() )\n+            return null; \n+        return modelCache.get(filenameOrURI) ;\n+    }\n+    \n+    @Override\n+    public boolean hasCachedModel(String filenameOrURI)\n+    { \n+        if ( ! isCachingModels() )\n+            return false ; \n+        return modelCache.containsKey(filenameOrURI) ;\n+    }\n+    \n+    @Override\n+    public void addCacheModel(String uri, Model m)\n+    { \n+        if ( isCachingModels() )\n+            modelCache.put(uri, m) ;\n+    }\n+\n+    @Override\n+    public void removeCacheModel(String uri)\n+    { \n+        if ( isCachingModels() )\n+            modelCache.remove(uri) ;\n+    }\n+\n+    // -------- Cache operations (end)\n+\n+    /** Load a model from a file (local or remote).\n+     *  This operation may attempt content negotiation for http URLs.\n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI)\n+    { \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n+        \n+        return loadModelWorker(filenameOrURI, null, null) ;\n+    }\n+\n+    /** Load a model from a file (local or remote).\n+     *  URI is the base for reading the model.\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n+    }\n+    \n+    /** Load a model from a file (local or remote).\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param baseURI  Base URI for loading the RDF model.\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+    */\n+\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n+\n+        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n+    }\n+\n+    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( hasCachedModel(filenameOrURI) )\n+        {\n+            if ( log.isDebugEnabled() )\n+                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n+            return getFromCache(filenameOrURI) ;\n+        }\n+\n+        Model m = ModelFactory.createDefaultModel() ;\n+        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n+        \n+        if ( isCachingModels() )\n+            addCacheModel(filenameOrURI, m) ;\n+        return m ;\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n+     *  defaulting to RDF/XML.\n+     * @param model\n+     * @param filenameOrURI\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n+        return readModel(model, filenameOrURI, null);\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param rdfSyntax RDF Serialization syntax.\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n+    }\n+\n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param baseURI\n+     * @param syntax\n+     * @return The model\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n+    {\n+        \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n+    }\n+    \n+    protected Model readModelWorker(Model model, String filenameOrURI, String baseURI, String syntax)\n+    {\n+        // Doesn't call open() - we want to make the syntax guess based on the mapped URI.\n+        String mappedURI = mapURI(filenameOrURI) ;\n+\n+        if ( log.isDebugEnabled() && ! mappedURI.equals(filenameOrURI) )\n+            log.debug(\"Map: \"+filenameOrURI+\" => \"+mappedURI) ;\n+\n+        if ( syntax == null && baseURI == null && mappedURI.startsWith( \"http:\" ) )\n+        {\n+            syntax = FileUtils.guessLang(mappedURI) ;\n+            // Content negotation in next version (FileManager2) \n+            model.read(mappedURI, syntax) ;\n+            return model ;\n+        }\n+        \n+        if ( syntax == null )\n+        {\n+            syntax = FileUtils.guessLang(mappedURI) ;\n+            if ( syntax == null || syntax.equals(\"\") )\n+                syntax = FileUtils.langXML ;\n+            if ( log.isDebugEnabled() ) \n+                log.debug(\"Syntax guess: \"+syntax);\n+        }\n+\n+        if ( baseURI == null )\n+            baseURI = chooseBaseURI(filenameOrURI) ;\n+\n+        TypedStream in = openNoMapOrNull(mappedURI) ;\n+        if ( in == null )\n+        {\n+            FmtLog.debug(log, \"Failed to locate '%s'\", mappedURI);\n+            throw new NotFoundException(\"Not found: \"+filenameOrURI) ;\n+        }\n+        if ( in.getMimeType() != null )\n+        {\n+            //syntax\n+        }\n+        model.read(in.getInput(), baseURI, syntax) ;\n+        try { in.getInput().close(); } catch (IOException ex) {}\n+        return model ;\n+    }\n+\n+    private static String chooseBaseURI(String baseURI)\n+    {\n+        String scheme = FileUtils.getScheme(baseURI) ;\n+        \n+        if ( scheme != null )\n+        {\n+            if ( scheme.equals(\"file\") )\n+            {\n+                if ( ! baseURI.startsWith(\"file:///\") )\n+                {\n+                    try {\n+                        // Fix up file URIs.  Yuk.", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTk3NA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440601974", "bodyText": "This method looks a lot like another method I'd read on this PR. Could they be merged into one and re-used? Or are they doing something different? (Will have another look after submitting the review)", "author": "kinow", "createdAt": "2020-06-16T05:55:01Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/adapters/AdapterFileManager.java", "diffHunk": "@@ -331,4 +339,189 @@ public InputStream openNoMap(String filenameOrURI) {\n     public TypedStream openNoMapOrNull(String filenameOrURI) {\n         return AdapterLib.convert(streamManager.openNoMapOrNull(filenameOrURI)) ;\n     }\n+    \n+    // -------- Cache operations (end)\n+    \n+    // LEGACY \n+\n+    /** Load a model from a file (local or remote).\n+     *  This operation may attempt content negotiation for http URLs.\n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI)\n+    { \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n+        \n+        return loadModelWorker(filenameOrURI, null, null) ;\n+    }\n+\n+    /** Load a model from a file (local or remote).\n+     *  URI is the base for reading the model.\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n+    }\n+    \n+    /** Load a model from a file (local or remote).\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param baseURI  Base URI for loading the RDF model.\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+    */\n+\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n+\n+        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n+    }\n+\n+    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( hasCachedModel(filenameOrURI) )\n+        {\n+            if ( log.isDebugEnabled() )\n+                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n+            return getFromCache(filenameOrURI) ;\n+        }\n+\n+        Model m = ModelFactory.createDefaultModel() ;\n+        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n+        \n+        if ( isCachingModels() )\n+            addCacheModel(filenameOrURI, m) ;\n+        return m ;\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n+     *  defaulting to RDF/XML.\n+     * @param model\n+     * @param filenameOrURI\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n+        return readModel(model, filenameOrURI, null);\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param rdfSyntax RDF Serialization syntax.\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n+    }\n+\n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param baseURI\n+     * @param syntax\n+     * @return The model\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n+    {\n+        \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n+    }\n+    \n+    private static String chooseBaseURI(String baseURI)\n+    {\n+        String scheme = FileUtils.getScheme(baseURI) ;\n+        \n+        if ( scheme != null )\n+        {\n+            if ( scheme.equals(\"file\") )\n+            {\n+                if ( ! baseURI.startsWith(\"file:///\") )\n+                {\n+                    try {\n+                        // Fix up file URIs.  Yuk.", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNDIyNA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440604224", "bodyText": "It's FileManager#chooseBaseURI and AdapterFileManager#chooseBaseURI. They look identical. Should they be moved somewhere else so that both classes can re-use it?", "author": "kinow", "createdAt": "2020-06-16T06:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTk3NA=="}], "type": "inlineReview"}, {"oid": "dd3ee540c13087adca06cba5b170804e9de06e54", "url": "https://github.com/apache/jena/commit/dd3ee540c13087adca06cba5b170804e9de06e54", "message": "FileManager, N3 and testing clean-up", "committedDate": "2020-06-16T15:19:46Z", "type": "commit"}, {"oid": "b267b673a0da00ec123537abad9dcb984d8fba94", "url": "https://github.com/apache/jena/commit/b267b673a0da00ec123537abad9dcb984d8fba94", "message": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "committedDate": "2020-06-16T15:19:46Z", "type": "commit"}, {"oid": "97701ba5ad116bf146ef618310df4eba1488fd19", "url": "https://github.com/apache/jena/commit/97701ba5ad116bf146ef618310df4eba1488fd19", "message": "Fix permissions", "committedDate": "2020-06-16T15:19:47Z", "type": "commit"}, {"oid": "4b1d3c567d65b7344cd6b132a7f1beecbb503795", "url": "https://github.com/apache/jena/commit/4b1d3c567d65b7344cd6b132a7f1beecbb503795", "message": "JENA-1917: Deprecate readModel, loadModel; add internal versions", "committedDate": "2020-06-16T15:19:47Z", "type": "commit"}, {"oid": "4b1d3c567d65b7344cd6b132a7f1beecbb503795", "url": "https://github.com/apache/jena/commit/4b1d3c567d65b7344cd6b132a7f1beecbb503795", "message": "JENA-1917: Deprecate readModel, loadModel; add internal versions", "committedDate": "2020-06-16T15:19:47Z", "type": "forcePushed"}, {"oid": "26ffcde985ad3def09e03ac8d2aa1dccdefc1cc0", "url": "https://github.com/apache/jena/commit/26ffcde985ad3def09e03ac8d2aa1dccdefc1cc0", "message": "JENA-1917: Deprecate jena-core Locators and LocationMapper", "committedDate": "2020-06-17T16:02:28Z", "type": "commit"}]}