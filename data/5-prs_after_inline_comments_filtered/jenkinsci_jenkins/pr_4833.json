{"pr_number": 4833, "pr_title": "[JENKINS-62723] Fix behaviour of Util.isOverridden()", "pr_createdAt": "2020-07-07T20:11:45Z", "pr_url": "https://github.com/jenkinsci/jenkins/pull/4833", "timeline": [{"oid": "b98fe97940296024a3376f128a1b7b2eebb210fb", "url": "https://github.com/jenkinsci/jenkins/commit/b98fe97940296024a3376f128a1b7b2eebb210fb", "message": "[JENKINS-62723] Demonstrating that Util.isOverridden is broken on final overrides", "committedDate": "2020-07-07T14:15:51Z", "type": "commit"}, {"oid": "94eaecbe9352f3ee723d8ddb128085704c08a22c", "url": "https://github.com/jenkinsci/jenkins/commit/94eaecbe9352f3ee723d8ddb128085704c08a22c", "message": "Make ErrorCollector actually work", "committedDate": "2020-07-07T14:26:29Z", "type": "commit"}, {"oid": "ccc0e347240d2f10da77ac8a311be9a30d5434ed", "url": "https://github.com/jenkinsci/jenkins/commit/ccc0e347240d2f10da77ac8a311be9a30d5434ed", "message": "[JENKINS-62723] Improve Util.isOverridden\n\nIt will now deal with final/abstract methods appropriately.\nIt will also clearly report bad arguments (base not base of derived, or base does not declare the method).\nAdded a unit test for interface cases.\n\nSmall gap to be looked into: overrides provided via default implementation of a (derived) interface.", "committedDate": "2020-07-07T20:09:59Z", "type": "commit"}, {"oid": "9c088c27f205e8e96125c5d55cb05a49b22909d5", "url": "https://github.com/jenkinsci/jenkins/commit/9c088c27f205e8e96125c5d55cb05a49b22909d5", "message": "[JENKINS-62723] Further fix for Util.isOverridden\n\nThis handles the remaining case (override provided by default implementation of an interface).", "committedDate": "2020-07-07T20:23:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjA0NQ==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451166045", "bodyText": "maybe document with @throws", "author": "jglick", "createdAt": "2020-07-07T21:54:39Z", "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {\n+            throw new IllegalArgumentException(\"The specified method is not declared by the specified base class (\" + base.getCanonicalName() + \"), or it is private, static or final.\");", "originalCommit": "9c088c27f205e8e96125c5d55cb05a49b22909d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2ODM0Nw==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451168347", "bodyText": "Good point.", "author": "Zastai", "createdAt": "2020-07-07T22:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2Njc4Nw==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451166787", "bodyText": "The definition may come from a (non-default) interface method too. So this comment seems misleading?", "author": "jglick", "createdAt": "2020-07-07T21:56:24Z", "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {\n+            throw new IllegalArgumentException(\"The specified method is not declared by the specified base class (\" + base.getCanonicalName() + \"), or it is private, static or final.\");\n+        }\n+        final Method derivedMethod = Util.getMethod(derived, base, methodName, types);\n+        // the lookup will either return null or the base method when no override has been found (depending on whether\n+        // the base is an interface)\n+        return derivedMethod != null && derivedMethod != baseMethod;\n     }\n \n-    private static Method getMethod(@NonNull Class clazz, @NonNull String methodName, @NonNull Class... types) {\n-        Method res = null;\n+    private static Method getMethod(@NonNull Class<?> clazz, @Nullable Class<?> base, @NonNull String methodName, @NonNull Class<?>... types) {\n         try {\n-            res = clazz.getDeclaredMethod(methodName, types);\n-            // private, static or final methods can not be overridden\n-            if (res != null && (Modifier.isPrivate(res.getModifiers()) || Modifier.isFinal(res.getModifiers()) \n-                    || Modifier.isStatic(res.getModifiers()))) {\n-                res = null;\n+            final Method res = clazz.getDeclaredMethod(methodName, types);\n+            final int mod = res.getModifiers();\n+            // private and static methods are never ok, and end the search\n+            if (Modifier.isPrivate(mod) || Modifier.isStatic(mod)) {\n+                return null;\n             }\n+            // when looking for the base/declaring method, final is not ok\n+            if (base == null && Modifier.isFinal(mod)) {\n+                return null;\n+            }\n+            // when looking for the overriding method, abstract is not ok\n+            if (base != null && Modifier.isAbstract(mod)) {\n+                return null;\n+            }\n+            return res;\n         } catch (NoSuchMethodException e) {\n+            // If the base is an interface, the implementation may come from a default implementation on a derived\n+            // interface. So look at interfaces too.", "originalCommit": "9c088c27f205e8e96125c5d55cb05a49b22909d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2OTIyNA==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451169224", "bodyText": "This path is for looking for an override. A non-default interface method can't be an override (because it's abstract).", "author": "Zastai", "createdAt": "2020-07-07T22:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2Njc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTcwMA==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451171700", "bodyText": "OK, only fuzzily understand what is going on here, ignore.", "author": "jglick", "createdAt": "2020-07-07T22:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2Njc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjkzMA==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451166930", "bodyText": "ditto this variable naming", "author": "jglick", "createdAt": "2020-07-07T21:56:46Z", "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {\n+            throw new IllegalArgumentException(\"The specified method is not declared by the specified base class (\" + base.getCanonicalName() + \"), or it is private, static or final.\");\n+        }\n+        final Method derivedMethod = Util.getMethod(derived, base, methodName, types);\n+        // the lookup will either return null or the base method when no override has been found (depending on whether\n+        // the base is an interface)\n+        return derivedMethod != null && derivedMethod != baseMethod;\n     }\n \n-    private static Method getMethod(@NonNull Class clazz, @NonNull String methodName, @NonNull Class... types) {\n-        Method res = null;\n+    private static Method getMethod(@NonNull Class<?> clazz, @Nullable Class<?> base, @NonNull String methodName, @NonNull Class<?>... types) {\n         try {\n-            res = clazz.getDeclaredMethod(methodName, types);\n-            // private, static or final methods can not be overridden\n-            if (res != null && (Modifier.isPrivate(res.getModifiers()) || Modifier.isFinal(res.getModifiers()) \n-                    || Modifier.isStatic(res.getModifiers()))) {\n-                res = null;\n+            final Method res = clazz.getDeclaredMethod(methodName, types);\n+            final int mod = res.getModifiers();\n+            // private and static methods are never ok, and end the search\n+            if (Modifier.isPrivate(mod) || Modifier.isStatic(mod)) {\n+                return null;\n             }\n+            // when looking for the base/declaring method, final is not ok\n+            if (base == null && Modifier.isFinal(mod)) {\n+                return null;\n+            }\n+            // when looking for the overriding method, abstract is not ok\n+            if (base != null && Modifier.isAbstract(mod)) {\n+                return null;\n+            }\n+            return res;\n         } catch (NoSuchMethodException e) {\n+            // If the base is an interface, the implementation may come from a default implementation on a derived\n+            // interface. So look at interfaces too.\n+            if (base != null && Modifier.isInterface(base.getModifiers())) {\n+                for (Class<?> iface : clazz.getInterfaces()) {\n+                    if (base.equals(iface) || !base.isAssignableFrom(iface)) {\n+                        continue;\n+                    }\n+                    final Method defaultImpl = Util.getMethod(iface, base, methodName, types);", "originalCommit": "9c088c27f205e8e96125c5d55cb05a49b22909d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2OTI0OA==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451169248", "bodyText": "No, because an interface can only inherit from other interfaces, and getMethod won't return abstract methods, so here it either returns a default-implemented method or null.", "author": "Zastai", "createdAt": "2020-07-07T22:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTYyNw==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451171627", "bodyText": "Should we not also check that baseMethod.getDeclaringClass() == base?", "author": "jglick", "createdAt": "2020-07-07T22:08:03Z", "path": "core/src/main/java/hudson/Util.java", "diffHunk": "@@ -1432,36 +1432,76 @@ public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNul\n     }\n \n     /**\n-     * Checks if the method defined on the base type with the given arguments\n-     * is overridden in the given derived type.\n-     */\n-    public static boolean isOverridden(@NonNull Class base, @NonNull Class derived, @NonNull String methodName, @NonNull Class... types) {\n-        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\n+     * Checks whether the method defined on the base type with the given arguments is overridden in the given derived\n+     * type.\n+     *\n+     * @param base       The base type.\n+     * @param derived    The derived type.\n+     * @param methodName The name of the method.\n+     * @param types      The types of the arguments for the method.\n+     * @return {@code true} when {@code derived} provides the specified method other than as inherited from {@code base}.\n+     */\n+    public static boolean isOverridden(@NonNull Class<?> base, @NonNull Class<?> derived, @NonNull String methodName, @NonNull Class<?>... types) {\n+        // If derived is not a subclass or implementor of base, it can't override any method\n+        // Technically this should also be triggered when base == derived, because it can't override its own method, but\n+        // the unit tests explicitly test for that as working.\n+        if (!base.isAssignableFrom(derived)) {\n+            throw new IllegalArgumentException(\"The specified derived class (\" + derived.getCanonicalName() + \") does not derive from the specified base class (\" + base.getCanonicalName() + \").\");\n+        }\n+        final Method baseMethod = Util.getMethod(base, null, methodName, types);\n+        if (baseMethod == null) {", "originalCommit": "9c088c27f205e8e96125c5d55cb05a49b22909d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3NTg1NQ==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451175855", "bodyText": "The method sadly did not document as a reuirement, and is expected to work even when the class given does not itself define the method.\nAn org search seemed to turn up at least one case where the method is called to check whether a class overrides equals, hashCode and toString, where base is not passed as Object.class, and also does not itself override those methods (https://github.com/jenkinsci/git-plugin/blob/c99d18fcbd064bb9c4a4c2d8ec5ce28217042846/src/test/java/jenkins/plugins/git/traits/GitSCMExtensionTraitTest.java#L34). So adding the restriction would seem to cause a regression there.", "author": "Zastai", "createdAt": "2020-07-07T22:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3NzU5Mg==", "url": "https://github.com/jenkinsci/jenkins/pull/4833#discussion_r451177592", "bodyText": "Well, that is just test code that could be fixed at any time, but point taken that there could be production plugin code floating around somewhere (outside @jenkinsci) that improperly passes a subtype of the type defining the method for some reason.", "author": "jglick", "createdAt": "2020-07-07T22:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTYyNw=="}], "type": "inlineReview"}, {"oid": "7c2abcfa944cbe1285c9932dc797ee6c1db8eee9", "url": "https://github.com/jenkinsci/jenkins/commit/7c2abcfa944cbe1285c9932dc797ee6c1db8eee9", "message": "[JENKINS-62723] Extend JavaDoc with `@throws`", "committedDate": "2020-07-07T22:09:21Z", "type": "commit"}]}