{"pr_number": 1286, "pr_title": "#1178 update validator generate subcommand to create encrypted BLS keystore", "pr_createdAt": "2020-03-05T01:49:17Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1286", "timeline": [{"oid": "914317f82ac9931d284b42cea1753a617e0b950a", "url": "https://github.com/ConsenSys/teku/commit/914317f82ac9931d284b42cea1753a617e0b950a", "message": "#1178 Generate encrypted keystore from validate generate subcommand\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T01:02:09Z", "type": "commit"}, {"oid": "803201c2c4b68aa49efb85fb75cc842327e4e2a7", "url": "https://github.com/ConsenSys/teku/commit/803201c2c4b68aa49efb85fb75cc842327e4e2a7", "message": "cli param labels\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T01:16:44Z", "type": "commit"}, {"oid": "dbdfe0b62b203c0f3743d2e2d892180d1e97a015", "url": "https://github.com/ConsenSys/teku/commit/dbdfe0b62b203c0f3743d2e2d892180d1e97a015", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T01:45:54Z", "type": "commit"}, {"oid": "3c8c4c185f1126c2991df47457e204a7073abd85", "url": "https://github.com/ConsenSys/teku/commit/3c8c4c185f1126c2991df47457e204a7073abd85", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T05:16:36Z", "type": "commit"}, {"oid": "b7638623ccc0ef0ef0a428b7e4069a475a5994a2", "url": "https://github.com/ConsenSys/teku/commit/b7638623ccc0ef0ef0a428b7e4069a475a5994a2", "message": "Add unit test case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T07:59:14Z", "type": "commit"}, {"oid": "05541e5f9cc81589e76819dbe9b91a4392c3992f", "url": "https://github.com/ConsenSys/teku/commit/05541e5f9cc81589e76819dbe9b91a4392c3992f", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T08:00:10Z", "type": "commit"}, {"oid": "97487d6d035ddfef60029d3ebd7a92cc798fcb28", "url": "https://github.com/ConsenSys/teku/commit/97487d6d035ddfef60029d3ebd7a92cc798fcb28", "message": "update cli text\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T08:04:27Z", "type": "commit"}, {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "url": "https://github.com/ConsenSys/teku/commit/a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "message": "add line seperator in yaml line\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-05T08:07:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388601927", "bodyText": "has the web3j problem been solved?", "author": "macfarla", "createdAt": "2020-03-05T22:22:35Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODM3OQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638379", "bodyText": "I don't know about web3j. I moved the call in a method so that I can mock it in tests.", "author": "usmansaleem", "createdAt": "2020-03-06T00:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTEzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641139", "bodyText": "Web3j remains problematic unfortunately.", "author": "ajsutton", "createdAt": "2020-03-06T00:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzNzcwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388637705", "bodyText": "False doesn't seem like the right default here.  Writing unencrypted keys to disk is a really bad idea.", "author": "ajsutton", "createdAt": "2020-03-06T00:11:26Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NTIzMg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389555232", "bodyText": "--encrypt-keys defaults to true now.", "author": "usmansaleem", "createdAt": "2020-03-09T09:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzNzcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODE2MA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638160", "bodyText": "How does this relate to --output-file?  Seems kind of confusing to have two separate options to specify where to output things.  @jakehaugen any ideas on the right CLI options for this?", "author": "ajsutton", "createdAt": "2020-03-06T00:12:55Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NjQ5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389556497", "bodyText": "--keystore-output-dir is not used anymore. Instead I am now using --output-path to be treated either as directory or file depending upon we are using encrypted mode or unencrypted mode.", "author": "usmansaleem", "createdAt": "2020-03-09T09:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODg3NQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638875", "bodyText": "Rather than overriding this method in tests, it would be better to pass in a Consumer<Integer> shutdownFunction to the constructor (ie prefer delegation over inheritance).  You can pass a mock in tests and System::exit in production.\nYou will likely need two constructors for DepositCommand - a noarg one that passes System::exit and one that accepts the consumer that tests can use.", "author": "ajsutton", "createdAt": "2020-03-06T00:15:24Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3Njk4NA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388676984", "bodyText": "Implemented functional consumer interface.", "author": "usmansaleem", "createdAt": "2020-03-06T02:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388639875", "bodyText": "Two issues here:\n\nIt's vital that we write the keys to output before sending the deposit transaction.  Otherwise if we fail somewhere we've just burned a lot of ETH and lost the keys forever.\nSince the logic for writing keys has become more complex we should create a KeyWriter interface with 2 separate implementations - one that writes YAML to a PrintStream (used for all unencrypted output) and one that writes to a keystore for encrypted output.", "author": "ajsutton", "createdAt": "2020-03-06T00:18:35Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2ODY4NA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388668684", "bodyText": "Yes I hear you, thats why I wrote file in finally block that should have written keys up to sendTransaction fails. Using KeyWrite interface is better idea though.", "author": "usmansaleem", "createdAt": "2020-03-06T01:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTYyMA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388669620", "bodyText": "A finally block does not guarantee it happens first.  If the process or computer crashed the key would never be written and the funds would be lost.", "author": "ajsutton", "createdAt": "2020-03-06T01:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NzA4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389557082", "bodyText": "We now have KeyWriter which is implemented by YamlKeysWriter and EncryptedKeyStoreWriter.", "author": "usmansaleem", "createdAt": "2020-03-09T09:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NzQxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389557415", "bodyText": "The approach to write keys has been changed so that they get persisted first before sendTransaction is called.", "author": "usmansaleem", "createdAt": "2020-03-09T09:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388640998", "bodyText": "We should have a way to specify the password to use for keystrokes.  No point writing an encrypted keystore if you write an unencrypted password for it as well.  It's probably enough to be able to specify a password for all signing keys and a (potentially different) password for all withdrawal keys.", "author": "ajsutton", "createdAt": "2020-03-06T00:22:11Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTI4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388669282", "bodyText": "that make sense. Let me figure out whether to read the password from stdin or from files or from cli option.", "author": "usmansaleem", "createdAt": "2020-03-06T01:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MDc2Mw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388670763", "bodyText": "The password should not be included on the command line.  Using ps auxwww any user on the same box can see command line arguments for any running program.  It also tends to get written to places like .bash_history", "author": "ajsutton", "createdAt": "2020-03-06T01:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MTIxMA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388671210", "bodyText": "password input file it is ... unless we are open for \"interactive shell\" approach to read the input from user.", "author": "usmansaleem", "createdAt": "2020-03-06T01:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MTQ4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388671483", "bodyText": "I think an interactive mode would be an excellent option to support.  Need to check with POs as to priority and probably get Jake to think about the details.", "author": "ajsutton", "createdAt": "2020-03-06T01:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MTU5MQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388671591", "bodyText": "\ud83d\udc4d", "author": "usmansaleem", "createdAt": "2020-03-06T01:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1ODUzNA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389558534", "bodyText": "The interactive mode is now supported, along with reading values from environment variable as well as from a file.\n--validator-password\n--validator-password:env\n--validator-password:file", "author": "usmansaleem", "createdAt": "2020-03-09T09:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTM2MA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641360", "bodyText": "It would be much better to use:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return new BigInteger(1, token).toString(16); // hex encoding\n          \n          \n            \n                return Bytes.wrap(token).toHexString()", "author": "ajsutton", "createdAt": "2020-03-06T00:23:25Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];\n+    secureRandom.nextBytes(token);\n+    return new BigInteger(1, token).toString(16); // hex encoding", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1ODkxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389558915", "bodyText": "This method has been removed.", "author": "usmansaleem", "createdAt": "2020-03-09T09:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTk4MA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641980", "bodyText": "Using a spy for the class under test is really unpleasant.\nWe also normally use the Mockito static methods instead of the @Mock annotations. Not for any particular reason, but it's pretty consistent so seems worth sticking with it.", "author": "ajsutton", "createdAt": "2020-03-06T00:25:22Z", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzEyNg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677126", "bodyText": "The unit test code has been updated as per the suggestions.", "author": "usmansaleem", "createdAt": "2020-03-06T02:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzIxOQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643219", "bodyText": "This should be able to use the when format:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n          \n          \n            \n                when(commonParams.createTransactionSender()).thenReturn(depositTransactionSender);\n          \n      \n    \n    \n  \n\nThat way we get type checking done by the compiler.", "author": "ajsutton", "createdAt": "2020-03-06T00:28:39Z", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzE4MA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677180", "bodyText": "\ud83d\udc4d", "author": "usmansaleem", "createdAt": "2020-03-06T02:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzM3Ng==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643376", "bodyText": "The mock transaction sender should just return completed futures and you won't need to override this.", "author": "ajsutton", "createdAt": "2020-03-06T00:29:01Z", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzI3NQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677275", "bodyText": "Thanks for the hint, I was having some trouble with it :). It's sorted out now.", "author": "usmansaleem", "createdAt": "2020-03-06T02:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzU5OA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643598", "bodyText": "Is it worth checking we can actually decrypt the keystore?", "author": "ajsutton", "createdAt": "2020-03-06T00:29:33Z", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTEzMg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559132", "bodyText": "The tests are now decrypting the keystore.", "author": "usmansaleem", "createdAt": "2020-03-09T09:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzIyMw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388627223", "bodyText": "nit: final", "author": "jframe", "createdAt": "2020-03-05T23:35:26Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTMzOA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559338", "bodyText": "This method has been removed.", "author": "usmansaleem", "createdAt": "2020-03-09T09:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzk2OQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388627969", "bodyText": "Think we should use SecureRandom for the random seed", "author": "jframe", "createdAt": "2020-03-05T23:37:52Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzY0OQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677649", "bodyText": "tuweni Bytes random by default use new SecureRandom, but we should/can pass our own SecureRandom instance as well.", "author": "usmansaleem", "createdAt": "2020-03-06T02:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTQ2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559466", "bodyText": "done.", "author": "usmansaleem", "createdAt": "2020-03-09T09:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyOTMxNg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388629316", "bodyText": "Thinking we should log an error at this point so we know which keystore failed to be created", "author": "jframe", "createdAt": "2020-03-05T23:42:42Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTk2Mw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559963", "bodyText": "The methods has been extracted to a new class and they will be logging appropriate logging statements before erroring out.", "author": "usmansaleem", "createdAt": "2020-03-09T09:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyOTMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDYyNg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388630626", "bodyText": "nit: instead the generic Pair a small custom class would help with readability so that you do something like validatorKeyPair.getValidatorKey() instead of getLeft for example", "author": "jframe", "createdAt": "2020-03-05T23:47:25Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU2MDI4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389560283", "bodyText": "Its not used anymore.", "author": "usmansaleem", "createdAt": "2020-03-09T10:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDk5MA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388630990", "bodyText": "nit: transactionReceiptFutures?", "author": "jframe", "createdAt": "2020-03-05T23:48:41Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjM1OQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388632359", "bodyText": "rename to validatorKeyStoreFile and similarly rename password1File to validatoryPasswordFile", "author": "jframe", "createdAt": "2020-03-05T23:53:08Z", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU2MDYyNQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389560625", "bodyText": "This unit test has been refactored.", "author": "usmansaleem", "createdAt": "2020-03-09T10:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjc2Nw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388632767", "bodyText": "rename withdrawalKeyStoreFile and similarly rename password2File to withdrawalPasswordFile", "author": "jframe", "createdAt": "2020-03-05T23:54:26Z", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");\n+    final Path password1File = parentDir.resolve(\"validator_password_\" + suffix + \".txt\");\n+    final Path keystore2File = parentDir.resolve(\"withdrawal_keystore_\" + suffix + \".json\");", "originalCommit": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU2MDc5MQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389560791", "bodyText": "This unit test has been refactored.", "author": "usmansaleem", "createdAt": "2020-03-09T10:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjc2Nw=="}], "type": "inlineReview"}, {"oid": "2e38f2b14a848e05b6266f04425804f53ee21f97", "url": "https://github.com/ConsenSys/teku/commit/2e38f2b14a848e05b6266f04425804f53ee21f97", "message": "review suggestion - use functional interface to invoke System.exit\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-06T01:45:22Z", "type": "commit"}, {"oid": "866e7910bd9924cc6451eab560743189db78d4dd", "url": "https://github.com/ConsenSys/teku/commit/866e7910bd9924cc6451eab560743189db78d4dd", "message": "review suggestion - use static mock function\n\n -- removed mockito junit5 extensions\n -- updated mock senddeposittransaction to return completed future\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-06T02:02:22Z", "type": "commit"}, {"oid": "b13acdfaaef8203ea2b8b74efa7584307e06d59e", "url": "https://github.com/ConsenSys/teku/commit/b13acdfaaef8203ea2b8b74efa7584307e06d59e", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-06T05:09:20Z", "type": "commit"}, {"oid": "1811f480ea049f9598bdc61a90e9cb2c94bd1524", "url": "https://github.com/ConsenSys/teku/commit/1811f480ea049f9598bdc61a90e9cb2c94bd1524", "message": "wip\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-06T07:14:46Z", "type": "commit"}, {"oid": "d6a4c3cb48159960e64bafad9ea5796763e15eb7", "url": "https://github.com/ConsenSys/teku/commit/d6a4c3cb48159960e64bafad9ea5796763e15eb7", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-06T08:11:11Z", "type": "commit"}, {"oid": "4e6a6fabc93d95278774a6b174c9b05ab8eb286c", "url": "https://github.com/ConsenSys/teku/commit/4e6a6fabc93d95278774a6b174c9b05ab8eb286c", "message": "Use new KeysWriter in DepositCommand.\nTODO: Update unit test case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-06T09:19:29Z", "type": "commit"}, {"oid": "5a3f29a46c4e0e81450d3b3bab08662dd3d63aae", "url": "https://github.com/ConsenSys/teku/commit/5a3f29a46c4e0e81450d3b3bab08662dd3d63aae", "message": "Merge upstream branch\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-08T23:28:41Z", "type": "commit"}, {"oid": "67343355fa41c7628f2f3660ba5f044ad9566fc7", "url": "https://github.com/ConsenSys/teku/commit/67343355fa41c7628f2f3660ba5f044ad9566fc7", "message": "Interactive mode to read password. Also use arggroup\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T04:09:34Z", "type": "commit"}, {"oid": "6cd5ab26e48c1290d7bc2a61e16ff7ab34c3516f", "url": "https://github.com/ConsenSys/teku/commit/6cd5ab26e48c1290d7bc2a61e16ff7ab34c3516f", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T04:13:02Z", "type": "commit"}, {"oid": "4010e602c4a52d5abeadbd5a4a3ada7600c0147e", "url": "https://github.com/ConsenSys/teku/commit/4010e602c4a52d5abeadbd5a4a3ada7600c0147e", "message": "arg group not working, removed it temporarily\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T05:43:37Z", "type": "commit"}, {"oid": "998eae48ba1f9a665795e4156db17d84e7d9fab8", "url": "https://github.com/ConsenSys/teku/commit/998eae48ba1f9a665795e4156db17d84e7d9fab8", "message": "cleaning up interactive mode\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T07:27:30Z", "type": "commit"}, {"oid": "1be3527676a0a252dc727820860df98f060350db", "url": "https://github.com/ConsenSys/teku/commit/1be3527676a0a252dc727820860df98f060350db", "message": "fixing unit test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T09:37:45Z", "type": "commit"}, {"oid": "5efc5a5ca901eabd21f2213f295d3666709e08c5", "url": "https://github.com/ConsenSys/teku/commit/5efc5a5ca901eabd21f2213f295d3666709e08c5", "message": "merge upstream\n\nSigned-off-by: Usman Saleem <usman@usmans.info>\n\n# Conflicts:\n#\tartemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "committedDate": "2020-03-09T09:39:49Z", "type": "commit"}, {"oid": "1d63fa6a192ae950d1789f00947deb8e2f895e9f", "url": "https://github.com/ConsenSys/teku/commit/1d63fa6a192ae950d1789f00947deb8e2f895e9f", "message": "merge conflicts status_log\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T09:47:47Z", "type": "commit"}, {"oid": "2987c4dfa2f934d4957292d2fd4bbe70abb453d4", "url": "https://github.com/ConsenSys/teku/commit/2987c4dfa2f934d4957292d2fd4bbe70abb453d4", "message": "fixing depositsender acceptance test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T10:11:35Z", "type": "commit"}, {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "url": "https://github.com/ConsenSys/teku/commit/eb4e4fced1d629777d6f8440fd26e8a158d4253d", "message": "fixing depositsender acceptance test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-09T13:09:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389994985", "bodyText": "This isn't the right approach.  If we're outputting to STDOUT, we need to make sure logging is either disabled or sent to STDERR.  Otherwise people who run this tool in real life will get corrupt output.", "author": "ajsutton", "createdAt": "2020-03-09T22:24:58Z", "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisDepositSender.java", "diffHunk": "@@ -44,6 +47,11 @@ public String sendValidatorDeposits(final BesuNode eth1Node, final int numberOfV\n     container.start();\n     Waiter.waitFor(() -> assertThat(container.isRunning()).isFalse());\n     container.stop();\n-    return validatorKeys.toString();\n+    // because we have introduced some logging, only pick lines which start with a - {\n+    return validatorKeys\n+        .toString()\n+        .lines()\n+        .filter(s -> s.startsWith(\"- {\"))\n+        .collect(Collectors.joining(System.lineSeparator()));", "originalCommit": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMjcxNw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390022717", "bodyText": "It's because of the limitation of \"testcontainer\" docker API we are using that captures whole of standard/error output. A more better approach, which I tested, is to mount the \"keys\" file with --output-path and read that file after running the command. However, in Windows environment this usually cause an issue because we would have \"share\" the host location via docker preference. In another project of ours, we used user's home folder and create a temp directory there which can be mounted to docker container, I wonder if we can use same approach.\nLast, but not least, is that I can remove the \"info\" logging that I introduced so that it only outputs the yaml keys on std out.", "author": "usmansaleem", "createdAt": "2020-03-09T23:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzQ0OA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390023448", "bodyText": "It's not really docker related - if we're saying we'll output the content to STDOUT, we should only output the content to STDOUT but the logs are going there as well (they don't go to STDERR by default).  We can configure test containers to capture STDOUT and STDERR separately if need be.\nI suspect just removing the log messages is probably the simplest approach though.", "author": "ajsutton", "createdAt": "2020-03-09T23:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MTMzMg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390041332", "bodyText": "Removed additional logging for \"yaml keys on standard out\" mode.", "author": "usmansaleem", "createdAt": "2020-03-10T01:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389996656", "bodyText": "colon in the arg name is weird. I'd have expected --validator-password-file. Might be possible to do it with a single --validator-password option - if no arg use interactive prompt, if it starts with env: treat as an environment variable and otherwise treat as a file path.  Not entirely sure that's a good idea though...\n@jakehaugen any thoughts?", "author": "ajsutton", "createdAt": "2020-03-09T22:29:38Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "originalCommit": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzE3NA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390023174", "bodyText": "I picked the :file :env approach from PicoCLI's sample code. We can modify them as per our needs. https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/interactive/PasswordDemo.java", "author": "usmansaleem", "createdAt": "2020-03-09T23:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzcwOA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390023708", "bodyText": "Yeah I have no idea why they thought that was normal...", "author": "ajsutton", "createdAt": "2020-03-09T23:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNDM2NA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390024364", "bodyText": "You are suggesting to use --stdin:validator-password, --env:validator-password, --file:validator-password as an alternative? Or simply use three mutually exclusive parameters? i.e. --validator-password-stdin, --validator-password-file, --validator-pasword-env?", "author": "usmansaleem", "createdAt": "2020-03-09T23:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNDY4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390024681", "bodyText": "OR.... --validator-password=env:VAL_PASS approach?", "author": "usmansaleem", "createdAt": "2020-03-09T23:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNTQ5Mg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390025492", "bodyText": "Two possible approaches:\n\n\nSeparate options.  So you'd have --validator-password-file and --validator-password-env if neither of those is specified, use the interactive prompt.\n\n\nA single option that works out how to interpret the arg (feeling like this is going to be confusing, so leaning towards option 1).  So not specifying the option or --validator-password with no arg uses an interactive prompt.  --validator-password env:SOME_VAR would read from an environment var (the env: prefix is what tells us it's an env var) and --validator-password <any-arg> reads from a file (assuming  doesn't start with env:).", "author": "ajsutton", "createdAt": "2020-03-10T00:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNTY0NA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390025644", "bodyText": "But you should really talk to Jake. That's why we have a UX person. :)", "author": "ajsutton", "createdAt": "2020-03-10T00:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTY0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389999646", "bodyText": "It seems weird to have to specify --validator-password to get the prompt to provide the password. Makes me naturally want to specify the password on the command line which is insecure and doesn't actually work.", "author": "ajsutton", "createdAt": "2020-03-09T22:37:35Z", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},\n+              paramLabel = \"<FILE>\",\n+              description = \"Read password from the file to encrypt the validator keys\")\n+          File validatorPasswordFile,\n+      @Option(\n+              names = {\"--validator-password:env\"},\n+              paramLabel = \"<ENV_VAR>\",\n+              description = \"Read password from environment variable to encrypt the validator keys\")\n+          String validatorPasswordEnv,\n+      @Option(\n+              names = {\"--validator-password\"},", "originalCommit": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTc5NQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389999795", "bodyText": "Probably should check that only one of the three options for specifying the password have been provided.  Otherwise it will be very confusing which password actually gets used.", "author": "ajsutton", "createdAt": "2020-03-09T22:38:01Z", "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {", "originalCommit": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390000403", "bodyText": "It's really annoying to get the missing options error message in small chunks.  ie I tried:\n$ ./build/install/teku/bin/teku validator generate\nMissing required options [--node-url=<URL>, --contract-address=<ADDRESS>, --private-key=<KEY>]\n\n$ ./build/install/teku/bin/teku validator generate --node-url=http://localhost:8545 --contract-address=dddddddd --private-key=222222222\nMissing options: [--validator-password | --validator-password:env | --validator-password:file]\n\n$ ./build/install/teku/bin/teku validator generate --node-url=http://localhost:8545 --contract-address=dddddddd --private-key=222222222 --validator-password\nEnter value for --validator-password (Password to encrypt validator keys):\nMissing options: [--withdrawal-password | --withdrawal-password:env | --withdrawal-password:file]\n\nSo it took me four goes to actually be told all of what I had to provide.", "author": "ajsutton", "createdAt": "2020-03-09T22:39:51Z", "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {\n+    if (!isBlank(password)) {\n+      return password;\n+    }\n+\n+    if (environmentVariable != null) {\n+      final String password = System.getenv(environmentVariable);\n+      if (isBlank(password)) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Error in reading password from environment variable: \" + environmentVariable);\n+      }\n+      return password;\n+    }\n+\n+    if (passwordFile != null) {\n+      try {\n+        final String password =\n+            Files.asCharSource(passwordFile, StandardCharsets.UTF_8).readFirstLine();\n+        if (isBlank(password)) {\n+          throw new ParameterException(\n+              spec.commandLine(), \"Empty password read from password file: \" + passwordFile);\n+        }\n+        return password;\n+      } catch (final FileNotFoundException e) {\n+        throw new ParameterException(\n+            spec.commandLine(), \"Password file not found: \" + passwordFile);\n+      } catch (IOException e) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Unexpected IO error while reading password from file [\"\n+                + passwordFile\n+                + \"] : \"\n+                + e.getMessage());\n+      }\n+    }\n+\n+    final String errorMessage =\n+        String.format(\n+            \"Missing options: [--%1$s-password | --%1$s-password:env | --%1$s-password:file]\",\n+            errorPrefix);\n+    throw new ParameterException(spec.commandLine(), errorMessage);", "originalCommit": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3Mjg4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390272886", "bodyText": "I have introduced mutually exclusive ArgGroup so that picocli handles these errors automagically. I do have to extract out subcommands by converting methods to standalone classes to make ArgGroup work (I believe PicoCli has a bug where ArgGroup doesn't work if methods are used as subcommands). I have also changed the --encrypt-keys to --encrypted-keystore-enabled and we now run in interactive mode to obtain passwords if none of the non-interactive password options are specified. The ArgGroup also allows to provide sub-section heading. e.g.\n./teku validator generate --help\n\nteku validator generate [OPTIONS]\n\nDescription:\n\nRegister validators by generating new keys and sending deposit transactions to\nan Ethereum 1 node\n\nOptions:\n  -a, --amount=<GWEI>       Deposit amount in Gwei (default: 32000000000)\n  -c, --contract-address=<ADDRESS>\n                            Address of the deposit contract\n  -e, --encrypted-keystore-enabled=<true|false>\n                            Create encrypted keystores for validator and\n                              withdrawal keys. (Default: true)\n  -h, --help                Show this help message and exit.\n  -n, --number-of-validators=<NUMBER>\n                            The number of validators to create keys for and\n                              register\n  -o, --output-path=<FILE|DIR>\n                            Path to output file for unencrypted keys or output\n                              directory for encrypted keystore files. If not\n                              set, unencrypted keys will be written on standard\n                              out and encrypted keystores will be created in\n                              current directory\n  -p, --private-key=<KEY>   Ethereum 1 private key to use to send transactions\n  -u, --node-url=<URL>      JSON-RPC endpoint URL for the Ethereum 1 node to\n                              send transactions via\n  -V, --version             Print version information and exit.\nNon-interactive password options for validator keystores:\n      --validator-password-env=<ENV_VAR>\n                            Read password from environment variable to encrypt\n                              the validator keys\n      --validator-password-file=<FILE>\n                            Read password from the file to encrypt the\n                              validator keys\nNon-interactive password options for withdrawal keystores:\n      --withdrawal-password-env=<ENV_VAR>\n                            Read password from environment variable to encrypt\n                              the withdrawal keys\n      --withdrawal-password-file=<FILE>\n                            Read password from the file to encrypt the\n                              withdrawal keys\n\nTeku is licensed under the Apache License 2.0\n\n(@jakehaugen and @arash009  FYI)", "author": "usmansaleem", "createdAt": "2020-03-10T12:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3Mzk3OA==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390273978", "bodyText": "Running generate command with required parameters only:\n./teku validator generate --contract-address=dddddddddddddddddddddddddddddddddddddddd \\\n--number-of-validators=1 \\\n--private-key=8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63 \\\n--node-url=http://localhost:8545\nEnter password for Validator Keystore:\nRe-Enter password for Validator Keystore:\nEnter password for Withdrawal Keystore:\nRe-Enter password for Withdrawal Keystore:\n22:18:24.268 [INFO ] - Generating Encrypted Keystores in .", "author": "usmansaleem", "createdAt": "2020-03-10T12:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5ODU3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390598572", "bodyText": "To confirm, do you have to use the same method to supply the validator password and withdrawal password? e..g. can I supply validator password via env variable, and use interactive method for withdrawal password? (I dont think there really is a use case for that, but just checking what works)", "author": "arash009", "createdAt": "2020-03-10T20:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0OTAzNQ==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r391349035", "bodyText": "@arash009  yes, both validator keystore and withdrawal keystore options are independent of each other, so validator keystore's password can come from environment variable for instance, while withdrawal's password can be read from file. However, due to mutually exclusive mode, you can either specify --validator-password-env or --validator-password-file but not both.", "author": "usmansaleem", "createdAt": "2020-03-12T00:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTM3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390001377", "bodyText": "If I run the command twice, does this wind up overwriting the existing keys (losing my funds)?  Would it be better to use the public key as part of the directory name rather than the index - then it's guaranteed to be unique.", "author": "ajsutton", "createdAt": "2020-03-09T22:42:47Z", "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystoreWriter.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static tech.pegasys.artemis.util.crypto.SecureRandomProvider.createSecureRandom;\n+import static tech.pegasys.teku.logging.StatusLogger.STATUS_LOG;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.logging.log4j.Level;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.KeyStore;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreLoader;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreValidationException;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+import tech.pegasys.artemis.util.bls.BLSKeyPair;\n+\n+public class EncryptedKeystoreWriter implements KeysWriter {\n+  private final String validatorKeyPassword;\n+  private final String withdrawalKeyPassword;\n+  private final Path outputPath;\n+  private final AtomicInteger counter = new AtomicInteger(0);\n+\n+  public EncryptedKeystoreWriter(\n+      final String validatorKeyPassword,\n+      final String withdrawalKeyPassword,\n+      final Path outputPath) {\n+    this.validatorKeyPassword = validatorKeyPassword;\n+    this.withdrawalKeyPassword = withdrawalKeyPassword;\n+    this.outputPath = outputPath;\n+  }\n+\n+  @Override\n+  public void writeKeys(final BLSKeyPair validatorKey, final BLSKeyPair withdrawalKey)\n+      throws UncheckedIOException, KeyStoreValidationException {\n+    final Path keystoreDirectory = createKeystoreDirectory();\n+\n+    final KeyStoreData validatorKeyStoreData =\n+        generateKeystoreData(validatorKey, validatorKeyPassword);\n+    final KeyStoreData withdrawalKeyStoreData =\n+        generateKeystoreData(withdrawalKey, withdrawalKeyPassword);\n+\n+    saveKeyStore(keystoreDirectory.resolve(\"validator_keystore.json\"), validatorKeyStoreData);\n+    saveKeyStore(keystoreDirectory.resolve(\"withdrawal_keystore.json\"), withdrawalKeyStoreData);\n+  }\n+\n+  private Path createKeystoreDirectory() {\n+    final Path keystoreDirectory = outputPath.resolve(\"validator_\" + counter.incrementAndGet());", "originalCommit": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMjY5Mw==", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390032693", "bodyText": "Yes, thats a good catch. I'll modify logic to use public key as folder name.", "author": "usmansaleem", "createdAt": "2020-03-10T00:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTM3Nw=="}], "type": "inlineReview"}, {"oid": "27ac813be91da89eaed75fdb98ec147d88b31723", "url": "https://github.com/ConsenSys/teku/commit/27ac813be91da89eaed75fdb98ec147d88b31723", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T00:29:18Z", "type": "commit"}, {"oid": "740c37c3546245cba6d9484a0586a23371433b4e", "url": "https://github.com/ConsenSys/teku/commit/740c37c3546245cba6d9484a0586a23371433b4e", "message": "fixing expected output in yamlkeyswritertest due to tuweni output in lower case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T00:53:09Z", "type": "commit"}, {"oid": "f4c60c78df5d79eebe5a9f7f1658dc7ec755dfe3", "url": "https://github.com/ConsenSys/teku/commit/f4c60c78df5d79eebe5a9f7f1658dc7ec755dfe3", "message": "DepositCommand - reverting stdout logs\n\n -- reverted stdout logs when yaml keys are required to be printed on standard out\n -- fixed acceptance test case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T01:01:04Z", "type": "commit"}, {"oid": "4569ecb20aa21cc68529b35c55aade82ce107fb7", "url": "https://github.com/ConsenSys/teku/commit/4569ecb20aa21cc68529b35c55aade82ce107fb7", "message": "Review suggestions - use validator bls public key as directory name\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T02:02:37Z", "type": "commit"}, {"oid": "481eee36e02b5db6638441820ffb8d93f55b36bc", "url": "https://github.com/ConsenSys/teku/commit/481eee36e02b5db6638441820ffb8d93f55b36bc", "message": "Converting subcommands methods to static classes to allow ArgGroups\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T08:26:42Z", "type": "commit"}, {"oid": "914c0504b4575a7dca42ba7e986410f209474d1b", "url": "https://github.com/ConsenSys/teku/commit/914c0504b4575a7dca42ba7e986410f209474d1b", "message": "Updating deposit subcommands and unit test cases\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T12:02:31Z", "type": "commit"}, {"oid": "d2645ad94f6fdfa01ad060756ca02e320301a664", "url": "https://github.com/ConsenSys/teku/commit/d2645ad94f6fdfa01ad060756ca02e320301a664", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T12:03:04Z", "type": "commit"}, {"oid": "a3805453241a698d4ab3b505c96852bd7971fb68", "url": "https://github.com/ConsenSys/teku/commit/a3805453241a698d4ab3b505c96852bd7971fb68", "message": "typo in exception msg\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-10T12:16:19Z", "type": "commit"}, {"oid": "8d5d673cbcce5a6e1dc9522be1b3848546052b0a", "url": "https://github.com/ConsenSys/teku/commit/8d5d673cbcce5a6e1dc9522be1b3848546052b0a", "message": "Merging upstream master\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-12T00:44:15Z", "type": "commit"}, {"oid": "14ff85250c05d02fc4be349dc5ca949618287f17", "url": "https://github.com/ConsenSys/teku/commit/14ff85250c05d02fc4be349dc5ca949618287f17", "message": "Review suggestion - update non-interactive option name to include keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>", "committedDate": "2020-03-12T02:03:55Z", "type": "commit"}]}