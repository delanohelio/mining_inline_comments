{"pr_number": 1144, "pr_title": "Add disk querying to beacon/block rest API", "pr_createdAt": "2020-02-09T23:31:07Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1144", "timeline": [{"oid": "642030da2831cbf217355b7f9a5a25cc3357b82a", "url": "https://github.com/ConsenSys/teku/commit/642030da2831cbf217355b7f9a5a25cc3357b82a", "message": "Add disk querying to beacon/block rest API", "committedDate": "2020-02-09T23:29:15Z", "type": "commit"}, {"oid": "28214045ae9d3c7240c10c0def7793adaf3b8b7d", "url": "https://github.com/ConsenSys/teku/commit/28214045ae9d3c7240c10c0def7793adaf3b8b7d", "message": "Merge branch 'master' into diskQueryingForRestAPI", "committedDate": "2020-02-09T23:31:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyOTExMg==", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376829112", "bodyText": "We should be passing in the HistoricalChainData client, not creating it in the constructor here.  Possibly should even be passing HistoricalChainData into BeaconRestApi rather than event bus.", "author": "ajsutton", "createdAt": "2020-02-10T00:00:32Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -15,60 +15,79 @@\n \n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n+import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n \n public class BeaconBlockHandler implements BeaconRestApiHandler {\n \n   private final ChainStorageClient client;\n+  private final HistoricalChainData historicalChainData;\n \n-  public BeaconBlockHandler(ChainStorageClient client) {\n+  public BeaconBlockHandler(ChainStorageClient client, EventBus eventBus) {\n     this.client = client;\n+    this.historicalChainData = new HistoricalChainData(eventBus);", "originalCommit": "28214045ae9d3c7240c10c0def7793adaf3b8b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MDUzMA==", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376840530", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-10T01:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyOTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyOTk2MA==", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376829960", "bodyText": "return getBlockBySlot(slot)\n  .map(block -> ImmutableMap.of(\"block\", block, \"blockRoot\", block.hash_tree_root()))\n  .orElse(null);", "author": "ajsutton", "createdAt": "2020-02-10T00:10:20Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -15,60 +15,79 @@\n \n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n+import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n \n public class BeaconBlockHandler implements BeaconRestApiHandler {\n \n   private final ChainStorageClient client;\n+  private final HistoricalChainData historicalChainData;\n \n-  public BeaconBlockHandler(ChainStorageClient client) {\n+  public BeaconBlockHandler(ChainStorageClient client, EventBus eventBus) {\n     this.client = client;\n+    this.historicalChainData = new HistoricalChainData(eventBus);\n   }\n \n   @Override\n   public String getPath() {\n-    return \"/beacon/block/\";\n+    return \"/beacon/block\";\n   }\n \n   @Override\n   public Object handleRequest(RequestParams param) {\n     Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    Map<String, Object> jsonObject = new HashMap<>();\n-    BeaconBlock block;\n-    Bytes32 blockRoot;\n     if (queryParamMap.containsKey(\"root\")) {\n       Bytes32 root = Bytes32.fromHexString(param.getQueryParam(\"root\"));\n       return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    } else if (queryParamMap.containsKey(\"epoch\")) {\n-      UnsignedLong epoch = UnsignedLong.valueOf(param.getQueryParam(\"epoch\"));\n-      Optional<Bytes32> blockRootAtSlot =\n-          client.getBlockRootBySlot(compute_start_slot_at_epoch(epoch));\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+    }\n+\n+    UnsignedLong slot;\n+    if (queryParamMap.containsKey(\"epoch\")) {\n+      slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(param.getQueryParam(\"epoch\")));\n     } else if (queryParamMap.containsKey(\"slot\")) {\n-      UnsignedLong slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n-      Optional<Bytes32> blockRootAtSlot = client.getBlockRootBySlot(slot);\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+      slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n     } else {\n       return null;\n     }\n-    jsonObject.put(\"block\", block);\n-    jsonObject.put(\"blockRoot\", blockRoot.toHexString());\n+\n+    Optional<Pair<BeaconBlock, Bytes32>> blockAndRoot = getBlockBySlot(slot);\n+    if (blockAndRoot.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<String, Object> jsonObject = new HashMap<>();\n+    jsonObject.put(\"blockRoot\", blockAndRoot.get().getRight().toHexString());\n+    jsonObject.put(\"block\", blockAndRoot.get().getLeft());\n+\n     return jsonObject;", "originalCommit": "28214045ae9d3c7240c10c0def7793adaf3b8b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MTk3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376841973", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-10T01:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyOTk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzMDA0OA==", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376830048", "bodyText": "This can just return Optional<BeaconBlock> since the root is just calculated by calling block.hash_tree_root() anyway.", "author": "ajsutton", "createdAt": "2020-02-10T00:11:00Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -15,60 +15,79 @@\n \n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n+import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n \n public class BeaconBlockHandler implements BeaconRestApiHandler {\n \n   private final ChainStorageClient client;\n+  private final HistoricalChainData historicalChainData;\n \n-  public BeaconBlockHandler(ChainStorageClient client) {\n+  public BeaconBlockHandler(ChainStorageClient client, EventBus eventBus) {\n     this.client = client;\n+    this.historicalChainData = new HistoricalChainData(eventBus);\n   }\n \n   @Override\n   public String getPath() {\n-    return \"/beacon/block/\";\n+    return \"/beacon/block\";\n   }\n \n   @Override\n   public Object handleRequest(RequestParams param) {\n     Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    Map<String, Object> jsonObject = new HashMap<>();\n-    BeaconBlock block;\n-    Bytes32 blockRoot;\n     if (queryParamMap.containsKey(\"root\")) {\n       Bytes32 root = Bytes32.fromHexString(param.getQueryParam(\"root\"));\n       return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    } else if (queryParamMap.containsKey(\"epoch\")) {\n-      UnsignedLong epoch = UnsignedLong.valueOf(param.getQueryParam(\"epoch\"));\n-      Optional<Bytes32> blockRootAtSlot =\n-          client.getBlockRootBySlot(compute_start_slot_at_epoch(epoch));\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+    }\n+\n+    UnsignedLong slot;\n+    if (queryParamMap.containsKey(\"epoch\")) {\n+      slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(param.getQueryParam(\"epoch\")));\n     } else if (queryParamMap.containsKey(\"slot\")) {\n-      UnsignedLong slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n-      Optional<Bytes32> blockRootAtSlot = client.getBlockRootBySlot(slot);\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+      slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n     } else {\n       return null;\n     }\n-    jsonObject.put(\"block\", block);\n-    jsonObject.put(\"blockRoot\", blockRoot.toHexString());\n+\n+    Optional<Pair<BeaconBlock, Bytes32>> blockAndRoot = getBlockBySlot(slot);\n+    if (blockAndRoot.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<String, Object> jsonObject = new HashMap<>();\n+    jsonObject.put(\"blockRoot\", blockAndRoot.get().getRight().toHexString());\n+    jsonObject.put(\"block\", blockAndRoot.get().getLeft());\n+\n     return jsonObject;\n   }\n+\n+  private Optional<Pair<BeaconBlock, Bytes32>> getBlockBySlot(UnsignedLong slot) {", "originalCommit": "28214045ae9d3c7240c10c0def7793adaf3b8b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MTEzNQ==", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376841135", "bodyText": "I only did that because if we're able to find the block in memory, we already access it using its root. I guess assuming that the hash tree roots will be cached going forward, this is unnecessary.", "author": "cemozerr", "createdAt": "2020-02-10T01:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzMDA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MTgwNg==", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376841806", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-10T01:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzMDA0OA=="}], "type": "inlineReview"}, {"oid": "38c4105d72521a4ee9cda7486103bb848758bfc0", "url": "https://github.com/ConsenSys/teku/commit/38c4105d72521a4ee9cda7486103bb848758bfc0", "message": "Resolve comments", "committedDate": "2020-02-10T02:03:29Z", "type": "commit"}, {"oid": "620997d9723d4884c788e6e8b53e4e5c2e0e2c8f", "url": "https://github.com/ConsenSys/teku/commit/620997d9723d4884c788e6e8b53e4e5c2e0e2c8f", "message": "Run spotless", "committedDate": "2020-02-10T02:06:36Z", "type": "commit"}, {"oid": "5264171f442821a3c33c6856c32dd2496494c85b", "url": "https://github.com/ConsenSys/teku/commit/5264171f442821a3c33c6856c32dd2496494c85b", "message": "Quick fixes", "committedDate": "2020-02-10T02:18:50Z", "type": "commit"}, {"oid": "b02f0434ea9ee08591c3b60570ef1dd4e52c72d7", "url": "https://github.com/ConsenSys/teku/commit/b02f0434ea9ee08591c3b60570ef1dd4e52c72d7", "message": "Run spotless", "committedDate": "2020-02-10T02:21:22Z", "type": "commit"}]}