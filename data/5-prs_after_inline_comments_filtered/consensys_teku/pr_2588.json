{"pr_number": 2588, "pr_title": "#2449 Validator API REST client", "pr_createdAt": "2020-08-17T03:52:36Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2588", "timeline": [{"oid": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "url": "https://github.com/ConsenSys/teku/commit/edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "message": "#2449 Validator API REST client\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-08-17T03:51:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2MjE1NA==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471962154", "bodyText": "I'd avoid supplyAsync as it doesn't give any control over which threads are used to execute the request.  Instead I'd pass in the AsyncRunner instance ValidatorClient has and use that.  Then it will use the existing thread pool for the validator client.\nOr if the aim is just to ensure any exceptions get wrapped up in the returned future (good idea), you could just use SafeFuture.of", "author": "ajsutton", "createdAt": "2020-08-18T07:11:51Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n+import tech.pegasys.teku.datastructures.state.Fork;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.validator.SubnetSubscription;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.service.serviceutils.ServiceConfig;\n+import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n+import tech.pegasys.teku.validator.api.ValidatorDuties;\n+import tech.pegasys.teku.validator.remote.apiclient.OkHttpValidatorRestApiClient;\n+import tech.pegasys.teku.validator.remote.apiclient.ValidatorRestApiClient;\n+\n+public class RemoteValidatorApiHandler implements ValidatorApiChannel {\n+\n+  private final ValidatorRestApiClient apiClient;\n+\n+  @SuppressWarnings(\"unused\")\n+  public RemoteValidatorApiHandler(final ServiceConfig config) {\n+    // TODO: create config for validator client [https://github.com/PegaSysEng/teku/issues/2450]\n+    apiClient = new OkHttpValidatorRestApiClient(\"http://127.0.0.1:8888\");\n+  }\n+\n+  public RemoteValidatorApiHandler(final ValidatorRestApiClient apiClient) {\n+    this.apiClient = apiClient;\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<ForkInfo>> getForkInfo() {\n+    return SafeFuture.supplyAsync(() -> apiClient.getFork().map(this::mapGetForkResponse));\n+  }\n+\n+  private ForkInfo mapGetForkResponse(final GetForkResponse response) {\n+    final Fork fork = new Fork(response.previous_version, response.current_version, response.epoch);\n+    return new ForkInfo(fork, response.genesis_validators_root);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<List<ValidatorDuties>>> getDuties(\n+      final UInt64 epoch, final Collection<BLSPublicKey> publicKeys) {\n+    if (publicKeys.isEmpty()) {\n+      return SafeFuture.completedFuture(Optional.of(Collections.emptyList()));\n+    }\n+\n+    return SafeFuture.supplyAsync(", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2NTM5Nw==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471965397", "bodyText": "Is there a reason this one isn't jumping to a separate thread?", "author": "ajsutton", "createdAt": "2020-08-18T07:18:29Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n+import tech.pegasys.teku.datastructures.state.Fork;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.validator.SubnetSubscription;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.service.serviceutils.ServiceConfig;\n+import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n+import tech.pegasys.teku.validator.api.ValidatorDuties;\n+import tech.pegasys.teku.validator.remote.apiclient.OkHttpValidatorRestApiClient;\n+import tech.pegasys.teku.validator.remote.apiclient.ValidatorRestApiClient;\n+\n+public class RemoteValidatorApiHandler implements ValidatorApiChannel {\n+\n+  private final ValidatorRestApiClient apiClient;\n+\n+  @SuppressWarnings(\"unused\")\n+  public RemoteValidatorApiHandler(final ServiceConfig config) {\n+    // TODO: create config for validator client [https://github.com/PegaSysEng/teku/issues/2450]\n+    apiClient = new OkHttpValidatorRestApiClient(\"http://127.0.0.1:8888\");\n+  }\n+\n+  public RemoteValidatorApiHandler(final ValidatorRestApiClient apiClient) {\n+    this.apiClient = apiClient;\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<ForkInfo>> getForkInfo() {\n+    return SafeFuture.supplyAsync(() -> apiClient.getFork().map(this::mapGetForkResponse));\n+  }\n+\n+  private ForkInfo mapGetForkResponse(final GetForkResponse response) {\n+    final Fork fork = new Fork(response.previous_version, response.current_version, response.epoch);\n+    return new ForkInfo(fork, response.genesis_validators_root);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<List<ValidatorDuties>>> getDuties(\n+      final UInt64 epoch, final Collection<BLSPublicKey> publicKeys) {\n+    if (publicKeys.isEmpty()) {\n+      return SafeFuture.completedFuture(Optional.of(Collections.emptyList()));\n+    }\n+\n+    return SafeFuture.supplyAsync(\n+        () -> {\n+          final List<BLSPubKey> blsPubKeys =\n+              publicKeys.stream().map(BLSPubKey::new).collect(Collectors.toList());\n+          final ValidatorDutiesRequest validatorDutiesRequest =\n+              new ValidatorDutiesRequest(epoch, blsPubKeys);\n+\n+          final List<ValidatorDuties> validatorDuties =\n+              apiClient.getDuties(validatorDutiesRequest).stream()\n+                  .map(this::mapToApiValidatorDuties)\n+                  .collect(Collectors.toList());\n+\n+          return Optional.of(validatorDuties);\n+        });\n+  }\n+\n+  private ValidatorDuties mapToApiValidatorDuties(\n+      final tech.pegasys.teku.api.schema.ValidatorDuties schemaValidatorDuties) {\n+    return ValidatorDuties.withDuties(\n+        schemaValidatorDuties.validator_pubkey.asBLSPublicKey(),\n+        schemaValidatorDuties.validator_index,\n+        schemaValidatorDuties.attestation_committee_index,\n+        schemaValidatorDuties.attestation_committee_position,\n+        schemaValidatorDuties.aggregator_modulo,\n+        schemaValidatorDuties.block_proposal_slots,\n+        schemaValidatorDuties.attestation_slot);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<Attestation>> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    return SafeFuture.supplyAsync(\n+        () ->\n+            apiClient\n+                .createUnsignedAttestation(slot, committeeIndex)\n+                .map(tech.pegasys.teku.api.schema.Attestation::asInternalAttestation));\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    apiClient.sendSignedAttestation(schemaAttestation);", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2NTU2MQ==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471965561", "bodyText": "Also not jumping to a different thread.", "author": "ajsutton", "createdAt": "2020-08-18T07:18:50Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n+import tech.pegasys.teku.datastructures.state.Fork;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.validator.SubnetSubscription;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.service.serviceutils.ServiceConfig;\n+import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n+import tech.pegasys.teku.validator.api.ValidatorDuties;\n+import tech.pegasys.teku.validator.remote.apiclient.OkHttpValidatorRestApiClient;\n+import tech.pegasys.teku.validator.remote.apiclient.ValidatorRestApiClient;\n+\n+public class RemoteValidatorApiHandler implements ValidatorApiChannel {\n+\n+  private final ValidatorRestApiClient apiClient;\n+\n+  @SuppressWarnings(\"unused\")\n+  public RemoteValidatorApiHandler(final ServiceConfig config) {\n+    // TODO: create config for validator client [https://github.com/PegaSysEng/teku/issues/2450]\n+    apiClient = new OkHttpValidatorRestApiClient(\"http://127.0.0.1:8888\");\n+  }\n+\n+  public RemoteValidatorApiHandler(final ValidatorRestApiClient apiClient) {\n+    this.apiClient = apiClient;\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<ForkInfo>> getForkInfo() {\n+    return SafeFuture.supplyAsync(() -> apiClient.getFork().map(this::mapGetForkResponse));\n+  }\n+\n+  private ForkInfo mapGetForkResponse(final GetForkResponse response) {\n+    final Fork fork = new Fork(response.previous_version, response.current_version, response.epoch);\n+    return new ForkInfo(fork, response.genesis_validators_root);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<List<ValidatorDuties>>> getDuties(\n+      final UInt64 epoch, final Collection<BLSPublicKey> publicKeys) {\n+    if (publicKeys.isEmpty()) {\n+      return SafeFuture.completedFuture(Optional.of(Collections.emptyList()));\n+    }\n+\n+    return SafeFuture.supplyAsync(\n+        () -> {\n+          final List<BLSPubKey> blsPubKeys =\n+              publicKeys.stream().map(BLSPubKey::new).collect(Collectors.toList());\n+          final ValidatorDutiesRequest validatorDutiesRequest =\n+              new ValidatorDutiesRequest(epoch, blsPubKeys);\n+\n+          final List<ValidatorDuties> validatorDuties =\n+              apiClient.getDuties(validatorDutiesRequest).stream()\n+                  .map(this::mapToApiValidatorDuties)\n+                  .collect(Collectors.toList());\n+\n+          return Optional.of(validatorDuties);\n+        });\n+  }\n+\n+  private ValidatorDuties mapToApiValidatorDuties(\n+      final tech.pegasys.teku.api.schema.ValidatorDuties schemaValidatorDuties) {\n+    return ValidatorDuties.withDuties(\n+        schemaValidatorDuties.validator_pubkey.asBLSPublicKey(),\n+        schemaValidatorDuties.validator_index,\n+        schemaValidatorDuties.attestation_committee_index,\n+        schemaValidatorDuties.attestation_committee_position,\n+        schemaValidatorDuties.aggregator_modulo,\n+        schemaValidatorDuties.block_proposal_slots,\n+        schemaValidatorDuties.attestation_slot);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<Attestation>> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    return SafeFuture.supplyAsync(\n+        () ->\n+            apiClient\n+                .createUnsignedAttestation(slot, committeeIndex)\n+                .map(tech.pegasys.teku.api.schema.Attestation::asInternalAttestation));\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    apiClient.sendSignedAttestation(schemaAttestation);\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(\n+      final Attestation attestation, final Optional<Integer> validatorIndex) {\n+    sendSignedAttestation(attestation);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<BeaconBlock>> createUnsignedBlock(\n+      final UInt64 slot, final BLSSignature randaoReveal, final Optional<Bytes32> graffiti) {\n+    return SafeFuture.supplyAsync(\n+        () -> {\n+          final tech.pegasys.teku.api.schema.BLSSignature schemaBLSSignature =\n+              new tech.pegasys.teku.api.schema.BLSSignature(randaoReveal);\n+\n+          return apiClient\n+              .createUnsignedBlock(slot, schemaBLSSignature, graffiti)\n+              .map(tech.pegasys.teku.api.schema.BeaconBlock::asInternalBeaconBlock);\n+        });\n+  }\n+\n+  @Override\n+  public void sendSignedBlock(final SignedBeaconBlock block) {\n+    apiClient.sendSignedBlock(new tech.pegasys.teku.api.schema.SignedBeaconBlock(block));", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2Njc3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471966777", "bodyText": "None of these jump threads either.", "author": "ajsutton", "createdAt": "2020-08-18T07:21:01Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n+import tech.pegasys.teku.datastructures.state.Fork;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.validator.SubnetSubscription;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.service.serviceutils.ServiceConfig;\n+import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n+import tech.pegasys.teku.validator.api.ValidatorDuties;\n+import tech.pegasys.teku.validator.remote.apiclient.OkHttpValidatorRestApiClient;\n+import tech.pegasys.teku.validator.remote.apiclient.ValidatorRestApiClient;\n+\n+public class RemoteValidatorApiHandler implements ValidatorApiChannel {\n+\n+  private final ValidatorRestApiClient apiClient;\n+\n+  @SuppressWarnings(\"unused\")\n+  public RemoteValidatorApiHandler(final ServiceConfig config) {\n+    // TODO: create config for validator client [https://github.com/PegaSysEng/teku/issues/2450]\n+    apiClient = new OkHttpValidatorRestApiClient(\"http://127.0.0.1:8888\");\n+  }\n+\n+  public RemoteValidatorApiHandler(final ValidatorRestApiClient apiClient) {\n+    this.apiClient = apiClient;\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<ForkInfo>> getForkInfo() {\n+    return SafeFuture.supplyAsync(() -> apiClient.getFork().map(this::mapGetForkResponse));\n+  }\n+\n+  private ForkInfo mapGetForkResponse(final GetForkResponse response) {\n+    final Fork fork = new Fork(response.previous_version, response.current_version, response.epoch);\n+    return new ForkInfo(fork, response.genesis_validators_root);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<List<ValidatorDuties>>> getDuties(\n+      final UInt64 epoch, final Collection<BLSPublicKey> publicKeys) {\n+    if (publicKeys.isEmpty()) {\n+      return SafeFuture.completedFuture(Optional.of(Collections.emptyList()));\n+    }\n+\n+    return SafeFuture.supplyAsync(\n+        () -> {\n+          final List<BLSPubKey> blsPubKeys =\n+              publicKeys.stream().map(BLSPubKey::new).collect(Collectors.toList());\n+          final ValidatorDutiesRequest validatorDutiesRequest =\n+              new ValidatorDutiesRequest(epoch, blsPubKeys);\n+\n+          final List<ValidatorDuties> validatorDuties =\n+              apiClient.getDuties(validatorDutiesRequest).stream()\n+                  .map(this::mapToApiValidatorDuties)\n+                  .collect(Collectors.toList());\n+\n+          return Optional.of(validatorDuties);\n+        });\n+  }\n+\n+  private ValidatorDuties mapToApiValidatorDuties(\n+      final tech.pegasys.teku.api.schema.ValidatorDuties schemaValidatorDuties) {\n+    return ValidatorDuties.withDuties(\n+        schemaValidatorDuties.validator_pubkey.asBLSPublicKey(),\n+        schemaValidatorDuties.validator_index,\n+        schemaValidatorDuties.attestation_committee_index,\n+        schemaValidatorDuties.attestation_committee_position,\n+        schemaValidatorDuties.aggregator_modulo,\n+        schemaValidatorDuties.block_proposal_slots,\n+        schemaValidatorDuties.attestation_slot);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<Attestation>> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    return SafeFuture.supplyAsync(\n+        () ->\n+            apiClient\n+                .createUnsignedAttestation(slot, committeeIndex)\n+                .map(tech.pegasys.teku.api.schema.Attestation::asInternalAttestation));\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    apiClient.sendSignedAttestation(schemaAttestation);\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(\n+      final Attestation attestation, final Optional<Integer> validatorIndex) {\n+    sendSignedAttestation(attestation);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<BeaconBlock>> createUnsignedBlock(\n+      final UInt64 slot, final BLSSignature randaoReveal, final Optional<Bytes32> graffiti) {\n+    return SafeFuture.supplyAsync(\n+        () -> {\n+          final tech.pegasys.teku.api.schema.BLSSignature schemaBLSSignature =\n+              new tech.pegasys.teku.api.schema.BLSSignature(randaoReveal);\n+\n+          return apiClient\n+              .createUnsignedBlock(slot, schemaBLSSignature, graffiti)\n+              .map(tech.pegasys.teku.api.schema.BeaconBlock::asInternalBeaconBlock);\n+        });\n+  }\n+\n+  @Override\n+  public void sendSignedBlock(final SignedBeaconBlock block) {\n+    apiClient.sendSignedBlock(new tech.pegasys.teku.api.schema.SignedBeaconBlock(block));\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<Attestation>> createAggregate(final Bytes32 attestationHashTreeRoot) {\n+    return SafeFuture.supplyAsync(\n+        () ->\n+            apiClient\n+                .createAggregate(attestationHashTreeRoot)\n+                .map(tech.pegasys.teku.api.schema.Attestation::asInternalAttestation));\n+  }\n+\n+  @Override\n+  public void sendAggregateAndProof(final SignedAggregateAndProof aggregateAndProof) {\n+    apiClient.sendAggregateAndProof(\n+        new tech.pegasys.teku.api.schema.SignedAggregateAndProof(aggregateAndProof));\n+  }\n+\n+  @Override\n+  public void subscribeToBeaconCommitteeForAggregation(\n+      final int committeeIndex, final UInt64 aggregationSlot) {\n+    apiClient.subscribeToBeaconCommitteeForAggregation(committeeIndex, aggregationSlot);\n+  }\n+\n+  @Override\n+  public void subscribeToPersistentSubnets(final Set<SubnetSubscription> subnetSubscriptions) {\n+    final Set<tech.pegasys.teku.api.schema.SubnetSubscription> schemaSubscriptions =\n+        subnetSubscriptions.stream()\n+            .map(\n+                s ->\n+                    new tech.pegasys.teku.api.schema.SubnetSubscription(\n+                        s.getSubnetId(), s.getUnsubscriptionSlot()))\n+            .collect(Collectors.toSet());\n+\n+    apiClient.subscribeToPersistentSubnets(schemaSubscriptions);\n+  }", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MTY5Mg==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471971692", "bodyText": "Maybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private HttpUrl.Builder urlBuilder(final ValidatorApiMethod apiMethod) {\n          \n          \n            \n                return new HttpUrl.Builder()\n          \n          \n            \n                    .scheme(baseEndpoint.scheme())\n          \n          \n            \n                    .host(baseEndpoint.host())\n          \n          \n            \n                    .port(baseEndpoint.port())\n          \n          \n            \n                    .encodedPath(apiMethod.getPath());\n          \n          \n            \n              private HttpUrl.Builder urlBuilder(final ValidatorApiMethod apiMethod) {\n          \n          \n            \n                return baseEndpoint.resolve(apiMethod.getPath());\n          \n      \n    \n    \n  \n\nThat way if the base URL includes a username/password or other elements we didn't expect they'll be preserved.  Slightly tempted to make the paths in ValidatorApiMethod not start with / so they're fully relative and then if you specified http://localhost:5051/beaconNode/ we'd preserve the /beaconNode/ path which may be useful when load balancers get involved or to use a future Infura API where a product key would be included in the URL.", "author": "ajsutton", "createdAt": "2020-08-18T07:29:32Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/apiclient/OkHttpValidatorRestApiClient.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote.apiclient;\n+\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_AGGREGATE;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_DUTIES;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_FORK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_AGGREGATE_AND_PROOF;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_PERSISTENT_SUBNETS;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import okhttp3.HttpUrl;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.request.SubscribeToBeaconCommitteeRequest;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.Attestation;\n+import tech.pegasys.teku.api.schema.BLSSignature;\n+import tech.pegasys.teku.api.schema.BeaconBlock;\n+import tech.pegasys.teku.api.schema.SignedAggregateAndProof;\n+import tech.pegasys.teku.api.schema.SignedBeaconBlock;\n+import tech.pegasys.teku.api.schema.SubnetSubscription;\n+import tech.pegasys.teku.api.schema.ValidatorDuties;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class OkHttpValidatorRestApiClient implements ValidatorRestApiClient {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final MediaType APPLICATION_JSON =\n+      MediaType.parse(\"application/json; charset=utf-8\");\n+  private static final Map<String, String> EMPTY_QUERY_PARAMS = Collections.emptyMap();\n+\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final OkHttpClient httpClient;\n+  private final HttpUrl baseEndpoint;\n+\n+  public OkHttpValidatorRestApiClient(final String baseEndpoint) {\n+    this(HttpUrl.parse(baseEndpoint), new OkHttpClient());\n+  }\n+\n+  @VisibleForTesting\n+  OkHttpValidatorRestApiClient(final HttpUrl baseEndpoint, final OkHttpClient okHttpClient) {\n+    this.baseEndpoint = baseEndpoint;\n+    this.httpClient = okHttpClient;\n+  }\n+\n+  @Override\n+  public Optional<GetForkResponse> getFork() {\n+    return get(GET_FORK, EMPTY_QUERY_PARAMS, GetForkResponse.class);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  public List<ValidatorDuties> getDuties(final ValidatorDutiesRequest request) {\n+    return post(GET_DUTIES, request, ValidatorDuties[].class)\n+        .map(Arrays::asList)\n+        .orElse(Collections.EMPTY_LIST);\n+  }\n+\n+  @Override\n+  public Optional<BeaconBlock> createUnsignedBlock(\n+      final UInt64 slot, final BLSSignature randaoReveal, final Optional<Bytes32> graffiti) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"randao_reveal\", encodeQueryParam(randaoReveal));\n+    graffiti.ifPresent(bytes32 -> queryParams.put(\"graffiti\", encodeQueryParam(bytes32)));\n+\n+    return get(GET_UNSIGNED_BLOCK, queryParams, BeaconBlock.class);\n+  }\n+\n+  @Override\n+  public void sendSignedBlock(final SignedBeaconBlock beaconBlock) {\n+    post(SEND_SIGNED_BLOCK, beaconBlock, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"committee_index\", String.valueOf(committeeIndex));\n+\n+    return get(GET_UNSIGNED_ATTESTATION, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    post(SEND_SIGNED_ATTESTATION, attestation, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createAggregate(final Bytes32 attestationHashTreeRoot) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(UInt64.ZERO));\n+    queryParams.put(\"attestation_data_root\", encodeQueryParam(attestationHashTreeRoot));\n+\n+    return get(GET_AGGREGATE, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendAggregateAndProof(final SignedAggregateAndProof signedAggregateAndProof) {\n+    post(SEND_SIGNED_AGGREGATE_AND_PROOF, signedAggregateAndProof, null);\n+  }\n+\n+  @Override\n+  public void subscribeToBeaconCommitteeForAggregation(\n+      final int committeeIndex, final UInt64 aggregationSlot) {\n+    final SubscribeToBeaconCommitteeRequest request =\n+        new SubscribeToBeaconCommitteeRequest(committeeIndex, aggregationSlot);\n+    post(SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION, request, null);\n+  }\n+\n+  @Override\n+  public void subscribeToPersistentSubnets(final Set<SubnetSubscription> subnetSubscriptions) {\n+    post(SUBSCRIBE_TO_PERSISTENT_SUBNETS, subnetSubscriptions, null);\n+  }\n+\n+  public <T> Optional<T> get(\n+      final ValidatorApiMethod apiMethod,\n+      final Map<String, String> queryParams,\n+      final Class<T> responseClass) {\n+    final HttpUrl.Builder httpUrlBuilder = urlBuilder(apiMethod);\n+    if (queryParams != null && !queryParams.isEmpty()) {\n+      queryParams.forEach(httpUrlBuilder::addQueryParameter);\n+    }\n+\n+    final Request request = new Request.Builder().url(httpUrlBuilder.build()).build();\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private <T> Optional<T> post(\n+      final ValidatorApiMethod apiMethod,\n+      final Object requestBodyObj,\n+      final Class<T> responseClass) {\n+    final String requestBody;\n+    try {\n+      requestBody = jsonProvider.objectToJSON(requestBodyObj);\n+    } catch (JsonProcessingException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    final Request request =\n+        new Request.Builder()\n+            .url(urlBuilder(apiMethod).build())\n+            .post(RequestBody.create(requestBody, APPLICATION_JSON))\n+            .build();\n+\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private HttpUrl.Builder urlBuilder(final ValidatorApiMethod apiMethod) {\n+    return new HttpUrl.Builder()\n+        .scheme(baseEndpoint.scheme())\n+        .host(baseEndpoint.host())\n+        .port(baseEndpoint.port())\n+        .encodedPath(apiMethod.getPath());", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjE1MA==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471972150", "bodyText": "This feels like an error more than a warn - likely we've just missed performing some validator duty.", "author": "ajsutton", "createdAt": "2020-08-18T07:30:09Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/apiclient/OkHttpValidatorRestApiClient.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote.apiclient;\n+\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_AGGREGATE;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_DUTIES;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_FORK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_AGGREGATE_AND_PROOF;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_PERSISTENT_SUBNETS;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import okhttp3.HttpUrl;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.request.SubscribeToBeaconCommitteeRequest;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.Attestation;\n+import tech.pegasys.teku.api.schema.BLSSignature;\n+import tech.pegasys.teku.api.schema.BeaconBlock;\n+import tech.pegasys.teku.api.schema.SignedAggregateAndProof;\n+import tech.pegasys.teku.api.schema.SignedBeaconBlock;\n+import tech.pegasys.teku.api.schema.SubnetSubscription;\n+import tech.pegasys.teku.api.schema.ValidatorDuties;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class OkHttpValidatorRestApiClient implements ValidatorRestApiClient {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final MediaType APPLICATION_JSON =\n+      MediaType.parse(\"application/json; charset=utf-8\");\n+  private static final Map<String, String> EMPTY_QUERY_PARAMS = Collections.emptyMap();\n+\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final OkHttpClient httpClient;\n+  private final HttpUrl baseEndpoint;\n+\n+  public OkHttpValidatorRestApiClient(final String baseEndpoint) {\n+    this(HttpUrl.parse(baseEndpoint), new OkHttpClient());\n+  }\n+\n+  @VisibleForTesting\n+  OkHttpValidatorRestApiClient(final HttpUrl baseEndpoint, final OkHttpClient okHttpClient) {\n+    this.baseEndpoint = baseEndpoint;\n+    this.httpClient = okHttpClient;\n+  }\n+\n+  @Override\n+  public Optional<GetForkResponse> getFork() {\n+    return get(GET_FORK, EMPTY_QUERY_PARAMS, GetForkResponse.class);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  public List<ValidatorDuties> getDuties(final ValidatorDutiesRequest request) {\n+    return post(GET_DUTIES, request, ValidatorDuties[].class)\n+        .map(Arrays::asList)\n+        .orElse(Collections.EMPTY_LIST);\n+  }\n+\n+  @Override\n+  public Optional<BeaconBlock> createUnsignedBlock(\n+      final UInt64 slot, final BLSSignature randaoReveal, final Optional<Bytes32> graffiti) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"randao_reveal\", encodeQueryParam(randaoReveal));\n+    graffiti.ifPresent(bytes32 -> queryParams.put(\"graffiti\", encodeQueryParam(bytes32)));\n+\n+    return get(GET_UNSIGNED_BLOCK, queryParams, BeaconBlock.class);\n+  }\n+\n+  @Override\n+  public void sendSignedBlock(final SignedBeaconBlock beaconBlock) {\n+    post(SEND_SIGNED_BLOCK, beaconBlock, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"committee_index\", String.valueOf(committeeIndex));\n+\n+    return get(GET_UNSIGNED_ATTESTATION, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    post(SEND_SIGNED_ATTESTATION, attestation, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createAggregate(final Bytes32 attestationHashTreeRoot) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(UInt64.ZERO));\n+    queryParams.put(\"attestation_data_root\", encodeQueryParam(attestationHashTreeRoot));\n+\n+    return get(GET_AGGREGATE, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendAggregateAndProof(final SignedAggregateAndProof signedAggregateAndProof) {\n+    post(SEND_SIGNED_AGGREGATE_AND_PROOF, signedAggregateAndProof, null);\n+  }\n+\n+  @Override\n+  public void subscribeToBeaconCommitteeForAggregation(\n+      final int committeeIndex, final UInt64 aggregationSlot) {\n+    final SubscribeToBeaconCommitteeRequest request =\n+        new SubscribeToBeaconCommitteeRequest(committeeIndex, aggregationSlot);\n+    post(SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION, request, null);\n+  }\n+\n+  @Override\n+  public void subscribeToPersistentSubnets(final Set<SubnetSubscription> subnetSubscriptions) {\n+    post(SUBSCRIBE_TO_PERSISTENT_SUBNETS, subnetSubscriptions, null);\n+  }\n+\n+  public <T> Optional<T> get(\n+      final ValidatorApiMethod apiMethod,\n+      final Map<String, String> queryParams,\n+      final Class<T> responseClass) {\n+    final HttpUrl.Builder httpUrlBuilder = urlBuilder(apiMethod);\n+    if (queryParams != null && !queryParams.isEmpty()) {\n+      queryParams.forEach(httpUrlBuilder::addQueryParameter);\n+    }\n+\n+    final Request request = new Request.Builder().url(httpUrlBuilder.build()).build();\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private <T> Optional<T> post(\n+      final ValidatorApiMethod apiMethod,\n+      final Object requestBodyObj,\n+      final Class<T> responseClass) {\n+    final String requestBody;\n+    try {\n+      requestBody = jsonProvider.objectToJSON(requestBodyObj);\n+    } catch (JsonProcessingException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    final Request request =\n+        new Request.Builder()\n+            .url(urlBuilder(apiMethod).build())\n+            .post(RequestBody.create(requestBody, APPLICATION_JSON))\n+            .build();\n+\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private HttpUrl.Builder urlBuilder(final ValidatorApiMethod apiMethod) {\n+    return new HttpUrl.Builder()\n+        .scheme(baseEndpoint.scheme())\n+        .host(baseEndpoint.host())\n+        .port(baseEndpoint.port())\n+        .encodedPath(apiMethod.getPath());\n+  }\n+\n+  private <T> Optional<T> executeCall(final Request request, final Class<T> responseClass) {\n+    try (final Response response = httpClient.newCall(request).execute()) {\n+      LOG.trace(\"{} {} {}\", request.method(), request.url(), response.code());\n+\n+      switch (response.code()) {\n+        case 200:\n+          {\n+            final String responseBody = response.body().string();\n+            if (responseClass != null) {\n+              final T responseObj = jsonProvider.jsonToObject(responseBody, responseClass);\n+              return Optional.of(responseObj);\n+            } else {\n+              return Optional.empty();\n+            }\n+          }\n+        case 202:\n+        case 204:\n+        case 404:\n+        case 503:\n+          {\n+            return Optional.empty();\n+          }\n+        case 400:\n+          {\n+            LOG.warn(\"Invalid params response from Beacon Node API - {}\", response.body().string());", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjY4Mg==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471972682", "bodyText": "We don't seem to use the result of this.", "author": "ajsutton", "createdAt": "2020-08-18T07:30:57Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/apiclient/OkHttpValidatorRestApiClient.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote.apiclient;\n+\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_AGGREGATE;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_DUTIES;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_FORK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_AGGREGATE_AND_PROOF;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_PERSISTENT_SUBNETS;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import okhttp3.HttpUrl;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.request.SubscribeToBeaconCommitteeRequest;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.Attestation;\n+import tech.pegasys.teku.api.schema.BLSSignature;\n+import tech.pegasys.teku.api.schema.BeaconBlock;\n+import tech.pegasys.teku.api.schema.SignedAggregateAndProof;\n+import tech.pegasys.teku.api.schema.SignedBeaconBlock;\n+import tech.pegasys.teku.api.schema.SubnetSubscription;\n+import tech.pegasys.teku.api.schema.ValidatorDuties;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class OkHttpValidatorRestApiClient implements ValidatorRestApiClient {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final MediaType APPLICATION_JSON =\n+      MediaType.parse(\"application/json; charset=utf-8\");\n+  private static final Map<String, String> EMPTY_QUERY_PARAMS = Collections.emptyMap();\n+\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final OkHttpClient httpClient;\n+  private final HttpUrl baseEndpoint;\n+\n+  public OkHttpValidatorRestApiClient(final String baseEndpoint) {\n+    this(HttpUrl.parse(baseEndpoint), new OkHttpClient());\n+  }\n+\n+  @VisibleForTesting\n+  OkHttpValidatorRestApiClient(final HttpUrl baseEndpoint, final OkHttpClient okHttpClient) {\n+    this.baseEndpoint = baseEndpoint;\n+    this.httpClient = okHttpClient;\n+  }\n+\n+  @Override\n+  public Optional<GetForkResponse> getFork() {\n+    return get(GET_FORK, EMPTY_QUERY_PARAMS, GetForkResponse.class);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  public List<ValidatorDuties> getDuties(final ValidatorDutiesRequest request) {\n+    return post(GET_DUTIES, request, ValidatorDuties[].class)\n+        .map(Arrays::asList)\n+        .orElse(Collections.EMPTY_LIST);\n+  }\n+\n+  @Override\n+  public Optional<BeaconBlock> createUnsignedBlock(\n+      final UInt64 slot, final BLSSignature randaoReveal, final Optional<Bytes32> graffiti) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"randao_reveal\", encodeQueryParam(randaoReveal));\n+    graffiti.ifPresent(bytes32 -> queryParams.put(\"graffiti\", encodeQueryParam(bytes32)));\n+\n+    return get(GET_UNSIGNED_BLOCK, queryParams, BeaconBlock.class);\n+  }\n+\n+  @Override\n+  public void sendSignedBlock(final SignedBeaconBlock beaconBlock) {\n+    post(SEND_SIGNED_BLOCK, beaconBlock, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"committee_index\", String.valueOf(committeeIndex));\n+\n+    return get(GET_UNSIGNED_ATTESTATION, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    post(SEND_SIGNED_ATTESTATION, attestation, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createAggregate(final Bytes32 attestationHashTreeRoot) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(UInt64.ZERO));\n+    queryParams.put(\"attestation_data_root\", encodeQueryParam(attestationHashTreeRoot));\n+\n+    return get(GET_AGGREGATE, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendAggregateAndProof(final SignedAggregateAndProof signedAggregateAndProof) {\n+    post(SEND_SIGNED_AGGREGATE_AND_PROOF, signedAggregateAndProof, null);\n+  }\n+\n+  @Override\n+  public void subscribeToBeaconCommitteeForAggregation(\n+      final int committeeIndex, final UInt64 aggregationSlot) {\n+    final SubscribeToBeaconCommitteeRequest request =\n+        new SubscribeToBeaconCommitteeRequest(committeeIndex, aggregationSlot);\n+    post(SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION, request, null);\n+  }\n+\n+  @Override\n+  public void subscribeToPersistentSubnets(final Set<SubnetSubscription> subnetSubscriptions) {\n+    post(SUBSCRIBE_TO_PERSISTENT_SUBNETS, subnetSubscriptions, null);\n+  }\n+\n+  public <T> Optional<T> get(\n+      final ValidatorApiMethod apiMethod,\n+      final Map<String, String> queryParams,\n+      final Class<T> responseClass) {\n+    final HttpUrl.Builder httpUrlBuilder = urlBuilder(apiMethod);\n+    if (queryParams != null && !queryParams.isEmpty()) {\n+      queryParams.forEach(httpUrlBuilder::addQueryParameter);\n+    }\n+\n+    final Request request = new Request.Builder().url(httpUrlBuilder.build()).build();\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private <T> Optional<T> post(\n+      final ValidatorApiMethod apiMethod,\n+      final Object requestBodyObj,\n+      final Class<T> responseClass) {\n+    final String requestBody;\n+    try {\n+      requestBody = jsonProvider.objectToJSON(requestBodyObj);\n+    } catch (JsonProcessingException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    final Request request =\n+        new Request.Builder()\n+            .url(urlBuilder(apiMethod).build())\n+            .post(RequestBody.create(requestBody, APPLICATION_JSON))\n+            .build();\n+\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private HttpUrl.Builder urlBuilder(final ValidatorApiMethod apiMethod) {\n+    return new HttpUrl.Builder()\n+        .scheme(baseEndpoint.scheme())\n+        .host(baseEndpoint.host())\n+        .port(baseEndpoint.port())\n+        .encodedPath(apiMethod.getPath());\n+  }\n+\n+  private <T> Optional<T> executeCall(final Request request, final Class<T> responseClass) {\n+    try (final Response response = httpClient.newCall(request).execute()) {\n+      LOG.trace(\"{} {} {}\", request.method(), request.url(), response.code());\n+\n+      switch (response.code()) {\n+        case 200:\n+          {\n+            final String responseBody = response.body().string();\n+            if (responseClass != null) {\n+              final T responseObj = jsonProvider.jsonToObject(responseBody, responseClass);\n+              return Optional.of(responseObj);\n+            } else {\n+              return Optional.empty();\n+            }\n+          }\n+        case 202:\n+        case 204:\n+        case 404:\n+        case 503:\n+          {\n+            return Optional.empty();\n+          }\n+        case 400:\n+          {\n+            LOG.warn(\"Invalid params response from Beacon Node API - {}\", response.body().string());\n+            return Optional.empty();\n+          }\n+        default:\n+          {\n+            final String responseBody = response.body().string();\n+            LOG.error(\n+                \"Unexpected error calling Beacon Node API (status = {}, response = {})\",\n+                response.code(),\n+                responseBody);\n+            throw new RuntimeException(\n+                \"Unexpected response from Beacon Node API (status = \"\n+                    + response.code()\n+                    + \", response = \"\n+                    + responseBody\n+                    + \")\");\n+          }\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"Error communicating with Beacon Node API\", e);\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private String encodeQueryParam(final Object value) {\n+    try {\n+      return removeQuotesIfPresent(jsonProvider.objectToJSON(value));\n+    } catch (JsonProcessingException e) {\n+      throw new RuntimeException(\n+          \"Can't encode param of type \" + value.getClass().getSimpleName(), e);\n+    }\n+  }\n+\n+  private String removeQuotesIfPresent(final String value) {\n+    StringUtils.strip(value, \"\\\"\");", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0MDc5NA==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r472640794", "bodyText": "Ah, I was playing around with it :)", "author": "lucassaldanha", "createdAt": "2020-08-19T03:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Mjk5MQ==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471972991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n          \n          \n            \n                if (value.startsWith('\"') && value.endsWith('\"')) {\n          \n      \n    \n    \n  \n\nI think... :)", "author": "ajsutton", "createdAt": "2020-08-18T07:31:28Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/apiclient/OkHttpValidatorRestApiClient.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote.apiclient;\n+\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_AGGREGATE;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_DUTIES;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_FORK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.GET_UNSIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_AGGREGATE_AND_PROOF;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_ATTESTATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SEND_SIGNED_BLOCK;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION;\n+import static tech.pegasys.teku.validator.remote.apiclient.ValidatorApiMethod.SUBSCRIBE_TO_PERSISTENT_SUBNETS;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import okhttp3.HttpUrl;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.request.SubscribeToBeaconCommitteeRequest;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.Attestation;\n+import tech.pegasys.teku.api.schema.BLSSignature;\n+import tech.pegasys.teku.api.schema.BeaconBlock;\n+import tech.pegasys.teku.api.schema.SignedAggregateAndProof;\n+import tech.pegasys.teku.api.schema.SignedBeaconBlock;\n+import tech.pegasys.teku.api.schema.SubnetSubscription;\n+import tech.pegasys.teku.api.schema.ValidatorDuties;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class OkHttpValidatorRestApiClient implements ValidatorRestApiClient {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final MediaType APPLICATION_JSON =\n+      MediaType.parse(\"application/json; charset=utf-8\");\n+  private static final Map<String, String> EMPTY_QUERY_PARAMS = Collections.emptyMap();\n+\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final OkHttpClient httpClient;\n+  private final HttpUrl baseEndpoint;\n+\n+  public OkHttpValidatorRestApiClient(final String baseEndpoint) {\n+    this(HttpUrl.parse(baseEndpoint), new OkHttpClient());\n+  }\n+\n+  @VisibleForTesting\n+  OkHttpValidatorRestApiClient(final HttpUrl baseEndpoint, final OkHttpClient okHttpClient) {\n+    this.baseEndpoint = baseEndpoint;\n+    this.httpClient = okHttpClient;\n+  }\n+\n+  @Override\n+  public Optional<GetForkResponse> getFork() {\n+    return get(GET_FORK, EMPTY_QUERY_PARAMS, GetForkResponse.class);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  public List<ValidatorDuties> getDuties(final ValidatorDutiesRequest request) {\n+    return post(GET_DUTIES, request, ValidatorDuties[].class)\n+        .map(Arrays::asList)\n+        .orElse(Collections.EMPTY_LIST);\n+  }\n+\n+  @Override\n+  public Optional<BeaconBlock> createUnsignedBlock(\n+      final UInt64 slot, final BLSSignature randaoReveal, final Optional<Bytes32> graffiti) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"randao_reveal\", encodeQueryParam(randaoReveal));\n+    graffiti.ifPresent(bytes32 -> queryParams.put(\"graffiti\", encodeQueryParam(bytes32)));\n+\n+    return get(GET_UNSIGNED_BLOCK, queryParams, BeaconBlock.class);\n+  }\n+\n+  @Override\n+  public void sendSignedBlock(final SignedBeaconBlock beaconBlock) {\n+    post(SEND_SIGNED_BLOCK, beaconBlock, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(slot));\n+    queryParams.put(\"committee_index\", String.valueOf(committeeIndex));\n+\n+    return get(GET_UNSIGNED_ATTESTATION, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    post(SEND_SIGNED_ATTESTATION, attestation, null);\n+  }\n+\n+  @Override\n+  public Optional<Attestation> createAggregate(final Bytes32 attestationHashTreeRoot) {\n+    final Map<String, String> queryParams = new HashMap<>();\n+    queryParams.put(\"slot\", encodeQueryParam(UInt64.ZERO));\n+    queryParams.put(\"attestation_data_root\", encodeQueryParam(attestationHashTreeRoot));\n+\n+    return get(GET_AGGREGATE, queryParams, Attestation.class);\n+  }\n+\n+  @Override\n+  public void sendAggregateAndProof(final SignedAggregateAndProof signedAggregateAndProof) {\n+    post(SEND_SIGNED_AGGREGATE_AND_PROOF, signedAggregateAndProof, null);\n+  }\n+\n+  @Override\n+  public void subscribeToBeaconCommitteeForAggregation(\n+      final int committeeIndex, final UInt64 aggregationSlot) {\n+    final SubscribeToBeaconCommitteeRequest request =\n+        new SubscribeToBeaconCommitteeRequest(committeeIndex, aggregationSlot);\n+    post(SUBSCRIBE_TO_COMMITTEE_FOR_AGGREGATION, request, null);\n+  }\n+\n+  @Override\n+  public void subscribeToPersistentSubnets(final Set<SubnetSubscription> subnetSubscriptions) {\n+    post(SUBSCRIBE_TO_PERSISTENT_SUBNETS, subnetSubscriptions, null);\n+  }\n+\n+  public <T> Optional<T> get(\n+      final ValidatorApiMethod apiMethod,\n+      final Map<String, String> queryParams,\n+      final Class<T> responseClass) {\n+    final HttpUrl.Builder httpUrlBuilder = urlBuilder(apiMethod);\n+    if (queryParams != null && !queryParams.isEmpty()) {\n+      queryParams.forEach(httpUrlBuilder::addQueryParameter);\n+    }\n+\n+    final Request request = new Request.Builder().url(httpUrlBuilder.build()).build();\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private <T> Optional<T> post(\n+      final ValidatorApiMethod apiMethod,\n+      final Object requestBodyObj,\n+      final Class<T> responseClass) {\n+    final String requestBody;\n+    try {\n+      requestBody = jsonProvider.objectToJSON(requestBodyObj);\n+    } catch (JsonProcessingException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    final Request request =\n+        new Request.Builder()\n+            .url(urlBuilder(apiMethod).build())\n+            .post(RequestBody.create(requestBody, APPLICATION_JSON))\n+            .build();\n+\n+    return executeCall(request, responseClass);\n+  }\n+\n+  private HttpUrl.Builder urlBuilder(final ValidatorApiMethod apiMethod) {\n+    return new HttpUrl.Builder()\n+        .scheme(baseEndpoint.scheme())\n+        .host(baseEndpoint.host())\n+        .port(baseEndpoint.port())\n+        .encodedPath(apiMethod.getPath());\n+  }\n+\n+  private <T> Optional<T> executeCall(final Request request, final Class<T> responseClass) {\n+    try (final Response response = httpClient.newCall(request).execute()) {\n+      LOG.trace(\"{} {} {}\", request.method(), request.url(), response.code());\n+\n+      switch (response.code()) {\n+        case 200:\n+          {\n+            final String responseBody = response.body().string();\n+            if (responseClass != null) {\n+              final T responseObj = jsonProvider.jsonToObject(responseBody, responseClass);\n+              return Optional.of(responseObj);\n+            } else {\n+              return Optional.empty();\n+            }\n+          }\n+        case 202:\n+        case 204:\n+        case 404:\n+        case 503:\n+          {\n+            return Optional.empty();\n+          }\n+        case 400:\n+          {\n+            LOG.warn(\"Invalid params response from Beacon Node API - {}\", response.body().string());\n+            return Optional.empty();\n+          }\n+        default:\n+          {\n+            final String responseBody = response.body().string();\n+            LOG.error(\n+                \"Unexpected error calling Beacon Node API (status = {}, response = {})\",\n+                response.code(),\n+                responseBody);\n+            throw new RuntimeException(\n+                \"Unexpected response from Beacon Node API (status = \"\n+                    + response.code()\n+                    + \", response = \"\n+                    + responseBody\n+                    + \")\");\n+          }\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"Error communicating with Beacon Node API\", e);\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private String encodeQueryParam(final Object value) {\n+    try {\n+      return removeQuotesIfPresent(jsonProvider.objectToJSON(value));\n+    } catch (JsonProcessingException e) {\n+      throw new RuntimeException(\n+          \"Can't encode param of type \" + value.getClass().getSimpleName(), e);\n+    }\n+  }\n+\n+  private String removeQuotesIfPresent(final String value) {\n+    StringUtils.strip(value, \"\\\"\");\n+    if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3NDU2MQ==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471974561", "bodyText": "Probably better to use Waiter.waitFor here so it will timeout. Or if you move to using AsyncRunner you could pass in a StubAsyncRunner and then use StubAsyncRunner.executeQueuedTasks() to trigger execution and the whole test would wind up being single threaded.", "author": "ajsutton", "createdAt": "2020-08-18T07:33:59Z", "path": "validator/remote/src/test/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandlerTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote;\n+\n+import static java.util.Collections.emptyList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.refEq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.AggregateAndProof;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.datastructures.validator.SubnetSubscription;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.validator.api.ValidatorDuties;\n+import tech.pegasys.teku.validator.remote.apiclient.ValidatorRestApiClient;\n+\n+class RemoteValidatorApiHandlerTest {\n+\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final ValidatorRestApiClient apiClient = mock(ValidatorRestApiClient.class);\n+\n+  private RemoteValidatorApiHandler apiHandler;\n+\n+  @BeforeEach\n+  public void beforeEach() {\n+    apiHandler = new RemoteValidatorApiHandler(apiClient);\n+  }\n+\n+  @Test\n+  public void getForkInfo_WhenPresent_ReturnsValue() {\n+    final ForkInfo forkInfo = dataStructureUtil.randomForkInfo();\n+    when(apiClient.getFork()).thenReturn(Optional.of(new GetForkResponse(forkInfo)));\n+\n+    SafeFuture<Optional<ForkInfo>> future = apiHandler.getForkInfo();\n+\n+    assertThat(unwrapToValue(future)).usingRecursiveComparison().isEqualTo(forkInfo);\n+  }\n+\n+  @Test\n+  public void getForkInfo_WhenNotPresent_ReturnsEmpty() {\n+    when(apiClient.getFork()).thenReturn(Optional.empty());\n+\n+    SafeFuture<Optional<ForkInfo>> future = apiHandler.getForkInfo();\n+\n+    assertThat(unwrapToOptional(future)).isNotPresent();\n+  }\n+\n+  @Test\n+  public void getDuties_WithEmptyPublicKeys_ReturnsEmpty() {\n+    SafeFuture<Optional<List<ValidatorDuties>>> future =\n+        apiHandler.getDuties(UInt64.ONE, emptyList());\n+\n+    assertThat(unwrapToValue(future)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getDuties_WhenNoneFound_ReturnsEmpty() {\n+    final BLSPublicKey blsPublicKey = dataStructureUtil.randomPublicKey();\n+\n+    when(apiClient.getDuties(any())).thenReturn(Collections.emptyList());\n+\n+    SafeFuture<Optional<List<ValidatorDuties>>> future =\n+        apiHandler.getDuties(UInt64.ONE, List.of(blsPublicKey));\n+\n+    assertThat(unwrapToValue(future)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getDuties_WhenFound_ReturnsDuties() {\n+    final BLSPublicKey blsPublicKey = dataStructureUtil.randomPublicKey();\n+    final tech.pegasys.teku.api.schema.ValidatorDuties schemaValidatorDuties =\n+        new tech.pegasys.teku.api.schema.ValidatorDuties(\n+            new BLSPubKey(blsPublicKey), 0, 0, 0, 0, List.of(UInt64.ZERO), UInt64.ZERO);\n+    final ValidatorDuties expectedValidatorDuties =\n+        ValidatorDuties.withDuties(blsPublicKey, 0, 0, 0, 0, List.of(UInt64.ZERO), UInt64.ZERO);\n+\n+    when(apiClient.getDuties(any())).thenReturn(List.of(schemaValidatorDuties));\n+\n+    SafeFuture<Optional<List<ValidatorDuties>>> future =\n+        apiHandler.getDuties(UInt64.ONE, List.of(blsPublicKey));\n+\n+    List<ValidatorDuties> validatorDuties = unwrapToValue(future);\n+\n+    assertThat(validatorDuties.get(0))\n+        .usingRecursiveComparison()\n+        .isEqualTo(expectedValidatorDuties);\n+  }\n+\n+  @Test\n+  public void getDuties_MapsRequestToApiCorrectly() {\n+    final BLSPublicKey blsPublicKey = dataStructureUtil.randomPublicKey();\n+    final BLSPubKey schemaBlsPubKey = new BLSPubKey(blsPublicKey);\n+    final ValidatorDutiesRequest request =\n+        new ValidatorDutiesRequest(UInt64.ONE, List.of(schemaBlsPubKey));\n+\n+    final ArgumentCaptor<ValidatorDutiesRequest> requestArgumentCaptor =\n+        ArgumentCaptor.forClass(ValidatorDutiesRequest.class);\n+\n+    when(apiClient.getDuties(any())).thenReturn(Collections.emptyList());\n+\n+    SafeFuture<Optional<List<ValidatorDuties>>> future =\n+        apiHandler.getDuties(UInt64.ONE, List.of(blsPublicKey));\n+\n+    assertThat(unwrapToOptional(future)).isPresent();\n+\n+    verify(apiClient).getDuties(requestArgumentCaptor.capture());\n+    assertThat(requestArgumentCaptor.getValue()).usingRecursiveComparison().isEqualTo(request);\n+  }\n+\n+  @Test\n+  public void createUnsignedAttestation_WhenNone_ReturnsEmpty() {\n+    when(apiClient.createUnsignedAttestation(any(), anyInt())).thenReturn(Optional.empty());\n+\n+    SafeFuture<Optional<Attestation>> future = apiHandler.createUnsignedAttestation(UInt64.ONE, 0);\n+\n+    assertThat(unwrapToOptional(future)).isEmpty();\n+  }\n+\n+  @Test\n+  public void createUnsignedAttestation_WhenFound_ReturnsAttestation() {\n+    final Attestation attestation = dataStructureUtil.randomAttestation();\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    when(apiClient.createUnsignedAttestation(eq(UInt64.ONE), eq(0)))\n+        .thenReturn(Optional.of(schemaAttestation));\n+\n+    SafeFuture<Optional<Attestation>> future = apiHandler.createUnsignedAttestation(UInt64.ONE, 0);\n+\n+    assertThat(unwrapToValue(future)).usingRecursiveComparison().isEqualTo(attestation);\n+  }\n+\n+  @Test\n+  public void sendSignedAttestation_InvokeApiWithCorrectRequest() {\n+    final Attestation attestation = dataStructureUtil.randomAttestation();\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    ArgumentCaptor<tech.pegasys.teku.api.schema.Attestation> argumentCaptor =\n+        ArgumentCaptor.forClass(tech.pegasys.teku.api.schema.Attestation.class);\n+\n+    apiHandler.sendSignedAttestation(attestation);\n+\n+    verify(apiClient).sendSignedAttestation(argumentCaptor.capture());\n+    assertThat(argumentCaptor.getValue()).usingRecursiveComparison().isEqualTo(schemaAttestation);\n+  }\n+\n+  @Test\n+  public void sendSignedAttestation_IgnoresValidatorIndexParameter_AndInvokeApi() {\n+    final Attestation attestation = dataStructureUtil.randomAttestation();\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    ArgumentCaptor<tech.pegasys.teku.api.schema.Attestation> argumentCaptor =\n+        ArgumentCaptor.forClass(tech.pegasys.teku.api.schema.Attestation.class);\n+\n+    apiHandler.sendSignedAttestation(attestation, Optional.of(1));\n+\n+    verify(apiClient).sendSignedAttestation(argumentCaptor.capture());\n+    assertThat(argumentCaptor.getValue()).usingRecursiveComparison().isEqualTo(schemaAttestation);\n+  }\n+\n+  @Test\n+  public void createUnsignedBlock_WhenNoneFound_ReturnsEmpty() {\n+    final BLSSignature blsSignature = dataStructureUtil.randomSignature();\n+\n+    SafeFuture<Optional<BeaconBlock>> future =\n+        apiHandler.createUnsignedBlock(UInt64.ONE, blsSignature, Optional.of(Bytes32.random()));\n+\n+    assertThat(unwrapToOptional(future)).isEmpty();\n+  }\n+\n+  @Test\n+  public void createUnsignedBlock_WhenFound_ReturnsBlock() {\n+    final BeaconBlock beaconBlock = dataStructureUtil.randomBeaconBlock(UInt64.ONE);\n+    final BLSSignature blsSignature = dataStructureUtil.randomSignature();\n+    final Optional<Bytes32> graffiti = Optional.of(Bytes32.random());\n+\n+    final tech.pegasys.teku.api.schema.BLSSignature schemaBlsSignature =\n+        new tech.pegasys.teku.api.schema.BLSSignature(blsSignature);\n+    final tech.pegasys.teku.api.schema.BeaconBlock schemaBeaconBlock =\n+        new tech.pegasys.teku.api.schema.BeaconBlock(beaconBlock);\n+\n+    when(apiClient.createUnsignedBlock(\n+            eq(beaconBlock.getSlot()), refEq(schemaBlsSignature), eq(graffiti)))\n+        .thenReturn(Optional.of(schemaBeaconBlock));\n+\n+    SafeFuture<Optional<BeaconBlock>> future =\n+        apiHandler.createUnsignedBlock(UInt64.ONE, blsSignature, graffiti);\n+\n+    assertThat(unwrapToValue(future)).usingRecursiveComparison().isEqualTo(beaconBlock);\n+  }\n+\n+  @Test\n+  public void sendSignedBlock_InvokeApiWithCorrectRequest() {\n+    final BeaconBlock beaconBlock = dataStructureUtil.randomBeaconBlock(UInt64.ONE);\n+    final BLSSignature signature = dataStructureUtil.randomSignature();\n+    final SignedBeaconBlock signedBeaconBlock = new SignedBeaconBlock(beaconBlock, signature);\n+\n+    final tech.pegasys.teku.api.schema.SignedBeaconBlock schemaSignedBlock =\n+        new tech.pegasys.teku.api.schema.SignedBeaconBlock(signedBeaconBlock);\n+\n+    ArgumentCaptor<tech.pegasys.teku.api.schema.SignedBeaconBlock> argumentCaptor =\n+        ArgumentCaptor.forClass(tech.pegasys.teku.api.schema.SignedBeaconBlock.class);\n+\n+    apiHandler.sendSignedBlock(signedBeaconBlock);\n+\n+    verify(apiClient).sendSignedBlock(argumentCaptor.capture());\n+    assertThat(argumentCaptor.getValue()).usingRecursiveComparison().isEqualTo(schemaSignedBlock);\n+  }\n+\n+  @Test\n+  public void createAggregate_WhenNotFound_ReturnsEmpty() {\n+    final Bytes32 attHashTreeRoot = Bytes32.random();\n+\n+    when(apiClient.createAggregate(eq(attHashTreeRoot))).thenReturn(Optional.empty());\n+\n+    SafeFuture<Optional<Attestation>> future = apiHandler.createAggregate(attHashTreeRoot);\n+\n+    assertThat(unwrapToOptional(future)).isEmpty();\n+  }\n+\n+  @Test\n+  public void createAggregate_WhenFound_ReturnsAttestation() {\n+    final Bytes32 attHashTreeRoot = Bytes32.random();\n+\n+    final Attestation attestation = dataStructureUtil.randomAttestation();\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    when(apiClient.createAggregate(eq(attHashTreeRoot))).thenReturn(Optional.of(schemaAttestation));\n+\n+    SafeFuture<Optional<Attestation>> future = apiHandler.createAggregate(attHashTreeRoot);\n+\n+    assertThat(unwrapToValue(future)).usingRecursiveComparison().isEqualTo(attestation);\n+  }\n+\n+  @Test\n+  public void sendSAggregateAndProof_InvokeApiWithCorrectRequest() {\n+    final AggregateAndProof aggregateAndProof = dataStructureUtil.randomAggregateAndProof();\n+    final BLSSignature signature = dataStructureUtil.randomSignature();\n+    final SignedAggregateAndProof signedAggregateAndProof =\n+        new SignedAggregateAndProof(aggregateAndProof, signature);\n+\n+    tech.pegasys.teku.api.schema.SignedAggregateAndProof schemaSignedAggAndProof =\n+        new tech.pegasys.teku.api.schema.SignedAggregateAndProof(signedAggregateAndProof);\n+\n+    ArgumentCaptor<tech.pegasys.teku.api.schema.SignedAggregateAndProof> argumentCaptor =\n+        ArgumentCaptor.forClass(tech.pegasys.teku.api.schema.SignedAggregateAndProof.class);\n+\n+    apiHandler.sendAggregateAndProof(signedAggregateAndProof);\n+\n+    verify(apiClient).sendAggregateAndProof(argumentCaptor.capture());\n+    assertThat(argumentCaptor.getValue())\n+        .usingRecursiveComparison()\n+        .isEqualTo(schemaSignedAggAndProof);\n+  }\n+\n+  @Test\n+  public void subscribeToBeaconCommitteeForAggregation_InvokeApi() {\n+    final int committeeIndex = 1;\n+    final UInt64 aggregationSlot = UInt64.ONE;\n+\n+    apiHandler.subscribeToBeaconCommitteeForAggregation(committeeIndex, aggregationSlot);\n+\n+    verify(apiClient)\n+        .subscribeToBeaconCommitteeForAggregation(eq(committeeIndex), eq(aggregationSlot));\n+  }\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void subscribeToPersistentSubnets_InvokeApi() {\n+    final int subnetId = 1;\n+    final UInt64 slot = UInt64.ONE;\n+\n+    final SubnetSubscription subnetSubscription = new SubnetSubscription(subnetId, slot);\n+    final tech.pegasys.teku.api.schema.SubnetSubscription schemaSubnetSubscription =\n+        new tech.pegasys.teku.api.schema.SubnetSubscription(subnetId, slot);\n+\n+    ArgumentCaptor<Set<tech.pegasys.teku.api.schema.SubnetSubscription>> argumentCaptor =\n+        ArgumentCaptor.forClass(Set.class);\n+\n+    apiHandler.subscribeToPersistentSubnets(Set.of(subnetSubscription));\n+\n+    verify(apiClient).subscribeToPersistentSubnets(argumentCaptor.capture());\n+\n+    final Set<tech.pegasys.teku.api.schema.SubnetSubscription> request = argumentCaptor.getValue();\n+    assertThat(request).hasSize(1);\n+    assertThat(request.stream().findFirst().get())\n+        .usingRecursiveComparison()\n+        .isEqualTo(schemaSubnetSubscription);\n+  }\n+\n+  private <T> Optional<T> unwrapToOptional(SafeFuture<Optional<T>> future) {\n+    try {\n+      return future.get();\n+    } catch (Exception e) {\n+      fail(\"Error unwrapping optional from SafeFuture\", e);\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private <T> T unwrapToValue(SafeFuture<Optional<T>> future) {\n+    try {\n+      return future.get().orElseThrow();\n+    } catch (Exception e) {\n+      fail(\"Error unwrapping value from SafeFuture\", e);\n+      throw new RuntimeException(e);\n+    }\n+  }", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3NTgyMg==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r471975822", "bodyText": "Clever. :)", "author": "ajsutton", "createdAt": "2020-08-18T07:35:59Z", "path": "validator/remote/src/test/java/tech/pegasys/teku/validator/remote/apiclient/SchemaObjectsTestFixture.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote.apiclient;\n+\n+import java.util.List;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.Attestation;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.BLSSignature;\n+import tech.pegasys.teku.api.schema.BeaconBlock;\n+import tech.pegasys.teku.api.schema.SignedAggregateAndProof;\n+import tech.pegasys.teku.api.schema.SignedBeaconBlock;\n+import tech.pegasys.teku.api.schema.SubnetSubscription;\n+import tech.pegasys.teku.api.schema.ValidatorDuties;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+public class SchemaObjectsTestFixture {", "originalCommit": "edff8394c04dc5e9fe96b7a4e1678eaf7e89460b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eab7c59f9c04992eeeba5adbe8f488cae660b7c7", "url": "https://github.com/ConsenSys/teku/commit/eab7c59f9c04992eeeba5adbe8f488cae660b7c7", "message": "PR comments\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-08-19T03:36:12Z", "type": "commit"}, {"oid": "3c41b10f7cf189d798571e1da51f6423c62f3fe1", "url": "https://github.com/ConsenSys/teku/commit/3c41b10f7cf189d798571e1da51f6423c62f3fe1", "message": "Merge branch 'master' into validator-using-apis\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-08-19T03:36:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2NjY4Mg==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r472666682", "bodyText": "Stray semicolon.", "author": "ajsutton", "createdAt": "2020-08-19T04:11:12Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n+import tech.pegasys.teku.datastructures.state.Fork;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.validator.SubnetSubscription;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.service.serviceutils.ServiceConfig;\n+import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n+import tech.pegasys.teku.validator.api.ValidatorDuties;\n+import tech.pegasys.teku.validator.remote.apiclient.OkHttpValidatorRestApiClient;\n+import tech.pegasys.teku.validator.remote.apiclient.ValidatorRestApiClient;\n+\n+public class RemoteValidatorApiHandler implements ValidatorApiChannel {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final ValidatorRestApiClient apiClient;\n+  private final AsyncRunner asyncRunner;\n+\n+  @SuppressWarnings(\"unused\")\n+  public RemoteValidatorApiHandler(final ServiceConfig config, final AsyncRunner asyncRunner) {\n+    // TODO: create config for validator client [https://github.com/PegaSysEng/teku/issues/2450]\n+    apiClient = new OkHttpValidatorRestApiClient(\"http://127.0.0.1:8888\");\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public RemoteValidatorApiHandler(\n+      final ValidatorRestApiClient apiClient, final AsyncRunner asyncRunner) {\n+    this.apiClient = apiClient;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<ForkInfo>> getForkInfo() {\n+    return asyncRunner.runAsync(() -> apiClient.getFork().map(this::mapGetForkResponse));\n+  }\n+\n+  private ForkInfo mapGetForkResponse(final GetForkResponse response) {\n+    final Fork fork = new Fork(response.previous_version, response.current_version, response.epoch);\n+    return new ForkInfo(fork, response.genesis_validators_root);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<List<ValidatorDuties>>> getDuties(\n+      final UInt64 epoch, final Collection<BLSPublicKey> publicKeys) {\n+    if (publicKeys.isEmpty()) {\n+      return SafeFuture.completedFuture(Optional.of(Collections.emptyList()));\n+    }\n+\n+    return asyncRunner.runAsync(\n+        () -> {\n+          final List<BLSPubKey> blsPubKeys =\n+              publicKeys.stream().map(BLSPubKey::new).collect(Collectors.toList());\n+          final ValidatorDutiesRequest validatorDutiesRequest =\n+              new ValidatorDutiesRequest(epoch, blsPubKeys);\n+\n+          final List<ValidatorDuties> validatorDuties =\n+              apiClient.getDuties(validatorDutiesRequest).stream()\n+                  .map(this::mapToApiValidatorDuties)\n+                  .collect(Collectors.toList());\n+\n+          return Optional.of(validatorDuties);\n+        });\n+  }\n+\n+  private ValidatorDuties mapToApiValidatorDuties(\n+      final tech.pegasys.teku.api.schema.ValidatorDuties schemaValidatorDuties) {\n+    return ValidatorDuties.withDuties(\n+        schemaValidatorDuties.validator_pubkey.asBLSPublicKey(),\n+        schemaValidatorDuties.validator_index,\n+        schemaValidatorDuties.attestation_committee_index,\n+        schemaValidatorDuties.attestation_committee_position,\n+        schemaValidatorDuties.aggregator_modulo,\n+        schemaValidatorDuties.block_proposal_slots,\n+        schemaValidatorDuties.attestation_slot);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<Attestation>> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    return asyncRunner.runAsync(\n+        () ->\n+            apiClient\n+                .createUnsignedAttestation(slot, committeeIndex)\n+                .map(tech.pegasys.teku.api.schema.Attestation::asInternalAttestation));\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    asyncRunner\n+        .runAsync(() -> apiClient.sendSignedAttestation(schemaAttestation))\n+        .finish(error -> LOG.error(\"Failed to send signed attestation\", error));\n+    ;", "originalCommit": "3c41b10f7cf189d798571e1da51f6423c62f3fe1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2NjgwNg==", "url": "https://github.com/ConsenSys/teku/pull/2588#discussion_r472666806", "bodyText": "Stray semicolon.", "author": "ajsutton", "createdAt": "2020-08-19T04:11:23Z", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.remote;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.response.GetForkResponse;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.ValidatorDutiesRequest;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n+import tech.pegasys.teku.datastructures.state.Fork;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.validator.SubnetSubscription;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.service.serviceutils.ServiceConfig;\n+import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n+import tech.pegasys.teku.validator.api.ValidatorDuties;\n+import tech.pegasys.teku.validator.remote.apiclient.OkHttpValidatorRestApiClient;\n+import tech.pegasys.teku.validator.remote.apiclient.ValidatorRestApiClient;\n+\n+public class RemoteValidatorApiHandler implements ValidatorApiChannel {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final ValidatorRestApiClient apiClient;\n+  private final AsyncRunner asyncRunner;\n+\n+  @SuppressWarnings(\"unused\")\n+  public RemoteValidatorApiHandler(final ServiceConfig config, final AsyncRunner asyncRunner) {\n+    // TODO: create config for validator client [https://github.com/PegaSysEng/teku/issues/2450]\n+    apiClient = new OkHttpValidatorRestApiClient(\"http://127.0.0.1:8888\");\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public RemoteValidatorApiHandler(\n+      final ValidatorRestApiClient apiClient, final AsyncRunner asyncRunner) {\n+    this.apiClient = apiClient;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<ForkInfo>> getForkInfo() {\n+    return asyncRunner.runAsync(() -> apiClient.getFork().map(this::mapGetForkResponse));\n+  }\n+\n+  private ForkInfo mapGetForkResponse(final GetForkResponse response) {\n+    final Fork fork = new Fork(response.previous_version, response.current_version, response.epoch);\n+    return new ForkInfo(fork, response.genesis_validators_root);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<List<ValidatorDuties>>> getDuties(\n+      final UInt64 epoch, final Collection<BLSPublicKey> publicKeys) {\n+    if (publicKeys.isEmpty()) {\n+      return SafeFuture.completedFuture(Optional.of(Collections.emptyList()));\n+    }\n+\n+    return asyncRunner.runAsync(\n+        () -> {\n+          final List<BLSPubKey> blsPubKeys =\n+              publicKeys.stream().map(BLSPubKey::new).collect(Collectors.toList());\n+          final ValidatorDutiesRequest validatorDutiesRequest =\n+              new ValidatorDutiesRequest(epoch, blsPubKeys);\n+\n+          final List<ValidatorDuties> validatorDuties =\n+              apiClient.getDuties(validatorDutiesRequest).stream()\n+                  .map(this::mapToApiValidatorDuties)\n+                  .collect(Collectors.toList());\n+\n+          return Optional.of(validatorDuties);\n+        });\n+  }\n+\n+  private ValidatorDuties mapToApiValidatorDuties(\n+      final tech.pegasys.teku.api.schema.ValidatorDuties schemaValidatorDuties) {\n+    return ValidatorDuties.withDuties(\n+        schemaValidatorDuties.validator_pubkey.asBLSPublicKey(),\n+        schemaValidatorDuties.validator_index,\n+        schemaValidatorDuties.attestation_committee_index,\n+        schemaValidatorDuties.attestation_committee_position,\n+        schemaValidatorDuties.aggregator_modulo,\n+        schemaValidatorDuties.block_proposal_slots,\n+        schemaValidatorDuties.attestation_slot);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<Attestation>> createUnsignedAttestation(\n+      final UInt64 slot, final int committeeIndex) {\n+    return asyncRunner.runAsync(\n+        () ->\n+            apiClient\n+                .createUnsignedAttestation(slot, committeeIndex)\n+                .map(tech.pegasys.teku.api.schema.Attestation::asInternalAttestation));\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(final Attestation attestation) {\n+    final tech.pegasys.teku.api.schema.Attestation schemaAttestation =\n+        new tech.pegasys.teku.api.schema.Attestation(attestation);\n+\n+    asyncRunner\n+        .runAsync(() -> apiClient.sendSignedAttestation(schemaAttestation))\n+        .finish(error -> LOG.error(\"Failed to send signed attestation\", error));\n+    ;\n+  }\n+\n+  @Override\n+  public void sendSignedAttestation(\n+      final Attestation attestation, final Optional<Integer> validatorIndex) {\n+    sendSignedAttestation(attestation);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<BeaconBlock>> createUnsignedBlock(\n+      final UInt64 slot, final BLSSignature randaoReveal, final Optional<Bytes32> graffiti) {\n+    return asyncRunner.runAsync(\n+        () -> {\n+          final tech.pegasys.teku.api.schema.BLSSignature schemaBLSSignature =\n+              new tech.pegasys.teku.api.schema.BLSSignature(randaoReveal);\n+\n+          return apiClient\n+              .createUnsignedBlock(slot, schemaBLSSignature, graffiti)\n+              .map(tech.pegasys.teku.api.schema.BeaconBlock::asInternalBeaconBlock);\n+        });\n+  }\n+\n+  @Override\n+  public void sendSignedBlock(final SignedBeaconBlock block) {\n+    asyncRunner\n+        .runAsync(\n+            () ->\n+                apiClient.sendSignedBlock(\n+                    new tech.pegasys.teku.api.schema.SignedBeaconBlock(block)))\n+        .finish(error -> LOG.error(\"Failed to send signed block\", error));\n+    ;", "originalCommit": "3c41b10f7cf189d798571e1da51f6423c62f3fe1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b39ec98c715d25c669aa09a19a5116c2e9493e17", "url": "https://github.com/ConsenSys/teku/commit/b39ec98c715d25c669aa09a19a5116c2e9493e17", "message": "Fix unit test\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-08-19T04:14:13Z", "type": "commit"}, {"oid": "f62c491dbe7e877bed1172ae465a548430b6c7ff", "url": "https://github.com/ConsenSys/teku/commit/f62c491dbe7e877bed1172ae465a548430b6c7ff", "message": "Merge branch 'master' into validator-using-apis", "committedDate": "2020-08-19T04:16:26Z", "type": "commit"}]}