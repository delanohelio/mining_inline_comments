{"pr_number": 2772, "pr_title": "Output validator performance", "pr_createdAt": "2020-09-09T14:58:40Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2772", "timeline": [{"oid": "ce428f308d0bfe88869ced2d11220f3ab184e7ac", "url": "https://github.com/ConsenSys/teku/commit/ce428f308d0bfe88869ced2d11220f3ab184e7ac", "message": "Initialize PerformanceTracker", "committedDate": "2020-09-09T13:09:41Z", "type": "commit"}, {"oid": "f5ea00d94291d41739f7e74f6056f2b3c3fa32ce", "url": "https://github.com/ConsenSys/teku/commit/f5ea00d94291d41739f7e74f6056f2b3c3fa32ce", "message": "Calculate attestation and block inclusion info", "committedDate": "2020-09-09T14:54:51Z", "type": "commit"}, {"oid": "8cf92562945167a36f418b176fdc82483a78ee44", "url": "https://github.com/ConsenSys/teku/commit/8cf92562945167a36f418b176fdc82483a78ee44", "message": "Run spotless", "committedDate": "2020-09-09T14:56:05Z", "type": "commit"}, {"oid": "ce9457787da6385464615276bab43345cb1f5b72", "url": "https://github.com/ConsenSys/teku/commit/ce9457787da6385464615276bab43345cb1f5b72", "message": "Fix error", "committedDate": "2020-09-09T14:56:23Z", "type": "commit"}, {"oid": "aa2e20ca15b4ab91b28d8b84d5ba89fda9bdfd96", "url": "https://github.com/ConsenSys/teku/commit/aa2e20ca15b4ab91b28d8b84d5ba89fda9bdfd96", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-09-09T14:59:16Z", "type": "commit"}, {"oid": "38bdb3ee2d4e59a8c6e7a36e36c3b2631e2ee898", "url": "https://github.com/ConsenSys/teku/commit/38bdb3ee2d4e59a8c6e7a36e36c3b2631e2ee898", "message": "Get attestations with their inclusion slot", "committedDate": "2020-09-15T19:06:32Z", "type": "commit"}, {"oid": "e4ad2a48af2810d249b2638b8f2a0b527e574e94", "url": "https://github.com/ConsenSys/teku/commit/e4ad2a48af2810d249b2638b8f2a0b527e574e94", "message": "Get blocks/attesations in range", "committedDate": "2020-09-15T19:06:32Z", "type": "commit"}, {"oid": "76f1dab9cf0b27e21099c85b08bda66202daa58d", "url": "https://github.com/ConsenSys/teku/commit/76f1dab9cf0b27e21099c85b08bda66202daa58d", "message": "Add inclusion distances and correct target/headblock", "committedDate": "2020-09-15T19:06:32Z", "type": "commit"}, {"oid": "774525df739dc5846b1c557c4a5598cbd1412061", "url": "https://github.com/ConsenSys/teku/commit/774525df739dc5846b1c557c4a5598cbd1412061", "message": "Run spotless", "committedDate": "2020-09-15T19:06:32Z", "type": "commit"}, {"oid": "cb110434294cc6c4c011d2552aee5796d5b8d838", "url": "https://github.com/ConsenSys/teku/commit/cb110434294cc6c4c011d2552aee5796d5b8d838", "message": "Run spotless", "committedDate": "2020-09-15T19:06:32Z", "type": "commit"}, {"oid": "eac591ca085f6efc0822c73d9438dcdc7e777f3f", "url": "https://github.com/ConsenSys/teku/commit/eac591ca085f6efc0822c73d9438dcdc7e777f3f", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-09-15T19:06:54Z", "type": "commit"}, {"oid": "ec4ec46e26d1d340d048f0d1905856da7e84b213", "url": "https://github.com/ConsenSys/teku/commit/ec4ec46e26d1d340d048f0d1905856da7e84b213", "message": "Refactor PerformanceTracker", "committedDate": "2020-09-15T20:21:13Z", "type": "commit"}, {"oid": "8fd0b3178c8eb882513b06dfee8c191829ebcf1b", "url": "https://github.com/ConsenSys/teku/commit/8fd0b3178c8eb882513b06dfee8c191829ebcf1b", "message": "Run spotless", "committedDate": "2020-09-15T20:21:13Z", "type": "commit"}, {"oid": "3b75f1fcf599c160da60f085a69224361c614a8e", "url": "https://github.com/ConsenSys/teku/commit/3b75f1fcf599c160da60f085a69224361c614a8e", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-09-15T20:21:27Z", "type": "commit"}, {"oid": "810017e2dba9482ac78f78de50825ea93b03cad3", "url": "https://github.com/ConsenSys/teku/commit/810017e2dba9482ac78f78de50825ea93b03cad3", "message": "Switch sorted map to navigable map", "committedDate": "2020-09-15T20:57:09Z", "type": "commit"}, {"oid": "bd392b2ab39ff0fbd3b98d4f1bb9e97b29daefaf", "url": "https://github.com/ConsenSys/teku/commit/bd392b2ab39ff0fbd3b98d4f1bb9e97b29daefaf", "message": "Do not use deprecated method", "committedDate": "2020-09-15T21:07:02Z", "type": "commit"}, {"oid": "a76c52e517b7338c244d10916735c77505bf3929", "url": "https://github.com/ConsenSys/teku/commit/a76c52e517b7338c244d10916735c77505bf3929", "message": "Integrate and debug PerformanceTracker", "committedDate": "2020-09-16T18:34:58Z", "type": "commit"}, {"oid": "55c770faa461247c011e9d3ef1d8183c32efc801", "url": "https://github.com/ConsenSys/teku/commit/55c770faa461247c011e9d3ef1d8183c32efc801", "message": "Log via STATUS_LOG", "committedDate": "2020-09-16T18:47:44Z", "type": "commit"}, {"oid": "081b6ff6faf7838350de0533bcd4360b0735192a", "url": "https://github.com/ConsenSys/teku/commit/081b6ff6faf7838350de0533bcd4360b0735192a", "message": "Dependency inject STATUS_LOG", "committedDate": "2020-09-16T21:40:52Z", "type": "commit"}, {"oid": "489a60b4964337f0643952136cd89d41e4bc3688", "url": "https://github.com/ConsenSys/teku/commit/489a60b4964337f0643952136cd89d41e4bc3688", "message": "Run spotless", "committedDate": "2020-09-17T17:19:05Z", "type": "commit"}, {"oid": "dd881365e7e5b041d9919f4dac482cca2bcb98a3", "url": "https://github.com/ConsenSys/teku/commit/dd881365e7e5b041d9919f4dac482cca2bcb98a3", "message": "Add tests", "committedDate": "2020-09-17T21:30:23Z", "type": "commit"}, {"oid": "6757f44ed86f3b69f828986b913d0acd2858885f", "url": "https://github.com/ConsenSys/teku/commit/6757f44ed86f3b69f828986b913d0acd2858885f", "message": "Add head/target root tests and CLI toggling", "committedDate": "2020-09-18T16:39:28Z", "type": "commit"}, {"oid": "26d2542b116362f9c0fa51bb37f1a5b9f2003fc5", "url": "https://github.com/ConsenSys/teku/commit/26d2542b116362f9c0fa51bb37f1a5b9f2003fc5", "message": "Run spotless", "committedDate": "2020-09-18T16:40:08Z", "type": "commit"}, {"oid": "571237ec510ef5fde681126ef7fa1d54034951a5", "url": "https://github.com/ConsenSys/teku/commit/571237ec510ef5fde681126ef7fa1d54034951a5", "message": "Merge branch 'master' into outputValidatorPerformance\n\n# Conflicts:\n#\tutil/src/main/java/tech/pegasys/teku/util/config/GlobalConfigurationBuilder.java", "committedDate": "2020-09-18T16:44:40Z", "type": "commit"}, {"oid": "56e725d377dfb1f567f81f236d88df55a3bc6d07", "url": "https://github.com/ConsenSys/teku/commit/56e725d377dfb1f567f81f236d88df55a3bc6d07", "message": "Clear redundant objects", "committedDate": "2020-09-18T17:10:26Z", "type": "commit"}, {"oid": "580646b2e41d7f8ba8de60f9102223286f63061b", "url": "https://github.com/ConsenSys/teku/commit/580646b2e41d7f8ba8de60f9102223286f63061b", "message": "Abstract PerformanceTracker interface", "committedDate": "2020-09-18T18:55:50Z", "type": "commit"}, {"oid": "3c06ccb17849c19b6e9d46ae8554cff819f92e82", "url": "https://github.com/ConsenSys/teku/commit/3c06ccb17849c19b6e9d46ae8554cff819f92e82", "message": "Run spotless", "committedDate": "2020-09-18T18:59:09Z", "type": "commit"}, {"oid": "ebdb7f74c09edf4e3193ddc0ffb4d4b18c549701", "url": "https://github.com/ConsenSys/teku/commit/ebdb7f74c09edf4e3193ddc0ffb4d4b18c549701", "message": "Do not print attestation performance information until ready", "committedDate": "2020-09-18T20:16:25Z", "type": "commit"}, {"oid": "c5ac8cef7cf05f5ac3a032e65fe0f418b1e89df7", "url": "https://github.com/ConsenSys/teku/commit/c5ac8cef7cf05f5ac3a032e65fe0f418b1e89df7", "message": "Run spotless", "committedDate": "2020-09-18T20:17:29Z", "type": "commit"}, {"oid": "9fd35664816acb36fff728e0a4a3a34755722a0d", "url": "https://github.com/ConsenSys/teku/commit/9fd35664816acb36fff728e0a4a3a34755722a0d", "message": "Fix tests and make cosmetic change to CLI", "committedDate": "2020-09-18T21:20:17Z", "type": "commit"}, {"oid": "52b97835a9d52e6773bd5ee42154e504079e42d0", "url": "https://github.com/ConsenSys/teku/commit/52b97835a9d52e6773bd5ee42154e504079e42d0", "message": "Run spotless", "committedDate": "2020-09-18T21:20:48Z", "type": "commit"}, {"oid": "7f18b8a6c31cb04699d8a400fe56cebaeb06e9fe", "url": "https://github.com/ConsenSys/teku/commit/7f18b8a6c31cb04699d8a400fe56cebaeb06e9fe", "message": "Merge branch 'master' into outputValidatorPerformance\n\n# Conflicts:\n#\tteku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java\n#\tteku/src/main/java/tech/pegasys/teku/cli/options/ValidatorOptions.java\n#\tteku/src/main/java/tech/pegasys/teku/cli/subcommand/ValidatorClientCommand.java\n#\tutil/src/main/java/tech/pegasys/teku/util/config/GlobalConfiguration.java\n#\tutil/src/main/java/tech/pegasys/teku/util/config/GlobalConfigurationBuilder.java", "committedDate": "2020-09-21T16:10:56Z", "type": "commit"}, {"oid": "e89b4ab26d2ee042e785db8f01b30742ce99f9bf", "url": "https://github.com/ConsenSys/teku/commit/e89b4ab26d2ee042e785db8f01b30742ce99f9bf", "message": "Fix merge errors", "committedDate": "2020-09-21T16:13:38Z", "type": "commit"}, {"oid": "d73ffe1813d544bb3c419336d4a7a7a568e4fe8d", "url": "https://github.com/ConsenSys/teku/commit/d73ffe1813d544bb3c419336d4a7a7a568e4fe8d", "message": "Run spotless", "committedDate": "2020-09-21T16:21:50Z", "type": "commit"}, {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "url": "https://github.com/ConsenSys/teku/commit/8c2bafcd94ffbffcf7567f67be8000a18ac81490", "message": "Change variable declaration order", "committedDate": "2020-09-21T16:27:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNDIwNA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492324204", "bodyText": "nit, i'd probably use currentSlot", "author": "rolfyone", "createdAt": "2020-09-21T20:23:05Z", "path": "storage/src/testFixtures/java/tech/pegasys/teku/storage/client/ChainUpdater.java", "diffHunk": "@@ -99,6 +99,16 @@ public SignedBlockAndState advanceChain(final long slot) {\n     return advanceChain(UInt64.valueOf(slot));\n   }\n \n+  public SignedBlockAndState advanceChainUntil(final long slot) {\n+    long currSlot = chainBuilder.getLatestSlot().longValue();", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MjAzNQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492992035", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T19:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNDIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNTk3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492325976", "bodyText": "much better off using\nfallbackValue = \"true\",\narity = \"0..1\"\n\nso that --validator-performance-tracking-enabled works to turn it on, and accepts =false to explicitly turn off. lots of examples in p2pOptions, loggingOptions...", "author": "rolfyone", "createdAt": "2020-09-21T20:26:33Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/options/ValidatorOptions.java", "diffHunk": "@@ -81,6 +81,17 @@\n       arity = \"1\")\n   private Bytes32 graffiti;\n \n+  @Option(\n+      names = {\"--validator-performance-tracking-enabled\"},\n+      paramLabel = \"<BOOLEAN>\",\n+      description = \"Enable validator performance tracking and logging\",\n+      arity = \"1\")\n+  private boolean validatorPerformanceTrackingEnabled = false;", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNjQyNg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492326426", "bodyText": "i'd be tempted to fix the locking-enabled while you're there...", "author": "rolfyone", "createdAt": "2020-09-21T20:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNTk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzQzNg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493043436", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T21:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMTEyMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492331121", "bodyText": "is this just an expensive modulo operation?\nif (slot.mod(SLOTS_PER_EPOCH).isGreaterThan(ZERO)) {\nreturn;\n}", "author": "rolfyone", "createdAt": "2020-09-21T20:36:37Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NTMyMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493045321", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T21:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMTEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMzcyOQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492333729", "bodyText": "nit: using long interface, the arithmetic can be currentEpoch.minus(2)", "author": "rolfyone", "createdAt": "2020-09-21T20:41:47Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NTQwNA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493045404", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T21:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMzcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0MTI3Mw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492341273", "bodyText": "looks like a function with taking 2 integers to get the attestation you need. might be worth a private function to clean up this portion so you don't get lost in setup...", "author": "rolfyone", "createdAt": "2020-09-21T20:56:33Z", "path": "validator/coordinator/src/test/java/tech/pegasys/teku/validator/coordinator/performance/PerformanceTrackerTest.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.validator.coordinator.performance.RecentChainDataPerformanceTracker.BLOCK_PERFORMANCE_EVALUATION_INTERVAL;\n+\n+import com.google.common.eventbus.EventBus;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BLSKeyGenerator;\n+import tech.pegasys.teku.bls.BLSKeyPair;\n+import tech.pegasys.teku.core.AttestationGenerator;\n+import tech.pegasys.teku.core.ChainBuilder;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.ChainUpdater;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class PerformanceTrackerTest {\n+\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final StatusLogger log = mock(StatusLogger.class);\n+  private final RecentChainData recentChainData =\n+      MemoryOnlyRecentChainData.create(mock(EventBus.class));\n+  private RecentChainDataPerformanceTracker performanceTracker =\n+      new RecentChainDataPerformanceTracker(recentChainData, log);\n+  private static final List<BLSKeyPair> VALIDATOR_KEYS = BLSKeyGenerator.generateKeyPairs(64);\n+  private final ChainBuilder chainBuilder = ChainBuilder.create(VALIDATOR_KEYS);\n+  private final ChainUpdater chainUpdater = new ChainUpdater(recentChainData, chainBuilder);\n+\n+  @BeforeAll\n+  static void setUp() {\n+    Constants.SLOTS_PER_EPOCH = 4;\n+  }\n+\n+  @BeforeEach\n+  void beforeEach() {\n+    chainUpdater.initializeGenesis();\n+    performanceTracker.start(UInt64.ZERO);\n+  }\n+\n+  @Test\n+  void shouldDisplayPerfectBlockInclusion() {\n+    chainUpdater.updateBestBlock(chainUpdater.advanceChainUntil(10));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(1));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(2));\n+    performanceTracker.onSlot(compute_start_slot_at_epoch(BLOCK_PERFORMANCE_EVALUATION_INTERVAL));\n+    BlockPerformance expectedBlockPerformance = new BlockPerformance(2, 2);\n+    verify(log).performance(expectedBlockPerformance.toString());\n+  }\n+\n+  @Test\n+  void shouldDisplayOneMissedBlock() {\n+    chainUpdater.updateBestBlock(chainUpdater.advanceChainUntil(10));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(1));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(2));\n+    performanceTracker.saveSentBlock(dataStructureUtil.randomSignedBeaconBlock(3));\n+    performanceTracker.onSlot(compute_start_slot_at_epoch(BLOCK_PERFORMANCE_EVALUATION_INTERVAL));\n+    BlockPerformance expectedBlockPerformance = new BlockPerformance(2, 3);\n+    verify(log).performance(expectedBlockPerformance.toString());\n+  }\n+\n+  @Test\n+  void shouldDisplayPerfectAttestationInclusion() {\n+    chainUpdater.updateBestBlock(chainUpdater.advanceChainUntil(1));\n+\n+    ChainBuilder.BlockOptions block1Options = ChainBuilder.BlockOptions.create();\n+    Attestation attestation1 =\n+        chainBuilder\n+            .streamValidAttestationsForBlockAtSlot(2)\n+            .filter(\n+                a ->\n+                    a.getData()\n+                        .getBeacon_block_root()\n+                        .equals(chainBuilder.getBlockAtSlot(1).getRoot()))\n+            .findFirst()\n+            .get();", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0OTExOA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493049118", "bodyText": "Definetely. Done.", "author": "cemozerr", "createdAt": "2020-09-22T21:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0MTI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwOTQwNA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492209404", "bodyText": "Would be nice to get a couple of unit tests for this new method.", "author": "mbaxter", "createdAt": "2020-09-21T16:56:02Z", "path": "infrastructure/unsigned/src/main/java/tech/pegasys/teku/infrastructure/unsigned/UInt64.java", "diffHunk": "@@ -113,6 +113,15 @@ public UInt64 increment() {\n     return plus(1);\n   }\n \n+  /**\n+   * Decrement this value by one and return the result.\n+   *\n+   * @return The result of decrementing this value by 1.\n+   */\n+  public UInt64 decrement() {", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzMDY2Ng==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492930666", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T18:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwOTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIxMDIwNg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492210206", "bodyText": "Do we need this log message?", "author": "mbaxter", "createdAt": "2020-09-21T16:57:25Z", "path": "services/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "diffHunk": "@@ -268,11 +272,24 @@ public void initAll() {\n     initSlotProcessor();\n     initMetrics();\n     initSyncStateTracker();\n+    initPerformanceTracker();\n     initValidatorApiHandler();\n     initRestAPI();\n     initOperationsReOrgManager();\n   }\n \n+  private void initPerformanceTracker() {\n+    LOG.debug(\"BeaconChainController.initPerformanceTracker()\");\n+    if (config.isValidatorPerformanceTrackingEnabled()) {\n+      performanceTracker = new RecentChainDataPerformanceTracker(recentChainData, STATUS_LOG);\n+      eventChannels.subscribe(SlotEventsChannel.class, performanceTracker);\n+    } else {\n+      performanceTracker = new NoOpPerformanceTracker();\n+      LOG.info(", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzMTUxMg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492931512", "bodyText": "I can see how its redundant. Removing it.", "author": "cemozerr", "createdAt": "2020-09-22T18:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIxMDIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNDI1OA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492304258", "bodyText": "Do we not want to track aggregate attestations?", "author": "mbaxter", "createdAt": "2020-09-21T19:44:32Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "diffHunk": "@@ -351,12 +356,13 @@ public void sendAggregateAndProof(final SignedAggregateAndProof aggregateAndProo\n     attestationManager\n         .onAttestation(ValidateableAttestation.fromSignedAggregate(aggregateAndProof))\n         .finish(\n-            result ->\n-                result.ifInvalid(\n-                    reason ->\n-                        VALIDATOR_LOGGER.producedInvalidAggregate(\n-                            aggregateAndProof.getMessage().getAggregate().getData().getSlot(),\n-                            reason)),\n+            result -> {\n+              result.ifInvalid(", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzMjI1OA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492932258", "bodyText": "I believe there is no reward for aggregating attestations. So displaying aggregated attestations in attestation effectiveness just wrongfully skews the result.", "author": "cemozerr", "createdAt": "2020-09-22T18:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNDI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzMjM5Mw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492932393", "bodyText": "But would be nice to get @benjaminion's input.", "author": "cemozerr", "createdAt": "2020-09-22T18:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNDI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcxNDkwOQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493714909", "bodyText": "I'm not really sure of a good metric around aggregations.", "author": "benjaminion", "createdAt": "2020-09-23T16:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNDI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNTI0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492305249", "bodyText": "Should we track the result here, so we can get stats on invalid attestations produced?", "author": "mbaxter", "createdAt": "2020-09-21T19:46:18Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "diffHunk": "@@ -324,6 +328,7 @@ public void sendSignedAttestation(\n                           expectedValidatorIndex,\n                           reason));\n               dutyMetrics.onAttestationPublished(attestation.getData().getSlot());\n+              performanceTracker.saveSentAttestation(attestation);", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzNTI0MA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492935240", "bodyText": "Tracking the result would be nice in terms of explaining why some attestations were not included on-chain, but they're already logged on an error level so I think that might be redundant.", "author": "cemozerr", "createdAt": "2020-09-22T18:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwODM4Ng==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492308386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        + \" - Number of sent attestations: %d\\n\"\n          \n          \n            \n                        + \" - Number of attestations included on chain: %d\\n\"\n          \n          \n            \n                        + \" - %%age of inclusion at: %d%%\\n\"\n          \n          \n            \n                        + \" - Inclusion distances: average: %f, min: %d, max: %d\\n\"\n          \n          \n            \n                        + \" - %%age with correct target at: %d%%\\n\"\n          \n          \n            \n                        + \" - %%age with correct head block root at: %d%%\",\n          \n          \n            \n                        + \" - Number of sent attestations: %d\\n\"\n          \n          \n            \n                        + \" - Number of sent attestations included on chain: %d\\n\"\n          \n          \n            \n                        + \" - Percentage of sent attestations included on chain: %d%%\\n\"\n          \n          \n            \n                        + \" - Inclusion distances: average: %f, min: %d, max: %d\\n\"\n          \n          \n            \n                        + \" - Percentage of sent attestations with correct target at: %d%%\\n\"\n          \n          \n            \n                        + \" - Percentage of sent attestations with correct head block root at: %d%%\",", "author": "mbaxter", "createdAt": "2020-09-21T19:52:22Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/AttestationPerformance.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static tech.pegasys.teku.validator.coordinator.performance.RecentChainDataPerformanceTracker.getPercentage;\n+\n+import com.google.common.base.Objects;\n+\n+public class AttestationPerformance {\n+  private final int numberOfSentAttestations;\n+  private final int numberOfIncludedAttestations;\n+  private final int inclusionDistanceMax;\n+  private final int inclusionDistanceMin;\n+  private final double inclusionDistanceAverage;\n+  private final double correctTargetCount;\n+  private final double correctHeadBlockCount;\n+\n+  public AttestationPerformance(\n+      int numberOfSentAttestations,\n+      int numberOfIncludedAttestations,\n+      int inclusionDistanceMax,\n+      int inclusionDistanceMin,\n+      double inclusionDistanceAverage,\n+      double correctTargetCount,\n+      double correctHeadBlockCount) {\n+    this.numberOfSentAttestations = numberOfSentAttestations;\n+    this.numberOfIncludedAttestations = numberOfIncludedAttestations;\n+    this.inclusionDistanceMax = inclusionDistanceMax;\n+    this.inclusionDistanceMin = inclusionDistanceMin;\n+    this.inclusionDistanceAverage = inclusionDistanceAverage;\n+    this.correctTargetCount = correctTargetCount;\n+    this.correctHeadBlockCount = correctHeadBlockCount;\n+  }\n+\n+  public static AttestationPerformance empty() {\n+    return new AttestationPerformance(0, 0, 0, 0, 0, 0, 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (!(o instanceof AttestationPerformance)) return false;\n+    AttestationPerformance that = (AttestationPerformance) o;\n+    return numberOfSentAttestations == that.numberOfSentAttestations\n+        && numberOfIncludedAttestations == that.numberOfIncludedAttestations\n+        && inclusionDistanceMax == that.inclusionDistanceMax\n+        && inclusionDistanceMin == that.inclusionDistanceMin\n+        && Double.compare(that.inclusionDistanceAverage, inclusionDistanceAverage) == 0\n+        && Double.compare(that.correctTargetCount, correctTargetCount) == 0\n+        && Double.compare(that.correctHeadBlockCount, correctHeadBlockCount) == 0;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(\n+        numberOfSentAttestations,\n+        numberOfIncludedAttestations,\n+        inclusionDistanceMax,\n+        inclusionDistanceMin,\n+        inclusionDistanceAverage,\n+        correctTargetCount,\n+        correctHeadBlockCount);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\n+        \"\\n ===== Attestation Performance Information ===== \\n\"\n+            + \" - Number of sent attestations: %d\\n\"\n+            + \" - Number of attestations included on chain: %d\\n\"\n+            + \" - %%age of inclusion at: %d%%\\n\"\n+            + \" - Inclusion distances: average: %f, min: %d, max: %d\\n\"\n+            + \" - %%age with correct target at: %d%%\\n\"\n+            + \" - %%age with correct head block root at: %d%%\",", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzNjMyNA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492936324", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T18:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwODM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwOTIzMg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492309232", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        + \" - Number of sent blocks: %d\\n\"\n          \n          \n            \n                        + \" - Number of blocks included on chain: %d\\n\"\n          \n          \n            \n                        + \" - %%age of inclusion at: %d%%\",\n          \n          \n            \n                        + \" - Number of sent blocks: %d\\n\"\n          \n          \n            \n                        + \" - Number of sent blocks included on chain: %d\\n\"\n          \n          \n            \n                        + \" - Percentage of sent blocks included on chain: %d%%\",", "author": "mbaxter", "createdAt": "2020-09-21T19:54:11Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/BlockPerformance.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static tech.pegasys.teku.validator.coordinator.performance.RecentChainDataPerformanceTracker.getPercentage;\n+\n+import com.google.common.base.Objects;\n+\n+public class BlockPerformance {\n+  private final int numberOfIncludedBlocks;\n+  private final int numberOfSentBlocks;\n+\n+  public BlockPerformance(int numberOfIncludedBlocks, int numberOfSentBlocks) {\n+    this.numberOfIncludedBlocks = numberOfIncludedBlocks;\n+    this.numberOfSentBlocks = numberOfSentBlocks;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (!(o instanceof BlockPerformance)) return false;\n+    BlockPerformance that = (BlockPerformance) o;\n+    return numberOfIncludedBlocks == that.numberOfIncludedBlocks\n+        && numberOfSentBlocks == that.numberOfSentBlocks;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(numberOfIncludedBlocks, numberOfSentBlocks);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\n+        \"\\n ===== Block Performance Information ===== \\n\"\n+            + \" - Number of sent blocks: %d\\n\"\n+            + \" - Number of blocks included on chain: %d\\n\"\n+            + \" - %%age of inclusion at: %d%%\",", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4NTAwOQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492985009", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T19:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwOTIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwOTc1NQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492309755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n          \n          \n            \n            public class DefaultPerformanceTracker implements PerformanceTracker {", "author": "mbaxter", "createdAt": "2020-09-21T19:55:10Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzNjc4Mw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492936783", "bodyText": "Nice suggestion. Done.", "author": "cemozerr", "createdAt": "2020-09-22T18:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwOTc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMDMwOA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492310308", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n          \n          \n            \n                if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(2))) {", "author": "mbaxter", "createdAt": "2020-09-21T19:56:14Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzNzUxNw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492937517", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T18:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMDMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjEzMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492316131", "bodyText": "This looks like an expensive check.  What about calling recentChainData.getBlockRootBySlot(block.getSlot()) for each block and checking for a match?", "author": "mbaxter", "createdAt": "2020-09-21T20:07:18Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0MDQ4OQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492940489", "bodyText": "Yeah that definitely makes more sense.", "author": "cemozerr", "createdAt": "2020-09-22T18:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4ODQxOA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492988418", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-22T19:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyMTYwMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492321601", "bodyText": "Might be good to have the 2-epoch value saved as a constant since it's used throughout\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));\n          \n          \n            \n                UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);", "author": "mbaxter", "createdAt": "2020-09-21T20:17:49Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .map(SignedBeaconBlock::getMessage)\n+            .filter(blockInEpoch::contains)\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(UInt64.valueOf(2))),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4OTE3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492989176", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-22T19:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyMTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MTgwMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492361801", "bodyText": "We already have a utility recentChainData.getBlockRootBySlot - we could add a similar one for checking the root at an epoch boundary:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n          \n          \n            \n                  final Optional<Bytes32> rootAtEpoch = recentChainData.getBlockRootByEpoch(state, analyzedEpoch);\n          \n          \n            \n                  if (rootAtEpoch.map(r -> r.equals(attestationTargetRoot).orElse(false)) {\n          \n      \n    \n    \n  \n\nAlthough, maybe we could run into an issue with data getting pruned out from under us?", "author": "mbaxter", "createdAt": "2020-09-21T21:40:25Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .map(SignedBeaconBlock::getMessage)\n+            .filter(blockInEpoch::contains)\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(UInt64.valueOf(2))),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = recentChainData.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {\n+      // Check if the sent attestation is included in any block in the appropriate range.\n+      // Appropriate range being: [ attestation_production_epoch, attestation_production_epoch + 1 ]\n+      UInt64 attestationSlot = sentAttestation.getData().getSlot();\n+      for (UInt64 currSlot = analyzedEpochStartSlot;\n+          currSlot.isLessThan(rangeEndSlot);\n+          currSlot = currSlot.increment()) {\n+        if (attestations.containsKey(currSlot)) {\n+          if (checkIfAttestationIsIncludedInList(sentAttestation, attestations.get(currSlot))) {\n+            inclusionDistances.add(currSlot.minus(attestationSlot).intValue());\n+          }\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MTQ1Ng==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492991456", "bodyText": "This is not an option anymore since we switched to CombinedChainDataClient.", "author": "cemozerr", "createdAt": "2020-09-22T19:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MTgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2ODE2NA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492368164", "bodyText": "Wondering if instead of looking up all of the recent attestations here, we should instead be listening for blocks as they're imported and saving any relevant information as we go?  Maybe we could do something like keep a mapping from epoch -> attestationDataHash -> BlockHashAndAttesterBits[]?", "author": "mbaxter", "createdAt": "2020-09-21T21:55:46Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .map(SignedBeaconBlock::getMessage)\n+            .filter(blockInEpoch::contains)\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(UInt64.valueOf(2))),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);", "originalCommit": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0OTI4Mw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492949283", "bodyText": "That would mean we'd need to deal with re-orgs which could make this pretty complex. The maximum amount of attestations that can be included in an epoch is 4096, so in two epochs 8k items. I don't think we need to be too concerned about the performance impact of this.", "author": "cemozerr", "createdAt": "2020-09-22T18:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2ODE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMjQwNA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493812404", "bodyText": "I was thinking when we go to actually output the performance metrics, we would filter out any irrelevant results by looking up whether the block hash is considered canonical.  This would be a big rework, so if anything we could possibly tackle this in a follow-up.", "author": "mbaxter", "createdAt": "2020-09-23T18:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2ODE2NA=="}], "type": "inlineReview"}, {"oid": "f469b35e83c22d7ab7b0a2df3c1c93d6f11b9b50", "url": "https://github.com/ConsenSys/teku/commit/f469b35e83c22d7ab7b0a2df3c1c93d6f11b9b50", "message": "Add tests for decrement", "committedDate": "2020-09-22T18:00:24Z", "type": "commit"}, {"oid": "8a4db11ba636157ec0e122fd9e33cac4a007e8b3", "url": "https://github.com/ConsenSys/teku/commit/8a4db11ba636157ec0e122fd9e33cac4a007e8b3", "message": "Remove redundant log message", "committedDate": "2020-09-22T18:02:03Z", "type": "commit"}, {"oid": "e4c6de184e605b1e1585bdceb4470f6cbc29154c", "url": "https://github.com/ConsenSys/teku/commit/e4c6de184e605b1e1585bdceb4470f6cbc29154c", "message": "Change output string", "committedDate": "2020-09-22T18:10:31Z", "type": "commit"}, {"oid": "8a295e1d36e1acc788ac2fcd901d9ce9db402c94", "url": "https://github.com/ConsenSys/teku/commit/8a295e1d36e1acc788ac2fcd901d9ce9db402c94", "message": "Change performance tracker class name", "committedDate": "2020-09-22T18:11:16Z", "type": "commit"}, {"oid": "24976f97a7a4690f1de94018189675a4d9dedb92", "url": "https://github.com/ConsenSys/teku/commit/24976f97a7a4690f1de94018189675a4d9dedb92", "message": "Switch to combined chain data client", "committedDate": "2020-09-22T19:34:04Z", "type": "commit"}, {"oid": "b5386bb5f7f07c8f65c9ec850812f607ec563ea1", "url": "https://github.com/ConsenSys/teku/commit/b5386bb5f7f07c8f65c9ec850812f607ec563ea1", "message": "Chage block performance string", "committedDate": "2020-09-22T19:34:52Z", "type": "commit"}, {"oid": "63b6e0549870f583da9e67d8ac8813cd5927924d", "url": "https://github.com/ConsenSys/teku/commit/63b6e0549870f583da9e67d8ac8813cd5927924d", "message": "Save two epoch value as constant", "committedDate": "2020-09-22T19:43:07Z", "type": "commit"}, {"oid": "2c2acea3ada0f3470a6c1a26b9cfa90203b6e72e", "url": "https://github.com/ConsenSys/teku/commit/2c2acea3ada0f3470a6c1a26b9cfa90203b6e72e", "message": "Change currSlot to current and add CLI fallback value", "committedDate": "2020-09-22T21:27:34Z", "type": "commit"}, {"oid": "5c00e1c4bcf7719c3cee58a61141ac3061a8f40b", "url": "https://github.com/ConsenSys/teku/commit/5c00e1c4bcf7719c3cee58a61141ac3061a8f40b", "message": "Clean up test code", "committedDate": "2020-09-22T21:40:09Z", "type": "commit"}, {"oid": "7be71de390007e37d3d00b227e6cda85ee8298b7", "url": "https://github.com/ConsenSys/teku/commit/7be71de390007e37d3d00b227e6cda85ee8298b7", "message": "Run spotless", "committedDate": "2020-09-22T21:40:48Z", "type": "commit"}, {"oid": "cdd18be23d9957ae947ef3456a122438df49e37f", "url": "https://github.com/ConsenSys/teku/commit/cdd18be23d9957ae947ef3456a122438df49e37f", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-09-22T21:45:18Z", "type": "commit"}, {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0", "url": "https://github.com/ConsenSys/teku/commit/f767397a919e8eb1e86a8201697a03c492aed4e0", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-09-23T14:28:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczNDQ0MA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493734440", "bodyText": "(optional) Might be nice to optimize this by just pulling the root.", "author": "mbaxter", "createdAt": "2020-09-23T16:37:14Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())", "originalCommit": "f767397a919e8eb1e86a8201697a03c492aed4e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1MDQ0Ng==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493750446", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Set<BeaconBlock> blockRootsInEpoch = new HashSet<>();\n          \n          \n            \n                Set<BeaconBlock> blocksInEpoch = new HashSet<>();", "author": "mbaxter", "createdAt": "2020-09-23T17:03:02Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {\n+      // Check if the sent attestation is included in any block in the appropriate range.\n+      // Appropriate range being: [ attestation_production_epoch, attestation_production_epoch + 1 ]\n+      UInt64 attestationSlot = sentAttestation.getData().getSlot();\n+      for (UInt64 currSlot = analyzedEpochStartSlot;\n+          currSlot.isLessThan(rangeEndSlot);\n+          currSlot = currSlot.increment()) {\n+        if (attestations.containsKey(currSlot)) {\n+          if (checkIfAttestationIsIncludedInList(sentAttestation, attestations.get(currSlot))) {\n+            inclusionDistances.add(currSlot.minus(attestationSlot).intValue());\n+          }\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n+        correctTargetCount++;\n+\n+        // Check if the attestation had correct head block root\n+        Bytes32 attestationHeadBlockRoot = sentAttestation.getData().getBeacon_block_root();\n+        if (attestationHeadBlockRoot.equals(get_block_root_at_slot(state, attestationSlot))) {\n+          correctHeadBlockCount++;\n+        }\n+      }\n+    }\n+\n+    IntSummaryStatistics inclusionDistanceStatistics =\n+        inclusionDistances.stream().collect(Collectors.summarizingInt(Integer::intValue));\n+\n+    // IntSummaryStatistics returns Integer.MIN and MAX when the summarizend integer list is empty.\n+    return sentAttestations.size() > 0\n+        ? new AttestationPerformance(\n+            sentAttestations.size(),\n+            (int) inclusionDistanceStatistics.getCount(),\n+            inclusionDistanceStatistics.getMax(),\n+            inclusionDistanceStatistics.getMin(),\n+            inclusionDistanceStatistics.getAverage(),\n+            correctTargetCount,\n+            correctHeadBlockCount)\n+        : AttestationPerformance.empty();\n+  }\n+\n+  private boolean checkIfAttestationIsIncludedInList(\n+      Attestation sentAttestation, List<Attestation> aggregateAttestations) {\n+    for (Attestation aggregateAttestation : aggregateAttestations) {\n+      if (checkIfAttestationIsIncludedIn(sentAttestation, aggregateAttestation)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean checkIfAttestationIsIncludedIn(\n+      Attestation sentAttestation, Attestation aggregateAttestation) {\n+    return sentAttestation.getData().equals(aggregateAttestation.getData())\n+        && aggregateAttestation\n+            .getAggregation_bits()\n+            .isSuperSetOf(sentAttestation.getAggregation_bits());\n+  }\n+\n+  private Set<BeaconBlock> getBlocksInEpochs(UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    UInt64 epochStartSlot = compute_start_slot_at_epoch(startEpochInclusive);\n+    UInt64 endEpochStartSlot = compute_start_slot_at_epoch(endEpochExclusive);\n+\n+    Set<BeaconBlock> blockRootsInEpoch = new HashSet<>();", "originalCommit": "f767397a919e8eb1e86a8201697a03c492aed4e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODM1MQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493848351", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-23T19:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1MDQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1MzgwMg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493753802", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (UInt64 currSlot = analyzedEpochStartSlot;\n          \n          \n            \n                  for (UInt64 currSlot = attestationSlot.plus(1);", "author": "mbaxter", "createdAt": "2020-09-23T17:08:43Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {\n+      // Check if the sent attestation is included in any block in the appropriate range.\n+      // Appropriate range being: [ attestation_production_epoch, attestation_production_epoch + 1 ]\n+      UInt64 attestationSlot = sentAttestation.getData().getSlot();\n+      for (UInt64 currSlot = analyzedEpochStartSlot;", "originalCommit": "f767397a919e8eb1e86a8201697a03c492aed4e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODgwNg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493848806", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-23T19:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1MzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODg1OQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493848859", "bodyText": "Good idea btw.", "author": "cemozerr", "createdAt": "2020-09-23T19:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1MzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1NTgxMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493755811", "bodyText": "(nit) Might make sense to pull this farther down where it's actually used (after we loop through all of the attestations).", "author": "mbaxter", "createdAt": "2020-09-23T17:12:06Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();", "originalCommit": "f767397a919e8eb1e86a8201697a03c492aed4e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MjM0Ng==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493852346", "bodyText": "but then we'd be requesting a BeaconState object from combinedChainDataClient for every attestation in the for loop", "author": "cemozerr", "createdAt": "2020-09-23T19:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1NTgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjQwNg==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493856406", "bodyText": "ah - makes sense", "author": "mbaxter", "createdAt": "2020-09-23T19:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1NTgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MTY4MQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493771681", "bodyText": "Let's say we're running 1000 validators.  In the worst case we'd be looping over 2000 attestations (1 attestation per validator per epoch), and then looping through 8192 attestations looking for matches, which is 16,384,000 operations.  That seems like a lot of processing ...\nWhat if we do some preprocessing on the list of attestations to build a map from attestationDataHash -> slot -> aggregationBitSet?  Then the inner loop will have at most 64 elements.", "author": "mbaxter", "createdAt": "2020-09-23T17:38:09Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {", "originalCommit": "f767397a919e8eb1e86a8201697a03c492aed4e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4OTYzMA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r494389630", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-24T14:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MTY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwMzIxMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493803211", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void decrement_shouldThrowArithmeticExceptionWhenResultOverflows() {\n          \n          \n            \n              void decrement_shouldThrowArithmeticExceptionWhenResultUnderflows() {", "author": "mbaxter", "createdAt": "2020-09-23T18:31:18Z", "path": "infrastructure/unsigned/src/test/java/tech/pegasys/teku/infrastructure/unsigned/UInt64Test.java", "diffHunk": "@@ -239,6 +239,17 @@ void increment_shouldThrowArithmeticExceptionWhenResultOverflows() {\n     assertThatThrownBy(UInt64.MAX_VALUE::increment).isInstanceOf(ArithmeticException.class);\n   }\n \n+  @Test\n+  void decrement() {\n+    assertThat(UInt64.ONE.decrement()).isEqualTo(UInt64.ZERO);\n+    assertThat(UInt64.valueOf(3).decrement().decrement()).isEqualTo(UInt64.ONE);\n+  }\n+\n+  @Test\n+  void decrement_shouldThrowArithmeticExceptionWhenResultOverflows() {", "originalCommit": "f767397a919e8eb1e86a8201697a03c492aed4e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MzU5MQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493853591", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-23T19:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwMzIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDY1OA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493804658", "bodyText": "We should probably add a few tests for this to ValidatorOptionsTest", "author": "mbaxter", "createdAt": "2020-09-23T18:33:49Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/options/ValidatorOptions.java", "diffHunk": "@@ -81,6 +81,18 @@\n       arity = \"1\")\n   private Bytes32 graffiti;\n \n+  @Option(\n+      names = {\"--validator-performance-tracking-enabled\"},\n+      paramLabel = \"<BOOLEAN>\",\n+      description = \"Enable validator performance tracking and logging\",\n+      fallbackValue = \"true\",\n+      arity = \"0..1\")\n+  private boolean validatorPerformanceTrackingEnabled = false;", "originalCommit": "f767397a919e8eb1e86a8201697a03c492aed4e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMTE1NQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r494401155", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-24T15:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDY1OA=="}], "type": "inlineReview"}, {"oid": "eb2e2d0af642d31c95a7f7070b5467c9037a2607", "url": "https://github.com/ConsenSys/teku/commit/eb2e2d0af642d31c95a7f7070b5467c9037a2607", "message": "Fix the arithmetic exception", "committedDate": "2020-09-23T18:57:44Z", "type": "commit"}, {"oid": "97abe576fbed4493b7faca159a7c4dfedfffa28e", "url": "https://github.com/ConsenSys/teku/commit/97abe576fbed4493b7faca159a7c4dfedfffa28e", "message": "Only count duplicate inclusions once", "committedDate": "2020-09-23T19:17:56Z", "type": "commit"}, {"oid": "79a7c1c995aae80e0939ea5b7848faf57a97af5d", "url": "https://github.com/ConsenSys/teku/commit/79a7c1c995aae80e0939ea5b7848faf57a97af5d", "message": "Add tests for duplicate attestation counting", "committedDate": "2020-09-23T19:36:10Z", "type": "commit"}, {"oid": "304efd8b0568cdfbe93db3300322b3a6b3ccb529", "url": "https://github.com/ConsenSys/teku/commit/304efd8b0568cdfbe93db3300322b3a6b3ccb529", "message": "Run spotless", "committedDate": "2020-09-23T19:36:41Z", "type": "commit"}, {"oid": "0babef8d89d115b75779c94deab5df80ff2315a8", "url": "https://github.com/ConsenSys/teku/commit/0babef8d89d115b75779c94deab5df80ff2315a8", "message": "Pre-process attestations to avoid expensive inclusion checks", "committedDate": "2020-09-24T14:20:41Z", "type": "commit"}, {"oid": "e99a715a62e87fd4d91caf41822ee1fd22252abf", "url": "https://github.com/ConsenSys/teku/commit/e99a715a62e87fd4d91caf41822ee1fd22252abf", "message": "Make sure to find the minimum inclusion distance for duplicate attestations", "committedDate": "2020-09-24T14:50:52Z", "type": "commit"}, {"oid": "988d494b8fae63572b4312c76a52dee4cd89bc0c", "url": "https://github.com/ConsenSys/teku/commit/988d494b8fae63572b4312c76a52dee4cd89bc0c", "message": "Run spotless", "committedDate": "2020-09-24T14:51:19Z", "type": "commit"}, {"oid": "2f26a335609563ebda91fdcdc8df2d13fc62e35f", "url": "https://github.com/ConsenSys/teku/commit/2f26a335609563ebda91fdcdc8df2d13fc62e35f", "message": "Add validator option test", "committedDate": "2020-09-24T15:12:36Z", "type": "commit"}, {"oid": "0ead970b8a0f22074226ef9b0636e60803456abf", "url": "https://github.com/ConsenSys/teku/commit/0ead970b8a0f22074226ef9b0636e60803456abf", "message": "Run spotless", "committedDate": "2020-09-24T15:13:00Z", "type": "commit"}, {"oid": "1b489f4afd4d88dc22ba450f8c89e262847d4005", "url": "https://github.com/ConsenSys/teku/commit/1b489f4afd4d88dc22ba450f8c89e262847d4005", "message": "Add validator performance metrics", "committedDate": "2020-09-24T18:29:14Z", "type": "commit"}, {"oid": "ee3f9231d7a81eabc70aa5277d9c886617aef7c9", "url": "https://github.com/ConsenSys/teku/commit/ee3f9231d7a81eabc70aa5277d9c886617aef7c9", "message": "Run spotless", "committedDate": "2020-09-24T18:30:04Z", "type": "commit"}, {"oid": "28256385cba9b4bdd235bf63e7f8650c44392221", "url": "https://github.com/ConsenSys/teku/commit/28256385cba9b4bdd235bf63e7f8650c44392221", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-09-24T18:41:00Z", "type": "commit"}, {"oid": "10c2471cf03bc5cd0937086fb6ce6b7d3e1f1bc7", "url": "https://github.com/ConsenSys/teku/commit/10c2471cf03bc5cd0937086fb6ce6b7d3e1f1bc7", "message": "Only report block performance if non-zero blocks were produced", "committedDate": "2020-09-24T18:59:06Z", "type": "commit"}, {"oid": "3e48ef815be489c4c41c06cdda3ec5954568f3db", "url": "https://github.com/ConsenSys/teku/commit/3e48ef815be489c4c41c06cdda3ec5954568f3db", "message": "Fix all zeros error", "committedDate": "2020-09-29T18:23:19Z", "type": "commit"}, {"oid": "75205376ae73b01fc23951e18e64e122d8f18872", "url": "https://github.com/ConsenSys/teku/commit/75205376ae73b01fc23951e18e64e122d8f18872", "message": "Run spotless", "committedDate": "2020-09-29T18:24:12Z", "type": "commit"}, {"oid": "d89d94da8c77ca9a35442f63be9a21eab8e3033e", "url": "https://github.com/ConsenSys/teku/commit/d89d94da8c77ca9a35442f63be9a21eab8e3033e", "message": "Remove testing logs", "committedDate": "2020-09-29T19:38:00Z", "type": "commit"}, {"oid": "31e73429067a80f5007c221213727ebdb371d272", "url": "https://github.com/ConsenSys/teku/commit/31e73429067a80f5007c221213727ebdb371d272", "message": "Merge remote-tracking branch 'remotes/origin/master' into outputValidatorPerformance\n\n# Conflicts:\n#\tservices/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "committedDate": "2020-09-29T19:40:50Z", "type": "commit"}, {"oid": "a0cb333ccbd8cbeef08a461819390b58f991415d", "url": "https://github.com/ConsenSys/teku/commit/a0cb333ccbd8cbeef08a461819390b58f991415d", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-09-29T20:45:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzMzY3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497033677", "bodyText": "I'd suggest using an AtomicReference<UInt64> so we don't have to mess with the long value conversion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n          \n          \n            \n                if (currentEpoch.isLessThanOrEqualTo(latestAnalyzedEpoch.getAndSet(currentEpoch))) {", "author": "mbaxter", "createdAt": "2020-09-29T20:40:07Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {", "originalCommit": "31e73429067a80f5007c221213727ebdb371d272", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzOTE3OA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497039178", "bodyText": "Even better, you can use getAndUpdate to make sure latestAnalyzedEpoch only ever increases:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n          \n          \n            \n                if (currentEpoch.isLessThanOrEqualTo(latestAnalyzedEpoch.getAndUpdate(val -> val.isLessThan(currentEpoch) ? currentEpoch : val))) {", "author": "mbaxter", "createdAt": "2020-09-29T20:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzMzY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzNDc2OA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498334768", "bodyText": "That's a great suggestion. Done.", "author": "cemozerr", "createdAt": "2020-10-01T15:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzMzY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0Nzc4NQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497047785", "bodyText": "We can be a bit more efficient here if we pull blocks with getBlockInEffectAtSlot in a while loop and manually update the current slot.  That will avoid extra calls when blocks are skipped.", "author": "mbaxter", "createdAt": "2020-09-29T20:53:55Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        slotToBitlists.put(slot, attestation.getAggregation_bits());\n+      }\n+    }\n+\n+    for (Attestation sentAttestation : producedAttestations) {\n+      Bytes32 sentAttestationDataHash = sentAttestation.getData().hash_tree_root();\n+      UInt64 sentAttestationSlot = sentAttestation.getData().getSlot();\n+      if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) continue;\n+      NavigableMap<UInt64, Bitlist> slotAndBitlists =\n+          slotAndBitlistsByAttestationDataHash.get(sentAttestationDataHash);\n+      for (UInt64 slot : slotAndBitlists.keySet()) {\n+        if (slotAndBitlists.get(slot).isSuperSetOf(sentAttestation.getAggregation_bits())) {\n+          inclusionDistances.add(slot.minus(sentAttestationSlot).intValue());\n+          break;\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n+        correctTargetCount++;\n+\n+        // Check if the attestation had correct head block root\n+        Bytes32 attestationHeadBlockRoot = sentAttestation.getData().getBeacon_block_root();\n+        if (attestationHeadBlockRoot.equals(get_block_root_at_slot(state, sentAttestationSlot))) {\n+          correctHeadBlockCount++;\n+        }\n+      }\n+    }\n+\n+    IntSummaryStatistics inclusionDistanceStatistics =\n+        inclusionDistances.stream().collect(Collectors.summarizingInt(Integer::intValue));\n+\n+    // IntSummaryStatistics returns Integer.MIN and MAX when the summarized integer list is empty.\n+    return producedAttestations.size() > 0\n+        ? new AttestationPerformance(\n+            producedAttestations.size(),\n+            (int) inclusionDistanceStatistics.getCount(),\n+            inclusionDistanceStatistics.getMax(),\n+            inclusionDistanceStatistics.getMin(),\n+            inclusionDistanceStatistics.getAverage(),\n+            correctTargetCount,\n+            correctHeadBlockCount)\n+        : AttestationPerformance.empty();\n+  }\n+\n+  private Set<BeaconBlock> getBlocksInEpochs(UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    UInt64 epochStartSlot = compute_start_slot_at_epoch(startEpochInclusive);\n+    UInt64 endEpochStartSlot = compute_start_slot_at_epoch(endEpochExclusive);\n+\n+    Set<BeaconBlock> blocksInEpoch = new HashSet<>();\n+    for (UInt64 currSlot = epochStartSlot;\n+        currSlot.isLessThan(endEpochStartSlot);\n+        currSlot = currSlot.increment()) {\n+      combinedChainDataClient\n+          .getBlockAtSlotExact(currSlot)\n+          .join()\n+          .ifPresent(signedBlock -> blocksInEpoch.add(signedBlock.getMessage()));\n+    }", "originalCommit": "a0cb333ccbd8cbeef08a461819390b58f991415d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2NTI0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498365249", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-10-01T16:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0Nzc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MjYzMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497062631", "bodyText": "Can't we have multiple attestations with the same attestation data and different bits sets?  I think we need to accumulate all of the bits into a single Bitlist instead of overwriting.", "author": "mbaxter", "createdAt": "2020-09-29T21:12:22Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        slotToBitlists.put(slot, attestation.getAggregation_bits());", "originalCommit": "a0cb333ccbd8cbeef08a461819390b58f991415d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0MTE4Mw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498341183", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-10-01T15:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MjYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1MzYzMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498353631", "bodyText": "Added a test for it as well.", "author": "cemozerr", "createdAt": "2020-10-01T15:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MjYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzE1NQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497063155", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) continue;\n          \n          \n            \n                  if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) {\n          \n          \n            \n                    continue;\n          \n          \n            \n                  }", "author": "mbaxter", "createdAt": "2020-09-29T21:13:25Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        slotToBitlists.put(slot, attestation.getAggregation_bits());\n+      }\n+    }\n+\n+    for (Attestation sentAttestation : producedAttestations) {\n+      Bytes32 sentAttestationDataHash = sentAttestation.getData().hash_tree_root();\n+      UInt64 sentAttestationSlot = sentAttestation.getData().getSlot();\n+      if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) continue;", "originalCommit": "a0cb333ccbd8cbeef08a461819390b58f991415d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1NDAwNw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498354007", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-10-01T15:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzA1NQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497067055", "bodyText": "Is this distinction between SettableIntGauge and SettableDoubleGauge actually useful?  Looks like under the hood the ints are converted to doubles anyway ...", "author": "mbaxter", "createdAt": "2020-09-29T21:21:14Z", "path": "infrastructure/metrics/src/main/java/tech/pegasys/teku/infrastructure/metrics/SettableIntGauge.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.infrastructure.metrics;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import org.hyperledger.besu.plugin.services.metrics.MetricCategory;\n+\n+public class SettableIntGauge {", "originalCommit": "a0cb333ccbd8cbeef08a461819390b58f991415d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1MTgzMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498351831", "bodyText": "You're right. It was unnecessary. Removed.", "author": "cemozerr", "createdAt": "2020-10-01T15:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzA1NQ=="}], "type": "inlineReview"}, {"oid": "7167d3cd589a9045a8b1a208f54e8905200ceaca", "url": "https://github.com/ConsenSys/teku/commit/7167d3cd589a9045a8b1a208f54e8905200ceaca", "message": "Use AtomicReference instead of an AtomicLong", "committedDate": "2020-10-01T16:17:12Z", "type": "commit"}, {"oid": "d33102fde88535bae15a2180694e5be600783177", "url": "https://github.com/ConsenSys/teku/commit/d33102fde88535bae15a2180694e5be600783177", "message": "Resolve comments", "committedDate": "2020-10-01T16:17:12Z", "type": "commit"}, {"oid": "3f1eec3f436541ee42a38488ecef0017986dc027", "url": "https://github.com/ConsenSys/teku/commit/3f1eec3f436541ee42a38488ecef0017986dc027", "message": "Run spotless", "committedDate": "2020-10-01T16:17:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTUwMQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498461501", "bodyText": "I think we're now potentially processing blocks multiple times if there are skipped slots.  We need to update the slot based on the returned block's slot:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (currSlot.equals(UInt64.ZERO)) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  currSlot = currSlot.decrement();\n          \n          \n            \n                  if (block.getSlot().equals(UInt64.ZERO)) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  currSlot = block.getSlot().decrement();\n          \n      \n    \n    \n  \n\nWe should add a test that makes sure our calculations are correct when there are skipped slots.", "author": "mbaxter", "createdAt": "2020-10-01T19:14:53Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicReference<UInt64> latestAnalyzedEpoch = new AtomicReference<>(UInt64.ZERO);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.isLessThanOrEqualTo(\n+        latestAnalyzedEpoch.getAndUpdate(\n+            val -> val.isLessThan(currentEpoch) ? currentEpoch : val))) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        Bitlist bitlistToInsert = attestation.getAggregation_bits().copy();\n+        Bitlist alreadySetBits = slotToBitlists.get(slot);\n+        if (alreadySetBits != null) {\n+          bitlistToInsert.setAllBits(alreadySetBits);\n+        }\n+        slotToBitlists.put(slot, bitlistToInsert);\n+      }\n+    }\n+\n+    for (Attestation sentAttestation : producedAttestations) {\n+      Bytes32 sentAttestationDataHash = sentAttestation.getData().hash_tree_root();\n+      UInt64 sentAttestationSlot = sentAttestation.getData().getSlot();\n+      if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) {\n+        continue;\n+      }\n+      NavigableMap<UInt64, Bitlist> slotAndBitlists =\n+          slotAndBitlistsByAttestationDataHash.get(sentAttestationDataHash);\n+      for (UInt64 slot : slotAndBitlists.keySet()) {\n+        if (slotAndBitlists.get(slot).isSuperSetOf(sentAttestation.getAggregation_bits())) {\n+          inclusionDistances.add(slot.minus(sentAttestationSlot).intValue());\n+          break;\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n+        correctTargetCount++;\n+\n+        // Check if the attestation had correct head block root\n+        Bytes32 attestationHeadBlockRoot = sentAttestation.getData().getBeacon_block_root();\n+        if (attestationHeadBlockRoot.equals(get_block_root_at_slot(state, sentAttestationSlot))) {\n+          correctHeadBlockCount++;\n+        }\n+      }\n+    }\n+\n+    IntSummaryStatistics inclusionDistanceStatistics =\n+        inclusionDistances.stream().collect(Collectors.summarizingInt(Integer::intValue));\n+\n+    // IntSummaryStatistics returns Integer.MIN and MAX when the summarized integer list is empty.\n+    return producedAttestations.size() > 0\n+        ? new AttestationPerformance(\n+            producedAttestations.size(),\n+            (int) inclusionDistanceStatistics.getCount(),\n+            inclusionDistanceStatistics.getMax(),\n+            inclusionDistanceStatistics.getMin(),\n+            inclusionDistanceStatistics.getAverage(),\n+            correctTargetCount,\n+            correctHeadBlockCount)\n+        : AttestationPerformance.empty();\n+  }\n+\n+  private Set<BeaconBlock> getBlocksInEpochs(UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    UInt64 epochStartSlot = compute_start_slot_at_epoch(startEpochInclusive);\n+    UInt64 inclusiveEndEpochEndSlot = compute_start_slot_at_epoch(endEpochExclusive).decrement();\n+\n+    Set<BeaconBlock> blocksInEpoch = new HashSet<>();\n+    UInt64 currSlot = inclusiveEndEpochEndSlot;\n+    while (currSlot.isGreaterThanOrEqualTo(epochStartSlot)) {\n+      // PerformanceTracker should not be running if chain data is not available.\n+      BeaconBlock block =\n+          combinedChainDataClient\n+              .getBlockInEffectAtSlot(currSlot)\n+              .join()\n+              .orElseThrow()\n+              .getMessage();\n+      blocksInEpoch.add(block);\n+      if (currSlot.equals(UInt64.ZERO)) {\n+        break;\n+      }\n+      currSlot = currSlot.decrement();", "originalCommit": "3f1eec3f436541ee42a38488ecef0017986dc027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5MDE3MQ==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498490171", "bodyText": "Fixed. The current tests already test scenarios with skipped slots.", "author": "cemozerr", "createdAt": "2020-10-01T20:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NDgwMA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498464800", "bodyText": "(nit) Might be a bit simpler (and perform less copying) with something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Bitlist bitlistToInsert = attestation.getAggregation_bits().copy();\n          \n          \n            \n                    Bitlist alreadySetBits = slotToBitlists.get(slot);\n          \n          \n            \n                    if (alreadySetBits != null) {\n          \n          \n            \n                      bitlistToInsert.setAllBits(alreadySetBits);\n          \n          \n            \n                    }\n          \n          \n            \n                    slotToBitlists.put(slot, bitlistToInsert);\n          \n          \n            \n                    Bitlist bitlist = slotToBitlists.computeIfAbsent(slot, attestation.getAggregation_bits()::copy);\n          \n          \n            \n                    bitlistToInsert.setAllBits(attestation.getAggregation_bits());", "author": "mbaxter", "createdAt": "2020-10-01T19:21:50Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicReference<UInt64> latestAnalyzedEpoch = new AtomicReference<>(UInt64.ZERO);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.isLessThanOrEqualTo(\n+        latestAnalyzedEpoch.getAndUpdate(\n+            val -> val.isLessThan(currentEpoch) ? currentEpoch : val))) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        Bitlist bitlistToInsert = attestation.getAggregation_bits().copy();\n+        Bitlist alreadySetBits = slotToBitlists.get(slot);\n+        if (alreadySetBits != null) {\n+          bitlistToInsert.setAllBits(alreadySetBits);\n+        }\n+        slotToBitlists.put(slot, bitlistToInsert);", "originalCommit": "3f1eec3f436541ee42a38488ecef0017986dc027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3NzY0NA==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498477644", "bodyText": "For sure.", "author": "cemozerr", "createdAt": "2020-10-01T19:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NDgwMA=="}], "type": "inlineReview"}, {"oid": "3ff3dfc3a02a6305dc3c23ff3f64aa725ace86ec", "url": "https://github.com/ConsenSys/teku/commit/3ff3dfc3a02a6305dc3c23ff3f64aa725ace86ec", "message": "Simplify setting bitlist for slot", "committedDate": "2020-10-01T20:14:48Z", "type": "commit"}, {"oid": "015ea5a09df08cbaa72d7f1c3e3644b5663ed21d", "url": "https://github.com/ConsenSys/teku/commit/015ea5a09df08cbaa72d7f1c3e3644b5663ed21d", "message": "Resolve comments", "committedDate": "2020-10-01T20:31:31Z", "type": "commit"}, {"oid": "989bd8af564998660428212de7554ebcd72c0886", "url": "https://github.com/ConsenSys/teku/commit/989bd8af564998660428212de7554ebcd72c0886", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-10-01T20:31:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMDEyNw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498530127", "bodyText": "Looks like we don't need this rename anymore :D", "author": "mbaxter", "createdAt": "2020-10-01T21:48:30Z", "path": "infrastructure/metrics/src/main/java/tech/pegasys/teku/infrastructure/metrics/SettableDoubleGauge.java", "diffHunk": "@@ -17,19 +17,19 @@\n import org.hyperledger.besu.plugin.services.MetricsSystem;\n import org.hyperledger.besu.plugin.services.metrics.MetricCategory;\n \n-public class SettableGauge {\n+public class SettableDoubleGauge {", "originalCommit": "989bd8af564998660428212de7554ebcd72c0886", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMzgwNw==", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498533807", "bodyText": "Yep :D", "author": "cemozerr", "createdAt": "2020-10-01T21:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMDEyNw=="}], "type": "inlineReview"}, {"oid": "7e850e92935c923722c6cbc3f02f6b5f34577573", "url": "https://github.com/ConsenSys/teku/commit/7e850e92935c923722c6cbc3f02f6b5f34577573", "message": "Revert redundant name change", "committedDate": "2020-10-01T22:27:29Z", "type": "commit"}, {"oid": "7e850e92935c923722c6cbc3f02f6b5f34577573", "url": "https://github.com/ConsenSys/teku/commit/7e850e92935c923722c6cbc3f02f6b5f34577573", "message": "Revert redundant name change", "committedDate": "2020-10-01T22:27:29Z", "type": "forcePushed"}, {"oid": "64baa92bac7005738538e9822a72b197b1086176", "url": "https://github.com/ConsenSys/teku/commit/64baa92bac7005738538e9822a72b197b1086176", "message": "Merge branch 'master' into outputValidatorPerformance", "committedDate": "2020-10-01T22:27:45Z", "type": "commit"}]}