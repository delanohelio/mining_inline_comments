{"pr_number": 1170, "pr_title": "Replace naive fork choice implementation with protoarray", "pr_createdAt": "2020-02-16T02:26:41Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1170", "timeline": [{"oid": "7c229242fd09af41b606f271c6a0d4eca506cb46", "url": "https://github.com/ConsenSys/teku/commit/7c229242fd09af41b606f271c6a0d4eca506cb46", "message": "Implement protoArray onBlock method", "committedDate": "2020-02-16T02:16:58Z", "type": "commit"}, {"oid": "9db37bddf7447d59b9a5e0e60ea668829573ebb8", "url": "https://github.com/ConsenSys/teku/commit/9db37bddf7447d59b9a5e0e60ea668829573ebb8", "message": "Run spotless", "committedDate": "2020-02-16T02:34:12Z", "type": "commit"}, {"oid": "2616c0c4ee9cd3787eb6c315884b2b0a5b9f496f", "url": "https://github.com/ConsenSys/teku/commit/2616c0c4ee9cd3787eb6c315884b2b0a5b9f496f", "message": "WIP implement onAttestation", "committedDate": "2020-02-18T22:26:13Z", "type": "commit"}, {"oid": "41b2b717aa59f7a64238cb01a2a6725a68c567ff", "url": "https://github.com/ConsenSys/teku/commit/41b2b717aa59f7a64238cb01a2a6725a68c567ff", "message": "Merge branch 'master' into protoarray", "committedDate": "2020-04-05T18:32:48Z", "type": "commit"}, {"oid": "33035dc3420b402ac83897b61baf55b7b883502d", "url": "https://github.com/ConsenSys/teku/commit/33035dc3420b402ac83897b61baf55b7b883502d", "message": "Refactor code to match other implementations", "committedDate": "2020-04-06T03:42:16Z", "type": "commit"}, {"oid": "33035dc3420b402ac83897b61baf55b7b883502d", "url": "https://github.com/ConsenSys/teku/commit/33035dc3420b402ac83897b61baf55b7b883502d", "message": "Refactor code to match other implementations", "committedDate": "2020-04-06T03:42:16Z", "type": "forcePushed"}, {"oid": "95589326152b63ca2c65b8e3f15dcd3c2a118921", "url": "https://github.com/ConsenSys/teku/commit/95589326152b63ca2c65b8e3f15dcd3c2a118921", "message": "Add onBlock", "committedDate": "2020-04-06T03:53:59Z", "type": "commit"}, {"oid": "1707251c7d51426e9931b6035743b854c49486bd", "url": "https://github.com/ConsenSys/teku/commit/1707251c7d51426e9931b6035743b854c49486bd", "message": "Add findHead", "committedDate": "2020-04-06T03:59:23Z", "type": "commit"}, {"oid": "e256acd74dc081d6b7f8f97a80df1ce5ae45ff56", "url": "https://github.com/ConsenSys/teku/commit/e256acd74dc081d6b7f8f97a80df1ce5ae45ff56", "message": "Finish protoarray data structure implementation", "committedDate": "2020-04-06T17:20:04Z", "type": "commit"}, {"oid": "9191c1d319e511c871a9817e69376fb64398e681", "url": "https://github.com/ConsenSys/teku/commit/9191c1d319e511c871a9817e69376fb64398e681", "message": "Start implementing ProtoArrayForkChoice", "committedDate": "2020-04-06T22:42:37Z", "type": "commit"}, {"oid": "8c9d96356306a4c92efe456e1190e27771000355", "url": "https://github.com/ConsenSys/teku/commit/8c9d96356306a4c92efe456e1190e27771000355", "message": "Finish implementing ProtoArrayForkChoice", "committedDate": "2020-04-07T18:42:28Z", "type": "commit"}, {"oid": "a9fb90d5f477ca361a3d07ef6597d7dfe45bf0cc", "url": "https://github.com/ConsenSys/teku/commit/a9fb90d5f477ca361a3d07ef6597d7dfe45bf0cc", "message": "Make protoarray its own package", "committedDate": "2020-04-07T19:01:36Z", "type": "commit"}, {"oid": "4cc6801bd0ea7981910c8e16f80e18d497e4f25d", "url": "https://github.com/ConsenSys/teku/commit/4cc6801bd0ea7981910c8e16f80e18d497e4f25d", "message": "Merge remote-tracking branch 'remotes/origin/master' into protoarray", "committedDate": "2020-04-07T22:14:42Z", "type": "commit"}, {"oid": "c6fcc8d37dde7a418b3ce151401a406102b6b61c", "url": "https://github.com/ConsenSys/teku/commit/c6fcc8d37dde7a418b3ce151401a406102b6b61c", "message": "Add computeDeltas tests", "committedDate": "2020-04-08T00:14:25Z", "type": "commit"}, {"oid": "c488e3963f69db5033f7614702d58a7e53143eae", "url": "https://github.com/ConsenSys/teku/commit/c488e3963f69db5033f7614702d58a7e53143eae", "message": "Run spotless", "committedDate": "2020-04-08T00:15:17Z", "type": "commit"}, {"oid": "b29edbd313e46294e55c4f45ff38edf2d7913ae7", "url": "https://github.com/ConsenSys/teku/commit/b29edbd313e46294e55c4f45ff38edf2d7913ae7", "message": "Update comments to match java style", "committedDate": "2020-04-08T00:38:49Z", "type": "commit"}, {"oid": "3dcc4f1b1ca13b3081a21c73a3d3ecf063d51fd5", "url": "https://github.com/ConsenSys/teku/commit/3dcc4f1b1ca13b3081a21c73a3d3ecf063d51fd5", "message": "Remove unnecessary parantheses", "committedDate": "2020-04-08T00:39:54Z", "type": "commit"}, {"oid": "ef4fd12ffab4842e426d670bff741f414c7af5ac", "url": "https://github.com/ConsenSys/teku/commit/ef4fd12ffab4842e426d670bff741f414c7af5ac", "message": "Update comment", "committedDate": "2020-04-08T00:40:53Z", "type": "commit"}, {"oid": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "url": "https://github.com/ConsenSys/teku/commit/6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "message": "Add comment", "committedDate": "2020-04-08T00:45:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMjEyNw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405232127", "bodyText": "I wonder if we should create a custom lock which is more like what rust is using e.g.\npublic class RwLock<T> {\n  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n  private final T value;\n\n  public void withWriteLock(final Consumer<T> action) {\n    lock.writeLock().lock();\n    try {\n      action.accept(value);\n    } finally {\n      lock.writeLock().unlock();\n    }\n  }\n\n  public <R> R withReadLock(final Function<T, R> reader) {\n    lock.readLock().lock();\n    try {\n      return reader.apply(value);\n    } finally {\n      lock.readLock().unlock();\n    }\n  }\n}\n\nMostly it just feels a bit weird that ProtoArrayForkChoice has locks for ProtoArray rather than ProtoArray itself managing the read/write locks.  Having a class that \"locks up\" the value and encapsulates the locking makes more sense to me though.  Especially since you then can't ever forget to unlock something.", "author": "ajsutton", "createdAt": "2020-04-08T03:06:32Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3OTI1Mg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405679252", "bodyText": "I definitely thought of doing this but then went for the simple locks I have now. I think it's a good idea to get this in this PR.", "author": "cemozerr", "createdAt": "2020-04-08T17:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMjEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NzcwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405697701", "bodyText": "I'm thinking of coming back to this after I'm done with all the tests because I think implementing this might be a little problematic. One potential issue I see is that, with the encapsulation above, we would have to keep the read and write locks specific to functions. Also, I made an exercise of trying to use this API for findHead method in ForkChoiceProtoArray, and I was unable to get it to work unless I followed a pattern similar to\nprotoArray.withWriteLock(protoArrayWrite -> {\n            votes.withWriteLock(votesWrite -> {\n                 balances.withWriteLock(balancesWrite -> {\nList<Long> deltas = computeDeltas(protoArrayWrite.getIndices(), votesWrite, balancesWrite, newBalances);", "author": "cemozerr", "createdAt": "2020-04-08T17:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNDI2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405234266", "bodyText": "Any reason we didn't implement blockSlot?", "author": "ajsutton", "createdAt": "2020-04-08T03:15:23Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();\n+  private final ProtoArray protoArray;\n+  private final ElasticList<VoteTracker> votes;\n+  private List<UnsignedLong> balances;\n+\n+  private ProtoArrayForkChoice(\n+      ProtoArray protoArray, ElasticList<VoteTracker> votes, List<UnsignedLong> balances) {\n+    this.protoArray = protoArray;\n+    this.votes = votes;\n+    this.balances = balances;\n+  }\n+\n+  public static ProtoArrayForkChoice create(\n+      UnsignedLong finalizedBlockSlot,\n+      Bytes32 finalizedBlockStateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      Bytes32 finalizedRoot) {\n+    ProtoArray protoArray =\n+        new ProtoArray(\n+            Constants.PROTOARRAY_FORKCHOICE_PRUNE_THRESHOLD,\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            new ArrayList<>(),\n+            new HashMap<>());\n+\n+    protoArray.onBlock(\n+        finalizedBlockSlot,\n+        finalizedRoot,\n+        Optional.empty(),\n+        finalizedBlockStateRoot,\n+        justifiedEpoch,\n+        finalizedEpoch);\n+\n+    return new ProtoArrayForkChoice(\n+        protoArray, new ElasticList<>(VoteTracker.DEFAULT), new ArrayList<>());\n+  }\n+\n+  public void processAttestation(int validatorIndex, Bytes32 blockRoot, UnsignedLong targetEpoch) {\n+    votesLock.writeLock().lock();\n+    try {\n+      VoteTracker vote = votes.get(validatorIndex);\n+\n+      if (targetEpoch.compareTo(vote.getNextEpoch()) > 0 || vote.equals(VoteTracker.DEFAULT)) {\n+        vote.setNextRoot(blockRoot);\n+        vote.setNextEpoch(targetEpoch);\n+      }\n+    } finally {\n+      votesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void processBlock(\n+      UnsignedLong slot,\n+      Bytes32 blockRoot,\n+      Bytes32 parentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.onBlock(\n+          slot, blockRoot, Optional.of(parentRoot), stateRoot, justifiedEpoch, finalizedEpoch);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public Bytes32 findHead(\n+      UnsignedLong justifiedEpoch,\n+      Bytes32 justifiedRoot,\n+      UnsignedLong finalizedEpoch,\n+      List<UnsignedLong> justifiedStateBalances) {\n+    protoArrayLock.writeLock().lock();\n+    votesLock.writeLock().lock();\n+    balancesLock.writeLock().lock();\n+    try {\n+      List<UnsignedLong> oldBalances = balances;\n+      List<UnsignedLong> newBalances = justifiedStateBalances;\n+\n+      List<Long> deltas = computeDeltas(protoArray.getIndices(), votes, oldBalances, newBalances);\n+\n+      protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n+      balances = newBalances;\n+\n+      return protoArray.findHead(justifiedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+      votesLock.writeLock().unlock();\n+      balancesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.maybePrune(finalizedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.setPruneThreshold(pruneThreshold);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public int size() {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getNodes().size();\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public boolean containsBlock(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getIndices().containsKey(blockRoot);\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<BlockSlotAndStateRoot> blockSlotAndStateRoot(Bytes32 blockRoot) {", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5ODg2NQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405698865", "bodyText": "Implemented now.", "author": "cemozerr", "createdAt": "2020-04-08T17:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNDI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNDY1OA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405234658", "bodyText": "Do we need to check if this is null?", "author": "ajsutton", "createdAt": "2020-04-08T03:16:52Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();\n+  private final ProtoArray protoArray;\n+  private final ElasticList<VoteTracker> votes;\n+  private List<UnsignedLong> balances;\n+\n+  private ProtoArrayForkChoice(\n+      ProtoArray protoArray, ElasticList<VoteTracker> votes, List<UnsignedLong> balances) {\n+    this.protoArray = protoArray;\n+    this.votes = votes;\n+    this.balances = balances;\n+  }\n+\n+  public static ProtoArrayForkChoice create(\n+      UnsignedLong finalizedBlockSlot,\n+      Bytes32 finalizedBlockStateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      Bytes32 finalizedRoot) {\n+    ProtoArray protoArray =\n+        new ProtoArray(\n+            Constants.PROTOARRAY_FORKCHOICE_PRUNE_THRESHOLD,\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            new ArrayList<>(),\n+            new HashMap<>());\n+\n+    protoArray.onBlock(\n+        finalizedBlockSlot,\n+        finalizedRoot,\n+        Optional.empty(),\n+        finalizedBlockStateRoot,\n+        justifiedEpoch,\n+        finalizedEpoch);\n+\n+    return new ProtoArrayForkChoice(\n+        protoArray, new ElasticList<>(VoteTracker.DEFAULT), new ArrayList<>());\n+  }\n+\n+  public void processAttestation(int validatorIndex, Bytes32 blockRoot, UnsignedLong targetEpoch) {\n+    votesLock.writeLock().lock();\n+    try {\n+      VoteTracker vote = votes.get(validatorIndex);\n+\n+      if (targetEpoch.compareTo(vote.getNextEpoch()) > 0 || vote.equals(VoteTracker.DEFAULT)) {\n+        vote.setNextRoot(blockRoot);\n+        vote.setNextEpoch(targetEpoch);\n+      }\n+    } finally {\n+      votesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void processBlock(\n+      UnsignedLong slot,\n+      Bytes32 blockRoot,\n+      Bytes32 parentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.onBlock(\n+          slot, blockRoot, Optional.of(parentRoot), stateRoot, justifiedEpoch, finalizedEpoch);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public Bytes32 findHead(\n+      UnsignedLong justifiedEpoch,\n+      Bytes32 justifiedRoot,\n+      UnsignedLong finalizedEpoch,\n+      List<UnsignedLong> justifiedStateBalances) {\n+    protoArrayLock.writeLock().lock();\n+    votesLock.writeLock().lock();\n+    balancesLock.writeLock().lock();\n+    try {\n+      List<UnsignedLong> oldBalances = balances;\n+      List<UnsignedLong> newBalances = justifiedStateBalances;\n+\n+      List<Long> deltas = computeDeltas(protoArray.getIndices(), votes, oldBalances, newBalances);\n+\n+      protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n+      balances = newBalances;\n+\n+      return protoArray.findHead(justifiedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+      votesLock.writeLock().unlock();\n+      balancesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.maybePrune(finalizedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.setPruneThreshold(pruneThreshold);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public int size() {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getNodes().size();\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public boolean containsBlock(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getIndices().containsKey(blockRoot);\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<BlockSlotAndStateRoot> blockSlotAndStateRoot(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      int blockIndex = protoArray.getIndices().get(blockRoot);\n+\n+      if (protoArray.getNodes().size() > blockIndex) {\n+        ProtoNode node = protoArray.getNodes().get(blockIndex);", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMDUwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405700501", "bodyText": "protoArray.nodes is a list, so that's why I check for the block index being smaller than size. So, I don't think a null check is necessary here", "author": "cemozerr", "createdAt": "2020-04-08T17:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNDY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMTgwMA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405701800", "bodyText": "Oh you mean the blockIndex, yes we should.", "author": "cemozerr", "createdAt": "2020-04-08T17:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNDY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMjQ5MQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405702491", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-08T17:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNDY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTQxMA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405235410", "bodyText": "nit: probably clearer to invert this if and return early if blockIndex >= size.", "author": "ajsutton", "createdAt": "2020-04-08T03:19:32Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();\n+  private final ProtoArray protoArray;\n+  private final ElasticList<VoteTracker> votes;\n+  private List<UnsignedLong> balances;\n+\n+  private ProtoArrayForkChoice(\n+      ProtoArray protoArray, ElasticList<VoteTracker> votes, List<UnsignedLong> balances) {\n+    this.protoArray = protoArray;\n+    this.votes = votes;\n+    this.balances = balances;\n+  }\n+\n+  public static ProtoArrayForkChoice create(\n+      UnsignedLong finalizedBlockSlot,\n+      Bytes32 finalizedBlockStateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      Bytes32 finalizedRoot) {\n+    ProtoArray protoArray =\n+        new ProtoArray(\n+            Constants.PROTOARRAY_FORKCHOICE_PRUNE_THRESHOLD,\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            new ArrayList<>(),\n+            new HashMap<>());\n+\n+    protoArray.onBlock(\n+        finalizedBlockSlot,\n+        finalizedRoot,\n+        Optional.empty(),\n+        finalizedBlockStateRoot,\n+        justifiedEpoch,\n+        finalizedEpoch);\n+\n+    return new ProtoArrayForkChoice(\n+        protoArray, new ElasticList<>(VoteTracker.DEFAULT), new ArrayList<>());\n+  }\n+\n+  public void processAttestation(int validatorIndex, Bytes32 blockRoot, UnsignedLong targetEpoch) {\n+    votesLock.writeLock().lock();\n+    try {\n+      VoteTracker vote = votes.get(validatorIndex);\n+\n+      if (targetEpoch.compareTo(vote.getNextEpoch()) > 0 || vote.equals(VoteTracker.DEFAULT)) {\n+        vote.setNextRoot(blockRoot);\n+        vote.setNextEpoch(targetEpoch);\n+      }\n+    } finally {\n+      votesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void processBlock(\n+      UnsignedLong slot,\n+      Bytes32 blockRoot,\n+      Bytes32 parentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.onBlock(\n+          slot, blockRoot, Optional.of(parentRoot), stateRoot, justifiedEpoch, finalizedEpoch);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public Bytes32 findHead(\n+      UnsignedLong justifiedEpoch,\n+      Bytes32 justifiedRoot,\n+      UnsignedLong finalizedEpoch,\n+      List<UnsignedLong> justifiedStateBalances) {\n+    protoArrayLock.writeLock().lock();\n+    votesLock.writeLock().lock();\n+    balancesLock.writeLock().lock();\n+    try {\n+      List<UnsignedLong> oldBalances = balances;\n+      List<UnsignedLong> newBalances = justifiedStateBalances;\n+\n+      List<Long> deltas = computeDeltas(protoArray.getIndices(), votes, oldBalances, newBalances);\n+\n+      protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n+      balances = newBalances;\n+\n+      return protoArray.findHead(justifiedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+      votesLock.writeLock().unlock();\n+      balancesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.maybePrune(finalizedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.setPruneThreshold(pruneThreshold);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public int size() {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getNodes().size();\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public boolean containsBlock(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getIndices().containsKey(blockRoot);\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<BlockSlotAndStateRoot> blockSlotAndStateRoot(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      int blockIndex = protoArray.getIndices().get(blockRoot);\n+\n+      if (protoArray.getNodes().size() > blockIndex) {", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMjU1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405702557", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-08T17:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTU0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405235546", "bodyText": "nit: can return early.", "author": "ajsutton", "createdAt": "2020-04-08T03:20:05Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();\n+  private final ProtoArray protoArray;\n+  private final ElasticList<VoteTracker> votes;\n+  private List<UnsignedLong> balances;\n+\n+  private ProtoArrayForkChoice(\n+      ProtoArray protoArray, ElasticList<VoteTracker> votes, List<UnsignedLong> balances) {\n+    this.protoArray = protoArray;\n+    this.votes = votes;\n+    this.balances = balances;\n+  }\n+\n+  public static ProtoArrayForkChoice create(\n+      UnsignedLong finalizedBlockSlot,\n+      Bytes32 finalizedBlockStateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      Bytes32 finalizedRoot) {\n+    ProtoArray protoArray =\n+        new ProtoArray(\n+            Constants.PROTOARRAY_FORKCHOICE_PRUNE_THRESHOLD,\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            new ArrayList<>(),\n+            new HashMap<>());\n+\n+    protoArray.onBlock(\n+        finalizedBlockSlot,\n+        finalizedRoot,\n+        Optional.empty(),\n+        finalizedBlockStateRoot,\n+        justifiedEpoch,\n+        finalizedEpoch);\n+\n+    return new ProtoArrayForkChoice(\n+        protoArray, new ElasticList<>(VoteTracker.DEFAULT), new ArrayList<>());\n+  }\n+\n+  public void processAttestation(int validatorIndex, Bytes32 blockRoot, UnsignedLong targetEpoch) {\n+    votesLock.writeLock().lock();\n+    try {\n+      VoteTracker vote = votes.get(validatorIndex);\n+\n+      if (targetEpoch.compareTo(vote.getNextEpoch()) > 0 || vote.equals(VoteTracker.DEFAULT)) {\n+        vote.setNextRoot(blockRoot);\n+        vote.setNextEpoch(targetEpoch);\n+      }\n+    } finally {\n+      votesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void processBlock(\n+      UnsignedLong slot,\n+      Bytes32 blockRoot,\n+      Bytes32 parentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.onBlock(\n+          slot, blockRoot, Optional.of(parentRoot), stateRoot, justifiedEpoch, finalizedEpoch);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public Bytes32 findHead(\n+      UnsignedLong justifiedEpoch,\n+      Bytes32 justifiedRoot,\n+      UnsignedLong finalizedEpoch,\n+      List<UnsignedLong> justifiedStateBalances) {\n+    protoArrayLock.writeLock().lock();\n+    votesLock.writeLock().lock();\n+    balancesLock.writeLock().lock();\n+    try {\n+      List<UnsignedLong> oldBalances = balances;\n+      List<UnsignedLong> newBalances = justifiedStateBalances;\n+\n+      List<Long> deltas = computeDeltas(protoArray.getIndices(), votes, oldBalances, newBalances);\n+\n+      protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n+      balances = newBalances;\n+\n+      return protoArray.findHead(justifiedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+      votesLock.writeLock().unlock();\n+      balancesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.maybePrune(finalizedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.setPruneThreshold(pruneThreshold);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public int size() {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getNodes().size();\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public boolean containsBlock(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getIndices().containsKey(blockRoot);\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<BlockSlotAndStateRoot> blockSlotAndStateRoot(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      int blockIndex = protoArray.getIndices().get(blockRoot);\n+\n+      if (protoArray.getNodes().size() > blockIndex) {\n+        ProtoNode node = protoArray.getNodes().get(blockIndex);\n+        return Optional.of(new BlockSlotAndStateRoot(node.getSlot(), node.getStateRoot()));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<Checkpoint> latestMessage(int validatorIndex) {\n+    votesLock.readLock().lock();\n+    try {\n+      if (validatorIndex < votes.size()) {", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMzI3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405703273", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-08T17:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNjQ2OQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405236469", "bodyText": "Spotless is going to do bad things to this...  It will work out better as\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * - If a value in `indices` is greater to or equal to `indices.size()`.\n          \n          \n            \n               * - If some `Bytes32` in `votes` is not a key in `indices` (except for `Bytes32.ZERO`, this is\n          \n          \n            \n               * always valid).\n          \n          \n            \n                  * <ul>\n          \n          \n            \n               *   <li>If a value in `indices` is greater to or equal to `indices.size()`.\n          \n          \n            \n               *   <li>If some `Bytes32` in `votes` is not a key in `indices` (except for `Bytes32.ZERO`, this\n          \n          \n            \n               *       is always valid).\n          \n          \n            \n               * </ul>\n          \n      \n    \n    \n  \n\nbecause JavaDoc is HTML.", "author": "ajsutton", "createdAt": "2020-04-08T03:23:47Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();\n+  private final ProtoArray protoArray;\n+  private final ElasticList<VoteTracker> votes;\n+  private List<UnsignedLong> balances;\n+\n+  private ProtoArrayForkChoice(\n+      ProtoArray protoArray, ElasticList<VoteTracker> votes, List<UnsignedLong> balances) {\n+    this.protoArray = protoArray;\n+    this.votes = votes;\n+    this.balances = balances;\n+  }\n+\n+  public static ProtoArrayForkChoice create(\n+      UnsignedLong finalizedBlockSlot,\n+      Bytes32 finalizedBlockStateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      Bytes32 finalizedRoot) {\n+    ProtoArray protoArray =\n+        new ProtoArray(\n+            Constants.PROTOARRAY_FORKCHOICE_PRUNE_THRESHOLD,\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            new ArrayList<>(),\n+            new HashMap<>());\n+\n+    protoArray.onBlock(\n+        finalizedBlockSlot,\n+        finalizedRoot,\n+        Optional.empty(),\n+        finalizedBlockStateRoot,\n+        justifiedEpoch,\n+        finalizedEpoch);\n+\n+    return new ProtoArrayForkChoice(\n+        protoArray, new ElasticList<>(VoteTracker.DEFAULT), new ArrayList<>());\n+  }\n+\n+  public void processAttestation(int validatorIndex, Bytes32 blockRoot, UnsignedLong targetEpoch) {\n+    votesLock.writeLock().lock();\n+    try {\n+      VoteTracker vote = votes.get(validatorIndex);\n+\n+      if (targetEpoch.compareTo(vote.getNextEpoch()) > 0 || vote.equals(VoteTracker.DEFAULT)) {\n+        vote.setNextRoot(blockRoot);\n+        vote.setNextEpoch(targetEpoch);\n+      }\n+    } finally {\n+      votesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void processBlock(\n+      UnsignedLong slot,\n+      Bytes32 blockRoot,\n+      Bytes32 parentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.onBlock(\n+          slot, blockRoot, Optional.of(parentRoot), stateRoot, justifiedEpoch, finalizedEpoch);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public Bytes32 findHead(\n+      UnsignedLong justifiedEpoch,\n+      Bytes32 justifiedRoot,\n+      UnsignedLong finalizedEpoch,\n+      List<UnsignedLong> justifiedStateBalances) {\n+    protoArrayLock.writeLock().lock();\n+    votesLock.writeLock().lock();\n+    balancesLock.writeLock().lock();\n+    try {\n+      List<UnsignedLong> oldBalances = balances;\n+      List<UnsignedLong> newBalances = justifiedStateBalances;\n+\n+      List<Long> deltas = computeDeltas(protoArray.getIndices(), votes, oldBalances, newBalances);\n+\n+      protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n+      balances = newBalances;\n+\n+      return protoArray.findHead(justifiedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+      votesLock.writeLock().unlock();\n+      balancesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.maybePrune(finalizedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.setPruneThreshold(pruneThreshold);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public int size() {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getNodes().size();\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public boolean containsBlock(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getIndices().containsKey(blockRoot);\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<BlockSlotAndStateRoot> blockSlotAndStateRoot(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      int blockIndex = protoArray.getIndices().get(blockRoot);\n+\n+      if (protoArray.getNodes().size() > blockIndex) {\n+        ProtoNode node = protoArray.getNodes().get(blockIndex);\n+        return Optional.of(new BlockSlotAndStateRoot(node.getSlot(), node.getStateRoot()));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<Checkpoint> latestMessage(int validatorIndex) {\n+    votesLock.readLock().lock();\n+    try {\n+      if (validatorIndex < votes.size()) {\n+        VoteTracker vote = votes.get(validatorIndex);\n+        if (vote.equals(VoteTracker.DEFAULT)) {\n+          return Optional.empty();\n+        } else {\n+          return Optional.of(new Checkpoint(vote.getNextEpoch(), vote.getNextRoot()));\n+        }\n+      } else {\n+        return Optional.empty();\n+      }\n+    } finally {\n+      votesLock.readLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Returns a list of `deltas`, where there is one delta for each of the indices in\n+   * `0..indices.size()`.\n+   *\n+   * The deltas are formed by a change between `oldBalances` and `newBalances`,\n+   * and/or a change of vote in `votes`.\n+   *\n+   * ## Errors\n+   *\n+   * - If a value in `indices` is greater to or equal to `indices.size()`.\n+   * - If some `Bytes32` in `votes` is not a key in `indices` (except for `Bytes32.ZERO`, this is\n+   * always valid).", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwNDA5MQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405704091", "bodyText": "Interesting. Good to know. Done.", "author": "cemozerr", "createdAt": "2020-04-08T17:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNjQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzODQ0Nw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405238447", "bodyText": "This appears to be unused.", "author": "ajsutton", "createdAt": "2020-04-08T03:32:04Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/AttestationUtil.java", "diffHunk": "@@ -100,6 +100,10 @@ public static IndexedAttestation get_indexed_attestation(\n         attestation.getAggregate_signature());\n   }\n \n+  public static List<Integer> getParticipantIndices(BeaconState state, Attestation attestation) {", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MDE0OA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405660148", "bodyText": "Removed.", "author": "cemozerr", "createdAt": "2020-04-08T16:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzODQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzOTUyOA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405239528", "bodyText": "Is there any need to be able to adjust this at runtime? Doesn't seem like a setter is required and it should just be final and always stick with the initially configured value.", "author": "ajsutton", "createdAt": "2020-04-08T03:36:58Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MTQxOA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405661418", "bodyText": "Discussed offline.", "author": "cemozerr", "createdAt": "2020-04-08T16:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzOTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MTI1NQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405241255", "bodyText": "Probably should check for null here because it confuses the heck out of people when they get a NullPointerException from an int (it's because indices returns an Integer which can be null and throws NullPointerException when unboxed to int).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int justifiedIndex = indices.get(justifiedRoot);\n          \n          \n            \n                int justifiedIndex = checkNotNull(indices.get(justifiedRoot), \"Unknown justified root\");", "author": "ajsutton", "createdAt": "2020-04-08T03:44:31Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MzE1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405663156", "bodyText": "Good catch. Added checkNotNull's for both justifiedRoot and justifiedIndex.", "author": "cemozerr", "createdAt": "2020-04-08T16:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MzAzNA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405243034", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (deltas.size() != indices.size()) {\n          \n          \n            \n                  throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n          \n          \n            \n                }\n          \n          \n            \n               checkArgument(deltas.size() == indices.size(), \"ProtoArray: Invalid delta length\");", "author": "ajsutton", "createdAt": "2020-04-08T03:52:20Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2NDAzMg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405664032", "bodyText": "Good suggestion.", "author": "cemozerr", "createdAt": "2020-04-08T16:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MzAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2NDA3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405664072", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-08T16:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0MzAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NDQ4MA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405244480", "bodyText": "Good idea to make this a method on ProtoNode.", "author": "ajsutton", "createdAt": "2020-04-08T03:58:36Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }\n+\n+    if (!justifiedEpoch.equals(this.justifiedEpoch)\n+        || !finalizedEpoch.equals(this.finalizedEpoch)) {\n+      this.justifiedEpoch = justifiedEpoch;\n+      this.finalizedEpoch = finalizedEpoch;\n+    }\n+\n+    // Iterate backwards through all indices in `this.nodes`.\n+    for (int nodeIndex = nodes.size() - 1; nodeIndex >= 0; nodeIndex--) {\n+      ProtoNode node = nodes.get(nodeIndex);\n+\n+      // There is no need to adjust the balances or manage parent of the zero hash since it\n+      // is an alias to the genesis block. The weight applied to the genesis block is\n+      // irrelevant as we _always_ choose it and it's impossible for it to have a parent.\n+      if (node.getRoot().equals(Bytes32.ZERO)) {\n+        continue;\n+      }\n+\n+      long nodeDelta = deltas.get(nodeIndex);\n+      node.adjustWeight(nodeDelta);", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwNDg3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405704877", "bodyText": "Thanks!", "author": "cemozerr", "createdAt": "2020-04-08T17:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NDQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NjU5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405246597", "bodyText": "Took me a while to connect these two parts - I know we normally exit early, but I'd be very tempted to write this one as if(node.getParentIndex().isPresent()).  Meredith may disagree. :)\nIdeally I'd use node.getParentIndex().ifPresent(..) but it needs access to the non-final nodeIndex which is slightly annoying so the if structure is probably the best approach.", "author": "ajsutton", "createdAt": "2020-04-08T04:08:12Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }\n+\n+    if (!justifiedEpoch.equals(this.justifiedEpoch)\n+        || !finalizedEpoch.equals(this.finalizedEpoch)) {\n+      this.justifiedEpoch = justifiedEpoch;\n+      this.finalizedEpoch = finalizedEpoch;\n+    }\n+\n+    // Iterate backwards through all indices in `this.nodes`.\n+    for (int nodeIndex = nodes.size() - 1; nodeIndex >= 0; nodeIndex--) {\n+      ProtoNode node = nodes.get(nodeIndex);\n+\n+      // There is no need to adjust the balances or manage parent of the zero hash since it\n+      // is an alias to the genesis block. The weight applied to the genesis block is\n+      // irrelevant as we _always_ choose it and it's impossible for it to have a parent.\n+      if (node.getRoot().equals(Bytes32.ZERO)) {\n+        continue;\n+      }\n+\n+      long nodeDelta = deltas.get(nodeIndex);\n+      node.adjustWeight(nodeDelta);\n+\n+      if (node.getParentIndex().isEmpty()) {\n+        continue;\n+      }\n+\n+      int parentIndex = node.getParentIndex().get();\n+      deltas.set(parentIndex, deltas.get(parentIndex) + nodeDelta);\n+      maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex);\n+    }", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2NzMyOQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405667329", "bodyText": "Yeah, I tried to write with ifPresent but dealing with the non-final nodeIndex was just ugly.", "author": "cemozerr", "createdAt": "2020-04-08T16:48:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NjU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2ODIwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405668201", "bodyText": "You're giving me mixed signals now!!!! exit early or late!?!? jk, I see the point. Switched to isPresent().", "author": "cemozerr", "createdAt": "2020-04-08T16:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NjU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NzI5OQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405247299", "bodyText": "Suggest having a checkNotNull here as well so it's obvious why we get a NullPointerException if finalizedRoot is unknown.", "author": "ajsutton", "createdAt": "2020-04-08T04:11:22Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }\n+\n+    if (!justifiedEpoch.equals(this.justifiedEpoch)\n+        || !finalizedEpoch.equals(this.finalizedEpoch)) {\n+      this.justifiedEpoch = justifiedEpoch;\n+      this.finalizedEpoch = finalizedEpoch;\n+    }\n+\n+    // Iterate backwards through all indices in `this.nodes`.\n+    for (int nodeIndex = nodes.size() - 1; nodeIndex >= 0; nodeIndex--) {\n+      ProtoNode node = nodes.get(nodeIndex);\n+\n+      // There is no need to adjust the balances or manage parent of the zero hash since it\n+      // is an alias to the genesis block. The weight applied to the genesis block is\n+      // irrelevant as we _always_ choose it and it's impossible for it to have a parent.\n+      if (node.getRoot().equals(Bytes32.ZERO)) {\n+        continue;\n+      }\n+\n+      long nodeDelta = deltas.get(nodeIndex);\n+      node.adjustWeight(nodeDelta);\n+\n+      if (node.getParentIndex().isEmpty()) {\n+        continue;\n+      }\n+\n+      int parentIndex = node.getParentIndex().get();\n+      deltas.set(parentIndex, deltas.get(parentIndex) + nodeDelta);\n+      maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex);\n+    }\n+  }\n+\n+  /**\n+   * Update the tree with new finalization information. The tree is only actually pruned if both\n+   * of the two following criteria are met:\n+   *\n+   * - The supplied finalized epoch and root are different to the current values.\n+   * - The number of nodes in `this` is at least `this.pruneThreshold`.\n+   *\n+   * @param finalizedRoot\n+   */\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    int finalizedIndex = indices.get(finalizedRoot);", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2OTI3NQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405669275", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-08T16:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NzI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0ODE4OA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405248188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (newBestChildIndex < 0) {\n          \n          \n            \n                              throw new RuntimeException(\"ProtoArray: New best child index is less than 0\");\n          \n          \n            \n                            }\n          \n          \n            \n                            checkState(newBestChildIndex >= 0, \"ProtoArray: New best child index is less than 0\");", "author": "ajsutton", "createdAt": "2020-04-08T04:15:07Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }\n+\n+    if (!justifiedEpoch.equals(this.justifiedEpoch)\n+        || !finalizedEpoch.equals(this.finalizedEpoch)) {\n+      this.justifiedEpoch = justifiedEpoch;\n+      this.finalizedEpoch = finalizedEpoch;\n+    }\n+\n+    // Iterate backwards through all indices in `this.nodes`.\n+    for (int nodeIndex = nodes.size() - 1; nodeIndex >= 0; nodeIndex--) {\n+      ProtoNode node = nodes.get(nodeIndex);\n+\n+      // There is no need to adjust the balances or manage parent of the zero hash since it\n+      // is an alias to the genesis block. The weight applied to the genesis block is\n+      // irrelevant as we _always_ choose it and it's impossible for it to have a parent.\n+      if (node.getRoot().equals(Bytes32.ZERO)) {\n+        continue;\n+      }\n+\n+      long nodeDelta = deltas.get(nodeIndex);\n+      node.adjustWeight(nodeDelta);\n+\n+      if (node.getParentIndex().isEmpty()) {\n+        continue;\n+      }\n+\n+      int parentIndex = node.getParentIndex().get();\n+      deltas.set(parentIndex, deltas.get(parentIndex) + nodeDelta);\n+      maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex);\n+    }\n+  }\n+\n+  /**\n+   * Update the tree with new finalization information. The tree is only actually pruned if both\n+   * of the two following criteria are met:\n+   *\n+   * - The supplied finalized epoch and root are different to the current values.\n+   * - The number of nodes in `this` is at least `this.pruneThreshold`.\n+   *\n+   * @param finalizedRoot\n+   */\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    int finalizedIndex = indices.get(finalizedRoot);\n+\n+    if (finalizedIndex < pruneThreshold) {\n+      // Pruning at small numbers incurs more cost than benefit.\n+      return;\n+    }\n+\n+    // Remove the `indices` key/values for all the to-be-deleted nodes.\n+    for (int nodeIndex = 0; nodeIndex < finalizedIndex; nodeIndex++) {\n+      Bytes32 root = nodes.get(nodeIndex).getRoot();\n+      indices.remove(root);\n+    }\n+\n+    // Drop all the nodes prior to finalization.\n+    nodes.subList(0, finalizedIndex).clear();\n+\n+    // Adjust the indices map.\n+    indices.replaceAll(\n+        (key, value) -> {\n+          int newIndex = value - finalizedIndex;\n+          if (newIndex < 0) {\n+            throw new RuntimeException(\"ProtoArray: New array index less than 0.\");\n+          }\n+          return newIndex;\n+        });\n+\n+    // Iterate through all the existing nodes and adjust their indices to match the\n+    // new layout of nodes.\n+    for (ProtoNode node : nodes) {\n+      node.getParentIndex()\n+          .ifPresent(\n+              parentIndex -> {\n+                // If node.parentIndex is less than finalizedIndex, set is to None.\n+                if (parentIndex < finalizedIndex) {\n+                  node.setParentIndex(Optional.empty());\n+                } else {\n+                  node.setParentIndex(Optional.of(parentIndex - finalizedIndex));\n+                }\n+              });\n+\n+      node.getBestChildIndex()\n+          .ifPresent(\n+              bestChildIndex -> {\n+                int newBestChildIndex = bestChildIndex - finalizedIndex;\n+                if (newBestChildIndex < 0) {\n+                  throw new RuntimeException(\"ProtoArray: New best child index is less than 0\");\n+                }", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MTA3MA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405671070", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-08T16:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0ODE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0ODMzNA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405248334", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (newBestDescendantIndex < 0) {\n          \n          \n            \n                              throw new RuntimeException(\n          \n          \n            \n                                  \"ProtoArray: New best descendant index is less than 0\");\n          \n          \n            \n                            }\n          \n          \n            \n                            checkState(newBestDescendantIndex >= 0, \"ProtoArray: New best descendant index is less than 0\");", "author": "ajsutton", "createdAt": "2020-04-08T04:15:53Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }\n+\n+    if (!justifiedEpoch.equals(this.justifiedEpoch)\n+        || !finalizedEpoch.equals(this.finalizedEpoch)) {\n+      this.justifiedEpoch = justifiedEpoch;\n+      this.finalizedEpoch = finalizedEpoch;\n+    }\n+\n+    // Iterate backwards through all indices in `this.nodes`.\n+    for (int nodeIndex = nodes.size() - 1; nodeIndex >= 0; nodeIndex--) {\n+      ProtoNode node = nodes.get(nodeIndex);\n+\n+      // There is no need to adjust the balances or manage parent of the zero hash since it\n+      // is an alias to the genesis block. The weight applied to the genesis block is\n+      // irrelevant as we _always_ choose it and it's impossible for it to have a parent.\n+      if (node.getRoot().equals(Bytes32.ZERO)) {\n+        continue;\n+      }\n+\n+      long nodeDelta = deltas.get(nodeIndex);\n+      node.adjustWeight(nodeDelta);\n+\n+      if (node.getParentIndex().isEmpty()) {\n+        continue;\n+      }\n+\n+      int parentIndex = node.getParentIndex().get();\n+      deltas.set(parentIndex, deltas.get(parentIndex) + nodeDelta);\n+      maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex);\n+    }\n+  }\n+\n+  /**\n+   * Update the tree with new finalization information. The tree is only actually pruned if both\n+   * of the two following criteria are met:\n+   *\n+   * - The supplied finalized epoch and root are different to the current values.\n+   * - The number of nodes in `this` is at least `this.pruneThreshold`.\n+   *\n+   * @param finalizedRoot\n+   */\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    int finalizedIndex = indices.get(finalizedRoot);\n+\n+    if (finalizedIndex < pruneThreshold) {\n+      // Pruning at small numbers incurs more cost than benefit.\n+      return;\n+    }\n+\n+    // Remove the `indices` key/values for all the to-be-deleted nodes.\n+    for (int nodeIndex = 0; nodeIndex < finalizedIndex; nodeIndex++) {\n+      Bytes32 root = nodes.get(nodeIndex).getRoot();\n+      indices.remove(root);\n+    }\n+\n+    // Drop all the nodes prior to finalization.\n+    nodes.subList(0, finalizedIndex).clear();\n+\n+    // Adjust the indices map.\n+    indices.replaceAll(\n+        (key, value) -> {\n+          int newIndex = value - finalizedIndex;\n+          if (newIndex < 0) {\n+            throw new RuntimeException(\"ProtoArray: New array index less than 0.\");\n+          }\n+          return newIndex;\n+        });\n+\n+    // Iterate through all the existing nodes and adjust their indices to match the\n+    // new layout of nodes.\n+    for (ProtoNode node : nodes) {\n+      node.getParentIndex()\n+          .ifPresent(\n+              parentIndex -> {\n+                // If node.parentIndex is less than finalizedIndex, set is to None.\n+                if (parentIndex < finalizedIndex) {\n+                  node.setParentIndex(Optional.empty());\n+                } else {\n+                  node.setParentIndex(Optional.of(parentIndex - finalizedIndex));\n+                }\n+              });\n+\n+      node.getBestChildIndex()\n+          .ifPresent(\n+              bestChildIndex -> {\n+                int newBestChildIndex = bestChildIndex - finalizedIndex;\n+                if (newBestChildIndex < 0) {\n+                  throw new RuntimeException(\"ProtoArray: New best child index is less than 0\");\n+                }\n+                node.setBestChildIndex(Optional.of(newBestChildIndex));\n+              });\n+\n+      node.getBestDescendantIndex()\n+          .ifPresent(\n+              bestDescendantIndex -> {\n+                int newBestDescendantIndex = bestDescendantIndex - finalizedIndex;\n+                if (newBestDescendantIndex < 0) {\n+                  throw new RuntimeException(\n+                      \"ProtoArray: New best descendant index is less than 0\");\n+                }", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MTM1OA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405671358", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-08T16:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0ODMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0OTc2Mw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405249763", "bodyText": "Would be worth adding  @SuppressWarnings(\"StatementWithEmptyBody\") to the method so IntelliJ doesn't warn about these empty blocks.", "author": "ajsutton", "createdAt": "2020-04-08T04:22:04Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }\n+\n+    if (!justifiedEpoch.equals(this.justifiedEpoch)\n+        || !finalizedEpoch.equals(this.finalizedEpoch)) {\n+      this.justifiedEpoch = justifiedEpoch;\n+      this.finalizedEpoch = finalizedEpoch;\n+    }\n+\n+    // Iterate backwards through all indices in `this.nodes`.\n+    for (int nodeIndex = nodes.size() - 1; nodeIndex >= 0; nodeIndex--) {\n+      ProtoNode node = nodes.get(nodeIndex);\n+\n+      // There is no need to adjust the balances or manage parent of the zero hash since it\n+      // is an alias to the genesis block. The weight applied to the genesis block is\n+      // irrelevant as we _always_ choose it and it's impossible for it to have a parent.\n+      if (node.getRoot().equals(Bytes32.ZERO)) {\n+        continue;\n+      }\n+\n+      long nodeDelta = deltas.get(nodeIndex);\n+      node.adjustWeight(nodeDelta);\n+\n+      if (node.getParentIndex().isEmpty()) {\n+        continue;\n+      }\n+\n+      int parentIndex = node.getParentIndex().get();\n+      deltas.set(parentIndex, deltas.get(parentIndex) + nodeDelta);\n+      maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex);\n+    }\n+  }\n+\n+  /**\n+   * Update the tree with new finalization information. The tree is only actually pruned if both\n+   * of the two following criteria are met:\n+   *\n+   * - The supplied finalized epoch and root are different to the current values.\n+   * - The number of nodes in `this` is at least `this.pruneThreshold`.\n+   *\n+   * @param finalizedRoot\n+   */\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    int finalizedIndex = indices.get(finalizedRoot);\n+\n+    if (finalizedIndex < pruneThreshold) {\n+      // Pruning at small numbers incurs more cost than benefit.\n+      return;\n+    }\n+\n+    // Remove the `indices` key/values for all the to-be-deleted nodes.\n+    for (int nodeIndex = 0; nodeIndex < finalizedIndex; nodeIndex++) {\n+      Bytes32 root = nodes.get(nodeIndex).getRoot();\n+      indices.remove(root);\n+    }\n+\n+    // Drop all the nodes prior to finalization.\n+    nodes.subList(0, finalizedIndex).clear();\n+\n+    // Adjust the indices map.\n+    indices.replaceAll(\n+        (key, value) -> {\n+          int newIndex = value - finalizedIndex;\n+          if (newIndex < 0) {\n+            throw new RuntimeException(\"ProtoArray: New array index less than 0.\");\n+          }\n+          return newIndex;\n+        });\n+\n+    // Iterate through all the existing nodes and adjust their indices to match the\n+    // new layout of nodes.\n+    for (ProtoNode node : nodes) {\n+      node.getParentIndex()\n+          .ifPresent(\n+              parentIndex -> {\n+                // If node.parentIndex is less than finalizedIndex, set is to None.\n+                if (parentIndex < finalizedIndex) {\n+                  node.setParentIndex(Optional.empty());\n+                } else {\n+                  node.setParentIndex(Optional.of(parentIndex - finalizedIndex));\n+                }\n+              });\n+\n+      node.getBestChildIndex()\n+          .ifPresent(\n+              bestChildIndex -> {\n+                int newBestChildIndex = bestChildIndex - finalizedIndex;\n+                if (newBestChildIndex < 0) {\n+                  throw new RuntimeException(\"ProtoArray: New best child index is less than 0\");\n+                }\n+                node.setBestChildIndex(Optional.of(newBestChildIndex));\n+              });\n+\n+      node.getBestDescendantIndex()\n+          .ifPresent(\n+              bestDescendantIndex -> {\n+                int newBestDescendantIndex = bestDescendantIndex - finalizedIndex;\n+                if (newBestDescendantIndex < 0) {\n+                  throw new RuntimeException(\n+                      \"ProtoArray: New best descendant index is less than 0\");\n+                }\n+                node.setBestDescendantIndex(Optional.of(newBestDescendantIndex));\n+              });\n+    }\n+  }\n+\n+  /**\n+   * Observe the parent at `parentIndex` with respect to the child at `childIndex` and\n+   * potentially modify the `parent.bestChild` and `parent.bestDescendant` values.\n+   *\n+   * ## Detail\n+   *\n+   * There are four outcomes:\n+   *\n+   * - The child is already the best child but it's now invalid due to a FFG change and should be\n+   * removed.\n+   * - The child is already the best child and the parent is updated with the new best descendant.\n+   * - The child is not the best child but becomes the best child.\n+   * - The child is not the best child and does not become the best child.\n+   *\n+   * @param parentIndex\n+   * @param childIndex\n+   */\n+  private void maybeUpdateBestChildAndDescendant(int parentIndex, int childIndex) {\n+    ProtoNode child = nodes.get(childIndex);\n+    ProtoNode parent = nodes.get(parentIndex);\n+\n+    boolean childLeadsToViableHead = nodeLeadsToViableHead(child);\n+\n+    parent\n+        .getBestChildIndex()\n+        .ifPresentOrElse(\n+            bestChildIndex -> {\n+              if (bestChildIndex.equals(childIndex) && !childLeadsToViableHead) {\n+                // If the child is already the best-child of the parent but it's not viable for\n+                // the head, remove it.\n+                changeToNone(parent);\n+              } else if (bestChildIndex.equals(childIndex)) {\n+                // If the child is the best-child already, set it again to ensure that the\n+                // best-descendant of the parent is updated.\n+                changeToChild(parent, childIndex);\n+              } else {\n+                ProtoNode bestChild = nodes.get(bestChildIndex);\n+\n+                boolean bestChildLeadsToViableHead = nodeLeadsToViableHead(bestChild);\n+\n+                if (childLeadsToViableHead && !bestChildLeadsToViableHead) {\n+                  // The child leads to a viable head, but the current best-child doesn't.\n+                  changeToChild(parent, childIndex);\n+                } else if (!childLeadsToViableHead && bestChildLeadsToViableHead) {\n+                  // The best child leads to a viable head, but the child doesn't.\n+                  // No change.\n+                } else if (child.getWeight().equals(bestChild.getWeight())) {\n+                  // Tie-breaker of equal weights by root.\n+                  if (child.getRoot().compareTo(bestChild.getRoot()) >= 0) {\n+                    changeToChild(parent, childIndex);\n+                  } else {\n+                    // No change.\n+                  }", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3NzA2NA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405677064", "bodyText": "Good call. Done.", "author": "cemozerr", "createdAt": "2020-04-08T17:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0OTc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTQ5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405251497", "bodyText": "Is this actually in the spec? Surprised we don't just go with no change in this case (ie if we don't have something clearly better, stick with what we have).", "author": "ajsutton", "createdAt": "2020-04-08T04:29:09Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {\n+\n+  private int pruneThreshold;\n+  private UnsignedLong justifiedEpoch;\n+  private UnsignedLong finalizedEpoch;\n+\n+  private final List<ProtoNode> nodes;\n+  private final Map<Bytes32, Integer> indices;\n+\n+  public ProtoArray(\n+      int pruneThreshold,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      List<ProtoNode> nodes,\n+      Map<Bytes32, Integer> indices) {\n+    this.pruneThreshold = pruneThreshold;\n+    this.justifiedEpoch = justifiedEpoch;\n+    this.finalizedEpoch = finalizedEpoch;\n+    this.nodes = nodes;\n+    this.indices = indices;\n+  }\n+\n+  public Map<Bytes32, Integer> getIndices() {\n+    return indices;\n+  }\n+\n+  public List<ProtoNode> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    this.pruneThreshold = pruneThreshold;\n+  }\n+\n+\n+\n+  /**\n+   * Register a block with the fork choice.\n+   * It is only sane to supply a `None` parent for the genesis block.\n+   *\n+   * @param slot\n+   * @param root\n+   * @param optionalParentRoot\n+   * @param stateRoot\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void onBlock(\n+      UnsignedLong slot,\n+      Bytes32 root,\n+      Optional<Bytes32> optionalParentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    if (indices.containsKey(root)) {\n+      return;\n+    }\n+\n+    int nodeIndex = nodes.size();\n+\n+    ProtoNode node =\n+        new ProtoNode(\n+            slot,\n+            stateRoot,\n+            root,\n+            optionalParentRoot.map(indices::get),\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            UnsignedLong.ZERO,\n+            Optional.empty(),\n+            Optional.empty());\n+\n+    indices.put(node.getRoot(), nodeIndex);\n+    nodes.add(node);\n+\n+    node.getParentIndex()\n+        .ifPresent(parentIndex -> maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex));\n+  }\n+\n+  /**\n+   * Follows the best-descendant links to find the best-block (i.e., head-block).\n+   *\n+   * The result of this function is not guaranteed to be accurate if `onBlock` has\n+   * been called without a subsequent `applyScoreChanges` call. This is because\n+   * `onBlock` does not attempt to walk backwards through the tree and update the\n+   * best child / best descendant links.\n+   *\n+   * @param justifiedRoot\n+   * @return\n+   */\n+  public Bytes32 findHead(Bytes32 justifiedRoot) {\n+    int justifiedIndex = indices.get(justifiedRoot);\n+    ProtoNode justifiedNode = nodes.get(justifiedIndex);\n+\n+    int bestDescendantIndex = justifiedNode.getBestDescendantIndex().orElse(justifiedIndex);\n+    ProtoNode bestNode = nodes.get(bestDescendantIndex);\n+\n+    // Perform a sanity check that the node is indeed valid to be the head.\n+    if (!nodeIsViableForHead(bestNode)) {\n+      throw new RuntimeException(\"ProtoArray: Best node is not viable for head\");\n+    }\n+\n+    return bestNode.getRoot();\n+  }\n+\n+  /**\n+   * Iterate backwards through the array, touching all nodes and their parents and potentially\n+   * the bestChildIndex of each parent.\n+   *\n+   * The structure of the `nodes` array ensures that the child of each node is always\n+   * touched before its parent.\n+   *\n+   * For each node, the following is done:\n+   *\n+   * - Update the node's weight with the corresponding delta.\n+   * - Back-propagate each node's delta to its parents delta.\n+   * - Compare the current node with the parents best child, updating it if the current node\n+   * should become the best child.\n+   * - If required, update the parents best descendant with the current node or its best descendant.\n+   *\n+   * @param deltas\n+   * @param justifiedEpoch\n+   * @param finalizedEpoch\n+   */\n+  public void applyScoreChanges(\n+      List<Long> deltas, UnsignedLong justifiedEpoch, UnsignedLong finalizedEpoch) {\n+    if (deltas.size() != indices.size()) {\n+      throw new RuntimeException(\"ProtoArray: Invalid delta length\");\n+    }\n+\n+    if (!justifiedEpoch.equals(this.justifiedEpoch)\n+        || !finalizedEpoch.equals(this.finalizedEpoch)) {\n+      this.justifiedEpoch = justifiedEpoch;\n+      this.finalizedEpoch = finalizedEpoch;\n+    }\n+\n+    // Iterate backwards through all indices in `this.nodes`.\n+    for (int nodeIndex = nodes.size() - 1; nodeIndex >= 0; nodeIndex--) {\n+      ProtoNode node = nodes.get(nodeIndex);\n+\n+      // There is no need to adjust the balances or manage parent of the zero hash since it\n+      // is an alias to the genesis block. The weight applied to the genesis block is\n+      // irrelevant as we _always_ choose it and it's impossible for it to have a parent.\n+      if (node.getRoot().equals(Bytes32.ZERO)) {\n+        continue;\n+      }\n+\n+      long nodeDelta = deltas.get(nodeIndex);\n+      node.adjustWeight(nodeDelta);\n+\n+      if (node.getParentIndex().isEmpty()) {\n+        continue;\n+      }\n+\n+      int parentIndex = node.getParentIndex().get();\n+      deltas.set(parentIndex, deltas.get(parentIndex) + nodeDelta);\n+      maybeUpdateBestChildAndDescendant(parentIndex, nodeIndex);\n+    }\n+  }\n+\n+  /**\n+   * Update the tree with new finalization information. The tree is only actually pruned if both\n+   * of the two following criteria are met:\n+   *\n+   * - The supplied finalized epoch and root are different to the current values.\n+   * - The number of nodes in `this` is at least `this.pruneThreshold`.\n+   *\n+   * @param finalizedRoot\n+   */\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    int finalizedIndex = indices.get(finalizedRoot);\n+\n+    if (finalizedIndex < pruneThreshold) {\n+      // Pruning at small numbers incurs more cost than benefit.\n+      return;\n+    }\n+\n+    // Remove the `indices` key/values for all the to-be-deleted nodes.\n+    for (int nodeIndex = 0; nodeIndex < finalizedIndex; nodeIndex++) {\n+      Bytes32 root = nodes.get(nodeIndex).getRoot();\n+      indices.remove(root);\n+    }\n+\n+    // Drop all the nodes prior to finalization.\n+    nodes.subList(0, finalizedIndex).clear();\n+\n+    // Adjust the indices map.\n+    indices.replaceAll(\n+        (key, value) -> {\n+          int newIndex = value - finalizedIndex;\n+          if (newIndex < 0) {\n+            throw new RuntimeException(\"ProtoArray: New array index less than 0.\");\n+          }\n+          return newIndex;\n+        });\n+\n+    // Iterate through all the existing nodes and adjust their indices to match the\n+    // new layout of nodes.\n+    for (ProtoNode node : nodes) {\n+      node.getParentIndex()\n+          .ifPresent(\n+              parentIndex -> {\n+                // If node.parentIndex is less than finalizedIndex, set is to None.\n+                if (parentIndex < finalizedIndex) {\n+                  node.setParentIndex(Optional.empty());\n+                } else {\n+                  node.setParentIndex(Optional.of(parentIndex - finalizedIndex));\n+                }\n+              });\n+\n+      node.getBestChildIndex()\n+          .ifPresent(\n+              bestChildIndex -> {\n+                int newBestChildIndex = bestChildIndex - finalizedIndex;\n+                if (newBestChildIndex < 0) {\n+                  throw new RuntimeException(\"ProtoArray: New best child index is less than 0\");\n+                }\n+                node.setBestChildIndex(Optional.of(newBestChildIndex));\n+              });\n+\n+      node.getBestDescendantIndex()\n+          .ifPresent(\n+              bestDescendantIndex -> {\n+                int newBestDescendantIndex = bestDescendantIndex - finalizedIndex;\n+                if (newBestDescendantIndex < 0) {\n+                  throw new RuntimeException(\n+                      \"ProtoArray: New best descendant index is less than 0\");\n+                }\n+                node.setBestDescendantIndex(Optional.of(newBestDescendantIndex));\n+              });\n+    }\n+  }\n+\n+  /**\n+   * Observe the parent at `parentIndex` with respect to the child at `childIndex` and\n+   * potentially modify the `parent.bestChild` and `parent.bestDescendant` values.\n+   *\n+   * ## Detail\n+   *\n+   * There are four outcomes:\n+   *\n+   * - The child is already the best child but it's now invalid due to a FFG change and should be\n+   * removed.\n+   * - The child is already the best child and the parent is updated with the new best descendant.\n+   * - The child is not the best child but becomes the best child.\n+   * - The child is not the best child and does not become the best child.\n+   *\n+   * @param parentIndex\n+   * @param childIndex\n+   */\n+  private void maybeUpdateBestChildAndDescendant(int parentIndex, int childIndex) {\n+    ProtoNode child = nodes.get(childIndex);\n+    ProtoNode parent = nodes.get(parentIndex);\n+\n+    boolean childLeadsToViableHead = nodeLeadsToViableHead(child);\n+\n+    parent\n+        .getBestChildIndex()\n+        .ifPresentOrElse(\n+            bestChildIndex -> {\n+              if (bestChildIndex.equals(childIndex) && !childLeadsToViableHead) {\n+                // If the child is already the best-child of the parent but it's not viable for\n+                // the head, remove it.\n+                changeToNone(parent);\n+              } else if (bestChildIndex.equals(childIndex)) {\n+                // If the child is the best-child already, set it again to ensure that the\n+                // best-descendant of the parent is updated.\n+                changeToChild(parent, childIndex);\n+              } else {\n+                ProtoNode bestChild = nodes.get(bestChildIndex);\n+\n+                boolean bestChildLeadsToViableHead = nodeLeadsToViableHead(bestChild);\n+\n+                if (childLeadsToViableHead && !bestChildLeadsToViableHead) {\n+                  // The child leads to a viable head, but the current best-child doesn't.\n+                  changeToChild(parent, childIndex);\n+                } else if (!childLeadsToViableHead && bestChildLeadsToViableHead) {\n+                  // The best child leads to a viable head, but the child doesn't.\n+                  // No change.\n+                } else if (child.getWeight().equals(bestChild.getWeight())) {\n+                  // Tie-breaker of equal weights by root.\n+                  if (child.getRoot().compareTo(bestChild.getRoot()) >= 0) {", "originalCommit": "6df5929d3f42f6ace35ab86c3d76dedf39f2a5de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3NDE0Mw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405674143", "bodyText": "Yeah, this is what we have in the original spec code:\nhead = children.stream()\n              .filter(child -> get_latest_attesting_balance(store, child).compareTo(max) == 0)\n              .max(Comparator.comparing(Bytes::toHexString))\n              .get();```", "author": "cemozerr", "createdAt": "2020-04-08T16:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3NTI4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405675285", "bodyText": "In comments we have:\n  // Sort by latest attesting balance with ties broken lexicographically", "author": "cemozerr", "createdAt": "2020-04-08T16:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3NjE2NQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405676165", "bodyText": "Although I'm wondering if Bytes.compare() as I do now, or Bytes.toHexString() as I did in ForkChoiceUtil, does correct lexicographical comparison", "author": "cemozerr", "createdAt": "2020-04-08T17:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3NjgwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r405676801", "bodyText": "We might have had that as a hidden bug due to not having fork choice reference tests.", "author": "cemozerr", "createdAt": "2020-04-08T17:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc1Mzc1MQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407753751", "bodyText": "I believe they sort the same way whether you use the raw bytes or the hex string.", "author": "ajsutton", "createdAt": "2020-04-13T22:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTQ5Nw=="}], "type": "inlineReview"}, {"oid": "dc8e8ef87e9d75d953529d1842a1fcf5c965a284", "url": "https://github.com/ConsenSys/teku/commit/dc8e8ef87e9d75d953529d1842a1fcf5c965a284", "message": "Resolve comments", "committedDate": "2020-04-08T18:48:33Z", "type": "commit"}, {"oid": "4de1b05331b3590b401f71ef28db38339f0a0400", "url": "https://github.com/ConsenSys/teku/commit/4de1b05331b3590b401f71ef28db38339f0a0400", "message": "Implementing VotestTest", "committedDate": "2020-04-09T18:47:18Z", "type": "commit"}, {"oid": "dd756efd996fe895e437891dc8beabf73a1b1086", "url": "https://github.com/ConsenSys/teku/commit/dd756efd996fe895e437891dc8beabf73a1b1086", "message": "Fix computeDeltas test", "committedDate": "2020-04-09T19:57:44Z", "type": "commit"}, {"oid": "4bce1d13f8a746f5145c8d41ee57d82d42ac9631", "url": "https://github.com/ConsenSys/teku/commit/4bce1d13f8a746f5145c8d41ee57d82d42ac9631", "message": "Finish implementing VotesTest", "committedDate": "2020-04-09T20:25:44Z", "type": "commit"}, {"oid": "bf5a3ea9ecbc8b7e3422ae3be8f04589299b6614", "url": "https://github.com/ConsenSys/teku/commit/bf5a3ea9ecbc8b7e3422ae3be8f04589299b6614", "message": "Implement all Protoarray tests", "committedDate": "2020-04-09T22:25:09Z", "type": "commit"}, {"oid": "dac16df5234888f6044e7c3366b588d97d38a72a", "url": "https://github.com/ConsenSys/teku/commit/dac16df5234888f6044e7c3366b588d97d38a72a", "message": "Run spotless", "committedDate": "2020-04-09T22:31:03Z", "type": "commit"}, {"oid": "03a5eb947f3886763988e5edff032ce07b9e6ed8", "url": "https://github.com/ConsenSys/teku/commit/03a5eb947f3886763988e5edff032ce07b9e6ed8", "message": "Clarify variable naming", "committedDate": "2020-04-10T02:28:49Z", "type": "commit"}, {"oid": "af468347a39c35e88580457ecaf33734747c0d33", "url": "https://github.com/ConsenSys/teku/commit/af468347a39c35e88580457ecaf33734747c0d33", "message": "Start integrating ProtoArrayForkChoice into Teku", "committedDate": "2020-04-10T20:10:28Z", "type": "commit"}, {"oid": "26e13f554014ab3c93c055df3b72bd2e5e69f008", "url": "https://github.com/ConsenSys/teku/commit/26e13f554014ab3c93c055df3b72bd2e5e69f008", "message": "Merge remote-tracking branch 'remotes/origin/master' into protoarray", "committedDate": "2020-04-10T20:12:46Z", "type": "commit"}, {"oid": "7c0e68e25e54ed0796f471c2ba35a21f9ded2ccc", "url": "https://github.com/ConsenSys/teku/commit/7c0e68e25e54ed0796f471c2ba35a21f9ded2ccc", "message": "Finish implementing ForkChoice object", "committedDate": "2020-04-10T20:58:39Z", "type": "commit"}, {"oid": "02e2fb0c4c7bc403a1d36967621ca56ba5dc5f7e", "url": "https://github.com/ConsenSys/teku/commit/02e2fb0c4c7bc403a1d36967621ca56ba5dc5f7e", "message": "Start integrating Fork Choice", "committedDate": "2020-04-11T01:42:27Z", "type": "commit"}, {"oid": "b7e900405c942d69f2263246ce54ff5ba2ad0b1b", "url": "https://github.com/ConsenSys/teku/commit/b7e900405c942d69f2263246ce54ff5ba2ad0b1b", "message": "Finish initial integration", "committedDate": "2020-04-11T03:37:50Z", "type": "commit"}, {"oid": "d34e59d828011f59628021df65d790ef8aa6b26a", "url": "https://github.com/ConsenSys/teku/commit/d34e59d828011f59628021df65d790ef8aa6b26a", "message": "Fix test", "committedDate": "2020-04-13T17:17:42Z", "type": "commit"}, {"oid": "c680a2d5b96c878bfa684361714741637f69dd94", "url": "https://github.com/ConsenSys/teku/commit/c680a2d5b96c878bfa684361714741637f69dd94", "message": "Merge remote-tracking branch 'remotes/origin/master' into protoarray\n\n# Conflicts:\n#\tethereum/statetransition/build.gradle\n#\tethereum/statetransition/src/testFixtures/java/tech/pegasys/artemis/statetransition/BeaconChainUtil.java\n#\tservices/beaconchain/src/main/java/tech/pegasys/artemis/services/beaconchain/BeaconChainController.java", "committedDate": "2020-04-13T17:23:08Z", "type": "commit"}, {"oid": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "url": "https://github.com/ConsenSys/teku/commit/8585ee132eb5c89d44c871fbcbc5a276461a1b07", "message": "Remove import", "committedDate": "2020-04-13T17:35:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MjU2Nw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407762567", "bodyText": "I'd suggest calling this ForkChoiceStrategy and then you'd have ProtoArrayForkChoiceStrategy and StubForkChoiceStrategy as the two implementations.", "author": "ajsutton", "createdAt": "2020-04-13T22:44:53Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoiceClient.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.MutableStore;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.storage.Store;\n+\n+public interface ProtoArrayForkChoiceClient {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NTAwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407775005", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-13T23:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MjU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NTA5OA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407775098", "bodyText": "Great idea btw. I was just looking for this.", "author": "cemozerr", "createdAt": "2020-04-13T23:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MzE2OA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407763168", "bodyText": "This file appears to be in a directory called tech.pegasys.artemis.protoarray but they should be multiple directories.  IntelliJ shows them the same way but the GitHub diff shows the different (it should show tech/pegasys/artemis/protoarray)", "author": "ajsutton", "createdAt": "2020-04-13T22:46:40Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoNode.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoNode {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NDg3MQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407764871", "bodyText": "nit: this class could also be package private since it's an internal detail of the implementation.", "author": "ajsutton", "createdAt": "2020-04-13T22:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MzE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NTk4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407775983", "bodyText": "I think I fixed the directory issue now.", "author": "cemozerr", "createdAt": "2020-04-13T23:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MzE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NjA2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407776062", "bodyText": "Also made the ProtoNode class package private.", "author": "cemozerr", "createdAt": "2020-04-13T23:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MzE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NTAxMA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407765010", "bodyText": "nit: could be package private.", "author": "ajsutton", "createdAt": "2020-04-13T22:51:57Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArray.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class ProtoArray {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NjI3Ng==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407776276", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-04-13T23:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NTA0Nw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407765047", "bodyText": "nit: could be package private.", "author": "ajsutton", "createdAt": "2020-04-13T22:52:05Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ElasticList.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import java.util.ArrayList;\n+import java.util.function.Supplier;\n+\n+public class ElasticList<T> extends ArrayList<T> {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NjM2MA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407776360", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-04-13T23:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NTA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NTE2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407765162", "bodyText": "nit: Can be package private.", "author": "ajsutton", "createdAt": "2020-04-13T22:52:26Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/VoteTracker.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class VoteTracker {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NjQzMg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407776432", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-13T23:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NTE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NjY3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407766672", "bodyText": "This test name implies it's testing ComputeDeltas class but the function is actually in ProtoArrayForkChoice.   Probably should rename this to either ProtoArrayForkChoiceTest since we don't currently have one of those or ProtoArrayForkChoiceComputeDeltasTest if we do want to separate test classes for the one production class (which sometimes happens if you need different setup or just a lot of tests etc).\nThe other option would be to move the static compute_deltas method to a DeltaUtils kind of class and this is the test for that.", "author": "ajsutton", "createdAt": "2020-04-13T22:57:06Z", "path": "protoarray/src/test/java/tech/pegasys/artemis/protoarray/ComputeDeltasTest.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.protoarray.HashUtil.getHash;\n+import static tech.pegasys.artemis.protoarray.ProtoArrayForkChoice.computeDeltas;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class ComputeDeltasTest {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3Nzk4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407777982", "bodyText": "I did not understand this to be honest:\n\nProtoArrayForkChoiceComputeDeltasTest if we do want to separate test classes for the one production class\n\nNevertheless, I switched to ProtoArrayForkChoiceTest , since that makes sense.", "author": "cemozerr", "createdAt": "2020-04-13T23:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NjY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTA5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407769096", "bodyText": "We turned out to not use any of these functions.  Is there something we should be doing with them?", "author": "ajsutton", "createdAt": "2020-04-13T23:04:06Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.MutableStore;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice implements ProtoArrayForkChoiceClient {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();\n+  private final ProtoArray protoArray;\n+  private final ElasticList<VoteTracker> votes;\n+\n+  private List<UnsignedLong> balances;\n+\n+  private ProtoArrayForkChoice(\n+      ProtoArray protoArray, ElasticList<VoteTracker> votes, List<UnsignedLong> balances) {\n+    this.protoArray = protoArray;\n+    this.votes = votes;\n+    this.balances = balances;\n+  }\n+\n+  // Public\n+\n+  public static ProtoArrayForkChoice create(ReadOnlyStore store) {\n+    Bytes32 finalizedBlockRoot = store.getFinalizedCheckpoint().getRoot();\n+    return create(\n+        store.getBlock(finalizedBlockRoot).getSlot(),\n+        store.getBlockState(finalizedBlockRoot).hashTreeRoot(),\n+        store.getFinalizedCheckpoint().getEpoch(),\n+        store.getJustifiedCheckpoint().getEpoch(),\n+        finalizedBlockRoot);\n+  }\n+\n+  @Override\n+  public Bytes32 findHead(final Store store) {\n+    Checkpoint justifiedCheckpoint = store.getJustifiedCheckpoint();\n+    return findHead(\n+        justifiedCheckpoint.getEpoch(),\n+        justifiedCheckpoint.getRoot(),\n+        store.getFinalizedCheckpoint().getEpoch(),\n+        store.getCheckpointState(justifiedCheckpoint).getBalances().asList());\n+  }\n+\n+  @Override\n+  public void onAttestation(final IndexedAttestation attestation) {\n+    votesLock.writeLock().lock();\n+    try {\n+      attestation.getAttesting_indices().stream()\n+          .parallel()\n+          .forEach(\n+              validatorIndex -> {\n+                processAttestation(\n+                    Math.toIntExact(validatorIndex.longValue()),\n+                    attestation.getData().getBeacon_block_root(),\n+                    attestation.getData().getTarget().getEpoch());\n+              });\n+    } finally {\n+      votesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public void onBlock(final MutableStore store, final BeaconBlock block) {\n+    processBlock(\n+        block.getSlot(),\n+        block.hash_tree_root(),\n+        block.getParent_root(),\n+        block.getState_root(),\n+        store.getJustifiedCheckpoint().getEpoch(),\n+        store.getFinalizedCheckpoint().getEpoch());\n+  }\n+\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.maybePrune(finalizedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  // Internal\n+\n+  static ProtoArrayForkChoice create(\n+      UnsignedLong finalizedBlockSlot,\n+      Bytes32 finalizedBlockStateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      Bytes32 finalizedBlockRoot) {\n+    ProtoArray protoArray =\n+        new ProtoArray(\n+            Constants.PROTOARRAY_FORKCHOICE_PRUNE_THRESHOLD,\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            new ArrayList<>(),\n+            new HashMap<>());\n+\n+    protoArray.onBlock(\n+        finalizedBlockSlot,\n+        finalizedBlockRoot,\n+        Optional.empty(),\n+        finalizedBlockStateRoot,\n+        justifiedEpoch,\n+        finalizedEpoch);\n+\n+    return new ProtoArrayForkChoice(\n+        protoArray, new ElasticList<>(VoteTracker::Default), new ArrayList<>());\n+  }\n+\n+  void processAttestation(int validatorIndex, Bytes32 blockRoot, UnsignedLong targetEpoch) {\n+    VoteTracker vote = votes.get(validatorIndex);\n+\n+    if (targetEpoch.compareTo(vote.getNextEpoch()) > 0 || vote.equals(VoteTracker.Default())) {\n+      vote.setNextRoot(blockRoot);\n+      vote.setNextEpoch(targetEpoch);\n+    }\n+  }\n+\n+  void processBlock(\n+      UnsignedLong blockSlot,\n+      Bytes32 blockRoot,\n+      Bytes32 parentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.onBlock(\n+          blockSlot, blockRoot, Optional.of(parentRoot), stateRoot, justifiedEpoch, finalizedEpoch);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  Bytes32 findHead(\n+      UnsignedLong justifiedEpoch,\n+      Bytes32 justifiedRoot,\n+      UnsignedLong finalizedEpoch,\n+      List<UnsignedLong> justifiedStateBalances) {\n+    protoArrayLock.writeLock().lock();\n+    votesLock.writeLock().lock();\n+    balancesLock.writeLock().lock();\n+    try {\n+      List<UnsignedLong> oldBalances = balances;\n+      List<UnsignedLong> newBalances = justifiedStateBalances;\n+\n+      List<Long> deltas = computeDeltas(protoArray.getIndices(), votes, oldBalances, newBalances);\n+\n+      protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n+      balances = new ArrayList<>(newBalances);\n+\n+      return protoArray.findHead(justifiedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+      votesLock.writeLock().unlock();\n+      balancesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.setPruneThreshold(pruneThreshold);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public int size() {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getNodes().size();\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public boolean containsBlock(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getIndices().containsKey(blockRoot);\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<UnsignedLong> blockSlot(Bytes32 blockRoot) {\n+    return blockSlotAndStateRoot(blockRoot).map(BlockSlotAndStateRoot::getBlockSlot);\n+  }\n+\n+  public Optional<BlockSlotAndStateRoot> blockSlotAndStateRoot(Bytes32 blockRoot) {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4Mjg4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407782883", "bodyText": "Made a JIRA ticket as discussed offline: https://pegasys1.atlassian.net/secure/RapidBoard.jspa?rapidView=67&modal=detail&selectedIssue=BC-344", "author": "cemozerr", "createdAt": "2020-04-13T23:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTE5Mw==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407769193", "bodyText": "We didn't wind up using this either.", "author": "ajsutton", "createdAt": "2020-04-13T23:04:20Z", "path": "protoarray/src/main/java/tech.pegasys.artemis.protoarray/ProtoArrayForkChoice.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.addExact;\n+import static java.lang.Math.subtractExact;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.MutableStore;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class ProtoArrayForkChoice implements ProtoArrayForkChoiceClient {\n+  private final ReadWriteLock protoArrayLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock votesLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock balancesLock = new ReentrantReadWriteLock();\n+  private final ProtoArray protoArray;\n+  private final ElasticList<VoteTracker> votes;\n+\n+  private List<UnsignedLong> balances;\n+\n+  private ProtoArrayForkChoice(\n+      ProtoArray protoArray, ElasticList<VoteTracker> votes, List<UnsignedLong> balances) {\n+    this.protoArray = protoArray;\n+    this.votes = votes;\n+    this.balances = balances;\n+  }\n+\n+  // Public\n+\n+  public static ProtoArrayForkChoice create(ReadOnlyStore store) {\n+    Bytes32 finalizedBlockRoot = store.getFinalizedCheckpoint().getRoot();\n+    return create(\n+        store.getBlock(finalizedBlockRoot).getSlot(),\n+        store.getBlockState(finalizedBlockRoot).hashTreeRoot(),\n+        store.getFinalizedCheckpoint().getEpoch(),\n+        store.getJustifiedCheckpoint().getEpoch(),\n+        finalizedBlockRoot);\n+  }\n+\n+  @Override\n+  public Bytes32 findHead(final Store store) {\n+    Checkpoint justifiedCheckpoint = store.getJustifiedCheckpoint();\n+    return findHead(\n+        justifiedCheckpoint.getEpoch(),\n+        justifiedCheckpoint.getRoot(),\n+        store.getFinalizedCheckpoint().getEpoch(),\n+        store.getCheckpointState(justifiedCheckpoint).getBalances().asList());\n+  }\n+\n+  @Override\n+  public void onAttestation(final IndexedAttestation attestation) {\n+    votesLock.writeLock().lock();\n+    try {\n+      attestation.getAttesting_indices().stream()\n+          .parallel()\n+          .forEach(\n+              validatorIndex -> {\n+                processAttestation(\n+                    Math.toIntExact(validatorIndex.longValue()),\n+                    attestation.getData().getBeacon_block_root(),\n+                    attestation.getData().getTarget().getEpoch());\n+              });\n+    } finally {\n+      votesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public void onBlock(final MutableStore store, final BeaconBlock block) {\n+    processBlock(\n+        block.getSlot(),\n+        block.hash_tree_root(),\n+        block.getParent_root(),\n+        block.getState_root(),\n+        store.getJustifiedCheckpoint().getEpoch(),\n+        store.getFinalizedCheckpoint().getEpoch());\n+  }\n+\n+  public void maybePrune(Bytes32 finalizedRoot) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.maybePrune(finalizedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  // Internal\n+\n+  static ProtoArrayForkChoice create(\n+      UnsignedLong finalizedBlockSlot,\n+      Bytes32 finalizedBlockStateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch,\n+      Bytes32 finalizedBlockRoot) {\n+    ProtoArray protoArray =\n+        new ProtoArray(\n+            Constants.PROTOARRAY_FORKCHOICE_PRUNE_THRESHOLD,\n+            justifiedEpoch,\n+            finalizedEpoch,\n+            new ArrayList<>(),\n+            new HashMap<>());\n+\n+    protoArray.onBlock(\n+        finalizedBlockSlot,\n+        finalizedBlockRoot,\n+        Optional.empty(),\n+        finalizedBlockStateRoot,\n+        justifiedEpoch,\n+        finalizedEpoch);\n+\n+    return new ProtoArrayForkChoice(\n+        protoArray, new ElasticList<>(VoteTracker::Default), new ArrayList<>());\n+  }\n+\n+  void processAttestation(int validatorIndex, Bytes32 blockRoot, UnsignedLong targetEpoch) {\n+    VoteTracker vote = votes.get(validatorIndex);\n+\n+    if (targetEpoch.compareTo(vote.getNextEpoch()) > 0 || vote.equals(VoteTracker.Default())) {\n+      vote.setNextRoot(blockRoot);\n+      vote.setNextEpoch(targetEpoch);\n+    }\n+  }\n+\n+  void processBlock(\n+      UnsignedLong blockSlot,\n+      Bytes32 blockRoot,\n+      Bytes32 parentRoot,\n+      Bytes32 stateRoot,\n+      UnsignedLong justifiedEpoch,\n+      UnsignedLong finalizedEpoch) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.onBlock(\n+          blockSlot, blockRoot, Optional.of(parentRoot), stateRoot, justifiedEpoch, finalizedEpoch);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  Bytes32 findHead(\n+      UnsignedLong justifiedEpoch,\n+      Bytes32 justifiedRoot,\n+      UnsignedLong finalizedEpoch,\n+      List<UnsignedLong> justifiedStateBalances) {\n+    protoArrayLock.writeLock().lock();\n+    votesLock.writeLock().lock();\n+    balancesLock.writeLock().lock();\n+    try {\n+      List<UnsignedLong> oldBalances = balances;\n+      List<UnsignedLong> newBalances = justifiedStateBalances;\n+\n+      List<Long> deltas = computeDeltas(protoArray.getIndices(), votes, oldBalances, newBalances);\n+\n+      protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n+      balances = new ArrayList<>(newBalances);\n+\n+      return protoArray.findHead(justifiedRoot);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+      votesLock.writeLock().unlock();\n+      balancesLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setPruneThreshold(int pruneThreshold) {\n+    protoArrayLock.writeLock().lock();\n+    try {\n+      protoArray.setPruneThreshold(pruneThreshold);\n+    } finally {\n+      protoArrayLock.writeLock().unlock();\n+    }\n+  }\n+\n+  public int size() {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getNodes().size();\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public boolean containsBlock(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      return protoArray.getIndices().containsKey(blockRoot);\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<UnsignedLong> blockSlot(Bytes32 blockRoot) {\n+    return blockSlotAndStateRoot(blockRoot).map(BlockSlotAndStateRoot::getBlockSlot);\n+  }\n+\n+  public Optional<BlockSlotAndStateRoot> blockSlotAndStateRoot(Bytes32 blockRoot) {\n+    protoArrayLock.readLock().lock();\n+    try {\n+      int blockIndex =\n+          checkNotNull(\n+              protoArray.getIndices().get(blockRoot), \"ProtoArrayForkChoice: Unknown block root\");\n+      if (blockIndex >= protoArray.getNodes().size()) {\n+        return Optional.empty();\n+      } else {\n+        ProtoNode node = protoArray.getNodes().get(blockIndex);\n+        return Optional.of(new BlockSlotAndStateRoot(node.getBlockSlot(), node.getStateRoot()));\n+      }\n+    } finally {\n+      protoArrayLock.readLock().unlock();\n+    }\n+  }\n+\n+  public Optional<Checkpoint> latestMessage(int validatorIndex) {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MjkyOA==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407782928", "bodyText": "Discussed offline.", "author": "cemozerr", "createdAt": "2020-04-13T23:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTU0Mg==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407769542", "bodyText": "We should use a real variable name here not just __ - we really are using the value if only to check when to exit the loop.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int __ = 0; __ < 2; __++) {\n          \n          \n            \n                for (int i = 0; i < 2; i++) {", "author": "ajsutton", "createdAt": "2020-04-13T23:05:21Z", "path": "protoarray/src/test/java/tech/pegasys/artemis/protoarray/ComputeDeltasTest.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.protoarray.HashUtil.getHash;\n+import static tech.pegasys.artemis.protoarray.ProtoArrayForkChoice.computeDeltas;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class ComputeDeltasTest {\n+\n+  private Map<Bytes32, Integer> indices;\n+  private ElasticList<VoteTracker> votes;\n+  private List<UnsignedLong> oldBalances;\n+  private List<UnsignedLong> newBalances;\n+\n+  @BeforeEach\n+  void setUp() {\n+    indices = new HashMap<>();\n+    votes = new ElasticList<>(VoteTracker::Default);\n+    oldBalances = new ArrayList<>();\n+    newBalances = new ArrayList<>();\n+  }\n+\n+  @Test\n+  void zeroHash() {\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(Bytes32.ZERO, Bytes32.ZERO, ZERO));\n+      oldBalances.add(ZERO);\n+      newBalances.add(ZERO);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    // Deltas should all be zero\n+    assertThat(deltas).containsOnly(0L);\n+  }\n+\n+  @Test\n+  void allVotedTheSame() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(Bytes32.ZERO, getHash(0), ZERO));\n+      oldBalances.add(BALANCE);\n+      newBalances.add(BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    for (int i = 0; i < deltas.size(); i++) {\n+      long delta = deltas.get(i);\n+      if (i == 0) {\n+        // Zero'th root should have a delta\n+        assertThat(delta).isEqualTo(BALANCE.longValue() * Integer.toUnsignedLong(validatorCount));\n+      } else {\n+        // All other deltas should be zero\n+        assertThat(delta).isEqualTo(0L);\n+      }\n+    }\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void differentVotes() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(Bytes32.ZERO, getHash(i), ZERO));\n+      oldBalances.add(BALANCE);\n+      newBalances.add(BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    // Each root should have the same delta\n+    assertThat(deltas).containsOnly(BALANCE.longValue());\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void movingVotes() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(getHash(0), getHash(1), ZERO));\n+      oldBalances.add(BALANCE);\n+      newBalances.add(BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+\n+    assertThat(deltas).hasSize(validatorCount);\n+    long totalDelta = BALANCE.longValue() * Integer.toUnsignedLong(validatorCount);\n+\n+    for (int i = 0; i < deltas.size(); i++) {\n+      long delta = deltas.get(i);\n+      if (i == 0) {\n+        // Zero'th root should have a negative delta\n+        assertThat(delta).isEqualTo(-totalDelta);\n+      } else if (i == 1) {\n+        // First root should have positive delta\n+        assertThat(delta).isEqualTo(totalDelta);\n+      } else {\n+        // All other deltas should be zero\n+        assertThat(delta).isEqualTo(0L);\n+      }\n+    }\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void moveOutOfTree() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+\n+    // There is only one block.\n+    indices.put(getHash(1), 0);\n+\n+    // There are two validators.\n+    oldBalances = Collections.nCopies(2, BALANCE);\n+    newBalances = Collections.nCopies(2, BALANCE);\n+\n+    // One validator moves their vote from the block to the zero hash.\n+    votes.add(new VoteTracker(getHash(1), Bytes32.ZERO, ZERO));\n+\n+    // One validator moves their vote from the block to something outside the tree.\n+    votes.add(new VoteTracker(getHash(1), getHash(1337), ZERO));\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(1);\n+\n+    // The block should have lost both balances\n+    assertThat(deltas.get(0)).isEqualTo(-BALANCE.longValue() * 2);\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void changingBalances() {\n+\n+    final UnsignedLong OLD_BALANCE = valueOf(42);\n+    final UnsignedLong NEW_BALANCE = OLD_BALANCE.times(valueOf(2));\n+\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(getHash(0), getHash(1), ZERO));\n+      oldBalances.add(OLD_BALANCE);\n+      newBalances.add(NEW_BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    for (int i = 0; i < deltas.size(); i++) {\n+      long delta = deltas.get(i);\n+      if (i == 0) {\n+        // Zero'th root should have a negative delta\n+        assertThat(delta).isEqualTo(-OLD_BALANCE.longValue() * validatorCount);\n+      } else if (i == 1) {\n+        // First root should have positive delta\n+        assertThat(delta).isEqualTo(NEW_BALANCE.longValue() * validatorCount);\n+      } else {\n+        // All other deltas should be zero\n+        assertThat(delta).isEqualTo(0L);\n+      }\n+    }\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void validatorAppears() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+\n+    // There are two blocks.\n+    indices.put(getHash(1), 0);\n+    indices.put(getHash(2), 1);\n+\n+    // There is only one validator in the old balances.\n+    oldBalances.add(BALANCE);\n+\n+    // There are two validators in the new balances.\n+    newBalances.addAll(List.of(BALANCE, BALANCE));\n+\n+    // Both validators move votes from block 1 to block 2.\n+    for (int __ = 0; __ < 2; __++) {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MzM2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407783366", "bodyText": "Done. Honestly, I don't know what had gotten into me to write it that way.", "author": "cemozerr", "createdAt": "2020-04-13T23:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTk1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407769956", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int __ = 0; __ < 2; __++) {\n          \n          \n            \n                for (int i = 0; i < 2; i++) {", "author": "ajsutton", "createdAt": "2020-04-13T23:06:48Z", "path": "protoarray/src/test/java/tech/pegasys/artemis/protoarray/ComputeDeltasTest.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.protoarray;\n+\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.protoarray.HashUtil.getHash;\n+import static tech.pegasys.artemis.protoarray.ProtoArrayForkChoice.computeDeltas;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class ComputeDeltasTest {\n+\n+  private Map<Bytes32, Integer> indices;\n+  private ElasticList<VoteTracker> votes;\n+  private List<UnsignedLong> oldBalances;\n+  private List<UnsignedLong> newBalances;\n+\n+  @BeforeEach\n+  void setUp() {\n+    indices = new HashMap<>();\n+    votes = new ElasticList<>(VoteTracker::Default);\n+    oldBalances = new ArrayList<>();\n+    newBalances = new ArrayList<>();\n+  }\n+\n+  @Test\n+  void zeroHash() {\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(Bytes32.ZERO, Bytes32.ZERO, ZERO));\n+      oldBalances.add(ZERO);\n+      newBalances.add(ZERO);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    // Deltas should all be zero\n+    assertThat(deltas).containsOnly(0L);\n+  }\n+\n+  @Test\n+  void allVotedTheSame() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(Bytes32.ZERO, getHash(0), ZERO));\n+      oldBalances.add(BALANCE);\n+      newBalances.add(BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    for (int i = 0; i < deltas.size(); i++) {\n+      long delta = deltas.get(i);\n+      if (i == 0) {\n+        // Zero'th root should have a delta\n+        assertThat(delta).isEqualTo(BALANCE.longValue() * Integer.toUnsignedLong(validatorCount));\n+      } else {\n+        // All other deltas should be zero\n+        assertThat(delta).isEqualTo(0L);\n+      }\n+    }\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void differentVotes() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(Bytes32.ZERO, getHash(i), ZERO));\n+      oldBalances.add(BALANCE);\n+      newBalances.add(BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    // Each root should have the same delta\n+    assertThat(deltas).containsOnly(BALANCE.longValue());\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void movingVotes() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(getHash(0), getHash(1), ZERO));\n+      oldBalances.add(BALANCE);\n+      newBalances.add(BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+\n+    assertThat(deltas).hasSize(validatorCount);\n+    long totalDelta = BALANCE.longValue() * Integer.toUnsignedLong(validatorCount);\n+\n+    for (int i = 0; i < deltas.size(); i++) {\n+      long delta = deltas.get(i);\n+      if (i == 0) {\n+        // Zero'th root should have a negative delta\n+        assertThat(delta).isEqualTo(-totalDelta);\n+      } else if (i == 1) {\n+        // First root should have positive delta\n+        assertThat(delta).isEqualTo(totalDelta);\n+      } else {\n+        // All other deltas should be zero\n+        assertThat(delta).isEqualTo(0L);\n+      }\n+    }\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void moveOutOfTree() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+\n+    // There is only one block.\n+    indices.put(getHash(1), 0);\n+\n+    // There are two validators.\n+    oldBalances = Collections.nCopies(2, BALANCE);\n+    newBalances = Collections.nCopies(2, BALANCE);\n+\n+    // One validator moves their vote from the block to the zero hash.\n+    votes.add(new VoteTracker(getHash(1), Bytes32.ZERO, ZERO));\n+\n+    // One validator moves their vote from the block to something outside the tree.\n+    votes.add(new VoteTracker(getHash(1), getHash(1337), ZERO));\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(1);\n+\n+    // The block should have lost both balances\n+    assertThat(deltas.get(0)).isEqualTo(-BALANCE.longValue() * 2);\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void changingBalances() {\n+\n+    final UnsignedLong OLD_BALANCE = valueOf(42);\n+    final UnsignedLong NEW_BALANCE = OLD_BALANCE.times(valueOf(2));\n+\n+    int validatorCount = 16;\n+\n+    for (int i = 0; i < validatorCount; i++) {\n+      indices.put(getHash(i), i);\n+      votes.add(new VoteTracker(getHash(0), getHash(1), ZERO));\n+      oldBalances.add(OLD_BALANCE);\n+      newBalances.add(NEW_BALANCE);\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(validatorCount);\n+\n+    for (int i = 0; i < deltas.size(); i++) {\n+      long delta = deltas.get(i);\n+      if (i == 0) {\n+        // Zero'th root should have a negative delta\n+        assertThat(delta).isEqualTo(-OLD_BALANCE.longValue() * validatorCount);\n+      } else if (i == 1) {\n+        // First root should have positive delta\n+        assertThat(delta).isEqualTo(NEW_BALANCE.longValue() * validatorCount);\n+      } else {\n+        // All other deltas should be zero\n+        assertThat(delta).isEqualTo(0L);\n+      }\n+    }\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void validatorAppears() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+\n+    // There are two blocks.\n+    indices.put(getHash(1), 0);\n+    indices.put(getHash(2), 1);\n+\n+    // There is only one validator in the old balances.\n+    oldBalances.add(BALANCE);\n+\n+    // There are two validators in the new balances.\n+    newBalances.addAll(List.of(BALANCE, BALANCE));\n+\n+    // Both validators move votes from block 1 to block 2.\n+    for (int __ = 0; __ < 2; __++) {\n+      votes.add(new VoteTracker(getHash(1), getHash(2), ZERO));\n+    }\n+\n+    List<Long> deltas = computeDeltas(indices, votes, oldBalances, newBalances);\n+    assertThat(deltas).hasSize(2);\n+\n+    // Block 1 should have only lost one balance\n+    assertThat(deltas.get(0)).isEqualTo(-BALANCE.longValue());\n+\n+    // Block 2 should have gained two balances\n+    assertThat(deltas.get(1)).isEqualTo(2 * BALANCE.longValue());\n+\n+    votesShouldBeUpdated(votes);\n+  }\n+\n+  @Test\n+  void validatorDisappears() {\n+    final UnsignedLong BALANCE = valueOf(42);\n+\n+    // There are two blocks.\n+    indices.put(getHash(1), 0);\n+    indices.put(getHash(2), 1);\n+\n+    // There is only one validator in the old balances.\n+    oldBalances.addAll(List.of(BALANCE, BALANCE));\n+\n+    // There are two validators in the new balances.\n+    newBalances.add(BALANCE);\n+\n+    // Both validators move votes from block 1 to block 2.\n+    for (int __ = 0; __ < 2; __++) {", "originalCommit": "8585ee132eb5c89d44c871fbcbc5a276461a1b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MzQwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1170#discussion_r407783405", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-13T23:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2OTk1Ng=="}], "type": "inlineReview"}, {"oid": "2c0e46406a28093262f74ca3718af3bcc8c8c16d", "url": "https://github.com/ConsenSys/teku/commit/2c0e46406a28093262f74ca3718af3bcc8c8c16d", "message": "Resolve comments", "committedDate": "2020-04-13T23:48:23Z", "type": "commit"}, {"oid": "6ed76e9f938d8411658f9d0fd950c06c7d40fb84", "url": "https://github.com/ConsenSys/teku/commit/6ed76e9f938d8411658f9d0fd950c06c7d40fb84", "message": "Merge branch 'master' into protoarray", "committedDate": "2020-04-13T23:52:00Z", "type": "commit"}, {"oid": "7327840f15ade21c2e2827b456f39dfe9103d718", "url": "https://github.com/ConsenSys/teku/commit/7327840f15ade21c2e2827b456f39dfe9103d718", "message": "Add package-info", "committedDate": "2020-04-14T00:09:37Z", "type": "commit"}]}