{"pr_number": 1661, "pr_title": "Implement attestation gossip validation requirements", "pr_createdAt": "2020-04-24T01:35:09Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1661", "timeline": [{"oid": "ce99c4a78634c3803c7cfdd055ee52ab1ade971e", "url": "https://github.com/ConsenSys/teku/commit/ce99c4a78634c3803c7cfdd055ee52ab1ade971e", "message": "Introduce AttestationValidator", "committedDate": "2020-04-24T00:35:32Z", "type": "commit"}, {"oid": "8689e47a47ec5274a364f4b1adc0926724aa8726", "url": "https://github.com/ConsenSys/teku/commit/8689e47a47ec5274a364f4b1adc0926724aa8726", "message": "Use AttestationValidator in AttestationTopicHandler.", "committedDate": "2020-04-24T01:10:31Z", "type": "commit"}, {"oid": "832fb0f151823dfc43126620c4dc6ab7b6fc3314", "url": "https://github.com/ConsenSys/teku/commit/832fb0f151823dfc43126620c4dc6ab7b6fc3314", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validate-attestations", "committedDate": "2020-04-24T01:35:21Z", "type": "commit"}, {"oid": "26c99d852716324f6fa6ee953df3ded930f94393", "url": "https://github.com/ConsenSys/teku/commit/26c99d852716324f6fa6ee953df3ded930f94393", "message": "Tidy up.", "committedDate": "2020-04-24T01:45:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyNTI1Mw==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414625253", "bodyText": "I think this should be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n          \n          \n            \n              private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(1000);", "author": "cemozerr", "createdAt": "2020-04-24T14:36:02Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);", "originalCommit": "26c99d852716324f6fa6ee953df3ded930f94393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5ODE2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r415398166", "bodyText": "True.  Turns out it doesn't matter much as both current time and attestation time are in seconds anyway. Both become equally bigger and the tolerance is still less than one second.", "author": "ajsutton", "createdAt": "2020-04-26T20:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyNTI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYzNDM3Ng==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414634376", "bodyText": "smart strategy.", "author": "cemozerr", "createdAt": "2020-04-24T14:47:45Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n+    final UnsignedLong aggregateSlot = aggregate.getData().getSlot();\n+    return maximumBroadcastTimeMillis(aggregateSlot).compareTo(currentTimeMillis) < 0;\n+  }\n+\n+  private UnsignedLong secondsToMillis(final UnsignedLong seconds) {\n+    return seconds.times(MILLIS_PER_SECOND);\n+  }\n+\n+  private UnsignedLong minimumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(aggregateSlot.times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+    final UnsignedLong lastAllowedTimeMillis = secondsToMillis(lastAllowedTime);\n+    return lastAllowedTimeMillis.compareTo(MAXIMUM_GOSSIP_CLOCK_DISPARITY) >= 0\n+        ? lastAllowedTimeMillis.minus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+        : ZERO;\n+  }\n+\n+  private UnsignedLong maximumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedSlot = aggregateSlot.plus(ATTESTATION_PROPAGATION_SLOT_RANGE);\n+    // The last allowed time is the end of the lastAllowedSlot.\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(lastAllowedSlot.plus(ONE).times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+\n+    // Add allowed clock disparity\n+    return secondsToMillis(lastAllowedTime).plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+  }\n+\n+  private static class ValidatorAndSlot {\n+    private final UnsignedLong slot;\n+    // Validator is identified via committee index and position to avoid resolving the actual\n+    // validator ID before checking for duplicates", "originalCommit": "26c99d852716324f6fa6ee953df3ded930f94393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYzODEyMA==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414638120", "bodyText": "nit: (it's an attestation regardless)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n          \n          \n            \n                  final UnsignedLong currentTimeMillis, final Attestation attestation) {", "author": "cemozerr", "createdAt": "2020-04-24T14:52:43Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {", "originalCommit": "26c99d852716324f6fa6ee953df3ded930f94393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NTI4Nw==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r415395287", "bodyText": "Yep, missed a few \"aggregate\" that should have been renamed when I switch to validating attestations first. Fixed.", "author": "ajsutton", "createdAt": "2020-04-26T20:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYzODEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MDYwOQ==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414640609", "bodyText": "Why do we need .plus(ONE) here?", "author": "cemozerr", "createdAt": "2020-04-24T14:55:57Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n+    final UnsignedLong aggregateSlot = aggregate.getData().getSlot();\n+    return maximumBroadcastTimeMillis(aggregateSlot).compareTo(currentTimeMillis) < 0;\n+  }\n+\n+  private UnsignedLong secondsToMillis(final UnsignedLong seconds) {\n+    return seconds.times(MILLIS_PER_SECOND);\n+  }\n+\n+  private UnsignedLong minimumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(aggregateSlot.times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+    final UnsignedLong lastAllowedTimeMillis = secondsToMillis(lastAllowedTime);\n+    return lastAllowedTimeMillis.compareTo(MAXIMUM_GOSSIP_CLOCK_DISPARITY) >= 0\n+        ? lastAllowedTimeMillis.minus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+        : ZERO;\n+  }\n+\n+  private UnsignedLong maximumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedSlot = aggregateSlot.plus(ATTESTATION_PROPAGATION_SLOT_RANGE);\n+    // The last allowed time is the end of the lastAllowedSlot.\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(lastAllowedSlot.plus(ONE).times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));", "originalCommit": "26c99d852716324f6fa6ee953df3ded930f94393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NTU5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r415395596", "bodyText": "Because you're allowed to send the attestation until the end of that slot.  lastAllowedSlot * SECONDS_PER_SLOT will give you the start of the slot and we want the end.", "author": "ajsutton", "createdAt": "2020-04-26T20:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MDYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NzUxOA==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414647518", "bodyText": "The first check seems a bit redundant and makes the code hard to read since Unix time starts back in the 1970s", "author": "cemozerr", "createdAt": "2020-04-24T15:04:48Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n+    final UnsignedLong aggregateSlot = aggregate.getData().getSlot();\n+    return maximumBroadcastTimeMillis(aggregateSlot).compareTo(currentTimeMillis) < 0;\n+  }\n+\n+  private UnsignedLong secondsToMillis(final UnsignedLong seconds) {\n+    return seconds.times(MILLIS_PER_SECOND);\n+  }\n+\n+  private UnsignedLong minimumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(aggregateSlot.times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+    final UnsignedLong lastAllowedTimeMillis = secondsToMillis(lastAllowedTime);\n+    return lastAllowedTimeMillis.compareTo(MAXIMUM_GOSSIP_CLOCK_DISPARITY) >= 0", "originalCommit": "26c99d852716324f6fa6ee953df3ded930f94393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzI3MA==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r415397270", "bodyText": "Tests often default to starting at time 0 or small numbers because they're easier to read.", "author": "ajsutton", "createdAt": "2020-04-26T20:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MzQwNg==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414653406", "bodyText": "nit: it's better to have these two functions match each other's style\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n          \n          \n            \n                  return INVALID;\n          \n          \n            \n                }\n          \n          \n            \n                if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n          \n          \n            \n                if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n          \n          \n            \n                  return INVALID;\n          \n          \n            \n                }\n          \n          \n            \n                if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis)) {", "author": "cemozerr", "createdAt": "2020-04-24T15:12:46Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {", "originalCommit": "26c99d852716324f6fa6ee953df3ded930f94393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzI5OA==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r415397298", "bodyText": "Good spot.", "author": "ajsutton", "createdAt": "2020-04-26T20:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MzQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1Njg3Ng==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414656876", "bodyText": "nit: this might be a little bit more appropriate\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n          \n          \n            \n              private ValidationResult addAndCheckFirstValidAttestation(final Attestation attestation) {", "author": "cemozerr", "createdAt": "2020-04-24T15:17:35Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {", "originalCommit": "26c99d852716324f6fa6ee953df3ded930f94393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzM2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r415397362", "bodyText": "Done.", "author": "ajsutton", "createdAt": "2020-04-26T20:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1Njg3Ng=="}], "type": "inlineReview"}, {"oid": "49508e3c6a63ffc01466f1b6a1671206e05182e9", "url": "https://github.com/ConsenSys/teku/commit/49508e3c6a63ffc01466f1b6a1671206e05182e9", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validate-attestations", "committedDate": "2020-04-26T20:33:32Z", "type": "commit"}, {"oid": "3886bd23501adf01030d8eee127190bfc526d3d4", "url": "https://github.com/ConsenSys/teku/commit/3886bd23501adf01030d8eee127190bfc526d3d4", "message": "Fix merge error.", "committedDate": "2020-04-26T20:33:59Z", "type": "commit"}, {"oid": "7b6b64592857e9fe0d2e6a378599784657e93efd", "url": "https://github.com/ConsenSys/teku/commit/7b6b64592857e9fe0d2e6a378599784657e93efd", "message": "Fix mixed renames of aggregate back to attestation.", "committedDate": "2020-04-26T20:35:25Z", "type": "commit"}, {"oid": "8be2acf8823d53746bef6a8fcc181afa2167dc50", "url": "https://github.com/ConsenSys/teku/commit/8be2acf8823d53746bef6a8fcc181afa2167dc50", "message": "Clarify comment.", "committedDate": "2020-04-26T20:37:14Z", "type": "commit"}, {"oid": "07f82a2a9720292c6a30ca9a1cca0ae68b7539ee", "url": "https://github.com/ConsenSys/teku/commit/07f82a2a9720292c6a30ca9a1cca0ae68b7539ee", "message": "Review feedback.", "committedDate": "2020-04-26T20:52:02Z", "type": "commit"}, {"oid": "02c9e46a3f42c4cedb655479e72ab889635d9da4", "url": "https://github.com/ConsenSys/teku/commit/02c9e46a3f42c4cedb655479e72ab889635d9da4", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validate-attestations", "committedDate": "2020-04-26T20:53:16Z", "type": "commit"}]}