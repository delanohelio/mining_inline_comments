{"pr_number": 1246, "pr_title": "Refactor deposit processing", "pr_createdAt": "2020-02-28T23:36:11Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1246", "timeline": [{"oid": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "url": "https://github.com/ConsenSys/teku/commit/1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "message": "Refactor deposit processing & implement DepositProcessingController", "committedDate": "2020-02-28T23:35:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODczNg==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386138736", "bodyText": "We should actually use the deposits list passed in.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                genesisGenerator.updateCandidateState(blockHash, timestamp, List.of());\n          \n          \n            \n                genesisGenerator.updateCandidateState(blockHash, timestamp, deposits);", "author": "ajsutton", "createdAt": "2020-03-01T20:39:31Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/genesis/GenesisHandler.java", "diffHunk": "@@ -51,42 +44,33 @@ public void onDepositsFromBlock(final DepositsFromBlockEvent event) {\n     if (!chainStorageClient.isPreGenesis()) {\n       return;\n     }\n-\n-    final Bytes32 eth1BlockHash = event.getBlockHash();\n-    final UnsignedLong eth1Timestamp = event.getBlockTimestamp();\n     final List<DepositWithIndex> deposits =\n         event.getDeposits().stream()\n             .map(DepositUtil::convertDepositEventToOperationDeposit)\n             .collect(Collectors.toList());\n-    genesisGenerator.addDepositsFromBlock(eth1BlockHash, eth1Timestamp, deposits);\n \n-    if (config.getDepositMode().equals(Constants.DEPOSIT_SIM)) {\n-      genesisGenerator\n-          .getGenesisStateIfValid(BeaconStateUtil::is_valid_genesis_stateSim)\n-          .ifPresent(\n-              candidate_state -> {\n-                setSimulationGenesisTime(candidate_state);\n-                eth2Genesis(new GenesisEvent(candidate_state));\n-              });\n-    } else {\n-      genesisGenerator\n-          .getGenesisStateIfValid(BeaconStateUtil::is_valid_genesis_state)\n-          .ifPresent(candidate_state -> eth2Genesis(new GenesisEvent(candidate_state)));\n-    }\n+    processNewData(event.getBlockHash(), event.getBlockTimestamp(), deposits);\n+  }\n+\n+  @Override\n+  public void onMinGenesisTimeBlock(MinGenesisTimeBlockEvent event) {\n+    processNewData(event.getBlockHash(), event.getTimestamp(), List.of());\n   }\n \n-  private void eth2Genesis(GenesisEvent genesisEvent) {\n+  private void processNewData(\n+      Bytes32 blockHash, UnsignedLong timestamp, List<DepositWithIndex> deposits) {\n+    genesisGenerator.updateCandidateState(blockHash, timestamp, List.of());", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM4MzM1Mw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386383353", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-03-02T13:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTA3Ng==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386141076", "bodyText": "The future chaining here is making life much more complex than it needs to be.  First, get the head, then when you have the head, decide if it's before min genesis and call the right method.  Right now you're starting the process to get head, then queuing up the process to decide if it's before or after, then queuing up the decision of which method to call etc.\nIt should just be:\n  public void start() {\n    getHead().thenCompose(headBlock -> {\n      if (isHeadBeforeMinGenesis(headBlock)) {\n        return headBeforeMinGenesisMode(headBlock);\n      } else {\n        return headAfterMinGenesisMode(headBlock);\n      }\n    });\n  }\n\nand isHeadBeforeMinGenesis, headBeforeMinGenesisMode and headAfterMinGenesisMode all take a EthBlock.Block rather than a SafeFuture<EthBlock.Block>.  Now life is easy. :)\nThe other detail is that you need to handle errors - mostly if getHead fails or the requests for deposits in headBeforeMinGenesisMode and headAfterMinGenesisMode fails.", "author": "ajsutton", "createdAt": "2020-03-01T21:10:00Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1Manager.java", "diffHunk": "@@ -13,113 +13,121 @@\n \n package tech.pegasys.artemis.pow;\n \n-import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n import java.math.BigInteger;\n-import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n-public class Eth1MinGenesisTimeBlockFinder {\n+public class Eth1Manager {\n \n   private static final Logger LOG = LogManager.getLogger();\n \n   private final Eth1Provider eth1Provider;\n-  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n   private final AsyncRunner asyncRunner;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositProcessingController depositProcessingController;\n \n-  private volatile Disposable latestBlockDisposable;\n-\n-  public Eth1MinGenesisTimeBlockFinder(\n+  public Eth1Manager(\n       Eth1Provider eth1Provider,\n-      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n-      AsyncRunner asyncRunner) {\n+      AsyncRunner asyncRunner,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositProcessingController depositProcessingController) {\n     this.eth1Provider = eth1Provider;\n-    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n     this.asyncRunner = asyncRunner;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositProcessingController = depositProcessingController;\n   }\n \n   public void start() {\n-    findAndPublishFirstValidBlock()\n-        .finish(\n-            () ->\n-                LOG.info(\n-                    \"Eth1MinGenesisBlockFinder successfully found first \"\n-                        + \"(time) valid genesis block\"));\n+\n+    SafeFuture<EthBlock.Block> headBlock = getHead();\n+\n+    SafeFuture<Boolean> isHeadBeforeMinGenesis = isHeadBeforeMinGenesis(headBlock);\n+\n+    isHeadBeforeMinGenesis.thenAccept(\n+        bool -> {\n+          if (bool) headBeforeMinGenesisMode(headBlock);\n+          else headAfterMinGenesisMode(headBlock);\n+        });", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM4NDk5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386384996", "bodyText": "Makes perfect sense. Done.", "author": "cemozerr", "createdAt": "2020-03-02T13:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM4ODQ2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386388466", "bodyText": "I'm now dealing with the error case of getHead in the getHead function itself, and I plan to do the same for headBeforeMinGenesis etc as well because it gives me more granular control. Does that make sense?", "author": "cemozerr", "createdAt": "2020-03-02T13:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTYxNg==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386141616", "bodyText": "Suggest renaming to notifyMinGenesisTimeBlockReached to make it clear this is firing an event not dealing with things \"post\" (aka after) the genesis time block reached.", "author": "ajsutton", "createdAt": "2020-03-01T21:17:10Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1Manager.java", "diffHunk": "@@ -13,113 +13,121 @@\n \n package tech.pegasys.artemis.pow;\n \n-import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n import java.math.BigInteger;\n-import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n-public class Eth1MinGenesisTimeBlockFinder {\n+public class Eth1Manager {\n \n   private static final Logger LOG = LogManager.getLogger();\n \n   private final Eth1Provider eth1Provider;\n-  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n   private final AsyncRunner asyncRunner;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositProcessingController depositProcessingController;\n \n-  private volatile Disposable latestBlockDisposable;\n-\n-  public Eth1MinGenesisTimeBlockFinder(\n+  public Eth1Manager(\n       Eth1Provider eth1Provider,\n-      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n-      AsyncRunner asyncRunner) {\n+      AsyncRunner asyncRunner,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositProcessingController depositProcessingController) {\n     this.eth1Provider = eth1Provider;\n-    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n     this.asyncRunner = asyncRunner;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositProcessingController = depositProcessingController;\n   }\n \n   public void start() {\n-    findAndPublishFirstValidBlock()\n-        .finish(\n-            () ->\n-                LOG.info(\n-                    \"Eth1MinGenesisBlockFinder successfully found first \"\n-                        + \"(time) valid genesis block\"));\n+\n+    SafeFuture<EthBlock.Block> headBlock = getHead();\n+\n+    SafeFuture<Boolean> isHeadBeforeMinGenesis = isHeadBeforeMinGenesis(headBlock);\n+\n+    isHeadBeforeMinGenesis.thenAccept(\n+        bool -> {\n+          if (bool) headBeforeMinGenesisMode(headBlock);\n+          else headAfterMinGenesisMode(headBlock);\n+        });\n+  }\n+\n+  public SafeFuture<Void> headBeforeMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    return head.thenCompose(\n+            headBlock ->\n+                depositProcessingController.fetchDepositsFromGenesisTo(headBlock.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(head.getNow(null));\n+              depositProcessingController.switchToBlockByBlockMode();\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });\n+  }\n+\n+  public SafeFuture<Void> headAfterMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    SafeFuture<EthBlock.Block> minGenesisBlock =\n+        head.thenCompose(this::findMinGenesisTimeBlockInHistory);\n+\n+    return minGenesisBlock\n+        .thenCompose(\n+            block -> depositProcessingController.fetchDepositsFromGenesisTo(block.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(minGenesisBlock.getNow(null));\n+              postMinGenesisTimeBlock(eth1EventsChannel, block);\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });\n   }\n \n-  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+  public SafeFuture<EthBlock.Block> getHead() {\n     return eth1Provider\n         .getLatestEth1BlockFuture()\n         .thenApply(EthBlock.Block::getNumber)\n         .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n         .thenApply(UnsignedLong::valueOf)\n-        .thenCompose(eth1Provider::getEth1BlockFuture)\n-        .thenCompose(\n-            block -> {\n-              int comparison = compareBlockTimestampToMinGenesisTime(block);\n-              if (comparison > 0) {\n-                // If block timestamp is greater than min genesis time\n-                // find first valid block in history\n-                return findFirstValidBlockInHistory(block);\n-              } else if (comparison < 0) {\n-                // If block timestamp is less than min genesis time\n-                // subscribe to new block events and wait for the first\n-                // valid block\n-                return waitForFirstValidBlock();\n-              } else {\n-                return SafeFuture.completedFuture(block);\n-              }\n-            })\n-        .thenAccept(this::publishFirstValidBlock)\n-        .exceptionallyCompose(\n-            err -> {\n-              if (latestBlockDisposable != null) {\n-                latestBlockDisposable.dispose();\n-              }\n+        .thenCompose(eth1Provider::getEth1BlockFuture);\n+  }\n \n-              LOG.debug(\n-                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n-                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n-                      + \" seconds\",\n-                  err);\n-\n-              System.out.println(\"adding one delayed run\");\n-              return asyncRunner.runAfterDelay(\n-                  this::findAndPublishFirstValidBlock,\n-                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n-                  TimeUnit.SECONDS);\n-            });\n+  public SafeFuture<Boolean> isHeadBeforeMinGenesis(SafeFuture<EthBlock.Block> headBlock) {\n+    return headBlock.thenApply(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          // If block timestamp is greater than min genesis time,\n+          // min genesis block must have been in history\n+          return comparison > 0;\n+        });\n   }\n \n-  private void publishFirstValidBlock(EthBlock.Block block) {\n-    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+  public static EthBlock.Block postMinGenesisTimeBlock(", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM5NDQ3OA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386394478", "bodyText": "makes sense. done.", "author": "cemozerr", "createdAt": "2020-03-02T13:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTYzOA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386141638", "bodyText": "If it's equal then min genesis time is also in the existing block chain list (because it is the head block).", "author": "ajsutton", "createdAt": "2020-03-01T21:17:25Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1Manager.java", "diffHunk": "@@ -13,113 +13,121 @@\n \n package tech.pegasys.artemis.pow;\n \n-import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n import java.math.BigInteger;\n-import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n-public class Eth1MinGenesisTimeBlockFinder {\n+public class Eth1Manager {\n \n   private static final Logger LOG = LogManager.getLogger();\n \n   private final Eth1Provider eth1Provider;\n-  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n   private final AsyncRunner asyncRunner;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositProcessingController depositProcessingController;\n \n-  private volatile Disposable latestBlockDisposable;\n-\n-  public Eth1MinGenesisTimeBlockFinder(\n+  public Eth1Manager(\n       Eth1Provider eth1Provider,\n-      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n-      AsyncRunner asyncRunner) {\n+      AsyncRunner asyncRunner,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositProcessingController depositProcessingController) {\n     this.eth1Provider = eth1Provider;\n-    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n     this.asyncRunner = asyncRunner;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositProcessingController = depositProcessingController;\n   }\n \n   public void start() {\n-    findAndPublishFirstValidBlock()\n-        .finish(\n-            () ->\n-                LOG.info(\n-                    \"Eth1MinGenesisBlockFinder successfully found first \"\n-                        + \"(time) valid genesis block\"));\n+\n+    SafeFuture<EthBlock.Block> headBlock = getHead();\n+\n+    SafeFuture<Boolean> isHeadBeforeMinGenesis = isHeadBeforeMinGenesis(headBlock);\n+\n+    isHeadBeforeMinGenesis.thenAccept(\n+        bool -> {\n+          if (bool) headBeforeMinGenesisMode(headBlock);\n+          else headAfterMinGenesisMode(headBlock);\n+        });\n+  }\n+\n+  public SafeFuture<Void> headBeforeMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    return head.thenCompose(\n+            headBlock ->\n+                depositProcessingController.fetchDepositsFromGenesisTo(headBlock.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(head.getNow(null));\n+              depositProcessingController.switchToBlockByBlockMode();\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });\n+  }\n+\n+  public SafeFuture<Void> headAfterMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    SafeFuture<EthBlock.Block> minGenesisBlock =\n+        head.thenCompose(this::findMinGenesisTimeBlockInHistory);\n+\n+    return minGenesisBlock\n+        .thenCompose(\n+            block -> depositProcessingController.fetchDepositsFromGenesisTo(block.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(minGenesisBlock.getNow(null));\n+              postMinGenesisTimeBlock(eth1EventsChannel, block);\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });\n   }\n \n-  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+  public SafeFuture<EthBlock.Block> getHead() {\n     return eth1Provider\n         .getLatestEth1BlockFuture()\n         .thenApply(EthBlock.Block::getNumber)\n         .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n         .thenApply(UnsignedLong::valueOf)\n-        .thenCompose(eth1Provider::getEth1BlockFuture)\n-        .thenCompose(\n-            block -> {\n-              int comparison = compareBlockTimestampToMinGenesisTime(block);\n-              if (comparison > 0) {\n-                // If block timestamp is greater than min genesis time\n-                // find first valid block in history\n-                return findFirstValidBlockInHistory(block);\n-              } else if (comparison < 0) {\n-                // If block timestamp is less than min genesis time\n-                // subscribe to new block events and wait for the first\n-                // valid block\n-                return waitForFirstValidBlock();\n-              } else {\n-                return SafeFuture.completedFuture(block);\n-              }\n-            })\n-        .thenAccept(this::publishFirstValidBlock)\n-        .exceptionallyCompose(\n-            err -> {\n-              if (latestBlockDisposable != null) {\n-                latestBlockDisposable.dispose();\n-              }\n+        .thenCompose(eth1Provider::getEth1BlockFuture);\n+  }\n \n-              LOG.debug(\n-                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n-                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n-                      + \" seconds\",\n-                  err);\n-\n-              System.out.println(\"adding one delayed run\");\n-              return asyncRunner.runAfterDelay(\n-                  this::findAndPublishFirstValidBlock,\n-                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n-                  TimeUnit.SECONDS);\n-            });\n+  public SafeFuture<Boolean> isHeadBeforeMinGenesis(SafeFuture<EthBlock.Block> headBlock) {\n+    return headBlock.thenApply(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          // If block timestamp is greater than min genesis time,\n+          // min genesis block must have been in history\n+          return comparison > 0;", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM5NzU4OA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386397588", "bodyText": "oh true. good catch!", "author": "cemozerr", "createdAt": "2020-03-02T13:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTcwMA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386141700", "bodyText": "Using chaining is probably better here than getNow.\npublic SafeFuture<Void> headAfterMinGenesisMode(EthBlock.Block head) {\n    return findMinGenesisTimeBlockInHistory(head)\n        .thenCompose(this::sendDepositsUpToMinGenesis)\n        .thenAccept(\n            minGenesisTimeBlock -> {\n              postMinGenesisTimeBlock(eth1EventsChannel, minGenesisTimeBlock);\n              depositProcessingController.startSubscription(minGenesisTimeBlock.getNumber());\n            });\n  }\n\n  private SafeFuture<Block> sendDepositsUpToMinGenesis(final Block minGenesisTimeBlock) {\n    return depositProcessingController\n        .fetchDepositsFromGenesisTo(minGenesisTimeBlock.getNumber())\n        .thenApply(__ -> minGenesisTimeBlock);\n  }", "author": "ajsutton", "createdAt": "2020-03-01T21:18:16Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1Manager.java", "diffHunk": "@@ -13,113 +13,121 @@\n \n package tech.pegasys.artemis.pow;\n \n-import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n import java.math.BigInteger;\n-import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n-public class Eth1MinGenesisTimeBlockFinder {\n+public class Eth1Manager {\n \n   private static final Logger LOG = LogManager.getLogger();\n \n   private final Eth1Provider eth1Provider;\n-  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n   private final AsyncRunner asyncRunner;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositProcessingController depositProcessingController;\n \n-  private volatile Disposable latestBlockDisposable;\n-\n-  public Eth1MinGenesisTimeBlockFinder(\n+  public Eth1Manager(\n       Eth1Provider eth1Provider,\n-      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n-      AsyncRunner asyncRunner) {\n+      AsyncRunner asyncRunner,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositProcessingController depositProcessingController) {\n     this.eth1Provider = eth1Provider;\n-    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n     this.asyncRunner = asyncRunner;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositProcessingController = depositProcessingController;\n   }\n \n   public void start() {\n-    findAndPublishFirstValidBlock()\n-        .finish(\n-            () ->\n-                LOG.info(\n-                    \"Eth1MinGenesisBlockFinder successfully found first \"\n-                        + \"(time) valid genesis block\"));\n+\n+    SafeFuture<EthBlock.Block> headBlock = getHead();\n+\n+    SafeFuture<Boolean> isHeadBeforeMinGenesis = isHeadBeforeMinGenesis(headBlock);\n+\n+    isHeadBeforeMinGenesis.thenAccept(\n+        bool -> {\n+          if (bool) headBeforeMinGenesisMode(headBlock);\n+          else headAfterMinGenesisMode(headBlock);\n+        });\n+  }\n+\n+  public SafeFuture<Void> headBeforeMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    return head.thenCompose(\n+            headBlock ->\n+                depositProcessingController.fetchDepositsFromGenesisTo(headBlock.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(head.getNow(null));\n+              depositProcessingController.switchToBlockByBlockMode();\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });\n+  }\n+\n+  public SafeFuture<Void> headAfterMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    SafeFuture<EthBlock.Block> minGenesisBlock =\n+        head.thenCompose(this::findMinGenesisTimeBlockInHistory);\n+\n+    return minGenesisBlock\n+        .thenCompose(\n+            block -> depositProcessingController.fetchDepositsFromGenesisTo(block.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(minGenesisBlock.getNow(null));\n+              postMinGenesisTimeBlock(eth1EventsChannel, block);\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM5OTY1MA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386399650", "bodyText": "yeah, this is cleaner, although its a bit vague (from sendDepositsUpToMinGenesis's own pov) why it returns the minGenesisBlock. done tho.", "author": "cemozerr", "createdAt": "2020-03-02T13:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTczMw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386141733", "bodyText": "nit: LOG is now unused.", "author": "ajsutton", "createdAt": "2020-03-01T21:18:43Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1Manager.java", "diffHunk": "@@ -13,113 +13,121 @@\n \n package tech.pegasys.artemis.pow;\n \n-import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n import java.math.BigInteger;\n-import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n-public class Eth1MinGenesisTimeBlockFinder {\n+public class Eth1Manager {\n \n   private static final Logger LOG = LogManager.getLogger();", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MTc3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386141773", "bodyText": "Appears to be unused, but may be needed for some of the error handling that's currently missing.", "author": "ajsutton", "createdAt": "2020-03-01T21:19:10Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1Manager.java", "diffHunk": "@@ -13,113 +13,121 @@\n \n package tech.pegasys.artemis.pow;\n \n-import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n import java.math.BigInteger;\n-import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n-public class Eth1MinGenesisTimeBlockFinder {\n+public class Eth1Manager {\n \n   private static final Logger LOG = LogManager.getLogger();\n \n   private final Eth1Provider eth1Provider;\n-  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n   private final AsyncRunner asyncRunner;", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MjM3NA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386142374", "bodyText": "I'd be tempted to split this into a MinimumGenesisTimeBlockFinder class.", "author": "ajsutton", "createdAt": "2020-03-01T21:27:08Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1Manager.java", "diffHunk": "@@ -13,113 +13,121 @@\n \n package tech.pegasys.artemis.pow;\n \n-import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n import java.math.BigInteger;\n-import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n-public class Eth1MinGenesisTimeBlockFinder {\n+public class Eth1Manager {\n \n   private static final Logger LOG = LogManager.getLogger();\n \n   private final Eth1Provider eth1Provider;\n-  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n   private final AsyncRunner asyncRunner;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositProcessingController depositProcessingController;\n \n-  private volatile Disposable latestBlockDisposable;\n-\n-  public Eth1MinGenesisTimeBlockFinder(\n+  public Eth1Manager(\n       Eth1Provider eth1Provider,\n-      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n-      AsyncRunner asyncRunner) {\n+      AsyncRunner asyncRunner,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositProcessingController depositProcessingController) {\n     this.eth1Provider = eth1Provider;\n-    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n     this.asyncRunner = asyncRunner;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositProcessingController = depositProcessingController;\n   }\n \n   public void start() {\n-    findAndPublishFirstValidBlock()\n-        .finish(\n-            () ->\n-                LOG.info(\n-                    \"Eth1MinGenesisBlockFinder successfully found first \"\n-                        + \"(time) valid genesis block\"));\n+\n+    SafeFuture<EthBlock.Block> headBlock = getHead();\n+\n+    SafeFuture<Boolean> isHeadBeforeMinGenesis = isHeadBeforeMinGenesis(headBlock);\n+\n+    isHeadBeforeMinGenesis.thenAccept(\n+        bool -> {\n+          if (bool) headBeforeMinGenesisMode(headBlock);\n+          else headAfterMinGenesisMode(headBlock);\n+        });\n+  }\n+\n+  public SafeFuture<Void> headBeforeMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    return head.thenCompose(\n+            headBlock ->\n+                depositProcessingController.fetchDepositsFromGenesisTo(headBlock.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(head.getNow(null));\n+              depositProcessingController.switchToBlockByBlockMode();\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });\n+  }\n+\n+  public SafeFuture<Void> headAfterMinGenesisMode(SafeFuture<EthBlock.Block> head) {\n+    SafeFuture<EthBlock.Block> minGenesisBlock =\n+        head.thenCompose(this::findMinGenesisTimeBlockInHistory);\n+\n+    return minGenesisBlock\n+        .thenCompose(\n+            block -> depositProcessingController.fetchDepositsFromGenesisTo(block.getNumber()))\n+        .thenRun(\n+            () -> {\n+              EthBlock.Block block = checkNotNull(minGenesisBlock.getNow(null));\n+              postMinGenesisTimeBlock(eth1EventsChannel, block);\n+              depositProcessingController.startSubscription(block.getNumber());\n+            });\n   }\n \n-  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+  public SafeFuture<EthBlock.Block> getHead() {\n     return eth1Provider\n         .getLatestEth1BlockFuture()\n         .thenApply(EthBlock.Block::getNumber)\n         .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n         .thenApply(UnsignedLong::valueOf)\n-        .thenCompose(eth1Provider::getEth1BlockFuture)\n-        .thenCompose(\n-            block -> {\n-              int comparison = compareBlockTimestampToMinGenesisTime(block);\n-              if (comparison > 0) {\n-                // If block timestamp is greater than min genesis time\n-                // find first valid block in history\n-                return findFirstValidBlockInHistory(block);\n-              } else if (comparison < 0) {\n-                // If block timestamp is less than min genesis time\n-                // subscribe to new block events and wait for the first\n-                // valid block\n-                return waitForFirstValidBlock();\n-              } else {\n-                return SafeFuture.completedFuture(block);\n-              }\n-            })\n-        .thenAccept(this::publishFirstValidBlock)\n-        .exceptionallyCompose(\n-            err -> {\n-              if (latestBlockDisposable != null) {\n-                latestBlockDisposable.dispose();\n-              }\n+        .thenCompose(eth1Provider::getEth1BlockFuture);\n+  }\n \n-              LOG.debug(\n-                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n-                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n-                      + \" seconds\",\n-                  err);\n-\n-              System.out.println(\"adding one delayed run\");\n-              return asyncRunner.runAfterDelay(\n-                  this::findAndPublishFirstValidBlock,\n-                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n-                  TimeUnit.SECONDS);\n-            });\n+  public SafeFuture<Boolean> isHeadBeforeMinGenesis(SafeFuture<EthBlock.Block> headBlock) {\n+    return headBlock.thenApply(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          // If block timestamp is greater than min genesis time,\n+          // min genesis block must have been in history\n+          return comparison > 0;\n+        });\n   }\n \n-  private void publishFirstValidBlock(EthBlock.Block block) {\n-    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+  public static EthBlock.Block postMinGenesisTimeBlock(\n+      Eth1EventsChannel eth1EventsChannel, EthBlock.Block block) {\n+    eth1EventsChannel.onMinGenesisTimeBlock(\n         new MinGenesisTimeBlockEvent(\n             UnsignedLong.valueOf(block.getTimestamp()),\n             UnsignedLong.valueOf(block.getNumber()),\n             Bytes32.fromHexString(block.getHash())));\n+    return block;\n   }\n \n   /**\n-   * Find first valid block in history that has timestamp greater than MIN_GENESIS_TIME\n+   * Find first block in history that has timestamp greater than MIN_GENESIS_TIME\n    *\n    * @param estimationBlock estimationBlock that will be used for estimation\n-   * @return first valid block in history\n+   * @return min genesis time block\n    */\n-  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n-    UnsignedLong estimatedFirstValidBlockNumber =\n-        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+  private SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNjI4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386406285", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-03-02T13:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MjM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MjgxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r386142815", "bodyText": "We've got a weird mix of volatile and non-volatile fields in this class.  I think we'll wind up with calls from two sources - Eth1Manager and the latest block subscription.  Probably the best thing it to make all fields non-volatile but all entry point methods (including ones passed as handlers to the subscription subscribe method) should be synchronised.\nNot 100% sure of that though.", "author": "ajsutton", "createdAt": "2020-03-01T21:33:30Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.Eth1Manager.compareBlockTimestampToMinGenesisTime;\n+import static tech.pegasys.artemis.pow.Eth1Manager.postMinGenesisTimeBlock;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositsFetcher depositsFetcher;\n+\n+  private volatile Disposable newBlockSubscription;\n+  private boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private boolean isBlockByBlockModeOn = false;\n+  private volatile BigInteger blockByBlockLastFetchedBlockNumber = BigInteger.ZERO;", "originalCommit": "1ce48ed9cd9e2fe68ce9005515db86bb30fb7f40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a5cc288e40a03322a18eda0e2f12af9c1c82e4e", "url": "https://github.com/ConsenSys/teku/commit/8a5cc288e40a03322a18eda0e2f12af9c1c82e4e", "message": "Resolve comments & refactor PowchainService", "committedDate": "2020-03-02T15:10:09Z", "type": "commit"}, {"oid": "7b330100ae624caf5af38035fbd6e541c9808838", "url": "https://github.com/ConsenSys/teku/commit/7b330100ae624caf5af38035fbd6e541c9808838", "message": "Make eth1 calls guaranteed & manage block range at controller", "committedDate": "2020-03-04T14:36:53Z", "type": "commit"}, {"oid": "bde3609fde4068be7816c546b31224544f10cddc", "url": "https://github.com/ConsenSys/teku/commit/bde3609fde4068be7816c546b31224544f10cddc", "message": "Create Test suites for both DepositFetcher and DepositProcessingController", "committedDate": "2020-03-04T20:55:51Z", "type": "commit"}, {"oid": "65b11a75b642e7aaf898576b480f42012d0d6d52", "url": "https://github.com/ConsenSys/teku/commit/65b11a75b642e7aaf898576b480f42012d0d6d52", "message": "Wrap up PR", "committedDate": "2020-03-04T22:03:37Z", "type": "commit"}, {"oid": "77a89266d9591b435124bdbadc9c2daa6beaa9f0", "url": "https://github.com/ConsenSys/teku/commit/77a89266d9591b435124bdbadc9c2daa6beaa9f0", "message": "Run spotless", "committedDate": "2020-03-04T22:04:37Z", "type": "commit"}, {"oid": "b34a5872c146613b2ab1c7c81b3bdbd8fbf52cc7", "url": "https://github.com/ConsenSys/teku/commit/b34a5872c146613b2ab1c7c81b3bdbd8fbf52cc7", "message": "Merge remote-tracking branch 'remotes/origin/master' into refactorDepositsAndGenesis\n\n# Conflicts:\n#\tethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/GenesisGenerator.java\n#\tethereum/datastructures/src/test/java/tech/pegasys/artemis/datastructures/util/GenesisGeneratorTest.java\n#\tethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/events/GenesisEvent.java\n#\tethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/genesis/GenesisHandler.java", "committedDate": "2020-03-04T22:28:24Z", "type": "commit"}, {"oid": "f6dbf1d8bb2e9c19b9e602372691291600ae22a0", "url": "https://github.com/ConsenSys/teku/commit/f6dbf1d8bb2e9c19b9e602372691291600ae22a0", "message": "Fix merge bug", "committedDate": "2020-03-04T22:29:51Z", "type": "commit"}, {"oid": "91099bfb49878837884d043d85caaf3af2333fd4", "url": "https://github.com/ConsenSys/teku/commit/91099bfb49878837884d043d85caaf3af2333fd4", "message": "Add deleted file to git", "committedDate": "2020-03-04T22:31:02Z", "type": "commit"}, {"oid": "b42a6297ca42aa158c799c825e300a3eedf828c8", "url": "https://github.com/ConsenSys/teku/commit/b42a6297ca42aa158c799c825e300a3eedf828c8", "message": "Fix bootnodes config", "committedDate": "2020-03-04T22:44:17Z", "type": "commit"}, {"oid": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "url": "https://github.com/ConsenSys/teku/commit/39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "message": "Merge branch 'master' into refactorDepositsAndGenesis", "committedDate": "2020-03-05T00:18:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4MTkwOQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387981909", "bodyText": "This is potentially quite common and not directly related to user action so it shouldn't be warn level.  I'd be tempted to make it INFO and include something to identify which deposit (maybe deposit number and if we can include the validator public key that would be useful).", "author": "ajsutton", "createdAt": "2020-03-04T22:50:27Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -145,7 +149,7 @@ static void process_deposit_without_checking_merkle_proof(\n                     deposit.getData().getSignature(),\n                     compute_domain(DOMAIN_DEPOSIT));\n         if (!proof_is_valid) {\n-          STDOUT.log(Level.DEBUG, \"Skipping invalid deposit\");\n+          LOG.warn(\"Skipping invalid deposit\");", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQxMjIyNA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388412224", "bodyText": "Done. Printing with pubkeys now, and with indices when they're available. However, indices might not always be available so I had to put an else statement for printing, which is not great, fyi.", "author": "cemozerr", "createdAt": "2020-03-05T16:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4MTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NDI0NQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387984245", "bodyText": "I'd be tempted to just make this a DepositContractAccessor.create method.  It's simple enough that it probably doesn't need a separate factory class.  Then the DepositContractAccessor constructor can be made private (or package protected if it's needed by tests).", "author": "ajsutton", "createdAt": "2020-03-04T22:56:16Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositContractFactory.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import org.web3j.protocol.Web3j;\n+import org.web3j.tx.ClientTransactionManager;\n+import org.web3j.tx.gas.DefaultGasProvider;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+\n+public class DepositContractFactory {\n+\n+  public static DepositContractAccessor eth1DepositContractAccessor(", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTUzNQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388451535", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T17:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NDI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NDMwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387984301", "bodyText": "This can be private.", "author": "ajsutton", "createdAt": "2020-03-04T22:56:23Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositContractFactory.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import org.web3j.protocol.Web3j;\n+import org.web3j.tx.ClientTransactionManager;\n+import org.web3j.tx.gas.DefaultGasProvider;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+\n+public class DepositContractFactory {\n+\n+  public static DepositContractAccessor eth1DepositContractAccessor(\n+      Eth1Provider eth1Provider, Web3j web3j, String address) {\n+    DepositContract contract = eth1DepositContract(web3j, address);\n+    return new DepositContractAccessor(eth1Provider, contract);\n+  }\n+\n+  public static DepositContract eth1DepositContract(Web3j web3j, String address) {", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NTQ4OA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387985488", "bodyText": "I think I'd just always use the range form of this.  It's not worth the extra code and we are technically always requesting a range, even if it's a range of 1.", "author": "ajsutton", "createdAt": "2020-03-04T22:59:25Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositFetcher.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositFetcher {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositContract depositContract;\n+  private final AsyncRunner asyncRunner;\n+\n+  public DepositFetcher(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositContract depositContract,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositContract = depositContract;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  // Inclusive on both sides\n+  public synchronized SafeFuture<Void> fetchDepositsInRange(\n+      BigInteger fromBlockNumber, BigInteger toBlockNumber) {\n+\n+    if (fromBlockNumber.equals(toBlockNumber)) {", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ4OTc1Mw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388489753", "bodyText": "Done", "author": "cemozerr", "createdAt": "2020-03-05T18:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NTQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NTY2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387985661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"Retrying request of deposit events for \"\n          \n          \n            \n                                    + \"block numbers in the range ({}, {})\",\n          \n          \n            \n                                \"Retrying request of deposit events for block numbers in the range ({}, {})\",", "author": "ajsutton", "createdAt": "2020-03-04T22:59:56Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositFetcher.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositFetcher {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositContract depositContract;\n+  private final AsyncRunner asyncRunner;\n+\n+  public DepositFetcher(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositContract depositContract,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositContract = depositContract;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  // Inclusive on both sides\n+  public synchronized SafeFuture<Void> fetchDepositsInRange(\n+      BigInteger fromBlockNumber, BigInteger toBlockNumber) {\n+\n+    if (fromBlockNumber.equals(toBlockNumber)) {\n+      LOG.trace(\"Attempting to fetch deposit events for block number {}\", fromBlockNumber);\n+    } else {\n+      LOG.trace(\n+          \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+          fromBlockNumber,\n+          toBlockNumber);\n+    }\n+\n+    return getDepositEventsInRangeFromContract(fromBlockNumber, toBlockNumber)\n+        .thenApply(this::groupDepositEventResponsesByBlockHash)\n+        .thenCompose(\n+            eventResponsesByBlockHash ->\n+                postDepositEvents(\n+                    getListOfEthBlockFutures(eventResponsesByBlockHash.keySet()),\n+                    eventResponsesByBlockHash));\n+  }\n+\n+  private SafeFuture<List<DepositContract.DepositEventEventResponse>>\n+      getDepositEventsInRangeFromContract(BigInteger fromBlockNumber, BigInteger toBlockNumber) {\n+\n+    DefaultBlockParameter fromBlock = DefaultBlockParameter.valueOf(fromBlockNumber);\n+    DefaultBlockParameter toBlock = DefaultBlockParameter.valueOf(toBlockNumber);\n+\n+    return depositContract\n+        .depositEventInRange(fromBlock, toBlock)\n+        .exceptionallyCompose(\n+            (err) -> {\n+              if (fromBlockNumber.equals(toBlockNumber)) {\n+                LOG.warn(\"Retrying request of deposit events for block number {}\", fromBlockNumber);\n+              } else {\n+                LOG.warn(\n+                    \"Retrying request of deposit events for \"\n+                        + \"block numbers in the range ({}, {})\",", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDE1MQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388490151", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T18:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NTY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NTg0OA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387985848", "bodyText": "I'd just have the range version of this log too.  And we should include the error that occurred in the message.\nSo probably:\nLOG.warn(\"Failed to request deposit events for blocks \" + fromBlock + \" to \" + toBlock + \". Retrying\", err)", "author": "ajsutton", "createdAt": "2020-03-04T23:00:25Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositFetcher.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositFetcher {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositContract depositContract;\n+  private final AsyncRunner asyncRunner;\n+\n+  public DepositFetcher(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositContract depositContract,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositContract = depositContract;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  // Inclusive on both sides\n+  public synchronized SafeFuture<Void> fetchDepositsInRange(\n+      BigInteger fromBlockNumber, BigInteger toBlockNumber) {\n+\n+    if (fromBlockNumber.equals(toBlockNumber)) {\n+      LOG.trace(\"Attempting to fetch deposit events for block number {}\", fromBlockNumber);\n+    } else {\n+      LOG.trace(\n+          \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+          fromBlockNumber,\n+          toBlockNumber);\n+    }\n+\n+    return getDepositEventsInRangeFromContract(fromBlockNumber, toBlockNumber)\n+        .thenApply(this::groupDepositEventResponsesByBlockHash)\n+        .thenCompose(\n+            eventResponsesByBlockHash ->\n+                postDepositEvents(\n+                    getListOfEthBlockFutures(eventResponsesByBlockHash.keySet()),\n+                    eventResponsesByBlockHash));\n+  }\n+\n+  private SafeFuture<List<DepositContract.DepositEventEventResponse>>\n+      getDepositEventsInRangeFromContract(BigInteger fromBlockNumber, BigInteger toBlockNumber) {\n+\n+    DefaultBlockParameter fromBlock = DefaultBlockParameter.valueOf(fromBlockNumber);\n+    DefaultBlockParameter toBlock = DefaultBlockParameter.valueOf(toBlockNumber);\n+\n+    return depositContract\n+        .depositEventInRange(fromBlock, toBlock)\n+        .exceptionallyCompose(\n+            (err) -> {\n+              if (fromBlockNumber.equals(toBlockNumber)) {", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDgzNg==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388490836", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T18:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NzEwNA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387987104", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          return asyncRunner\n          \n          \n            \n                              .getDelayedFuture(Constants.ETH1_DEPOSIT_REQUEST_RETRY_TIMEOUT, TimeUnit.SECONDS)\n          \n          \n            \n                              .thenCompose(\n          \n          \n            \n                                  __ -> getDepositEventsInRangeFromContract(fromBlockNumber, toBlockNumber));\n          \n          \n            \n                          return asyncRunner.runAfterDelay(\n          \n          \n            \n                              () -> getDepositEventsInRangeFromContract(fromBlockNumber, toBlockNumber),\n          \n          \n            \n                              Constants.ETH1_DEPOSIT_REQUEST_RETRY_TIMEOUT,\n          \n          \n            \n                              TimeUnit.SECONDS);", "author": "ajsutton", "createdAt": "2020-03-04T23:03:54Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositFetcher.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositFetcher {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositContract depositContract;\n+  private final AsyncRunner asyncRunner;\n+\n+  public DepositFetcher(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositContract depositContract,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositContract = depositContract;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  // Inclusive on both sides\n+  public synchronized SafeFuture<Void> fetchDepositsInRange(\n+      BigInteger fromBlockNumber, BigInteger toBlockNumber) {\n+\n+    if (fromBlockNumber.equals(toBlockNumber)) {\n+      LOG.trace(\"Attempting to fetch deposit events for block number {}\", fromBlockNumber);\n+    } else {\n+      LOG.trace(\n+          \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+          fromBlockNumber,\n+          toBlockNumber);\n+    }\n+\n+    return getDepositEventsInRangeFromContract(fromBlockNumber, toBlockNumber)\n+        .thenApply(this::groupDepositEventResponsesByBlockHash)\n+        .thenCompose(\n+            eventResponsesByBlockHash ->\n+                postDepositEvents(\n+                    getListOfEthBlockFutures(eventResponsesByBlockHash.keySet()),\n+                    eventResponsesByBlockHash));\n+  }\n+\n+  private SafeFuture<List<DepositContract.DepositEventEventResponse>>\n+      getDepositEventsInRangeFromContract(BigInteger fromBlockNumber, BigInteger toBlockNumber) {\n+\n+    DefaultBlockParameter fromBlock = DefaultBlockParameter.valueOf(fromBlockNumber);\n+    DefaultBlockParameter toBlock = DefaultBlockParameter.valueOf(toBlockNumber);\n+\n+    return depositContract\n+        .depositEventInRange(fromBlock, toBlock)\n+        .exceptionallyCompose(\n+            (err) -> {\n+              if (fromBlockNumber.equals(toBlockNumber)) {\n+                LOG.warn(\"Retrying request of deposit events for block number {}\", fromBlockNumber);\n+              } else {\n+                LOG.warn(\n+                    \"Retrying request of deposit events for \"\n+                        + \"block numbers in the range ({}, {})\",\n+                    fromBlockNumber,\n+                    toBlockNumber);\n+              }\n+\n+              return asyncRunner\n+                  .getDelayedFuture(Constants.ETH1_DEPOSIT_REQUEST_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+                  .thenCompose(\n+                      __ -> getDepositEventsInRangeFromContract(fromBlockNumber, toBlockNumber));", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MTI3NA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388491274", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T18:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NzkwMw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387987903", "bodyText": "These should only be accessed inside synchronised blocks now so shouldn't need to be volatile.", "author": "ajsutton", "createdAt": "2020-03-04T23:06:09Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MTg1NA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388491854", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T18:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NzkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4ODYxMg==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387988612", "bodyText": "Google code style allows string constants to be on a single line. Unless it's way over the line length it's usually more readable as a single string.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"Unable to subscribe to the Eth1Node. Node won't \"\n          \n          \n            \n                                    + \"have access to new deposits after genesis.\",\n          \n          \n            \n                                error));\n          \n          \n            \n                                \"Unable to subscribe to the Eth1Node. Node won't have access to new deposits after genesis.\",\n          \n          \n            \n                                error));", "author": "ajsutton", "createdAt": "2020-03-04T23:08:08Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MjI2Nw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388492267", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T18:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4ODYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4ODg1NA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r387988854", "bodyText": "We should consistently use braces.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else fetchLatestSubscriptionDepositsOverRange();\n          \n          \n            \n                } else {\n          \n          \n            \n                  fetchLatestSubscriptionDepositsOverRange();\n          \n          \n            \n                }", "author": "ajsutton", "createdAt": "2020-03-04T23:08:46Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));\n+  }\n+\n+  private synchronized void onNewCanonicalBlockNumber(BigInteger latestCanonicalBlockNumber) {\n+    if (latestCanonicalBlockNumber.compareTo(this.latestCanonicalBlockNumber) <= 0) {\n+      return;\n+    }\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    fetchLatestSubscriptionDeposits();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDeposits() {\n+    if (isBlockByBlockModeOn) {\n+      fetchLatestDepositsOneBlockAtATime();\n+    } else fetchLatestSubscriptionDepositsOverRange();", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzgwNg==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388493806", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T18:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4ODg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMTUzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388011539", "bodyText": "The method is already synchronised so we don't need this nested synchronised block anymore.", "author": "ajsutton", "createdAt": "2020-03-05T00:18:28Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));\n+  }\n+\n+  private synchronized void onNewCanonicalBlockNumber(BigInteger latestCanonicalBlockNumber) {\n+    if (latestCanonicalBlockNumber.compareTo(this.latestCanonicalBlockNumber) <= 0) {\n+      return;\n+    }\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    fetchLatestSubscriptionDeposits();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDeposits() {\n+    if (isBlockByBlockModeOn) {\n+      fetchLatestDepositsOneBlockAtATime();\n+    } else fetchLatestSubscriptionDepositsOverRange();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDepositsOverRange() {\n+    final BigInteger toBlock;\n+    final BigInteger fromBlock;\n+\n+    if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+      return;\n+    }\n+    active = true;\n+\n+    fromBlock = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    toBlock = latestCanonicalBlockNumber;\n+\n+    depositFetcher\n+        .fetchDepositsInRange(fromBlock, toBlock)\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(toBlock),\n+            (err) -> onSubscriptionDepositRequestFailed(err, fromBlock, toBlock));\n+  }\n+\n+  private synchronized void fetchLatestDepositsOneBlockAtATime() {\n+    final BigInteger nextBlockNumber;\n+\n+    synchronized (DepositProcessingController.this) {", "originalCommit": "b42a6297ca42aa158c799c825e300a3eedf828c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NDA3NA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388494074", "bodyText": "Makes sense.", "author": "cemozerr", "createdAt": "2020-03-05T18:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMzE3NQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388013175", "bodyText": "This should probably be in an else block or the minus will underflow when min genesis time has been reached.", "author": "ajsutton", "createdAt": "2020-03-05T00:24:09Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));\n+  }\n+\n+  private synchronized void onNewCanonicalBlockNumber(BigInteger latestCanonicalBlockNumber) {\n+    if (latestCanonicalBlockNumber.compareTo(this.latestCanonicalBlockNumber) <= 0) {\n+      return;\n+    }\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    fetchLatestSubscriptionDeposits();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDeposits() {\n+    if (isBlockByBlockModeOn) {\n+      fetchLatestDepositsOneBlockAtATime();\n+    } else fetchLatestSubscriptionDepositsOverRange();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDepositsOverRange() {\n+    final BigInteger toBlock;\n+    final BigInteger fromBlock;\n+\n+    if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+      return;\n+    }\n+    active = true;\n+\n+    fromBlock = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    toBlock = latestCanonicalBlockNumber;\n+\n+    depositFetcher\n+        .fetchDepositsInRange(fromBlock, toBlock)\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(toBlock),\n+            (err) -> onSubscriptionDepositRequestFailed(err, fromBlock, toBlock));\n+  }\n+\n+  private synchronized void fetchLatestDepositsOneBlockAtATime() {\n+    final BigInteger nextBlockNumber;\n+\n+    synchronized (DepositProcessingController.this) {\n+      if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+        return;\n+      }\n+      active = true;\n+\n+      nextBlockNumber = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    }\n+\n+    depositFetcher\n+        .fetchDepositsInRange(nextBlockNumber, nextBlockNumber)\n+        .thenCompose(\n+            __ ->\n+                eth1Provider.getGuaranteedEth1BlockFuture(\n+                    UnsignedLong.valueOf(nextBlockNumber), asyncRunner))\n+        .thenAccept(\n+            block -> {\n+              final BigInteger blockNumber = block.getNumber();\n+              LOG.trace(\"Successfully fetched block {} for min genesis checking\", blockNumber);\n+              LOG.trace(\n+                  \"Seconds until min genesis block {}\",\n+                  Constants.MIN_GENESIS_TIME.minus(\n+                      calculateCandidateGenesisTimestamp(block.getTimestamp())));", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NTIzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388495239", "bodyText": "Makes sense.", "author": "cemozerr", "createdAt": "2020-03-05T18:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMzE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMzYxOQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388013619", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            LOG.debug(\"Switching back to fetching deposits by range\");\n          \n          \n            \n                            LOG.debug(\"Minimum genesis time reached, switching back to fetching deposits by range\");", "author": "ajsutton", "createdAt": "2020-03-05T00:25:38Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));\n+  }\n+\n+  private synchronized void onNewCanonicalBlockNumber(BigInteger latestCanonicalBlockNumber) {\n+    if (latestCanonicalBlockNumber.compareTo(this.latestCanonicalBlockNumber) <= 0) {\n+      return;\n+    }\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    fetchLatestSubscriptionDeposits();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDeposits() {\n+    if (isBlockByBlockModeOn) {\n+      fetchLatestDepositsOneBlockAtATime();\n+    } else fetchLatestSubscriptionDepositsOverRange();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDepositsOverRange() {\n+    final BigInteger toBlock;\n+    final BigInteger fromBlock;\n+\n+    if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+      return;\n+    }\n+    active = true;\n+\n+    fromBlock = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    toBlock = latestCanonicalBlockNumber;\n+\n+    depositFetcher\n+        .fetchDepositsInRange(fromBlock, toBlock)\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(toBlock),\n+            (err) -> onSubscriptionDepositRequestFailed(err, fromBlock, toBlock));\n+  }\n+\n+  private synchronized void fetchLatestDepositsOneBlockAtATime() {\n+    final BigInteger nextBlockNumber;\n+\n+    synchronized (DepositProcessingController.this) {\n+      if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+        return;\n+      }\n+      active = true;\n+\n+      nextBlockNumber = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    }\n+\n+    depositFetcher\n+        .fetchDepositsInRange(nextBlockNumber, nextBlockNumber)\n+        .thenCompose(\n+            __ ->\n+                eth1Provider.getGuaranteedEth1BlockFuture(\n+                    UnsignedLong.valueOf(nextBlockNumber), asyncRunner))\n+        .thenAccept(\n+            block -> {\n+              final BigInteger blockNumber = block.getNumber();\n+              LOG.trace(\"Successfully fetched block {} for min genesis checking\", blockNumber);\n+              LOG.trace(\n+                  \"Seconds until min genesis block {}\",\n+                  Constants.MIN_GENESIS_TIME.minus(\n+                      calculateCandidateGenesisTimestamp(block.getTimestamp())));\n+              if (MinimumGenesisTimeBlockFinder.compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                notifyMinGenesisTimeBlockReached(eth1EventsChannel, block);\n+                isBlockByBlockModeOn = false;\n+                LOG.debug(\"Switching back to fetching deposits by range\");", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NTU0Mg==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388495542", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-03-05T18:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMzYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMzk0Nw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388013947", "bodyText": "nit: We're not using a subscription to get deposits anymore so these onSubscription* methods should just be onDepositRequestSuccessful etc.", "author": "ajsutton", "createdAt": "2020-03-05T00:26:46Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));\n+  }\n+\n+  private synchronized void onNewCanonicalBlockNumber(BigInteger latestCanonicalBlockNumber) {\n+    if (latestCanonicalBlockNumber.compareTo(this.latestCanonicalBlockNumber) <= 0) {\n+      return;\n+    }\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    fetchLatestSubscriptionDeposits();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDeposits() {\n+    if (isBlockByBlockModeOn) {\n+      fetchLatestDepositsOneBlockAtATime();\n+    } else fetchLatestSubscriptionDepositsOverRange();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDepositsOverRange() {\n+    final BigInteger toBlock;\n+    final BigInteger fromBlock;\n+\n+    if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+      return;\n+    }\n+    active = true;\n+\n+    fromBlock = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    toBlock = latestCanonicalBlockNumber;\n+\n+    depositFetcher\n+        .fetchDepositsInRange(fromBlock, toBlock)\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(toBlock),\n+            (err) -> onSubscriptionDepositRequestFailed(err, fromBlock, toBlock));\n+  }\n+\n+  private synchronized void fetchLatestDepositsOneBlockAtATime() {\n+    final BigInteger nextBlockNumber;\n+\n+    synchronized (DepositProcessingController.this) {\n+      if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+        return;\n+      }\n+      active = true;\n+\n+      nextBlockNumber = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    }\n+\n+    depositFetcher\n+        .fetchDepositsInRange(nextBlockNumber, nextBlockNumber)\n+        .thenCompose(\n+            __ ->\n+                eth1Provider.getGuaranteedEth1BlockFuture(\n+                    UnsignedLong.valueOf(nextBlockNumber), asyncRunner))\n+        .thenAccept(\n+            block -> {\n+              final BigInteger blockNumber = block.getNumber();\n+              LOG.trace(\"Successfully fetched block {} for min genesis checking\", blockNumber);\n+              LOG.trace(\n+                  \"Seconds until min genesis block {}\",\n+                  Constants.MIN_GENESIS_TIME.minus(\n+                      calculateCandidateGenesisTimestamp(block.getTimestamp())));\n+              if (MinimumGenesisTimeBlockFinder.compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                notifyMinGenesisTimeBlockReached(eth1EventsChannel, block);\n+                isBlockByBlockModeOn = false;\n+                LOG.debug(\"Switching back to fetching deposits by range\");\n+              }\n+            })\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(nextBlockNumber),\n+            (err) -> onSubscriptionDepositRequestFailed(err, nextBlockNumber));\n+  }\n+\n+  private synchronized void onSubscriptionDepositRequestSuccessful(BigInteger requestToBlock) {", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NzAxMw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388497013", "bodyText": "The request methods still get run after a block received from the subscription actually. So I'm on the side of keeping them.", "author": "cemozerr", "createdAt": "2020-03-05T18:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNDE5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388014196", "bodyText": "Just the range version here too.", "author": "ajsutton", "createdAt": "2020-03-05T00:27:41Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));\n+  }\n+\n+  private synchronized void onNewCanonicalBlockNumber(BigInteger latestCanonicalBlockNumber) {\n+    if (latestCanonicalBlockNumber.compareTo(this.latestCanonicalBlockNumber) <= 0) {\n+      return;\n+    }\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    fetchLatestSubscriptionDeposits();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDeposits() {\n+    if (isBlockByBlockModeOn) {\n+      fetchLatestDepositsOneBlockAtATime();\n+    } else fetchLatestSubscriptionDepositsOverRange();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDepositsOverRange() {\n+    final BigInteger toBlock;\n+    final BigInteger fromBlock;\n+\n+    if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+      return;\n+    }\n+    active = true;\n+\n+    fromBlock = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    toBlock = latestCanonicalBlockNumber;\n+\n+    depositFetcher\n+        .fetchDepositsInRange(fromBlock, toBlock)\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(toBlock),\n+            (err) -> onSubscriptionDepositRequestFailed(err, fromBlock, toBlock));\n+  }\n+\n+  private synchronized void fetchLatestDepositsOneBlockAtATime() {\n+    final BigInteger nextBlockNumber;\n+\n+    synchronized (DepositProcessingController.this) {\n+      if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+        return;\n+      }\n+      active = true;\n+\n+      nextBlockNumber = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    }\n+\n+    depositFetcher\n+        .fetchDepositsInRange(nextBlockNumber, nextBlockNumber)\n+        .thenCompose(\n+            __ ->\n+                eth1Provider.getGuaranteedEth1BlockFuture(\n+                    UnsignedLong.valueOf(nextBlockNumber), asyncRunner))\n+        .thenAccept(\n+            block -> {\n+              final BigInteger blockNumber = block.getNumber();\n+              LOG.trace(\"Successfully fetched block {} for min genesis checking\", blockNumber);\n+              LOG.trace(\n+                  \"Seconds until min genesis block {}\",\n+                  Constants.MIN_GENESIS_TIME.minus(\n+                      calculateCandidateGenesisTimestamp(block.getTimestamp())));\n+              if (MinimumGenesisTimeBlockFinder.compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                notifyMinGenesisTimeBlockReached(eth1EventsChannel, block);\n+                isBlockByBlockModeOn = false;\n+                LOG.debug(\"Switching back to fetching deposits by range\");\n+              }\n+            })\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(nextBlockNumber),\n+            (err) -> onSubscriptionDepositRequestFailed(err, nextBlockNumber));\n+  }\n+\n+  private synchronized void onSubscriptionDepositRequestSuccessful(BigInteger requestToBlock) {\n+    active = false;\n+    latestSuccessfullyQueriedBlock = requestToBlock;\n+\n+    if (latestCanonicalBlockNumber.compareTo(latestSuccessfullyQueriedBlock) > 0) {\n+      fetchLatestSubscriptionDeposits();\n+    }\n+  }\n+\n+  private synchronized void onSubscriptionDepositRequestFailed(\n+      Throwable err, BigInteger fromBlock) {\n+    onSubscriptionDepositRequestFailed(err, fromBlock, fromBlock);\n+  }\n+\n+  private synchronized void onSubscriptionDepositRequestFailed(\n+      Throwable err, BigInteger fromBlock, BigInteger toBlock) {\n+    active = false;\n+\n+    if (!fromBlock.equals(toBlock)) {", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5ODA3NA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388498074", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T19:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNDE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNDMwMw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388014303", "bodyText": "Add \"Retrying\" to the end so the user knows it's being reattempted.", "author": "ajsutton", "createdAt": "2020-03-05T00:28:05Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositProcessingController.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.calculateCandidateGenesisTimestamp;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProcessingController {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final DepositFetcher depositFetcher;\n+\n+  private Disposable newBlockSubscription;\n+  private volatile boolean active = false;\n+\n+  // BlockByBlock mode is used to request deposit events and block information for each block\n+  private volatile boolean isBlockByBlockModeOn = false;\n+\n+  private BigInteger latestSuccessfullyQueriedBlock = BigInteger.ZERO;\n+  private BigInteger latestCanonicalBlockNumber = BigInteger.ZERO;\n+\n+  public DepositProcessingController(\n+      Eth1Provider eth1Provider,\n+      Eth1EventsChannel eth1EventsChannel,\n+      AsyncRunner asyncRunner,\n+      DepositFetcher depositFetcher) {\n+    this.eth1Provider = eth1Provider;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.asyncRunner = asyncRunner;\n+    this.depositFetcher = depositFetcher;\n+  }\n+\n+  public synchronized void switchToBlockByBlockMode() {\n+    LOG.debug(\"Switching to blockByBlock mode\");\n+    isBlockByBlockModeOn = true;\n+  }\n+\n+  // inclusive of start block\n+  public synchronized void startSubscription(BigInteger subscriptionStartBlock) {\n+    LOG.debug(\"Starting subscription at block {}\", subscriptionStartBlock);\n+    latestSuccessfullyQueriedBlock = subscriptionStartBlock.subtract(BigInteger.ONE);\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::onNewCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  public void stopIfSubscribed() {\n+    if (newBlockSubscription != null) {\n+      newBlockSubscription.dispose();\n+    }\n+  }\n+\n+  // Inclusive\n+  public synchronized SafeFuture<Void> fetchDepositsFromGenesisTo(BigInteger toBlockNumber) {\n+    return depositFetcher.fetchDepositsInRange(BigInteger.ZERO, toBlockNumber);\n+  }\n+\n+  private synchronized void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_SUBSCRIPTION_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            () -> startSubscription(latestSuccessfullyQueriedBlock),\n+            (error) ->\n+                LOG.warn(\n+                    \"Unable to subscribe to the Eth1Node. Node won't \"\n+                        + \"have access to new deposits after genesis.\",\n+                    error));\n+  }\n+\n+  private synchronized void onNewCanonicalBlockNumber(BigInteger latestCanonicalBlockNumber) {\n+    if (latestCanonicalBlockNumber.compareTo(this.latestCanonicalBlockNumber) <= 0) {\n+      return;\n+    }\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    fetchLatestSubscriptionDeposits();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDeposits() {\n+    if (isBlockByBlockModeOn) {\n+      fetchLatestDepositsOneBlockAtATime();\n+    } else fetchLatestSubscriptionDepositsOverRange();\n+  }\n+\n+  private synchronized void fetchLatestSubscriptionDepositsOverRange() {\n+    final BigInteger toBlock;\n+    final BigInteger fromBlock;\n+\n+    if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+      return;\n+    }\n+    active = true;\n+\n+    fromBlock = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    toBlock = latestCanonicalBlockNumber;\n+\n+    depositFetcher\n+        .fetchDepositsInRange(fromBlock, toBlock)\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(toBlock),\n+            (err) -> onSubscriptionDepositRequestFailed(err, fromBlock, toBlock));\n+  }\n+\n+  private synchronized void fetchLatestDepositsOneBlockAtATime() {\n+    final BigInteger nextBlockNumber;\n+\n+    synchronized (DepositProcessingController.this) {\n+      if (active || latestCanonicalBlockNumber.equals(latestSuccessfullyQueriedBlock)) {\n+        return;\n+      }\n+      active = true;\n+\n+      nextBlockNumber = latestSuccessfullyQueriedBlock.add(BigInteger.ONE);\n+    }\n+\n+    depositFetcher\n+        .fetchDepositsInRange(nextBlockNumber, nextBlockNumber)\n+        .thenCompose(\n+            __ ->\n+                eth1Provider.getGuaranteedEth1BlockFuture(\n+                    UnsignedLong.valueOf(nextBlockNumber), asyncRunner))\n+        .thenAccept(\n+            block -> {\n+              final BigInteger blockNumber = block.getNumber();\n+              LOG.trace(\"Successfully fetched block {} for min genesis checking\", blockNumber);\n+              LOG.trace(\n+                  \"Seconds until min genesis block {}\",\n+                  Constants.MIN_GENESIS_TIME.minus(\n+                      calculateCandidateGenesisTimestamp(block.getTimestamp())));\n+              if (MinimumGenesisTimeBlockFinder.compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                notifyMinGenesisTimeBlockReached(eth1EventsChannel, block);\n+                isBlockByBlockModeOn = false;\n+                LOG.debug(\"Switching back to fetching deposits by range\");\n+              }\n+            })\n+        .finish(\n+            __ -> onSubscriptionDepositRequestSuccessful(nextBlockNumber),\n+            (err) -> onSubscriptionDepositRequestFailed(err, nextBlockNumber));\n+  }\n+\n+  private synchronized void onSubscriptionDepositRequestSuccessful(BigInteger requestToBlock) {\n+    active = false;\n+    latestSuccessfullyQueriedBlock = requestToBlock;\n+\n+    if (latestCanonicalBlockNumber.compareTo(latestSuccessfullyQueriedBlock) > 0) {\n+      fetchLatestSubscriptionDeposits();\n+    }\n+  }\n+\n+  private synchronized void onSubscriptionDepositRequestFailed(\n+      Throwable err, BigInteger fromBlock) {\n+    onSubscriptionDepositRequestFailed(err, fromBlock, fromBlock);\n+  }\n+\n+  private synchronized void onSubscriptionDepositRequestFailed(\n+      Throwable err, BigInteger fromBlock, BigInteger toBlock) {\n+    active = false;\n+\n+    if (!fromBlock.equals(toBlock)) {\n+      LOG.warn(\n+          \"Failed to fetch deposit events for block numbers in the range ({}, {})\",", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5ODM1OQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388498359", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T19:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNDc5OQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388014799", "bodyText": "If we're not able to retry this at all, it probably should be a fatal level.  The program is no longer able to function as it should and needs to be restarted.  Definitely at least error level.", "author": "ajsutton", "createdAt": "2020-03-05T00:30:06Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DepositManager.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.isBlockAfterMinGenesis;\n+import static tech.pegasys.artemis.pow.MinimumGenesisTimeBlockFinder.notifyMinGenesisTimeBlockReached;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.Eth1EventsChannel;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DepositManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final AsyncRunner asyncRunner;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final DepositProcessingController depositProcessingController;\n+  private final MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder;\n+\n+  public Eth1DepositManager(\n+      Eth1Provider eth1Provider,\n+      AsyncRunner asyncRunner,\n+      Eth1EventsChannel eth1EventsChannel,\n+      DepositProcessingController depositProcessingController,\n+      MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder) {\n+    this.eth1Provider = eth1Provider;\n+    this.asyncRunner = asyncRunner;\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.depositProcessingController = depositProcessingController;\n+    this.minimumGenesisTimeBlockFinder = minimumGenesisTimeBlockFinder;\n+  }\n+\n+  public void start() {\n+    getHead()\n+        .thenCompose(\n+            headBlock -> {\n+              if (isBlockAfterMinGenesis(headBlock)) {\n+                return headAfterMinGenesisMode(headBlock);\n+              } else {\n+                return headBeforeMinGenesisMode(headBlock);\n+              }\n+            })\n+        .finish(\n+            () -> LOG.info(\"Eth1DepositsManager successfully ran startup sequence.\"),\n+            (err) -> LOG.warn(\"Eth1DepositsManager unable to run startup sequence.\", err));", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5ODc0NA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388498744", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T19:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNDc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNTMyMw==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388015323", "bodyText": "Is it possible to pass AsyncRunner into the constructor of this class rather than having to pass it into this method each time?  It should just be an implementation detail of Web3jEth1Provider that it delays retrying.", "author": "ajsutton", "createdAt": "2020-03-05T00:32:01Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Web3jEth1Provider.java", "diffHunk": "@@ -55,6 +58,34 @@ public Web3jEth1Provider(Web3j web3j) {\n         .thenApply(EthBlock::getBlock);\n   }\n \n+  @Override\n+  public SafeFuture<EthBlock.Block> getGuaranteedEth1BlockFuture(\n+      String blockHash, AsyncRunner asyncRunner) {", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwMjMyMA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388502320", "bodyText": "Makes total sense.", "author": "cemozerr", "createdAt": "2020-03-05T19:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjI5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388016296", "bodyText": "Can you add a @TearDown to reset Constants to the minimal config again so other tests don't get caught out please.", "author": "ajsutton", "createdAt": "2020-03-05T00:35:12Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class MinimumGenesisTimeBlockFinderTest {\n+\n+  private Eth1Provider eth1Provider;\n+\n+  private MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder;\n+  //  private PublishSubject<EthBlock.Block> blockPublisher;\n+\n+  @BeforeEach\n+  void setUp() {\n+    eth1Provider = mock(Eth1Provider.class);\n+\n+    minimumGenesisTimeBlockFinder = new MinimumGenesisTimeBlockFinder(eth1Provider);\n+\n+    //    blockPublisher = mockFlowablePublisher();\n+\n+    Constants.MIN_GENESIS_DELAY = 1;", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNzM4MA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388507380", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-03-05T19:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjQ0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388016446", "bodyText": "Why are these all commented out?", "author": "ajsutton", "createdAt": "2020-03-05T00:35:39Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class MinimumGenesisTimeBlockFinderTest {\n+\n+  private Eth1Provider eth1Provider;\n+\n+  private MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder;\n+  //  private PublishSubject<EthBlock.Block> blockPublisher;\n+\n+  @BeforeEach\n+  void setUp() {\n+    eth1Provider = mock(Eth1Provider.class);\n+\n+    minimumGenesisTimeBlockFinder = new MinimumGenesisTimeBlockFinder(eth1Provider);\n+\n+    //    blockPublisher = mockFlowablePublisher();\n+\n+    Constants.MIN_GENESIS_DELAY = 1;\n+    // calculateCandidateGenesisTimestamp will return\n+    // blockTime + 2\n+  }\n+\n+  @Test\n+  void minGenesisBlock_belowEstimatedBlock() {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n+\n+    //    mockLatestCanonicalBlock(1000);\n+    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n+\n+    setMinGenesisTime(500);\n+\n+    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n+    // 1000 - 100 = 900\n+\n+    mockBlockForEth1Provider(\"0x11\", 900, 600);\n+\n+    // since the estimated block still had higher timestamp than min genesis, we should explore\n+    // downwards\n+\n+    mockBlockForEth1Provider(\"0x08\", 899, 510);\n+\n+    // since the second requested block still had higher timestamp than min genesis, we should\n+    // explore downwards\n+\n+    mockBlockForEth1Provider(\"0x00\", 898, 490);\n+\n+    // since the last requested block now had lower timestamp than min genesis, we should publish\n+    // the block\n+    // right before this as the first valid block\n+\n+    EthBlock.Block minGenesisTimeBlock =\n+        minimumGenesisTimeBlockFinder.findMinGenesisTimeBlockInHistory(estimationBlock).join();\n+\n+    assertThatIsBlock(minGenesisTimeBlock, \"0x08\", 899, 510);\n+  }\n+\n+  @Test\n+  void minGenesisBlock_AboveEstimatedBlock() {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n+\n+    //    mockLatestCanonicalBlock(1000);\n+    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n+\n+    setMinGenesisTime(500);\n+\n+    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n+    // 1000 - 100 = 900\n+\n+    mockBlockForEth1Provider(\"0x08\", 900, 400);\n+\n+    // since the estimated block still had lower timestamp than min genesis, we should explore\n+    // upwards\n+\n+    mockBlockForEth1Provider(\"0x08\", 901, 450);\n+\n+    // since the second requested block still had lower timestamp than min genesis, we should\n+    // explore upwards\n+\n+    mockBlockForEth1Provider(\"0x08\", 902, 510);\n+\n+    // since the last requested block now had higher timestamp than min genesis, we should publish\n+    // the block\n+\n+    EthBlock.Block minGenesisTimeBlock =\n+        minimumGenesisTimeBlockFinder.findMinGenesisTimeBlockInHistory(estimationBlock).join();\n+\n+    assertThatIsBlock(minGenesisTimeBlock, \"0x08\", 902, 510);\n+  }\n+\n+  @Test\n+  void minGenesisBlock_EstimatedBlockIsTheValidBlock() {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n+\n+    //    mockLatestCanonicalBlock(1000);\n+    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n+\n+    setMinGenesisTime(502);\n+\n+    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n+    // 1000 - 100 = 900\n+\n+    mockBlockForEth1Provider(\"0x08\", 900, 500);\n+\n+    // since the genesis time calculated from the , we should publish the block\n+\n+    EthBlock.Block minGenesisTimeBlock =\n+        minimumGenesisTimeBlockFinder.findMinGenesisTimeBlockInHistory(estimationBlock).join();\n+\n+    assertThatIsBlock(minGenesisTimeBlock, \"0x08\", 900, 500);\n+  }\n+\n+  //  @Test\n+  //  void waitForFirstValidBlock() {", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMjI1OA==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388512258", "bodyText": "They became redundant with the tests written in DepositProcessingControllerTest. I forgot to delete them, they're deleted now.", "author": "cemozerr", "createdAt": "2020-03-05T19:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjg2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388016862", "bodyText": "Probably don't need this comment. :). Come to think of it though, we could maybe use a default method on the interface.  Not really sure what EventChannel would think of that but it would probably work.", "author": "ajsutton", "createdAt": "2020-03-05T00:37:00Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/DepositProvider.java", "diffHunk": "@@ -70,6 +79,10 @@ public synchronized void onFinalizedCheckpoint(FinalizedCheckpointEvent event) {\n     depositNavigableMap.headMap(finalizedState.getEth1_deposit_index()).clear();\n   }\n \n+  // It's sad that we have to do this. Is there any other way?", "originalCommit": "39d98ce246a8b1c9dd516ad30481b099ab8d0bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMjY0OQ==", "url": "https://github.com/ConsenSys/teku/pull/1246#discussion_r388512649", "bodyText": "Haha had forgotten to delete that after our chat. Deleted now.", "author": "cemozerr", "createdAt": "2020-03-05T19:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjg2Mg=="}], "type": "inlineReview"}, {"oid": "38601b70513f191a67593d390e6f0e08d7133c6a", "url": "https://github.com/ConsenSys/teku/commit/38601b70513f191a67593d390e6f0e08d7133c6a", "message": "Resolve comments", "committedDate": "2020-03-05T19:31:11Z", "type": "commit"}, {"oid": "097352f7c90414e98ddb91ffd2aaefc44bb4f1e0", "url": "https://github.com/ConsenSys/teku/commit/097352f7c90414e98ddb91ffd2aaefc44bb4f1e0", "message": "Merge branch 'master' into refactorDepositsAndGenesis", "committedDate": "2020-03-05T19:31:48Z", "type": "commit"}]}