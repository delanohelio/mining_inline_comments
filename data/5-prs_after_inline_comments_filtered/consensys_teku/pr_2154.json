{"pr_number": 2154, "pr_title": "Integrate fork choice tests", "pr_createdAt": "2020-06-15T23:17:43Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2154", "timeline": [{"oid": "cf33a1bae39b7ab8cf1ee3988a5fe9e6e3f428df", "url": "https://github.com/ConsenSys/teku/commit/cf33a1bae39b7ab8cf1ee3988a5fe9e6e3f428df", "message": "initial commit of fork choice description files", "committedDate": "2020-06-15T23:11:37Z", "type": "commit"}, {"oid": "a4213ec2cf921339858668e29bb381dcc57af863", "url": "https://github.com/ConsenSys/teku/commit/a4213ec2cf921339858668e29bb381dcc57af863", "message": "Initial commit of fork choice test executor", "committedDate": "2020-06-15T23:12:34Z", "type": "commit"}, {"oid": "50e427436b40a54201f4fa68b08e46bbfce5e663", "url": "https://github.com/ConsenSys/teku/commit/50e427436b40a54201f4fa68b08e46bbfce5e663", "message": "Add ForkChoiceTestFinder", "committedDate": "2020-06-15T23:13:34Z", "type": "commit"}, {"oid": "954b55d09b3c74e96ef78f7902a931b9c2e3cb35", "url": "https://github.com/ConsenSys/teku/commit/954b55d09b3c74e96ef78f7902a931b9c2e3cb35", "message": "Merge branch 'master' into integrateForkChoiceTests", "committedDate": "2020-06-15T23:30:44Z", "type": "commit"}, {"oid": "d042217413a8ed4b3a2bfe4c9637c51d2df58832", "url": "https://github.com/ConsenSys/teku/commit/d042217413a8ed4b3a2bfe4c9637c51d2df58832", "message": "initial commit of fork choice description files", "committedDate": "2020-06-15T23:48:02Z", "type": "commit"}, {"oid": "6842b775aeb3ee1ad32f3fc56ef8c68166929263", "url": "https://github.com/ConsenSys/teku/commit/6842b775aeb3ee1ad32f3fc56ef8c68166929263", "message": "Initial commit of fork choice test executor", "committedDate": "2020-06-15T23:48:02Z", "type": "commit"}, {"oid": "1e651b5902bc7de3b1114343b88b53ab704ff89b", "url": "https://github.com/ConsenSys/teku/commit/1e651b5902bc7de3b1114343b88b53ab704ff89b", "message": "Add ForkChoiceTestFinder", "committedDate": "2020-06-15T23:48:02Z", "type": "commit"}, {"oid": "fdd8ee9386e4f24c56d8cfa50c13ea2b37b2274e", "url": "https://github.com/ConsenSys/teku/commit/fdd8ee9386e4f24c56d8cfa50c13ea2b37b2274e", "message": "Merge remote-tracking branch 'origin/integrateForkChoiceTests' into integrateForkChoiceTests", "committedDate": "2020-06-15T23:52:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MzUwNw==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440883507", "bodyText": "nit: Seems like lines 67 to 72 are stale.", "author": "cemozerr", "createdAt": "2020-06-16T14:13:26Z", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.ReferenceTestFinder;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() throws Exception {\n+    Path rootDirectory = ReferenceTestFinder.findReferenceTestRootDirectory();", "originalCommit": "fdd8ee9386e4f24c56d8cfa50c13ea2b37b2274e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg5MDg5Ng==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440890896", "bodyText": "yes", "author": "ericsson49", "createdAt": "2020-06-16T14:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MzUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg5Mzk1OA==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440893958", "bodyText": "Cleaned up", "author": "ericsson49", "createdAt": "2020-06-16T14:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MzUwNw=="}], "type": "inlineReview"}, {"oid": "e1bfb85dc784c37d1959dec26523a80ead7ac647", "url": "https://github.com/ConsenSys/teku/commit/e1bfb85dc784c37d1959dec26523a80ead7ac647", "message": "Merge remote-tracking branch 'upstream/master' into integrateForkChoiceTests", "committedDate": "2020-06-16T14:25:03Z", "type": "commit"}, {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "url": "https://github.com/ConsenSys/teku/commit/003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "message": "Clean up stale code", "committedDate": "2020-06-16T14:26:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440911569", "bodyText": "What I understand is that: we try to process the block, and if it's unsuccessful, we add it to the blockBuffer, and then at the next step we try to process it again. Should we not be failing (throwing an error) if block or attestation processing fails? I'm assuming we're not failing on purpose.", "author": "cemozerr", "createdAt": "2020-06-16T14:49:58Z", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {", "originalCommit": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxODk2Nw==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440918967", "bodyText": "It can be the case, that a block arrived earlier or its parent block has not arrived yet, etc.\nBasically, any block or attestation can arrive and that can be a part of a test.\nSo, block/attestation processing error can be expected.", "author": "ericsson49", "createdAt": "2020-06-16T14:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyNjA1MQ==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440926051", "bodyText": "I see. That makes sense \ud83d\udc4d. Should we throw an error if there are still blocks/attestations left in the buffers after the last step? I assume we should have processed all the given objects at some point.", "author": "cemozerr", "createdAt": "2020-06-16T15:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkzODY3MQ==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440938671", "bodyText": "It's tricky.\nNormally, a non-empty buffer indicates something was wrong, but if a block or an attestation is invalid (e.g. wrong signature), it will stay in the buffer forever.\nSome logic can be implemented to tell invalid msgs from early ones, however, it's related to how the spec is structured at the moment.\nAs there is some demand from 'formal method' guys for a more declarative spec, that can happen. At the moment, I prefer to ignore this - normally, if a message is rejected, than it typically should affect fork choice and head should be different.\nI probably could improve tests and insert checks whether a message should be processed successfully, rejected as invalid or delayed. But it will require the test format change.", "author": "ericsson49", "createdAt": "2020-06-16T15:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk0MzA4Mg==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440943082", "bodyText": "Do you have invalid blocks and attestations in the test files on purpose? If not, all the attestations and blocks in the buffers (even the too early ones) would need to be consumed at some point, and we could throw an error if they are not consumed by the end of the test.", "author": "cemozerr", "createdAt": "2020-06-16T15:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk0NDEwNw==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440944107", "bodyText": "I have invalid ones on purpose", "author": "ericsson49", "createdAt": "2020-06-16T15:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk0NjAxMA==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440946010", "bodyText": "Hmm, a good next step could be to include the number of invalid blocks and attestations to test, and check that the number of invalid ones we perceived matches after processing, but I think that could be done later on, and it's for the best to merge this in soon.", "author": "cemozerr", "createdAt": "2020-06-16T15:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyMDQyMw==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440920423", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n          \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"Block is missing from store :\" + root);", "author": "cemozerr", "createdAt": "2020-06-16T15:00:53Z", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");", "originalCommit": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyMTY5Ng==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440921696", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");\n          \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"Block should not have been in store :\" + root);", "author": "cemozerr", "createdAt": "2020-06-16T15:02:33Z", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n+                break;\n+              }\n+            case \"block_not_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");", "originalCommit": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa60b3815df3438522f320bbc1e6e657db1bb9db", "url": "https://github.com/ConsenSys/teku/commit/fa60b3815df3438522f320bbc1e6e657db1bb9db", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>", "committedDate": "2020-06-16T15:04:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyMjkzMA==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440922930", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertEquals(root, head, \"head\");\n          \n          \n            \n                            assertEquals(root, head, \"Head does not match expected head: \\n head: \" + head + \"\\n expectedHead: \" + root);", "author": "cemozerr", "createdAt": "2020-06-16T15:04:16Z", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n+                break;\n+              }\n+            case \"block_not_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");\n+                break;\n+              }\n+            case \"head\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+                Bytes32 head = forkChoiceStrategy.findHead(transaction);\n+                transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n+                assertEquals(root, head, \"head\");", "originalCommit": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f4e3f54ce8a7ddfcad083ffe39facf80e0688298", "url": "https://github.com/ConsenSys/teku/commit/f4e3f54ce8a7ddfcad083ffe39facf80e0688298", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>", "committedDate": "2020-06-16T15:04:23Z", "type": "commit"}, {"oid": "9183ebad83248c0b063cf7b870b0552cc17ac9a6", "url": "https://github.com/ConsenSys/teku/commit/9183ebad83248c0b063cf7b870b0552cc17ac9a6", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>", "committedDate": "2020-06-16T15:04:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyNDM0OA==", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440924348", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertEquals(expected, actual, \"justified_checkpoint_epoch\");\n          \n          \n            \n                            assertEquals(expected, actual, \"Justified checkpoint epoch does not match expected: \\n actual: \" + actual + \"\\n expected: \" + expected);", "author": "cemozerr", "createdAt": "2020-06-16T15:06:11Z", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n+                break;\n+              }\n+            case \"block_not_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");\n+                break;\n+              }\n+            case \"head\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+                Bytes32 head = forkChoiceStrategy.findHead(transaction);\n+                transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n+                assertEquals(root, head, \"head\");\n+                break;\n+              }\n+            case \"justified_checkpoint_epoch\":\n+              {\n+                UnsignedLong expected = UnsignedLong.valueOf((Integer) e.getValue());\n+                UnsignedLong actual = storageClient.getStore().getJustifiedCheckpoint().getEpoch();\n+                assertEquals(expected, actual, \"justified_checkpoint_epoch\");", "originalCommit": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24b554d8b560de3fb7100abcc193da841592fb1b", "url": "https://github.com/ConsenSys/teku/commit/24b554d8b560de3fb7100abcc193da841592fb1b", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>", "committedDate": "2020-06-16T15:06:48Z", "type": "commit"}, {"oid": "7951eae465f7a66324ed8887a6bbf11e5eaa3838", "url": "https://github.com/ConsenSys/teku/commit/7951eae465f7a66324ed8887a6bbf11e5eaa3838", "message": "fix spotless problems", "committedDate": "2020-06-16T15:13:02Z", "type": "commit"}]}