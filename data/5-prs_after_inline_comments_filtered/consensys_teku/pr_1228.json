{"pr_number": 1228, "pr_title": "Implement Eth1MinGenesisTimeBlockFinder", "pr_createdAt": "2020-02-26T00:46:21Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1228", "timeline": [{"oid": "061392c0279932768bc51cc872347b2c2f3940c3", "url": "https://github.com/ConsenSys/teku/commit/061392c0279932768bc51cc872347b2c2f3940c3", "message": "Implement & test Eth1MinGenesisTimeBlock", "committedDate": "2020-02-26T00:44:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNjQ3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384216477", "bodyText": "compare doesn't have to return 1, 0 or -1 just anything positive or negative so we need to either use a signum kind of function or an if to check for < 0 & > 0 rather than 1 and -1 specifically.", "author": "ajsutton", "createdAt": "2020-02-26T00:50:24Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:", "originalCommit": "061392c0279932768bc51cc872347b2c2f3940c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzMDE0OA==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384630148", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-26T16:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNjQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNzQ0NA==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384217444", "bodyText": "nit: just return exploreBlocksDownwards(block)", "author": "ajsutton", "createdAt": "2020-02-26T00:53:19Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;", "originalCommit": "061392c0279932768bc51cc872347b2c2f3940c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMTc5NQ==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384621795", "bodyText": "3 return statements just looked ugly so I did this, but I can change it.", "author": "cemozerr", "createdAt": "2020-02-26T16:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNzQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzNjYwNg==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384636606", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-26T17:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNzQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384241996", "bodyText": "What happens if this fails?", "author": "ajsutton", "createdAt": "2020-02-26T02:21:36Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;\n+            case 0:\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring downwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(previousBlock);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+            case 0:\n+              // If exploring upwards and block timestamp >= min genesis time,\n+              // then current block must be the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring upwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = exploreBlocksUpwards(block);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(", "originalCommit": "061392c0279932768bc51cc872347b2c2f3940c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMjIwMA==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384622200", "bodyText": "There is an exceptionally compose at the end of the whole findFirstValidBlockAndPublish() so it gets run again. There is a test for it.", "author": "cemozerr", "createdAt": "2020-02-26T16:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMjUwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384622501", "bodyText": "https://github.com/PegaSysEng/teku/pull/1228/files#diff-b00a71e2a2f564197b1d296f0075e6c4R194", "author": "cemozerr", "createdAt": "2020-02-26T16:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MDQ5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384640496", "bodyText": "Oh nvm, I misread what you wrote. I will make sure this is handled.", "author": "cemozerr", "createdAt": "2020-02-26T17:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzQzOA==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384243438", "bodyText": "Probably need to handle the case where we reach the ETH1 genesis block and are still after min genesis time.", "author": "ajsutton", "createdAt": "2020-02-26T02:26:56Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);", "originalCommit": "061392c0279932768bc51cc872347b2c2f3940c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMzgyMQ==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384623821", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-26T16:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzQzOA=="}], "type": "inlineReview"}, {"oid": "945cf8015a25717764d0631e2d23db14023c94bc", "url": "https://github.com/ConsenSys/teku/commit/945cf8015a25717764d0631e2d23db14023c94bc", "message": "Resolve comments", "committedDate": "2020-02-26T17:08:44Z", "type": "commit"}, {"oid": "7bfe18f34a7d08a069c96896020f03f08b8df06b", "url": "https://github.com/ConsenSys/teku/commit/7bfe18f34a7d08a069c96896020f03f08b8df06b", "message": "Handle when requesting a future block errors out", "committedDate": "2020-02-26T19:17:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODIyMw==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384718223", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        (err) -> firstValidBlockFuture.completeExceptionally(new RuntimeException(err)));\n          \n          \n            \n                        (err) -> firstValidBlockFuture.completeExceptionally(err));", "author": "ajsutton", "createdAt": "2020-02-26T19:36:53Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // find first valid block in history\n+                return findFirstValidBlockInHistory(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // subscribe to new block events and wait for the first\n+                // valid block\n+                return waitForFirstValidBlock();\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // explore blocks downwards\n+                return exploreBlocksDownwards(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // explore blocks upwards\n+                return exploreBlocksUpwards(block);\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    if (previousBlock.getNumber().equals(BigInteger.ZERO)) {\n+      throw new RuntimeException(\n+          \"Reached Eth1Genesis before reaching a valid min Eth2 genesis time, \"\n+              + \"MIN_GENESIS_TIME constant must be wrong\");\n+    }\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison > 0) {\n+            // If exploring downwards and block timestamp > min genesis time,\n+            // then block must still be downwards.\n+            return exploreBlocksDownwards(block);\n+          } else if (comparison < 0) {\n+            // If exploring downwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return SafeFuture.completedFuture(previousBlock);\n+          } else {\n+            return SafeFuture.completedFuture(block);\n+          }\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison >= 0) {\n+            // If exploring upwards and block timestamp >= min genesis time,\n+            // then current block must be the first valid block.\n+            return SafeFuture.completedFuture(block);\n+          } else {\n+            // If exploring upwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return exploreBlocksUpwards(block);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(\n+            block -> {\n+              if (compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                firstValidBlockFuture.complete(block);\n+                latestBlockDisposable.dispose();\n+              }\n+            })\n+        .finish(\n+            () -> {},\n+            (err) -> firstValidBlockFuture.completeExceptionally(new RuntimeException(err)));", "originalCommit": "7bfe18f34a7d08a069c96896020f03f08b8df06b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0NDkzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384744939", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-26T20:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODIyMw=="}], "type": "inlineReview"}, {"oid": "eaa867db5cf41e33c40c29fbba060658a7cb3864", "url": "https://github.com/ConsenSys/teku/commit/eaa867db5cf41e33c40c29fbba060658a7cb3864", "message": "Add test for error and recovery of blocks in the future", "committedDate": "2020-02-26T20:24:41Z", "type": "commit"}, {"oid": "eba746b67dd52905c92c33cbc233b16a7bf4e377", "url": "https://github.com/ConsenSys/teku/commit/eba746b67dd52905c92c33cbc233b16a7bf4e377", "message": "Merge branch 'master' into triggerGenesisAccordingToTime", "committedDate": "2020-02-26T20:31:30Z", "type": "commit"}]}