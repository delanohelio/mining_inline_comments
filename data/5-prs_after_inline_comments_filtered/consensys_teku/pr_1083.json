{"pr_number": 1083, "pr_title": "Implement Eth1DataManager", "pr_createdAt": "2020-01-09T19:11:25Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1083", "timeline": [{"oid": "3d92ae0bac0b304ab6a7d26f24d34b2234c34d57", "url": "https://github.com/ConsenSys/teku/commit/3d92ae0bac0b304ab6a7d26f24d34b2234c34d57", "message": "Implement Eth1DataManager", "committedDate": "2020-01-09T19:07:22Z", "type": "commit"}, {"oid": "75dd4100238881faf5246d1f9a85fad8593abdc6", "url": "https://github.com/ConsenSys/teku/commit/75dd4100238881faf5246d1f9a85fad8593abdc6", "message": "Add magic number to Constants", "committedDate": "2020-01-09T19:14:18Z", "type": "commit"}, {"oid": "4ceb20e540a6ef816a520d67ecbd0f95974beb46", "url": "https://github.com/ConsenSys/teku/commit/4ceb20e540a6ef816a520d67ecbd0f95974beb46", "message": "Remove printlns", "committedDate": "2020-01-09T19:17:29Z", "type": "commit"}, {"oid": "8180a116ea0c2aa0e9f406c58d2fbe121ef81952", "url": "https://github.com/ConsenSys/teku/commit/8180a116ea0c2aa0e9f406c58d2fbe121ef81952", "message": "Run spotless", "committedDate": "2020-01-09T20:19:04Z", "type": "commit"}, {"oid": "014ac57d9a3b1a89167a3d1db1ad45d016355ba5", "url": "https://github.com/ConsenSys/teku/commit/014ac57d9a3b1a89167a3d1db1ad45d016355ba5", "message": "Fix VC related bug", "committedDate": "2020-01-09T21:26:46Z", "type": "commit"}, {"oid": "cac772b278845ad6177eb1b2bd69368f9ecac9dd", "url": "https://github.com/ConsenSys/teku/commit/cac772b278845ad6177eb1b2bd69368f9ecac9dd", "message": "Add default vote", "committedDate": "2020-01-09T22:17:49Z", "type": "commit"}, {"oid": "be90c306678c60521b0c39ae641273762f98b70a", "url": "https://github.com/ConsenSys/teku/commit/be90c306678c60521b0c39ae641273762f98b70a", "message": "Add second comparison test", "committedDate": "2020-01-10T14:31:23Z", "type": "commit"}, {"oid": "f9079bc457c49a6e429a0e1d089284aa189d492b", "url": "https://github.com/ConsenSys/teku/commit/f9079bc457c49a6e429a0e1d089284aa189d492b", "message": "Run spotless", "committedDate": "2020-01-10T14:36:34Z", "type": "commit"}, {"oid": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "url": "https://github.com/ConsenSys/teku/commit/ebdec8d13dcc2173e4af68d7fb418b3509658a05", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-10T14:42:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365295538", "bodyText": "I think we could get this data more efficiently by just polling for blocks at a certain height at regular time intervals, rather than using the new block event as a signal to query for blocks.\nI'm thinking we could do something like:\n\nOn startup:\n\nQuery the chain for the current block height\nCalculate the block number where we want to start caching using current height and SECONDS_PER_ETH1_BLOCK and other relevant constants\nPull blocks by number until our cache covers the time range we want\n\n\nPeriodically (every SECONDS_PER_ETH1_BLOCK?) query for new blocks to add to the cache", "author": "mbaxter", "createdAt": "2020-01-10T15:41:57Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwMjI0NQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365402245", "bodyText": "I agree that we probably should have a more aggressive approach on startup, to make sure we fill the eth1 blocks cache since we might be proposing a block soon (although voting without having seen too many eth1Blocks is not a significant issue for the validator): https://pegasys1.atlassian.net/browse/BC-21.  But for periodic updates, I think subscribing to each block is more straightforward.", "author": "cemozerr", "createdAt": "2020-01-10T19:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzMDY3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365430673", "bodyText": "We can execute periodic logic to pull blocks in onSlot for example, which is pretty straightforward.  It's just that we're subscribing to new blocks and putting load on the eth1 node without really needing to.  We really just need a block number to get us started, and then we can pull blocks sequentially.", "author": "mbaxter", "createdAt": "2020-01-10T21:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzMDkyNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365430927", "bodyText": "Also - is BC-21 the link you meant to post?", "author": "mbaxter", "createdAt": "2020-01-10T21:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMjc5NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365332794", "bodyText": "We should be careful about blocking with join - can we just wait on these futures and then post the event when they resolve?", "author": "mbaxter", "createdAt": "2020-01-10T16:57:15Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(\n+                block -> {\n+                  BigInteger cacheBlockNumber =\n+                      block\n+                          .getBlock()\n+                          .getNumber()\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                  EthBlock.Block eth1Block =\n+                      web3j\n+                          .ethGetBlockByNumber(\n+                              DefaultBlockParameter.valueOf(cacheBlockNumber), false)\n+                          .send()\n+                          .getBlock();\n+\n+                  Bytes32 eth1BlockHash = Bytes32.fromHexString(eth1Block.getHash());\n+                  UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(eth1Block.getTimestamp());\n+                  UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(eth1Block.getNumber());\n+                  UnsignedLong count =\n+                      depositContractListener.getDepositCount(cacheBlockNumber).join();\n+                  Bytes32 root = depositContractListener.getDepositRoot(cacheBlockNumber).join();", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQxODU4OQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365418589", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMjc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMzA2Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365333067", "bodyText": "Suggest using sendAsync here to get a future back", "author": "mbaxter", "createdAt": "2020-01-10T16:57:50Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(\n+                block -> {\n+                  BigInteger cacheBlockNumber =\n+                      block\n+                          .getBlock()\n+                          .getNumber()\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                  EthBlock.Block eth1Block =\n+                      web3j\n+                          .ethGetBlockByNumber(\n+                              DefaultBlockParameter.valueOf(cacheBlockNumber), false)\n+                          .send()", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQxODU2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365418561", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMzA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzI5OQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365337299", "bodyText": "Might be a good idea to have a specific exception for this - maybe Eth1RequestFailed", "author": "mbaxter", "createdAt": "2020-01-10T17:07:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java", "diffHunk": "@@ -51,11 +64,56 @@ public DepositContractListener(EventBus eventBus, DepositContract contract) {\n                 });\n   }\n \n+  @SuppressWarnings(\"rawtypes\")\n+  public SafeFuture<Bytes32> getDepositRoot(BigInteger blockHeight) {\n+    String encodedFunction = contract.get_deposit_root().encodeFunctionCall();\n+    return callFunctionAtBlockHeight(encodedFunction, blockHeight)\n+        .thenApply(\n+            ethCall -> {\n+              if (ethCall.hasError()) {\n+                throw new UnsupportedOperationException(", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0Mjk4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365442986", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T21:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzg5MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365337890", "bodyText": "How about just Eth1BlockEvent?", "author": "mbaxter", "createdAt": "2020-01-10T17:08:37Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/event/CacheEth1BlockEvent.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.event;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class CacheEth1BlockEvent {\n+\n+  private final UnsignedLong blockNumber;\n+  private final Bytes32 blockHash;\n+  private final UnsignedLong blockTimestamp;\n+  private final Bytes32 depositRoot;\n+  private final UnsignedLong depositCount;\n+\n+  public CacheEth1BlockEvent(", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQyMDgzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365420839", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MDI3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365340273", "bodyText": "I don't think we want to weaken the safe follow distance (ETH1_FOLLOW_DISTANCE) too much.  What about changing this parameter to something like ETH1_CACHE_BUFFER - so that we'll start caching blocks some small distance ahead of ETH1_FOLLOW_DISTANCE.", "author": "mbaxter", "createdAt": "2020-01-10T17:14:02Z", "path": "util/src/main/java/tech/pegasys/artemis/util/config/Constants.java", "diffHunk": "@@ -100,6 +101,7 @@\n   public static double TIME_TICKER_REFRESH_RATE = 2; // per sec\n   public static UnsignedLong GENESIS_START_DELAY = UnsignedLong.valueOf(5);\n   public static int COMMITTEE_INDEX_SUBSCRIPTION_LENGTH = 2; // in epochs\n+  public static int ETH1_CACHE_FOLLOW_DISTANCE = 100; // in blocks", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3MjA3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365372074", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T18:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MDI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NDI4OQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365354289", "bodyText": "I know this is written to match the spec, but I think we should try to implement this more efficiently.  There are a few O(n^2) loops here.  Suggest doing something like:\n    NavigableSet<Eth1Data> votesToConsider = getVotesToConsider();\n    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n    int index = 0;\n    for (Eth1Data eth1Vote : state.getEth1_data_votes()) {\n      if (!votesToConsider.contains(eth1Vote)) {\n        continue;\n      }\n      Eth1Vote vote = votes.computeIfAbsent(key -> new Eth1Vote(eth1Vote));\n      vote.incrementVotes();\n      vote.setIndex(index);\n      index++;\n    }\n\n    return validVotes.values()\n      .stream()\n      .max(Eth1Vote::compare)\n      .orElse(votesToConsider.last());", "author": "mbaxter", "createdAt": "2020-01-10T17:49:26Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(CacheEth1BlockEvent cacheEth1BlockEvent) {\n+    return new Eth1Data(\n+        cacheEth1BlockEvent.getDepositRoot(),\n+        cacheEth1BlockEvent.getDepositCount(),\n+        cacheEth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(CacheEth1BlockEvent cacheEth1BlockEvent) {\n+    eth1ChainCache.put(cacheEth1BlockEvent.getBlockTimestamp(), getEth1Data(cacheEth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    List<Eth1Data> validVotes = new ArrayList<>(state.getEth1_data_votes());\n+    validVotes.removeIf(v -> !votesToConsider.containsValue(v));", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5NTE2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365395161", "bodyText": "Done. It made the code less readable but I agree that efficiency might be important here, especially since this has to be done during block production.", "author": "cemozerr", "createdAt": "2020-01-10T19:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODA1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365358056", "bodyText": "If we're creating a block, the store must be initialized right?  Do we need this check?  Or should we just return early and log a warning if eth1DataManager is null?", "author": "mbaxter", "createdAt": "2020-01-10T17:59:11Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/ValidatorCoordinator.java", "diffHunk": "@@ -331,9 +319,25 @@ private void createBlockIfNecessary(\n \n       final Signer signer = getSigner(proposer);\n       final Bytes32 parentRoot = previousBlock.signing_root(\"signature\");\n+\n+      Eth1Data eth1Data;\n+      if (eth1DataManager == null) {", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzNzY0Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365437643", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-10T21:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODcxMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365358713", "bodyText": "Might be a good idea to set distinct values for the various constants to guard against bugs where we use the wrong constant.", "author": "mbaxter", "createdAt": "2020-01-10T18:01:00Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = new EventBus();\n+  private final UnsignedLong genesisTime = UnsignedLong.ZERO;\n+\n+  static {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(10);\n+    Constants.ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(100);\n+    Constants.SLOTS_PER_ETH1_VOTING_PERIOD = 10;\n+    Constants.SECONDS_PER_SLOT = 10;", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQyNzY4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365427685", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1OTgzMg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365359832", "bodyText": "I thought the later index should win - so we take the most recent vote in case of a tie.", "author": "mbaxter", "createdAt": "2020-01-10T18:03:51Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = new EventBus();\n+  private final UnsignedLong genesisTime = UnsignedLong.ZERO;\n+\n+  static {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(10);\n+    Constants.ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(100);\n+    Constants.SLOTS_PER_ETH1_VOTING_PERIOD = 10;\n+    Constants.SECONDS_PER_SLOT = 10;\n+  }\n+\n+  // RANGE_CONSTANT = 1000\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private Eth1DataManager eth1DataManager;\n+\n+  @BeforeEach\n+  void setUp() {\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getGenesis_time()).thenReturn(genesisTime);\n+    eth1DataManager = new Eth1DataManager(beaconState, eventBus);\n+  }\n+\n+  @Test\n+  void majorityVoteWins() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data2);\n+  }\n+\n+  @Test\n+  void smallestDistanceWinsIfNoMajority() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data1);", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzOTE4OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365439188", "bodyText": "yeah, the spec says -valid_votes.index(v), the \"-\" is the key there :D", "author": "cemozerr", "createdAt": "2020-01-10T21:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1OTgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjMwMg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365362302", "bodyText": "Suggest checking the lower bound here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        currentTime.minus(RANGE_CONSTANT),\n          \n          \n            \n                        currentTime.minus(RANGE_CONSTANT.times(UnsignedLong.valueOf(2))),", "author": "mbaxter", "createdAt": "2020-01-10T18:10:02Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = new EventBus();\n+  private final UnsignedLong genesisTime = UnsignedLong.ZERO;\n+\n+  static {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(10);\n+    Constants.ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(100);\n+    Constants.SLOTS_PER_ETH1_VOTING_PERIOD = 10;\n+    Constants.SECONDS_PER_SLOT = 10;\n+  }\n+\n+  // RANGE_CONSTANT = 1000\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private Eth1DataManager eth1DataManager;\n+\n+  @BeforeEach\n+  void setUp() {\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getGenesis_time()).thenReturn(genesisTime);\n+    eth1DataManager = new Eth1DataManager(beaconState, eventBus);\n+  }\n+\n+  @Test\n+  void majorityVoteWins() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data2);\n+  }\n+\n+  @Test\n+  void smallestDistanceWinsIfNoMajority() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data1);\n+  }\n+\n+  @Test\n+  void oldVoteDoesNotCount() {\n+    UnsignedLong slot = UnsignedLong.valueOf(300);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQyNTY1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365425656", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjcxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365362715", "bodyText": "Organizationally, feels like these utilities should live in the tech.pegasys.artemis.services.powchain package.", "author": "mbaxter", "createdAt": "2020-01-10T18:11:14Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5ODY1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365398656", "bodyText": "I agree, but that's a fairly big change that I don't want to incorporate into this PR.", "author": "cemozerr", "createdAt": "2020-01-10T19:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2Mjk0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365362946", "bodyText": "Should we cut this altogether and require callers to supply eth1data?", "author": "mbaxter", "createdAt": "2020-01-10T18:11:54Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java", "diffHunk": "@@ -59,15 +60,38 @@ public BeaconBlock createNewBlock(\n       final SSZList<Deposit> deposits)\n       throws StateTransitionException {\n     final UnsignedLong newEpoch = compute_epoch_at_slot(newSlot);\n+    return createNewBlock(\n+        signer,\n+        newSlot,\n+        previousState,\n+        parentBlockSigningRoot,\n+        StartupUtil.get_eth1_data_stub(previousState, newEpoch),", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5NzEzMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365397133", "bodyText": "Fair point.", "author": "cemozerr", "createdAt": "2020-01-10T19:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2Mjk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5NzgxNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365397814", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T19:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2Mjk0Ng=="}], "type": "inlineReview"}, {"oid": "b9600daa6b65178cfc63465da530941790a8d144", "url": "https://github.com/ConsenSys/teku/commit/b9600daa6b65178cfc63465da530941790a8d144", "message": "Change constant name", "committedDate": "2020-01-10T19:32:23Z", "type": "commit"}, {"oid": "f85c569e4483cf417e310c9e7308eb073c4b0203", "url": "https://github.com/ConsenSys/teku/commit/f85c569e4483cf417e310c9e7308eb073c4b0203", "message": "Optimize get_eth1_vote", "committedDate": "2020-01-10T19:32:37Z", "type": "commit"}, {"oid": "92d6cc5052a9f8103695fb4b8c8b04c3c31e9826", "url": "https://github.com/ConsenSys/teku/commit/92d6cc5052a9f8103695fb4b8c8b04c3c31e9826", "message": "Refactor async code", "committedDate": "2020-01-10T20:32:15Z", "type": "commit"}, {"oid": "fc97a541a150e798fed650af1c2826e0d90dc9a0", "url": "https://github.com/ConsenSys/teku/commit/fc97a541a150e798fed650af1c2826e0d90dc9a0", "message": "Change event name", "committedDate": "2020-01-10T20:34:58Z", "type": "commit"}, {"oid": "359233c5db63b1697e29f7111171303b442d9b51", "url": "https://github.com/ConsenSys/teku/commit/359233c5db63b1697e29f7111171303b442d9b51", "message": "Use .finish() instead of .thenRun()", "committedDate": "2020-01-10T20:48:02Z", "type": "commit"}, {"oid": "79d56a4a40c2570fddd05d5514e445119017ac5b", "url": "https://github.com/ConsenSys/teku/commit/79d56a4a40c2570fddd05d5514e445119017ac5b", "message": "Check the lower bound", "committedDate": "2020-01-10T20:53:11Z", "type": "commit"}, {"oid": "d8afe461d7ed092545065e8a27bbe5647d69ad94", "url": "https://github.com/ConsenSys/teku/commit/d8afe461d7ed092545065e8a27bbe5647d69ad94", "message": "Use distinct values for constants", "committedDate": "2020-01-10T20:57:08Z", "type": "commit"}, {"oid": "c75d07a2baf60ff1474cf9ef7dd69f53c4894f94", "url": "https://github.com/ConsenSys/teku/commit/c75d07a2baf60ff1474cf9ef7dd69f53c4894f94", "message": "Remove unnecessary null check", "committedDate": "2020-01-10T21:32:39Z", "type": "commit"}, {"oid": "7cfe1e793cbdcfbdaa8503797a63a976a5f888c0", "url": "https://github.com/ConsenSys/teku/commit/7cfe1e793cbdcfbdaa8503797a63a976a5f888c0", "message": "Add custom exceptions for rpc request failures", "committedDate": "2020-01-10T21:46:45Z", "type": "commit"}, {"oid": "fbb38d8e868b1658c27c0c6b9c2c6a430885c31d", "url": "https://github.com/ConsenSys/teku/commit/fbb38d8e868b1658c27c0c6b9c2c6a430885c31d", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-10T21:47:09Z", "type": "commit"}, {"oid": "d509aa772a8d394b9e4d9235371b73c6f7322215", "url": "https://github.com/ConsenSys/teku/commit/d509aa772a8d394b9e4d9235371b73c6f7322215", "message": "Fix bug", "committedDate": "2020-01-10T22:18:16Z", "type": "commit"}, {"oid": "964dae9a9c4e54b8116ee61948e71f604f062de1", "url": "https://github.com/ConsenSys/teku/commit/964dae9a9c4e54b8116ee61948e71f604f062de1", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-13T15:22:33Z", "type": "commit"}, {"oid": "247e77560c6ab125af4dc187639964faaecfa19f", "url": "https://github.com/ConsenSys/teku/commit/247e77560c6ab125af4dc187639964faaecfa19f", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-15T01:22:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMDE0MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366930141", "bodyText": "What if we just reuse the previous eth1data instead of making something up?:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StartupUtil.get_eth1_data_stub(previousState, newEpoch),\n          \n          \n            \n                    previousState.getEth1_data(),", "author": "mbaxter", "createdAt": "2020-01-15T15:13:40Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java", "diffHunk": "@@ -92,11 +95,13 @@ public BeaconBlock createEmptyBlock(\n       final BeaconState previousState,\n       final Bytes32 parentBlockSigningRoot)\n       throws StateTransitionException {\n+    final UnsignedLong newEpoch = compute_epoch_at_slot(newSlot);\n     return createNewBlock(\n         signer,\n         newSlot,\n         previousState,\n         parentBlockSigningRoot,\n+        StartupUtil.get_eth1_data_stub(previousState, newEpoch),", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MDEyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366980124", "bodyText": "The get_eth1_data_stub method was built for interop, to easily mock an eth1 data stub, we could totally get eth1 data from the previous state. However, I don't think it would add any value to change it, and it might introduce problems if we were to try interop testing again.", "author": "cemozerr", "createdAt": "2020-01-15T16:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMDE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMjkyNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366932927", "bodyText": "I think we want to subtract the follow distance and then add the eth1_cache_buffer:  cacheBlockNumber = Math.min(latestBlockNumber, latestBlockNumber - ETH1_FOLLOW_DISTANCE + ETH1_CACHE_BUFFER)\nEdit:  I was thinking that ETH1_CACHE_BUFFER was the difference from ETH1_FOLLOW_DISTANCE, but I see it's already being calculated relative to the follow distance.  Suggest either renaming to ETH1_CACHE_FOLLOW_DISTANCE or keeping the current name and setting it to just the difference from the ETH1_FOLLOW_DISTANCE (10).", "author": "mbaxter", "createdAt": "2020-01-15T15:18:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(\n+                block -> {\n+                  BigInteger cacheBlockNumber =\n+                      block\n+                          .getBlock()\n+                          .getNumber()\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzODk5Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366938992", "bodyText": "It also seems that cacheBlockNumber is basically an estimate since we're now collecting eth1data based on block timestamps.  So I think we actually want to define the leading edge of the buffer based on timestamp with something like: cacheStartTimestamp = now - ETH1_CACHE_BUFFER * SECONDS_PER_ETH1_BLOCK.", "author": "mbaxter", "createdAt": "2020-01-15T15:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMjkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0NzY3MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366947670", "bodyText": "If we've got the root cause, we should keep it rather than converting it to a string:\n  public Eth1RequestException(Throwable cause) {\n    super(cause);\n  }\n\nThis will give us more context when the exception gets logged.", "author": "mbaxter", "createdAt": "2020-01-15T15:42:01Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.exception;\n+\n+public class Eth1RequestException extends RuntimeException {\n+  public Eth1RequestException(String err) {\n+    super(err);\n+  }\n+\n+  public Eth1RequestException(RuntimeException e) {\n+    super(e.toString());\n+  }", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MDMzNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368170334", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T22:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0NzY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0Nzk3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366947972", "bodyText": "nice :D", "author": "mbaxter", "createdAt": "2020-01-15T15:42:29Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/exception/DepositCountRequestException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.exception;\n+\n+public class DepositCountRequestException extends Eth1RequestException {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MDg2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366980861", "bodyText": "haha thank you!!", "author": "cemozerr", "createdAt": "2020-01-15T16:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0Nzk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0OTk3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366949974", "bodyText": "(optional) Naming nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n          \n          \n            \n              static Eth1Data createEth1Data(Eth1BlockEvent eth1BlockEvent) {", "author": "mbaxter", "createdAt": "2020-01-15T15:45:45Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MDY4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368170682", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T22:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0OTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MTI1NQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366951255", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n          \n          \n            \n              private final NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();", "author": "mbaxter", "createdAt": "2020-01-15T15:47:46Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MDkxMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368170910", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T23:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzAyOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366953028", "bodyText": "You can just keep using else if's rather than adding the extra nesting in this else block.", "author": "mbaxter", "createdAt": "2020-01-15T15:50:41Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();\n+                newVote.setIndex(finalI);\n+                return newVote;\n+              });\n+      vote.incrementVotes();\n+      i++;\n+    }\n+\n+    Eth1Data defaultVote =\n+        !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();\n+\n+    Optional<Eth1Data> vote =\n+        validVotes.entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey);\n+\n+    return vote.orElse(defaultVote);\n+  }\n+\n+  public static class Eth1Vote implements Comparable<Eth1Vote> {\n+\n+    private int vote = 0;\n+    private int index = -1;\n+\n+    public void incrementVotes() {\n+      vote++;\n+    }\n+\n+    public void setIndex(int i) {\n+      index = i;\n+    }\n+\n+    @Override\n+    public int compareTo(Eth1Vote eth1Vote) {\n+      if (this.vote > eth1Vote.vote) {\n+        return 1;\n+      } else if (this.vote < eth1Vote.vote) {\n+        return -1;\n+      } else {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MTU3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368171577", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T23:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzM5NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366953394", "bodyText": "Internal classes usually go at the bottom of the class.", "author": "mbaxter", "createdAt": "2020-01-15T15:51:15Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();\n+                newVote.setIndex(finalI);\n+                return newVote;\n+              });\n+      vote.incrementVotes();\n+      i++;\n+    }\n+\n+    Eth1Data defaultVote =\n+        !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();\n+\n+    Optional<Eth1Data> vote =\n+        validVotes.entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey);\n+\n+    return vote.orElse(defaultVote);\n+  }\n+\n+  public static class Eth1Vote implements Comparable<Eth1Vote> {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MTY3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368171673", "bodyText": "it now has its own class.", "author": "cemozerr", "createdAt": "2020-01-17T23:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NTE1Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366955152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  int finalI = i;\n          \n          \n            \n                  final int currentIndex = i;", "author": "mbaxter", "createdAt": "2020-01-15T15:54:07Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MTg4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368171886", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T23:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NjAyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366956024", "bodyText": "(nit) You could pass the index into the constructor and make the index variable final.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Eth1Vote newVote = new Eth1Vote();\n          \n          \n            \n                            Eth1Vote newVote = new Eth1Vote(currentIndex);", "author": "mbaxter", "createdAt": "2020-01-15T15:55:31Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDQxMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369690410", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-22T17:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NjAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NzQ1MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366957450", "bodyText": "(nit) - could slightly simplify this with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();\n          \n          \n            \n                    votesToConsider.isEmpty() ? state.getEth1_data() : votesToConsider.lastEntry().getValue();", "author": "mbaxter", "createdAt": "2020-01-15T15:57:48Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();\n+                newVote.setIndex(finalI);\n+                return newVote;\n+              });\n+      vote.incrementVotes();\n+      i++;\n+    }\n+\n+    Eth1Data defaultVote =\n+        !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDk4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369690982", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-22T17:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MjIyMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366962220", "bodyText": "Nice tests!  Suggest adding a few more to check that the pruning functionality works, and to test what happens when the state contains votes that the manager doesn't have.", "author": "mbaxter", "createdAt": "2020-01-15T16:05:25Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIxNzM0MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371217341", "bodyText": "Done!", "author": "cemozerr", "createdAt": "2020-01-27T12:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2OTE4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366969186", "bodyText": "Probably worth adding a test or two for this class.", "author": "mbaxter", "createdAt": "2020-01-15T16:17:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aee7ddb31d023da565f0bb03b483e02de2234c75", "url": "https://github.com/ConsenSys/teku/commit/aee7ddb31d023da565f0bb03b483e02de2234c75", "message": "Implement cache range independent of beacon state", "committedDate": "2020-01-17T22:44:23Z", "type": "commit"}, {"oid": "1dc34a5ebb13226a99b8e9c2319371a5b473b213", "url": "https://github.com/ConsenSys/teku/commit/1dc34a5ebb13226a99b8e9c2319371a5b473b213", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-17T22:44:48Z", "type": "commit"}, {"oid": "f420b2451b6a28621225b9351ee0d2721ce2b8ac", "url": "https://github.com/ConsenSys/teku/commit/f420b2451b6a28621225b9351ee0d2721ce2b8ac", "message": "Delete Eth1DataResponse", "committedDate": "2020-01-17T22:50:43Z", "type": "commit"}, {"oid": "169f3610cbbef8b146ec6f436014447e4910ab6a", "url": "https://github.com/ConsenSys/teku/commit/169f3610cbbef8b146ec6f436014447e4910ab6a", "message": "Delete Eth1DataRequest", "committedDate": "2020-01-17T22:51:08Z", "type": "commit"}, {"oid": "74bc03ac5f7e9a8350f58653b7eadd264e5dd730", "url": "https://github.com/ConsenSys/teku/commit/74bc03ac5f7e9a8350f58653b7eadd264e5dd730", "message": "Keep root cause of exception", "committedDate": "2020-01-17T22:58:02Z", "type": "commit"}, {"oid": "45ec394ca175953f50606abf2e65e997d98752f2", "url": "https://github.com/ConsenSys/teku/commit/45ec394ca175953f50606abf2e65e997d98752f2", "message": "Change function name", "committedDate": "2020-01-17T22:59:10Z", "type": "commit"}, {"oid": "55e94f8daedbd2eece38830ad2d6b9d0f64cbdd3", "url": "https://github.com/ConsenSys/teku/commit/55e94f8daedbd2eece38830ad2d6b9d0f64cbdd3", "message": "Make cache object final", "committedDate": "2020-01-17T23:00:01Z", "type": "commit"}, {"oid": "67127b266841cfa639a2138b744fd227e2f114f8", "url": "https://github.com/ConsenSys/teku/commit/67127b266841cfa639a2138b744fd227e2f114f8", "message": "Refactor nesting if statement", "committedDate": "2020-01-17T23:03:01Z", "type": "commit"}, {"oid": "5c485718197db71ad3941f35bb824a271bb310b2", "url": "https://github.com/ConsenSys/teku/commit/5c485718197db71ad3941f35bb824a271bb310b2", "message": "Change variable name", "committedDate": "2020-01-17T23:04:43Z", "type": "commit"}, {"oid": "397bcc3f4022a4a86bbb288d2f491866bc0565d5", "url": "https://github.com/ConsenSys/teku/commit/397bcc3f4022a4a86bbb288d2f491866bc0565d5", "message": "Fix bug", "committedDate": "2020-01-17T23:06:11Z", "type": "commit"}, {"oid": "d76024dedb1a61447e4b4806e56fda273b5b182b", "url": "https://github.com/ConsenSys/teku/commit/d76024dedb1a61447e4b4806e56fda273b5b182b", "message": "Run spotless", "committedDate": "2020-01-17T23:07:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODczOTkyOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368739928", "bodyText": "delete line.", "author": "cemozerr", "createdAt": "2020-01-20T22:03:56Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTkyNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368741927", "bodyText": "change this to the argument", "author": "cemozerr", "createdAt": "2020-01-20T22:13:10Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actual_time_diff = latestBlockTimestamp.minus(blockTimestamp);\n+              return blockNumberDiff.dividedBy(actual_time_diff);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockNumberFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture) {\n+    return SafeFuture.allOf(latestBlockNumberFuture, blockNumberDiffFuture)\n+        .thenCompose(\n+            done -> {\n+              UnsignedLong latestBlockNumber = latestBlockNumberFuture.getNow(null);\n+              checkNotNull(latestBlockNumber);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+\n+              return getEth1BlockFuture(latestBlockNumber.minus(blockNumberDiff));\n+            });\n+  }\n+\n+  private static boolean isTimestampInRange(UnsignedLong timestamp) {\n+    return timestamp.compareTo(getCacheRangeLowerBound()) >= 0\n+        && timestamp.compareTo(getCacheRangeUpperBound()) <= 0;\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockTimestampFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(\n+        ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getTimestamp()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getNumber()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberDiffWithMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> secondsPerEth1BlockFuture,\n+      UnsignedLong rcrAverage) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, secondsPerEth1BlockFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong secondsPerEth1Block = secondsPerEth1BlockFuture.getNow(null);\n+              checkNotNull(secondsPerEth1Block);\n+\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              if (latestBlockTimestamp.compareTo(rcrAverage) < 0) {\n+                throw new RuntimeException(\n+                    \"Latest block timestamp is less than the cache mid-range\");\n+              }\n+              UnsignedLong timeDiff = latestBlockTimestamp.minus(rcrAverage);\n+              return timeDiff.dividedBy(secondsPerEth1Block);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(UnsignedLong blockNumber) {\n+    DefaultBlockParameter blockParameter =\n+        DefaultBlockParameter.valueOf(blockNumber.bigIntegerValue());\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(DefaultBlockParameter blockParameter) {\n+    return SafeFuture.of(web3j.ethGetBlockByNumber(blockParameter, false).sendAsync());\n+  }\n+\n+  private SafeFuture<EthBlock> getLatestEth1BlockFuture() {\n+    DefaultBlockParameter blockParameter = DefaultBlockParameterName.LATEST;\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<Void> postCacheEth1BlockEvent(UnsignedLong blockNumber, EthBlock.Block block) {\n+    SafeFuture<UnsignedLong> countFuture =\n+        SafeFuture.of(depositContractListener.getDepositCount(blockNumber));\n+    SafeFuture<Bytes32> rootFuture =\n+        SafeFuture.of(depositContractListener.getDepositRoot(blockNumber));\n+\n+    return SafeFuture.allOf(countFuture, rootFuture)\n+        .thenRun(\n+            () -> {\n+              Bytes32 root = rootFuture.getNow(null);\n+              checkNotNull(root);\n+\n+              UnsignedLong count = countFuture.getNow(null);\n+              checkNotNull(count);\n+\n+              Bytes32 eth1BlockHash = Bytes32.fromHexString(block.getHash());\n+              UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(block.getNumber());\n+\n+              eventBus.post(\n+                  new CacheEth1BlockEvent(\n+                      eth1BlockNumber, eth1BlockHash, eth1BlockTimestamp, root, count));\n+            });\n+  }\n+\n+  public static UnsignedLong getCacheRangeLowerBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(UnsignedLong.valueOf(SLOTS_PER_ETH1_VOTING_PERIOD * SECONDS_PER_SLOT))\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK).times(UnsignedLong.valueOf(2)));\n+  }\n+\n+  public static UnsignedLong getCacheRangeUpperBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK))\n+        .plus(ETH1_REQUEST_BUFFER);\n+  }\n+\n+  public static boolean hasBeenApproximately(UnsignedLong seconds, Date date) {\n+    return UnsignedLong.valueOf(date.getTime())\n+        .mod(SECONDS_PER_ETH1_BLOCK)", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0MDkwNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365640907", "bodyText": "This should just be super(e) so we don't loose the original stack trace.", "author": "ajsutton", "createdAt": "2020-01-13T03:52:02Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.exception;\n+\n+public class Eth1RequestException extends RuntimeException {\n+  public Eth1RequestException(String err) {\n+    super(err);\n+  }\n+\n+  public Eth1RequestException(RuntimeException e) {\n+    super(e.toString());", "originalCommit": "d509aa772a8d394b9e4d9235371b73c6f7322215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTAxNg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368375016", "bodyText": "I'd probably use a thenApply here which does the ethCall.hasError() check and throws an exception. That way this method a nice intuitive SafeFuture which completes normally when there's an error and we can avoid some duplication.\nI'd probably just have a common JsonRpcException or Eth1NodeException rather than the two specific exceptions for deposit count and deposit root.", "author": "ajsutton", "createdAt": "2020-01-20T05:30:03Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java", "diffHunk": "@@ -51,11 +65,56 @@ public DepositContractListener(EventBus eventBus, DepositContract contract) {\n                 });\n   }\n \n+  @SuppressWarnings(\"rawtypes\")\n+  public SafeFuture<Bytes32> getDepositRoot(UnsignedLong blockHeight) {\n+    String encodedFunction = contract.get_deposit_root().encodeFunctionCall();\n+    return callFunctionAtBlockNumber(encodedFunction, blockHeight)\n+        .thenApply(\n+            ethCall -> {\n+              if (ethCall.hasError()) {\n+                throw new DepositRootRequestException(\n+                    \"Eth1 call get_deposit_root() has failed:\" + ethCall.getError().getMessage());\n+              }\n+              String value = ethCall.getValue();\n+              List<Type> list = contract.get_deposit_root().decodeFunctionResponse(value);\n+              return Bytes32.wrap((byte[]) list.get(0).getValue());\n+            });\n+  }\n+\n+  @SuppressWarnings(\"rawtypes\")\n+  public SafeFuture<UnsignedLong> getDepositCount(UnsignedLong blockHeight) {\n+    String encodedFunction = contract.get_deposit_count().encodeFunctionCall();\n+    return callFunctionAtBlockNumber(encodedFunction, blockHeight)\n+        .thenApply(\n+            ethCall -> {\n+              if (ethCall.hasError()) {\n+                throw new DepositCountRequestException(\n+                    \"Eth1 call get_deposit_count() has failed:\" + ethCall.getError().getMessage());\n+              }\n+              String value = ethCall.getValue();\n+              List<Type> list = contract.get_deposit_count().decodeFunctionResponse(value);\n+              byte[] bytes = (byte[]) list.get(0).getValue();\n+              long deposit_count = Bytes.wrap(bytes).reverse().toLong();\n+              return UnsignedLong.valueOf(deposit_count);\n+            });\n+  }\n+\n   public DepositContract getContract() {\n     return contract;\n   }\n \n   public void stop() {\n     subscriptionNewDeposit.dispose();\n   }\n+\n+  private SafeFuture<EthCall> callFunctionAtBlockNumber(\n+      String encodedFunction, UnsignedLong blockHeight) {\n+    return SafeFuture.of(\n+        web3j\n+            .ethCall(\n+                Transaction.createEthCallTransaction(\n+                    null, contract.getContractAddress(), encodedFunction),\n+                DefaultBlockParameter.valueOf(blockHeight.bigIntegerValue()))\n+            .sendAsync());", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA5NjM2NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369096364", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-21T16:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTg0OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368375848", "bodyText": "We should probably bail out if the cache startup logic hasn't finished yet (or if it failed).  Otherwise this will throw because there's no value to get.", "author": "ajsutton", "createdAt": "2020-01-20T05:35:07Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNjIzNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369136235", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-21T17:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NjMyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368376324", "bodyText": "There's never anything that logs why were were  unsuccessful here so if it goes wrong we won't have any information to diagnose why.  Not sure what information is needed but it seems weird to fail with no indication as to why.", "author": "ajsutton", "createdAt": "2020-01-20T05:38:04Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNjYxOQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369136619", "bodyText": "Removed startup logic states, as discussed offline, to propagate up the exception.", "author": "cemozerr", "createdAt": "2020-01-21T17:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NjMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NzAwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368377005", "bodyText": "seconds is never used.", "author": "ajsutton", "createdAt": "2020-01-20T05:42:09Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actual_time_diff = latestBlockTimestamp.minus(blockTimestamp);\n+              return blockNumberDiff.dividedBy(actual_time_diff);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockNumberFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture) {\n+    return SafeFuture.allOf(latestBlockNumberFuture, blockNumberDiffFuture)\n+        .thenCompose(\n+            done -> {\n+              UnsignedLong latestBlockNumber = latestBlockNumberFuture.getNow(null);\n+              checkNotNull(latestBlockNumber);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+\n+              return getEth1BlockFuture(latestBlockNumber.minus(blockNumberDiff));\n+            });\n+  }\n+\n+  private static boolean isTimestampInRange(UnsignedLong timestamp) {\n+    return timestamp.compareTo(getCacheRangeLowerBound()) >= 0\n+        && timestamp.compareTo(getCacheRangeUpperBound()) <= 0;\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockTimestampFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(\n+        ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getTimestamp()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getNumber()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberDiffWithMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> secondsPerEth1BlockFuture,\n+      UnsignedLong rcrAverage) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, secondsPerEth1BlockFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong secondsPerEth1Block = secondsPerEth1BlockFuture.getNow(null);\n+              checkNotNull(secondsPerEth1Block);\n+\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              if (latestBlockTimestamp.compareTo(rcrAverage) < 0) {\n+                throw new RuntimeException(\n+                    \"Latest block timestamp is less than the cache mid-range\");\n+              }\n+              UnsignedLong timeDiff = latestBlockTimestamp.minus(rcrAverage);\n+              return timeDiff.dividedBy(secondsPerEth1Block);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(UnsignedLong blockNumber) {\n+    DefaultBlockParameter blockParameter =\n+        DefaultBlockParameter.valueOf(blockNumber.bigIntegerValue());\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(DefaultBlockParameter blockParameter) {\n+    return SafeFuture.of(web3j.ethGetBlockByNumber(blockParameter, false).sendAsync());\n+  }\n+\n+  private SafeFuture<EthBlock> getLatestEth1BlockFuture() {\n+    DefaultBlockParameter blockParameter = DefaultBlockParameterName.LATEST;\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<Void> postCacheEth1BlockEvent(UnsignedLong blockNumber, EthBlock.Block block) {\n+    SafeFuture<UnsignedLong> countFuture =\n+        SafeFuture.of(depositContractListener.getDepositCount(blockNumber));\n+    SafeFuture<Bytes32> rootFuture =\n+        SafeFuture.of(depositContractListener.getDepositRoot(blockNumber));\n+\n+    return SafeFuture.allOf(countFuture, rootFuture)\n+        .thenRun(\n+            () -> {\n+              Bytes32 root = rootFuture.getNow(null);\n+              checkNotNull(root);\n+\n+              UnsignedLong count = countFuture.getNow(null);\n+              checkNotNull(count);\n+\n+              Bytes32 eth1BlockHash = Bytes32.fromHexString(block.getHash());\n+              UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(block.getNumber());\n+\n+              eventBus.post(\n+                  new CacheEth1BlockEvent(\n+                      eth1BlockNumber, eth1BlockHash, eth1BlockTimestamp, root, count));\n+            });\n+  }\n+\n+  public static UnsignedLong getCacheRangeLowerBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(UnsignedLong.valueOf(SLOTS_PER_ETH1_VOTING_PERIOD * SECONDS_PER_SLOT))\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK).times(UnsignedLong.valueOf(2)));\n+  }\n+\n+  public static UnsignedLong getCacheRangeUpperBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK))\n+        .plus(ETH1_REQUEST_BUFFER);\n+  }\n+\n+  public static boolean hasBeenApproximately(UnsignedLong seconds, Date date) {", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MDg4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369140881", "bodyText": "replaced with seconds_per_eth1_block", "author": "cemozerr", "createdAt": "2020-01-21T17:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NzAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTYwOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368381608", "bodyText": "checkNotNull returns the value provided so you can do this as:\nUnsignedLong blockTimestamp = checkNotNull(blockTimestampFuture.getNow(null)`\n\nNot sure if it's actually better though...", "author": "ajsutton", "createdAt": "2020-01-20T06:08:47Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNzQ5OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369137498", "bodyText": "I think its more legible the first way, so I'm going to keep it that way unless you have a strong desire.", "author": "cemozerr", "createdAt": "2020-01-21T17:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTcxNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368381714", "bodyText": "This may be better described as the average time difference - in PoW networks it will vary significantly.", "author": "ajsutton", "createdAt": "2020-01-20T06:09:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actual_time_diff = latestBlockTimestamp.minus(blockTimestamp);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MDI2OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369140268", "bodyText": "I think I might be missing your point here. The actual time difference here represents the time difference between the latest block's timestamp and the block that we have in hand. We previously had estimated a different time difference if this function is getting called. So I'm not sure if calling it \"average\" would be appropriate.", "author": "cemozerr", "createdAt": "2020-01-21T17:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDI0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368740246", "bodyText": "We probably should have runCacheStartupLogic just return a SafeFuture<Void> and if it fails the SafeFuture completes exceptionally.  Then here we can catch that exception (with either exceptionally or finish(onSuccess, onFailure)) and retry after a short delay.  If we never retry then artemis will lose connection with the Eth1 chain and need to be restarted before it recovers.", "author": "ajsutton", "createdAt": "2020-01-20T22:05:29Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzMjcyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369132724", "bodyText": "Done. Actually had to make runCacheStartupLogic implement .finish() in itself due to needing to schedule the retry attempts multiple times in the future, so runCacheStartupLogic returns void in the end. Hopefully, that was the right thing to do.", "author": "cemozerr", "createdAt": "2020-01-21T17:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDY0Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368740642", "bodyText": "Leave the exception to propagate back out as a failed future here rather than converting to a state and losing the detail of what exception was thrown.", "author": "ajsutton", "createdAt": "2020-01-20T22:07:17Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNzc1MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369137750", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-21T17:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDY0Mg=="}], "type": "inlineReview"}, {"oid": "ea33291aa022b61cd418d4c3ebd8c29c12a44420", "url": "https://github.com/ConsenSys/teku/commit/ea33291aa022b61cd418d4c3ebd8c29c12a44420", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-20T23:10:16Z", "type": "commit"}, {"oid": "f7bcd1888dfd7ffd5fb13f14595218fd92f20bd9", "url": "https://github.com/ConsenSys/teku/commit/f7bcd1888dfd7ffd5fb13f14595218fd92f20bd9", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-21T21:06:27Z", "type": "commit"}, {"oid": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "url": "https://github.com/ConsenSys/teku/commit/c2158dca8ca832b749e0fa6a917008a571a33dc7", "message": "WIP: trying to run cache startup multiple times", "committedDate": "2020-01-21T21:28:55Z", "type": "commit"}, {"oid": "0fa8e22d14b48abc818f49dae4e952b60cf13863", "url": "https://github.com/ConsenSys/teku/commit/0fa8e22d14b48abc818f49dae4e952b60cf13863", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-22T15:40:24Z", "type": "commit"}, {"oid": "b859e27b9497e09314d822a2e4f32a4092da937d", "url": "https://github.com/ConsenSys/teku/commit/b859e27b9497e09314d822a2e4f32a4092da937d", "message": "Fix running cache startup multiple times", "committedDate": "2020-01-22T16:45:06Z", "type": "commit"}, {"oid": "6ab835fcac380d5bd8083fdafa6ffba3c305fd47", "url": "https://github.com/ConsenSys/teku/commit/6ab835fcac380d5bd8083fdafa6ffba3c305fd47", "message": "Run spotless", "committedDate": "2020-01-22T16:47:23Z", "type": "commit"}, {"oid": "f4e642d9495de5193043137c63f3089a37ec2fd2", "url": "https://github.com/ConsenSys/teku/commit/f4e642d9495de5193043137c63f3089a37ec2fd2", "message": "Change test-suite name", "committedDate": "2020-01-22T16:48:43Z", "type": "commit"}, {"oid": "eed0cf6e920b43e3cf272ca440072897879a47eb", "url": "https://github.com/ConsenSys/teku/commit/eed0cf6e920b43e3cf272ca440072897879a47eb", "message": "Finish cache tests and change nits", "committedDate": "2020-01-22T21:22:45Z", "type": "commit"}, {"oid": "b4c19e5bfb81d38d990e4080b022651ee4649a4e", "url": "https://github.com/ConsenSys/teku/commit/b4c19e5bfb81d38d990e4080b022651ee4649a4e", "message": "Add tests for voting in a new period", "committedDate": "2020-01-22T22:14:24Z", "type": "commit"}, {"oid": "f03caacf497a2fec42eab473dd1fd97e0acdff61", "url": "https://github.com/ConsenSys/teku/commit/f03caacf497a2fec42eab473dd1fd97e0acdff61", "message": "Run spotless", "committedDate": "2020-01-22T22:15:09Z", "type": "commit"}, {"oid": "59e76200223fe16886602413359638ce19573895", "url": "https://github.com/ConsenSys/teku/commit/59e76200223fe16886602413359638ce19573895", "message": "Implement tests for Eth1DataManager", "committedDate": "2020-01-24T00:01:18Z", "type": "commit"}, {"oid": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "url": "https://github.com/ConsenSys/teku/commit/7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "message": "Suppress warnings", "committedDate": "2020-01-24T17:14:46Z", "type": "commit"}, {"oid": "ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "url": "https://github.com/ConsenSys/teku/commit/ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "message": "Finish Eth1DataManager tests", "committedDate": "2020-01-24T21:47:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzMzIyMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370833220", "bodyText": "nit: I tend to init mocks in the field declaration rather than in setup just for brevity.", "author": "ajsutton", "createdAt": "2020-01-24T20:42:17Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private Eth1DataManager eth1DataManager;\n+  private Web3j web3j;\n+  private DepositContractListener depositContractListener;\n+\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+\n+  private final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+  private final UnsignedLong LATEST_BLOCK_TIMESTAMP =\n+      UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+  private final UnsignedLong INCONSEQUENTIAL_BLOCK_NUMBER = UnsignedLong.valueOf(100000);\n+  private final Request mockLatestBlockRequest =\n+      mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, LATEST_BLOCK_TIMESTAMP);\n+\n+  @BeforeEach\n+  void setUp() {\n+    web3j = mock(Web3j.class);\n+    depositContractListener = mock(DepositContractListener.class);", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIxODA2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371218066", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-27T12:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzMzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNDcxMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370834713", "bodyText": "It would be better if we injected an instance of java.time.Clock into the class and used that to retrieve the current instant rather than the static Instant.now().  In production you'd use Clock.systemUTC to create the instance so you get real time, but in tests you can use Clock.fixed to create a clock at a fixed time so tests are deterministic.  We may want something like https://github.com/hyperledger/besu/blob/bac5c673d3603b2aba70b7ffd77afd57a44775c8/testutil/src/main/java/org/hyperledger/besu/testutil/TestClock.java#L14 to make life easier and allow tests to manually step time forward.", "author": "ajsutton", "createdAt": "2020-01-24T20:46:26Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+  private final AsyncRunner asyncRunner;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+  private AtomicInteger cacheStartupRetry = new AtomicInteger(0);\n+  private AtomicBoolean cacheStartupDone = new AtomicBoolean(false);\n+\n+  public Eth1DataManager(\n+      Web3j web3j,\n+      EventBus eventBus,\n+      DepositContractListener depositContractListener,\n+      AsyncRunner asyncRunner) {\n+    this.web3j = web3j;\n+    this.eventBus = eventBus;\n+    this.depositContractListener = depositContractListener;\n+    this.asyncRunner = asyncRunner;\n+    eventBus.register(this);\n+\n+    runCacheStartup();\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    // Bail if cache startup logic hasn't finished yet\n+    if (!cacheStartupDone.get()) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true).reportExceptions();\n+  }\n+\n+  public void runCacheStartup() {\n+    doCacheStartup()\n+        .finish(\n+            () -> {\n+              LOG.info(\"Eth1DataManager successfully ran cache startup logic\");\n+              cacheStartupDone.set(true);\n+            });\n+  }\n+\n+  private SafeFuture<Void> doCacheStartup() {\n+    final UnsignedLong cacheMidRangeTimestamp = getCacheMidRangeTimestamp();\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> approximatedBlockNumberDiff =\n+        getApproximatedBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRangeTimestamp);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, approximatedBlockNumberDiff);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture, approximatedBlockNumberDiff, timestamp);\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getApproximatedBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture,\n+                        realSecondsPerEth1BlockFuture,\n+                        cacheMidRangeTimestamp);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<Void> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<Void> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture);\n+            })\n+        .exceptionallyCompose(\n+            err -> {\n+              if (cacheStartupRetry.incrementAndGet()\n+                  == Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP) {\n+                return SafeFuture.failedFuture(\n+                    new RuntimeException(\n+                        \"Eth1DataManager aborted due to multiple failed startup attempts\"));\n+              }\n+\n+              LOG.debug(\n+                  \"Eth1DataManager failed to run cache startup logic. Retry in \"\n+                      + Constants.ETH1_CACHE_STARTUP_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::doCacheStartup,\n+                  Constants.ETH1_CACHE_STARTUP_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private SafeFuture<Void> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture.thenCompose(\n+        ethBlock -> {\n+          EthBlock.Block block = ethBlock.getBlock();\n+          if (isDirectionUp) latestBlockReference.set(block);\n+          UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+          postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+          if (isTimestampInRange(timestamp)) {\n+            return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+          }\n+          return SafeFuture.completedFuture(null);\n+        });\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      UnsignedLong blockTimestamp) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actualTimeDiff = latestBlockTimestamp.minus(blockTimestamp);\n+              return actualTimeDiff.dividedBy(blockNumberDiff);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockNumberFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture) {\n+    return SafeFuture.allOf(latestBlockNumberFuture, blockNumberDiffFuture)\n+        .thenCompose(\n+            done -> {\n+              UnsignedLong latestBlockNumber = latestBlockNumberFuture.getNow(null);\n+              checkNotNull(latestBlockNumber);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+\n+              return getEth1BlockFuture(latestBlockNumber.minus(blockNumberDiff));\n+            });\n+  }\n+\n+  private static boolean isTimestampInRange(UnsignedLong timestamp) {\n+    return timestamp.compareTo(getCacheRangeLowerBound()) >= 0\n+        && timestamp.compareTo(getCacheRangeUpperBound()) <= 0;\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockTimestampFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(\n+        ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getTimestamp()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getNumber()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getApproximatedBlockNumberDiffWithMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> secondsPerEth1BlockFuture,\n+      UnsignedLong cacheMidRangeTimestamp) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, secondsPerEth1BlockFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong secondsPerEth1Block = secondsPerEth1BlockFuture.getNow(null);\n+              checkNotNull(secondsPerEth1Block);\n+\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              if (latestBlockTimestamp.compareTo(cacheMidRangeTimestamp) < 0) {\n+                throw new RuntimeException(\n+                    \"Latest block timestamp is less than the cache mid-range\");\n+              }\n+              UnsignedLong timeDiff = latestBlockTimestamp.minus(cacheMidRangeTimestamp);\n+              return timeDiff.dividedBy(secondsPerEth1Block);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(UnsignedLong blockNumber) {\n+    DefaultBlockParameter blockParameter =\n+        DefaultBlockParameter.valueOf(blockNumber.bigIntegerValue());\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(DefaultBlockParameter blockParameter) {\n+    return SafeFuture.of(web3j.ethGetBlockByNumber(blockParameter, false).sendAsync());\n+  }\n+\n+  private SafeFuture<EthBlock> getLatestEth1BlockFuture() {\n+    DefaultBlockParameter blockParameter = DefaultBlockParameterName.LATEST;\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<Void> postCacheEth1BlockEvent(UnsignedLong blockNumber, EthBlock.Block block) {\n+    SafeFuture<UnsignedLong> countFuture =\n+        SafeFuture.of(depositContractListener.getDepositCount(blockNumber));\n+    SafeFuture<Bytes32> rootFuture =\n+        SafeFuture.of(depositContractListener.getDepositRoot(blockNumber));\n+\n+    return SafeFuture.allOf(countFuture, rootFuture)\n+        .thenRun(\n+            () -> {\n+              Bytes32 root = rootFuture.getNow(null);\n+              checkNotNull(root);\n+\n+              UnsignedLong count = countFuture.getNow(null);\n+              checkNotNull(count);\n+\n+              Bytes32 eth1BlockHash = Bytes32.fromHexString(block.getHash());\n+              UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(block.getNumber());\n+\n+              eventBus.post(\n+                  new CacheEth1BlockEvent(\n+                      eth1BlockNumber, eth1BlockHash, eth1BlockTimestamp, root, count));\n+            });\n+  }\n+\n+  public static UnsignedLong getCacheRangeLowerBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(UnsignedLong.valueOf(SLOTS_PER_ETH1_VOTING_PERIOD * SECONDS_PER_SLOT))\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK).times(UnsignedLong.valueOf(2)));\n+  }\n+\n+  static UnsignedLong getCacheRangeUpperBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIxODEzNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371218137", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-27T12:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370835233", "bodyText": "This will catch all events posted, not just CacheEth1BlockEvent instances because ArgumentCaptor doesn't actually do type checks.", "author": "ajsutton", "createdAt": "2020-01-24T20:47:54Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private Eth1DataManager eth1DataManager;\n+  private Web3j web3j;\n+  private DepositContractListener depositContractListener;\n+\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+\n+  private final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+  private final UnsignedLong LATEST_BLOCK_TIMESTAMP =\n+      UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+  private final UnsignedLong INCONSEQUENTIAL_BLOCK_NUMBER = UnsignedLong.valueOf(100000);\n+  private final Request mockLatestBlockRequest =\n+      mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, LATEST_BLOCK_TIMESTAMP);\n+\n+  @BeforeEach\n+  void setUp() {\n+    web3j = mock(Web3j.class);\n+    depositContractListener = mock(DepositContractListener.class);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    UnsignedLong midRangeTimestamp =\n+        Eth1DataManager.getCacheRangeUpperBound().minus(UnsignedLong.ONE);\n+\n+    UnsignedLong firstUpwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.plus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondUpwardNumber = firstUpwardNumber.plus(UnsignedLong.ONE);\n+    UnsignedLong secondUpwardTimestamp = UnsignedLong.MAX_VALUE;\n+\n+    UnsignedLong firstDownwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.minus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondDownwardNumber = firstDownwardNumber.minus(UnsignedLong.ONE);\n+    UnsignedLong secondDownwardTimestamp = UnsignedLong.ONE;\n+\n+    Request midRangeBlockRequest =\n+        mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, midRangeTimestamp);\n+    Request firstUpwardBlockRequest = mockBlockRequest(firstUpwardNumber, midRangeTimestamp);\n+    Request secondUpwardBlockRequest = mockBlockRequest(secondUpwardNumber, secondUpwardTimestamp);\n+    Request firstDownwardBlockRequest = mockBlockRequest(firstDownwardNumber, midRangeTimestamp);\n+    Request secondDownwardBlockRequest =\n+        mockBlockRequest(secondDownwardNumber, secondDownwardTimestamp);\n+\n+    when(web3j.ethGetBlockByNumber(any(), eq(false)))\n+        .thenReturn(mockLatestBlockRequest)\n+        .thenReturn(midRangeBlockRequest)\n+        .thenReturn(firstUpwardBlockRequest)\n+        .thenReturn(secondUpwardBlockRequest)\n+        .thenReturn(firstDownwardBlockRequest)\n+        .thenReturn(secondDownwardBlockRequest);\n+\n+    eth1DataManager = new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner);\n+\n+    ArgumentCaptor<CacheEth1BlockEvent> eventArgumentCaptor =\n+        ArgumentCaptor.forClass(CacheEth1BlockEvent.class);\n+    verify(eventBus, times(5)).post(eventArgumentCaptor.capture());", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMyOTY3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371329677", "bodyText": "To account for this I'm doing this now:\n List<CacheEth1BlockEvent> eth1BlockEvents = eventArgumentCaptor.getAllValues().stream().filter(event -> event.getClass().equals(CacheEth1BlockEvent.class)).collect(Collectors.toList());", "author": "cemozerr", "createdAt": "2020-01-27T16:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1NzYxMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371457613", "bodyText": "But the filtered events will still count as one of the 5 calls that times(5) requires, causing the test to fail because of too many invocations.", "author": "ajsutton", "createdAt": "2020-01-27T20:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MDMyOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371560328", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T00:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzODkwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370838905", "bodyText": "I'd remove this call from the constructor and make runCacheStartup() a public start method.  Probably register with the eventBus in that method too rather than the constructor.\nIt will make the tests a lot clearer - right now they look like they are creating Eth1DataManager but never using it.  And generally it's good policy for constructors to not do any work so you have a separation of concerns between creating objects and actually starting work.", "author": "ajsutton", "createdAt": "2020-01-24T20:58:04Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+  private final AsyncRunner asyncRunner;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+  private AtomicInteger cacheStartupRetry = new AtomicInteger(0);\n+  private AtomicBoolean cacheStartupDone = new AtomicBoolean(false);\n+\n+  public Eth1DataManager(\n+      Web3j web3j,\n+      EventBus eventBus,\n+      DepositContractListener depositContractListener,\n+      AsyncRunner asyncRunner) {\n+    this.web3j = web3j;\n+    this.eventBus = eventBus;\n+    this.depositContractListener = depositContractListener;\n+    this.asyncRunner = asyncRunner;\n+    eventBus.register(this);\n+\n+    runCacheStartup();", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2MDU1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370860556", "bodyText": "I'm happy to report that I made the exact change you suggested before seeing your comment. \ud83d\ude0e", "author": "cemozerr", "createdAt": "2020-01-24T21:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzODkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1NjUzOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370856538", "bodyText": "I don't think this is giving us a very realistic set of results from web3j.  For example when we initially request the latest block, it returnsINCONSEQUENTIAL_BLOCK_NUMBER but then firstUpwardNumber is one block higher than that which it can't be because INCONSEQUENTIAL_BLOCK_NUMBER is the chain head.  Really INCONSEQUENTIAL_BLOCK_NUMBER should be LATEST_BLOCK_NUMBER and everything should be before that.\nAnd both INCONSEQUENTIAL_BLOKC_NUMBER and firstUpwardBlockRequest have the same timestamp which also can't happen.\nI suspect we need to do the math to work out what the blockchain actually needs to look like realistically. I'd say start the test with something like:\nfinal List<CacheEth1BlockEvent > blocks = Arrays.asList(\n mockBlock(10, <timestamp>),\n mockBlock(11, <timestamp>),\n .. for each block in the relevant range ..\n mockBlock(25, <timestamp>));\n\nThen you can setup the web3j mock to respond to any request by block number for those blocks specifically instead of using any() and just need to add in an expectation for getting the latest block which would return the last block in the list. And I would actually use plain numbers not constants for both block number and timestamps in that list for maximum readability.  You'll have to inject a Clock as I mentioned earlier so that you can have a fixed time rather than having to calculate things around Instant.now().\nDoing it this way means we have a very clear, readable list of the blocks involved in the chain we're trying to explore - easy to see that they're valid and work out why we're expecting what we are from the test.\nOne very useful trick you'll need to make this work instead of any() - DefaultBlockParameter doesn't provide useful equals methods so we need a custom argument matcher or mockito will never match the params.\nprivate DefaultBlockParameter blockParameterEq(final DefaultBlockParameter expected) {\n    return argThat(arg -> arg != null && arg.getValue().equals(expected.getValue()));\n  }\n\nwhich would be used like:\nwhen(web3j.ethGetBlockByNumber(blockParameterEq(blockParam), eq(false))).thenReturn(request);", "author": "ajsutton", "createdAt": "2020-01-24T21:45:51Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private Eth1DataManager eth1DataManager;\n+  private Web3j web3j;\n+  private DepositContractListener depositContractListener;\n+\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+\n+  private final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+  private final UnsignedLong LATEST_BLOCK_TIMESTAMP =\n+      UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+  private final UnsignedLong INCONSEQUENTIAL_BLOCK_NUMBER = UnsignedLong.valueOf(100000);\n+  private final Request mockLatestBlockRequest =\n+      mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, LATEST_BLOCK_TIMESTAMP);\n+\n+  @BeforeEach\n+  void setUp() {\n+    web3j = mock(Web3j.class);\n+    depositContractListener = mock(DepositContractListener.class);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    UnsignedLong midRangeTimestamp =\n+        Eth1DataManager.getCacheRangeUpperBound().minus(UnsignedLong.ONE);\n+\n+    UnsignedLong firstUpwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.plus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondUpwardNumber = firstUpwardNumber.plus(UnsignedLong.ONE);\n+    UnsignedLong secondUpwardTimestamp = UnsignedLong.MAX_VALUE;\n+\n+    UnsignedLong firstDownwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.minus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondDownwardNumber = firstDownwardNumber.minus(UnsignedLong.ONE);\n+    UnsignedLong secondDownwardTimestamp = UnsignedLong.ONE;\n+\n+    Request midRangeBlockRequest =\n+        mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, midRangeTimestamp);\n+    Request firstUpwardBlockRequest = mockBlockRequest(firstUpwardNumber, midRangeTimestamp);\n+    Request secondUpwardBlockRequest = mockBlockRequest(secondUpwardNumber, secondUpwardTimestamp);\n+    Request firstDownwardBlockRequest = mockBlockRequest(firstDownwardNumber, midRangeTimestamp);\n+    Request secondDownwardBlockRequest =\n+        mockBlockRequest(secondDownwardNumber, secondDownwardTimestamp);\n+\n+    when(web3j.ethGetBlockByNumber(any(), eq(false)))\n+        .thenReturn(mockLatestBlockRequest)\n+        .thenReturn(midRangeBlockRequest)\n+        .thenReturn(firstUpwardBlockRequest)\n+        .thenReturn(secondUpwardBlockRequest)\n+        .thenReturn(firstDownwardBlockRequest)\n+        .thenReturn(secondDownwardBlockRequest);", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MDUxOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371550518", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T00:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1NjUzOA=="}], "type": "inlineReview"}, {"oid": "f86d118c52d49bed0f865034d81a8dd83e312d4d", "url": "https://github.com/ConsenSys/teku/commit/f86d118c52d49bed0f865034d81a8dd83e312d4d", "message": "Refactor tests to make them more legible", "committedDate": "2020-01-27T22:17:42Z", "type": "commit"}, {"oid": "4a1f6beca715d582ff9f02ce5f538e9e0d16f020", "url": "https://github.com/ConsenSys/teku/commit/4a1f6beca715d582ff9f02ce5f538e9e0d16f020", "message": "Fix bug", "committedDate": "2020-01-27T22:28:21Z", "type": "commit"}, {"oid": "893e1cee34ee0c3ee5d5b6ee03ffe4a6c7af07a6", "url": "https://github.com/ConsenSys/teku/commit/893e1cee34ee0c3ee5d5b6ee03ffe4a6c7af07a6", "message": "Refactor the time dependency out of the Eth1Data cache tests", "committedDate": "2020-01-28T00:03:32Z", "type": "commit"}, {"oid": "2acf153ebeb06683fa84a0b453e5d4f116a4d9bb", "url": "https://github.com/ConsenSys/teku/commit/2acf153ebeb06683fa84a0b453e5d4f116a4d9bb", "message": "Use static class to capture specific events", "committedDate": "2020-01-28T00:43:08Z", "type": "commit"}, {"oid": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "url": "https://github.com/ConsenSys/teku/commit/6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-28T00:43:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTU3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371591574", "bodyText": "I'd use a stub here for simplicity rather than a mock.  If this was the only place we were likely to need it, a mock would be fine but we're going to mock TimeProvider a lot so it makes sense to introduce a stub for it in test-support.  Something like:\npublic class StubTimeProvider extends TimeProvider {\n  private UnsignedLong timeInSeconds;\n\n  public StubTimeProvider() {\n    this(UnsignedLong.valueOf(29842948));\n  }\n\n  public StubTimeProvider(final long timeInSeconds) {\n    this(UnsignedLong.valueOf(timeInSeconds));\n  }\n\n  public StubTimeProvider(final UnsignedLong timeInSeconds) {\n    this.timeInSeconds = timeInSeconds;\n  }\n\n  public void advanceTimeBySeconds(final long seconds) {\n    this.timeInSeconds = timeInSeconds.plus(UnsignedLong.valueOf(seconds));\n  }\n\n  @Override\n  public UnsignedLong getTimeInSeconds() {\n    return timeInSeconds;\n  }\n}", "author": "ajsutton", "createdAt": "2020-01-28T03:10:19Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxMTI3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371911272", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTgwMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371591800", "bodyText": "I don't think you need this filter now.", "author": "ajsutton", "createdAt": "2020-01-28T03:11:37Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);\n+  private final Web3j web3j = mock(Web3j.class);\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+  private final DepositContractListener depositContractListener =\n+      mock(DepositContractListener.class);\n+\n+  private EventBus eventBus;\n+  private Eth1DataManager eth1DataManager;\n+  private EventCapture eventCapture;\n+\n+  private static final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+\n+  static {\n+    ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(4);\n+    SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(6);\n+    ETH1_REQUEST_BUFFER = UnsignedLong.valueOf(1);\n+    SLOTS_PER_ETH1_VOTING_PERIOD = 5;\n+    SECONDS_PER_SLOT = 2;\n+  }\n+\n+  private final UnsignedLong testStartTime = UnsignedLong.valueOf(200);\n+\n+  // Cache Range:\n+  //    Lower Bound = 200 - (5 * 2) - (4 * 6 * 2) = 142\n+  //    Upper Bound = 200 - (4 * 6) + 1 = 177\n+  //    Mid-Range =  (142 + 177) / 2 = 160 (given that we use Half Up rounding (i.e. normal math\n+  // rounding))\n+  //\n+  // Number of blocks to middle\n+  //    = (current-time - mid-range) / (seconds_per_eth1_block)\n+  //    = (200 - 160) / (6)\n+  //    = 7 (here we use\n+  //    i.e. Teku will assume the middle-range block has block number current head - 7\n+\n+  @BeforeEach\n+  void setUp() {\n+    eventBus = new EventBus();\n+    eventCapture = new EventCapture(eventBus);\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+  }\n+\n+  @Test\n+  void checkTimeValues() {\n+    assertThat(eth1DataManager.getCacheRangeLowerBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(142));\n+    assertThat(eth1DataManager.getCacheRangeUpperBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(177));\n+    assertThat(Eth1DataManager.getCacheMidRangeTimestamp(timeProvider.getTimeInSeconds()))\n+        .isEqualByComparingTo(UnsignedLong.valueOf(160));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            new MockBlock(19, 186));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(8);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps)\n+        .containsExactlyInAnyOrder(138, 144, 150, 156, 162, 168, 174, 180);\n+  }\n+\n+  @Test\n+  void cacheStartup_recalculateSecondsToFindMidRangeBlock() {\n+    // There is ice-age! Average block times are at about 20 seconds! What does Teku do? FUNCTION.\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(15, 78),\n+            new MockBlock(16, 98),\n+            new MockBlock(17, 118),\n+            new MockBlock(18, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(19, 158),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(20, 178));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(3);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxMjYyMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371912623", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjM5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371592396", "bodyText": "I'd avoid spies here and just assert that there's no registration on the event bus until start is called:\neventBus = mock(EventBus.class);\neth1DataManager = new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\nverifyZeroInteractions(eventBus);\n\nBoth approaches are a bit specific to the implementation but at least this one will catch all potential interactions, even if Eth1DataManager switches to to a different event type.", "author": "ajsutton", "createdAt": "2020-01-28T03:15:15Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);\n+  private final Web3j web3j = mock(Web3j.class);\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+  private final DepositContractListener depositContractListener =\n+      mock(DepositContractListener.class);\n+\n+  private EventBus eventBus;\n+  private Eth1DataManager eth1DataManager;\n+  private EventCapture eventCapture;\n+\n+  private static final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+\n+  static {\n+    ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(4);\n+    SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(6);\n+    ETH1_REQUEST_BUFFER = UnsignedLong.valueOf(1);\n+    SLOTS_PER_ETH1_VOTING_PERIOD = 5;\n+    SECONDS_PER_SLOT = 2;\n+  }\n+\n+  private final UnsignedLong testStartTime = UnsignedLong.valueOf(200);\n+\n+  // Cache Range:\n+  //    Lower Bound = 200 - (5 * 2) - (4 * 6 * 2) = 142\n+  //    Upper Bound = 200 - (4 * 6) + 1 = 177\n+  //    Mid-Range =  (142 + 177) / 2 = 160 (given that we use Half Up rounding (i.e. normal math\n+  // rounding))\n+  //\n+  // Number of blocks to middle\n+  //    = (current-time - mid-range) / (seconds_per_eth1_block)\n+  //    = (200 - 160) / (6)\n+  //    = 7 (here we use\n+  //    i.e. Teku will assume the middle-range block has block number current head - 7\n+\n+  @BeforeEach\n+  void setUp() {\n+    eventBus = new EventBus();\n+    eventCapture = new EventCapture(eventBus);\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+  }\n+\n+  @Test\n+  void checkTimeValues() {\n+    assertThat(eth1DataManager.getCacheRangeLowerBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(142));\n+    assertThat(eth1DataManager.getCacheRangeUpperBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(177));\n+    assertThat(Eth1DataManager.getCacheMidRangeTimestamp(timeProvider.getTimeInSeconds()))\n+        .isEqualByComparingTo(UnsignedLong.valueOf(160));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            new MockBlock(19, 186));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(8);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps)\n+        .containsExactlyInAnyOrder(138, 144, 150, 156, 162, 168, 174, 180);\n+  }\n+\n+  @Test\n+  void cacheStartup_recalculateSecondsToFindMidRangeBlock() {\n+    // There is ice-age! Average block times are at about 20 seconds! What does Teku do? FUNCTION.\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(15, 78),\n+            new MockBlock(16, 98),\n+            new MockBlock(17, 118),\n+            new MockBlock(18, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(19, 158),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(20, 178));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(3);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps).containsExactlyInAnyOrder(158, 138, 178);\n+  }\n+\n+  @Test\n+  void cacheStartup_retryStartup() {\n+    Request mockRequest = mockFailedRequest();\n+    when(web3j.ethGetBlockByNumber(any(), eq(false))).thenReturn(mockRequest);\n+\n+    eth1DataManager.start();\n+\n+    verify(web3j, times(Math.toIntExact(Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP)))\n+        .ethGetBlockByNumber(any(), eq(false));\n+  }\n+\n+  @Test\n+  void onTick_startupNotDone() {\n+    eventBus = spy(new EventBus());\n+    eth1DataManager =\n+        spy(\n+            new Eth1DataManager(\n+                web3j, eventBus, depositContractListener, asyncRunner, timeProvider));\n+    eventBus.post(new Date());\n+    verifyNoInteractions(eth1DataManager);", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNDA4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371914086", "bodyText": "Makes sense. Tests are less brittle that way. Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjYwOQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371592609", "bodyText": "With the stub this would just become timeProvider.advanceTimeBySeconds(4).", "author": "ajsutton", "createdAt": "2020-01-28T03:16:23Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);\n+  private final Web3j web3j = mock(Web3j.class);\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+  private final DepositContractListener depositContractListener =\n+      mock(DepositContractListener.class);\n+\n+  private EventBus eventBus;\n+  private Eth1DataManager eth1DataManager;\n+  private EventCapture eventCapture;\n+\n+  private static final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+\n+  static {\n+    ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(4);\n+    SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(6);\n+    ETH1_REQUEST_BUFFER = UnsignedLong.valueOf(1);\n+    SLOTS_PER_ETH1_VOTING_PERIOD = 5;\n+    SECONDS_PER_SLOT = 2;\n+  }\n+\n+  private final UnsignedLong testStartTime = UnsignedLong.valueOf(200);\n+\n+  // Cache Range:\n+  //    Lower Bound = 200 - (5 * 2) - (4 * 6 * 2) = 142\n+  //    Upper Bound = 200 - (4 * 6) + 1 = 177\n+  //    Mid-Range =  (142 + 177) / 2 = 160 (given that we use Half Up rounding (i.e. normal math\n+  // rounding))\n+  //\n+  // Number of blocks to middle\n+  //    = (current-time - mid-range) / (seconds_per_eth1_block)\n+  //    = (200 - 160) / (6)\n+  //    = 7 (here we use\n+  //    i.e. Teku will assume the middle-range block has block number current head - 7\n+\n+  @BeforeEach\n+  void setUp() {\n+    eventBus = new EventBus();\n+    eventCapture = new EventCapture(eventBus);\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+  }\n+\n+  @Test\n+  void checkTimeValues() {\n+    assertThat(eth1DataManager.getCacheRangeLowerBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(142));\n+    assertThat(eth1DataManager.getCacheRangeUpperBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(177));\n+    assertThat(Eth1DataManager.getCacheMidRangeTimestamp(timeProvider.getTimeInSeconds()))\n+        .isEqualByComparingTo(UnsignedLong.valueOf(160));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            new MockBlock(19, 186));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(8);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps)\n+        .containsExactlyInAnyOrder(138, 144, 150, 156, 162, 168, 174, 180);\n+  }\n+\n+  @Test\n+  void cacheStartup_recalculateSecondsToFindMidRangeBlock() {\n+    // There is ice-age! Average block times are at about 20 seconds! What does Teku do? FUNCTION.\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(15, 78),\n+            new MockBlock(16, 98),\n+            new MockBlock(17, 118),\n+            new MockBlock(18, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(19, 158),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(20, 178));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(3);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps).containsExactlyInAnyOrder(158, 138, 178);\n+  }\n+\n+  @Test\n+  void cacheStartup_retryStartup() {\n+    Request mockRequest = mockFailedRequest();\n+    when(web3j.ethGetBlockByNumber(any(), eq(false))).thenReturn(mockRequest);\n+\n+    eth1DataManager.start();\n+\n+    verify(web3j, times(Math.toIntExact(Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP)))\n+        .ethGetBlockByNumber(any(), eq(false));\n+  }\n+\n+  @Test\n+  void onTick_startupNotDone() {\n+    eventBus = spy(new EventBus());\n+    eth1DataManager =\n+        spy(\n+            new Eth1DataManager(\n+                web3j, eventBus, depositContractListener, asyncRunner, timeProvider));\n+    eventBus.post(new Date());\n+    verifyNoInteractions(eth1DataManager);\n+  }\n+\n+  @Test\n+  void onTick_startupDoneGetNewBlocks() {\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            // Cache Range Updated Upper Bound: 181\n+            new MockBlock(19, 186),\n+            new MockBlock(20, 192));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime.plus(UnsignedLong.valueOf(4)));", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNDk4NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371914984", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzQ1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371593457", "bodyText": "I'd call this DelayedExecutorAsyncRunner - the name relates to what makes it's implementation special (e.g. ArrayList because it uses an array backing).", "author": "ajsutton", "createdAt": "2020-01-28T03:21:07Z", "path": "util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerProd implements AsyncRunner {", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNTM2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371915361", "bodyText": "That makes sense to me. Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzY3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371593674", "bodyText": "I would have thought this would be StubAsyncRunner and it would still delay running the provided action, but would do so until the test called an extra method to execute.  So an implementation like:\npublic class StubAsyncRunner implements AsyncRunner {\n  private List<Runnable> queuedActions = new ArrayList<>();\n\n  @Override\n  public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action, final Executor executor) {\n    final SafeFuture<U> result = new SafeFuture<>();\n    queuedActions.add(\n        () -> {\n          try {\n            propagateResult(action.get(), result);\n          } catch (final Throwable t) {\n            result.completeExceptionally(t);\n          }\n        });\n    return result;\n  }\n\n  @Override\n  public <U> SafeFuture<U> runAfterDelay(\n      Supplier<SafeFuture<U>> action, long delayAmount, TimeUnit delayUnit) {\n    return runAsync(action, null); // Executor is ignored anyway.\n  }\n\n  public void executeQueuedActions() {\n    final List<Runnable> actionsToExecute = queuedActions;\n    queuedActions = new ArrayList<>();\n    actionsToExecute.forEach(Runnable::run);\n  }\n\n  public boolean hasDelayedActions() {\n    return !queuedActions.isEmpty();\n  }\n}\n\nand then Eth1DataManager.catchStartup_retryStartup becomes:\n  @Test\n  void cacheStartup_retryStartup() {\n    Request mockRequest = mockFailedRequest();\n    when(web3j.ethGetBlockByNumber(any(), eq(false))).thenReturn(mockRequest);\n\n    eth1DataManager.start();\n\n    verify(web3j).ethGetBlockByNumber(any(), eq(false)); // First failed attempt\n\n    for (int i = 2; i <= Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP; i++) {\n      asyncRunner.executeQueuedActions();\n      verify(web3j, times(i)).ethGetBlockByNumber(any(), eq(false));\n    }\n\n    assertThat(asyncRunner.hasDelayedActions()).isFalse();\n  }\n\nThe main reason for this is that it preserves the important property that AsyncRunner doesn't execute the action immediately which we want to test.", "author": "ajsutton", "createdAt": "2020-01-28T03:22:27Z", "path": "util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerTest implements AsyncRunner {", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkyNTE0Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371925142", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDEyMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371594120", "bodyText": "A no-arg constructor is provided by default so this can be omitted.", "author": "ajsutton", "createdAt": "2020-01-28T03:25:12Z", "path": "util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerTest implements AsyncRunner {\n+\n+  public AsyncRunnerTest() {}", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNjI5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371916297", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDE0Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371594143", "bodyText": "A no-arg constructor is provided by default so this can be omitted.", "author": "ajsutton", "createdAt": "2020-01-28T03:25:21Z", "path": "util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerProd implements AsyncRunner {\n+\n+  public AsyncRunnerProd() {}", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNjM1MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371916351", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDE0Mw=="}], "type": "inlineReview"}, {"oid": "6db516ae0dfd96e38505b1420b9a5d0021125176", "url": "https://github.com/ConsenSys/teku/commit/6db516ae0dfd96e38505b1420b9a5d0021125176", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-28T16:15:27Z", "type": "commit"}, {"oid": "5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "url": "https://github.com/ConsenSys/teku/commit/5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "message": "Replace TimeProvider mocks with StubTimeProvider", "committedDate": "2020-01-28T16:26:44Z", "type": "commit"}, {"oid": "7f881ce904f9b4fc40b86ada51168682f1d00563", "url": "https://github.com/ConsenSys/teku/commit/7f881ce904f9b4fc40b86ada51168682f1d00563", "message": "Remove unnecessary filter", "committedDate": "2020-01-28T16:28:16Z", "type": "commit"}, {"oid": "c8f9b13570e759ec0075f324a9132ca528e638e8", "url": "https://github.com/ConsenSys/teku/commit/c8f9b13570e759ec0075f324a9132ca528e638e8", "message": "Make test more robust", "committedDate": "2020-01-28T16:31:06Z", "type": "commit"}, {"oid": "51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "url": "https://github.com/ConsenSys/teku/commit/51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "message": "Use eventSink and better test asyncRunner", "committedDate": "2020-01-28T16:54:06Z", "type": "commit"}, {"oid": "b81d84e28eefb82c8166c4925c78fb24229eb75b", "url": "https://github.com/ConsenSys/teku/commit/b81d84e28eefb82c8166c4925c78fb24229eb75b", "message": "Run spotless", "committedDate": "2020-01-28T16:55:19Z", "type": "commit"}, {"oid": "3dada667f085e40f47444349bdc138622c1d31a9", "url": "https://github.com/ConsenSys/teku/commit/3dada667f085e40f47444349bdc138622c1d31a9", "message": "Fix bug", "committedDate": "2020-01-28T17:10:08Z", "type": "commit"}, {"oid": "372d1f8830e1bf7f35630d5f8f42f3bbdf6aeb74", "url": "https://github.com/ConsenSys/teku/commit/372d1f8830e1bf7f35630d5f8f42f3bbdf6aeb74", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-28T21:46:48Z", "type": "commit"}, {"oid": "2c0b98832f6216306d55a290b92c1650ff1d037f", "url": "https://github.com/ConsenSys/teku/commit/2c0b98832f6216306d55a290b92c1650ff1d037f", "message": "Run spotless after merge", "committedDate": "2020-01-28T21:53:04Z", "type": "commit"}]}