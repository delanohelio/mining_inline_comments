{"pr_number": 3061, "pr_title": "add status query parameter to `/eth/v1/beacon/states/:state_id/validators`", "pr_createdAt": "2020-10-23T03:53:11Z", "pr_url": "https://github.com/ConsenSys/teku/pull/3061", "timeline": [{"oid": "57432a1415578c41fb054fb3375e94affe3747af", "url": "https://github.com/ConsenSys/teku/commit/57432a1415578c41fb054fb3375e94affe3747af", "message": "add status query parameter to `/eth/v1/beacon/states/:state_id/validators`\n\n - make id not being passed in the query string be interpreted as 'all validators', rather than result in an empty list.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-10-23T03:52:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4MTg5Nw==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r510581897", "bodyText": "I feel like something called statusFilter should actually be a Predicate<ValidatorStatus> or maybe just Predicate<Validator> rather than a list.  That would also smoothly handle the case where the param is specified but with no options which currently counts as not being specified but probably should exclude everything.\nIn any case we want to use a HashSet instead of List so that we can check if the status is present in O(1) instead of O(n) - when iterating every validator the difference will add up even for small lists.", "author": "ajsutton", "createdAt": "2020-10-23T04:06:52Z", "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "diffHunk": "@@ -565,15 +562,40 @@ public void requireStoreAvailable() {\n \n   private List<ValidatorResponse> getValidators(\n       final List<Integer> validatorIndices,\n+      final List<ValidatorStatus> statusFilter,", "originalCommit": "57432a1415578c41fb054fb3375e94affe3747af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxOTk2Mg==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r510619962", "bodyText": "specifying without any actual value isn't really a thing we've catered for anywhere. its technically possible, but i think most endpoints with query parameters will fail on that scenario, and you'll get a 500 back", "author": "rolfyone", "createdAt": "2020-10-23T05:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4MTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NDY2Mg==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r510584662", "bodyText": "Validator indices could be empty because none of the supplied validator public keys were known. In that case we should return empty list not all validators.", "author": "ajsutton", "createdAt": "2020-10-23T04:20:13Z", "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "diffHunk": "@@ -565,15 +562,40 @@ public void requireStoreAvailable() {\n \n   private List<ValidatorResponse> getValidators(\n       final List<Integer> validatorIndices,\n+      final List<ValidatorStatus> statusFilter,\n       final tech.pegasys.teku.datastructures.state.BeaconState state) {\n-    return validatorIndices.stream()\n-        .map(index -> ValidatorResponse.fromState(state, index))\n-        .collect(toList());\n+    final List<ValidatorResponse> result;\n+\n+    if (validatorIndices.isEmpty()) {", "originalCommit": "57432a1415578c41fb054fb3375e94affe3747af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU5MTg5OQ==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r510591899", "bodyText": "Also I can't add a comment on it because it's not a change but getValidatorsBalancesByStateRoot is returning empty when there are no validator indices.", "author": "ajsutton", "createdAt": "2020-10-23T04:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NDY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU5NTM2Mw==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r510595363", "bodyText": "There's  a weird mix of iteration and streaming here that's winding up converting to list multiple times.  It seems like this would be a lot cleaner if we passed in functions to select and filter the validators instead of lists.  I've done a rough spike of this (commenting out a bunch of tests to avoid flowing the changes round everywhere): efd37ca\nThe key thing is it introduces a ValidatorSelector interface which is essentially a function that takes a BeaconState and returns an IntStream of validator indices to use from that state.  So when no validator IDs are provided, the validator selector is state -> IntStream.range(0, state.getValidators.size()) - ie all validators.  Otherwise it just maps the list of validator selectors to an index.  An IntStream is returned rather than List<Integer> so each entry is processed in turn without having to load them all in memory (100k Integer instances isn't particularly friendly to the GC).", "author": "ajsutton", "createdAt": "2020-10-23T05:07:40Z", "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "diffHunk": "@@ -565,15 +562,40 @@ public void requireStoreAvailable() {\n \n   private List<ValidatorResponse> getValidators(\n       final List<Integer> validatorIndices,\n+      final List<ValidatorStatus> statusFilter,\n       final tech.pegasys.teku.datastructures.state.BeaconState state) {\n-    return validatorIndices.stream()\n-        .map(index -> ValidatorResponse.fromState(state, index))\n-        .collect(toList());\n+    final List<ValidatorResponse> result;\n+\n+    if (validatorIndices.isEmpty()) {\n+      final int validatorCount = state.getValidators().size();\n+      result = new ArrayList<>();\n+      for (int i = 0; i < validatorCount; i++) {\n+        result.add(ValidatorResponse.fromState(state, i));\n+      }\n+    } else {\n+      result =\n+          validatorIndices.stream()\n+              .map(index -> ValidatorResponse.fromState(state, index))\n+              .collect(toList());\n+    }\n+\n+    if (statusFilter.isEmpty()) {\n+      return result;\n+    }\n+    return result.stream().filter(v -> statusFilter.contains(v.status)).collect(toList());", "originalCommit": "57432a1415578c41fb054fb3375e94affe3747af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a6925983555a0e40c9f62d2bae3a1592a7cbfa83", "url": "https://github.com/ConsenSys/teku/commit/a6925983555a0e40c9f62d2bae3a1592a7cbfa83", "message": "Merge remote-tracking branch 'upstream/master' into validators-optional-indexes", "committedDate": "2020-10-26T23:58:22Z", "type": "commit"}, {"oid": "b3f0ec3675feaf569492ff00fa9ddcb2223465bf", "url": "https://github.com/ConsenSys/teku/commit/b3f0ec3675feaf569492ff00fa9ddcb2223465bf", "message": "Merge remote-tracking branch 'upstream/master' into validators-optional-indexes", "committedDate": "2020-10-27T00:09:54Z", "type": "commit"}, {"oid": "1c4acebb5fb07ccd04bfbd3d22d4225d10a49833", "url": "https://github.com/ConsenSys/teku/commit/1c4acebb5fb07ccd04bfbd3d22d4225d10a49833", "message": "Merge remote-tracking branch 'upstream/master' into validators-optional-indexes", "committedDate": "2020-10-27T00:23:01Z", "type": "commit"}, {"oid": "8c68805b7374443bfce62c43c89c1fdc781797e8", "url": "https://github.com/ConsenSys/teku/commit/8c68805b7374443bfce62c43c89c1fdc781797e8", "message": "started refactoring to use a StateSelector, still have some tests to write around the ChainDataProvider changes.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-10-27T23:33:59Z", "type": "commit"}, {"oid": "d1241d62d7857a41298f50e679d5a148d13c5505", "url": "https://github.com/ConsenSys/teku/commit/d1241d62d7857a41298f50e679d5a148d13c5505", "message": "more refactoring, tests added to show filters are behaving correctly\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-10-28T01:56:20Z", "type": "commit"}, {"oid": "da59bc71368a64fe9869760e048db38df0bffb29", "url": "https://github.com/ConsenSys/teku/commit/da59bc71368a64fe9869760e048db38df0bffb29", "message": "Merge remote-tracking branch 'upstream/master' into validators-optional-indexes", "committedDate": "2020-10-28T02:00:12Z", "type": "commit"}, {"oid": "25d9a7e58218218648c9e564d60dae0cffb9b67d", "url": "https://github.com/ConsenSys/teku/commit/25d9a7e58218218648c9e564d60dae0cffb9b67d", "message": "Merge remote-tracking branch 'upstream/master' into validators-optional-indexes", "committedDate": "2020-10-28T04:33:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMTAxMA==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r513101010", "bodyText": "Is not found really the right result? It's not listed as one of the possible response codes in the OpenAPI doc.  I'd have thought an empty list would be more appropriate but bit unsure if the state can't be found...", "author": "ajsutton", "createdAt": "2020-10-27T23:59:00Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/beacon/GetStateValidators.java", "diffHunk": "@@ -85,16 +102,21 @@ public GetStateValidators(final DataProvider dataProvider, final JsonProvider js\n       })\n   @Override\n   public void handle(@NotNull final Context ctx) throws Exception {\n-    final List<Integer> validatorIndices =\n-        stateValidatorsUtil.parseValidatorsParam(chainDataProvider, ctx);\n+    final Map<String, List<String>> queryParamMap = ctx.queryParamMap();\n+    final Map<String, String> pathParamMap = ctx.pathParamMap();\n+\n+    final List<String> validators =\n+        queryParamMap.containsKey(PARAM_ID)\n+            ? ListQueryParameterUtils.getParameterAsStringList(ctx.queryParamMap(), PARAM_ID)\n+            : Collections.emptyList();\n+\n+    final List<ValidatorStatus> statusFilter = stateValidatorsUtil.parseStatusFilter(queryParamMap);\n \n-    final Function<Bytes32, SafeFuture<Optional<List<ValidatorResponse>>>> rootHandler =\n-        (root) -> chainDataProvider.getValidatorsDetailsByStateRoot(root, validatorIndices);\n-    final Function<UInt64, SafeFuture<Optional<List<ValidatorResponse>>>> slotHandler =\n-        (slot) -> chainDataProvider.getValidatorsDetailsBySlot(slot, validatorIndices);\n+    SafeFuture<Optional<List<ValidatorResponse>>> future =\n+        chainDataProvider.getStateValidators(\n+            pathParamMap.getOrDefault(PARAM_STATE_ID, \"head\"), validators, statusFilter);\n \n-    processStateEndpointRequest(\n-        chainDataProvider, ctx, rootHandler, slotHandler, this::handleResult);\n+    handleOptionalResult(ctx, future, this::handleResult, SC_NOT_FOUND);", "originalCommit": "8c68805b7374443bfce62c43c89c1fdc781797e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE4NjQxOQ==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r513186419", "bodyText": "i can update the swagger, but it has to be possible, routes may be not found...", "author": "rolfyone", "createdAt": "2020-10-28T05:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMTAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE5MTI1NA==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r513191254", "bodyText": "But this is a case where the route is found and its returning 404 anyway. We need to document under what conditions this API will return 404 (as does the standard API).  Personally I'd rather it return no content to indicate the request was valid (so not a 4xx response) but there was no content to provide.  But the key thing is that different clients need to return the same response codes under the same conditions.", "author": "ajsutton", "createdAt": "2020-10-28T05:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3NzM3NQ==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r513177375", "bodyText": "Are there any cases where we need to get multiple states?  Following the pattern isn't bad but I suspect its very unlikely that we'd ever need a List here and could just have the Optional version as the only method for states (whereas blocks we do wind up selecting multiple sometimes).", "author": "ajsutton", "createdAt": "2020-10-28T04:43:46Z", "path": "data/provider/src/main/java/tech/pegasys/teku/api/stateselector/StateSelector.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.api.stateselector;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+\n+public interface StateSelector {\n+  SafeFuture<List<BeaconState>> getState();", "originalCommit": "25d9a7e58218218648c9e564d60dae0cffb9b67d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE4NjE1Ng==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r513186156", "bodyText": "i cant think of any, i was just following the pattern initially, i'll make it just have the optional interface.", "author": "rolfyone", "createdAt": "2020-10-28T05:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3NzM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3NzgzNA==", "url": "https://github.com/ConsenSys/teku/pull/3061#discussion_r513177834", "bodyText": "nit: I think this should just be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return Optional.ofNullable(getStore().getLatestFinalizedBlockAndState().getState());\n          \n          \n            \n                return Optional.of(getStore().getLatestFinalizedBlockAndState().getState());\n          \n      \n    \n    \n  \n\nbecause if we have a store it should have a finalized state.", "author": "ajsutton", "createdAt": "2020-10-28T04:45:16Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -421,6 +421,21 @@ private boolean isRecentData(final UInt64 slot) {\n     return Optional.ofNullable(getStore().getLatestFinalizedBlockAndState().getBlock());\n   }\n \n+  public Optional<BeaconState> getFinalizedState() {\n+    if (recentChainData.isPreGenesis()) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.ofNullable(getStore().getLatestFinalizedBlockAndState().getState());", "originalCommit": "25d9a7e58218218648c9e564d60dae0cffb9b67d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "342e1ce8b03c6c57176d83098bc3bbc46f66dc22", "url": "https://github.com/ConsenSys/teku/commit/342e1ce8b03c6c57176d83098bc3bbc46f66dc22", "message": "cleanup\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-10-28T05:16:27Z", "type": "commit"}, {"oid": "26e019c97f7125fde2e9ed11e2c553694bd019a9", "url": "https://github.com/ConsenSys/teku/commit/26e019c97f7125fde2e9ed11e2c553694bd019a9", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-10-28T05:34:22Z", "type": "commit"}, {"oid": "8ee7a34da5e9cee85b2bc044474ad94dda2a8c95", "url": "https://github.com/ConsenSys/teku/commit/8ee7a34da5e9cee85b2bc044474ad94dda2a8c95", "message": "revert some changes from an earlier commit.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-10-28T05:39:46Z", "type": "commit"}]}