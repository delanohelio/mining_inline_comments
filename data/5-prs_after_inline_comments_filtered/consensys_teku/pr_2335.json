{"pr_number": 2335, "pr_title": "Fix rpc handler close future leak", "pr_createdAt": "2020-07-09T16:26:07Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2335", "timeline": [{"oid": "1e4eb73e46824604d1088d37f9105e3be96270b7", "url": "https://github.com/ConsenSys/teku/commit/1e4eb73e46824604d1088d37f9105e3be96270b7", "message": "Add SafeFuture or() and orInterrupt() methods", "committedDate": "2020-07-09T13:37:25Z", "type": "commit"}, {"oid": "2e226fc5ce493bd6d95e4a1076d3cb82a9782f8e", "url": "https://github.com/ConsenSys/teku/commit/2e226fc5ce493bd6d95e4a1076d3cb82a9782f8e", "message": "Refactor RpcHandler.sendRequest() method to have a cleaner logic and not flood up the potentially long living connection.closeFuture() with dependencies", "committedDate": "2020-07-09T13:39:53Z", "type": "commit"}, {"oid": "4f5fcbd39b2a5e10180199cff07ff2645555d22d", "url": "https://github.com/ConsenSys/teku/commit/4f5fcbd39b2a5e10180199cff07ff2645555d22d", "message": "Add SafeFuture javadocs", "committedDate": "2020-07-09T14:20:04Z", "type": "commit"}, {"oid": "098fecabd232decdc86ee7930f20b9506dc4cbcb", "url": "https://github.com/ConsenSys/teku/commit/098fecabd232decdc86ee7930f20b9506dc4cbcb", "message": "Merge remote-tracking branch 'pegasys/master' into fix-rpc-handler-close-future-leak", "committedDate": "2020-07-09T16:26:30Z", "type": "commit"}, {"oid": "27aae9a095462d94768a7f0e55b8d265fdad9386", "url": "https://github.com/ConsenSys/teku/commit/27aae9a095462d94768a7f0e55b8d265fdad9386", "message": "Fix errorprone warns", "committedDate": "2020-07-09T16:46:57Z", "type": "commit"}, {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226", "url": "https://github.com/ConsenSys/teku/commit/7be46ad3a929e2bb2f7771a892464834ecd41226", "message": "Spotless apply", "committedDate": "2020-07-09T17:05:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MjU5OA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452442598", "bodyText": "Can we just use fut.getNumberOfDependents()?", "author": "mbaxter", "createdAt": "2020-07-09T19:30:08Z", "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");", "originalCommit": "7be46ad3a929e2bb2f7771a892464834ecd41226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwOTk5MA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452809990", "bodyText": "Oh, cool, thanks \ud83d\udc4d  I didn't even think this info is exposed!", "author": "Nashatyrev", "createdAt": "2020-07-10T12:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NjA3MA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452446070", "bodyText": "For readability, I'd probably move these classes out to the bottom of the file.", "author": "mbaxter", "createdAt": "2020-07-09T19:37:32Z", "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");\n+  }\n+\n+  @Test\n+  public void orTest1() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest2() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest3() {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.completeExceptionally(new IllegalStateException());\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest1() throws Exception {\n+    SafeFuture<Integer> interruptorFut = new SafeFuture<>();\n+    Interruptor interruptor =\n+        SafeFuture.createInterruptor(interruptorFut, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor);\n+\n+    assertThat(hasDependents(interruptorFut)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void interruptTest2() throws Exception {\n+    SafeFuture<Integer> interruptorFut1 = new SafeFuture<>();\n+    SafeFuture<Integer> interruptorFut2 = new SafeFuture<>();\n+    Interruptor interruptor1 =\n+        SafeFuture.createInterruptor(interruptorFut1, IllegalStateException::new);\n+    Interruptor interruptor2 =\n+        SafeFuture.createInterruptor(interruptorFut2, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor1, interruptor2);\n+\n+    assertThat(hasDependents(interruptorFut1)).isTrue();\n+    assertThat(hasDependents(interruptorFut2)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    interruptorFut2.complete(0);\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest3() throws Exception {\n+    class AsyncExec {", "originalCommit": "7be46ad3a929e2bb2f7771a892464834ecd41226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NzExNw==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452447117", "bodyText": "I'd probably split these separate test blocks out into separate test functions:  interrupt_chainOfFutures_successful(), interrupt_chainOfFutures_immediatelyInterrupted(), etc.", "author": "mbaxter", "createdAt": "2020-07-09T19:39:39Z", "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");\n+  }\n+\n+  @Test\n+  public void orTest1() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest2() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest3() {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.completeExceptionally(new IllegalStateException());\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest1() throws Exception {\n+    SafeFuture<Integer> interruptorFut = new SafeFuture<>();\n+    Interruptor interruptor =\n+        SafeFuture.createInterruptor(interruptorFut, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor);\n+\n+    assertThat(hasDependents(interruptorFut)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void interruptTest2() throws Exception {\n+    SafeFuture<Integer> interruptorFut1 = new SafeFuture<>();\n+    SafeFuture<Integer> interruptorFut2 = new SafeFuture<>();\n+    Interruptor interruptor1 =\n+        SafeFuture.createInterruptor(interruptorFut1, IllegalStateException::new);\n+    Interruptor interruptor2 =\n+        SafeFuture.createInterruptor(interruptorFut2, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor1, interruptor2);\n+\n+    assertThat(hasDependents(interruptorFut1)).isTrue();\n+    assertThat(hasDependents(interruptorFut2)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    interruptorFut2.complete(0);\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest3() throws Exception {\n+    class AsyncExec {\n+      SafeFuture<Integer> fut = new SafeFuture<>();\n+      boolean executed = false;\n+\n+      SafeFuture<Integer> exec() {\n+        executed = true;\n+        return fut;\n+      }\n+    }\n+\n+    class Test {\n+      SafeFuture<Integer> interruptorFut1 = new SafeFuture<>();\n+      SafeFuture<Integer> interruptorFut2 = new SafeFuture<>();\n+      Interruptor interruptor1 =\n+          SafeFuture.createInterruptor(interruptorFut1, IllegalStateException::new);\n+      Interruptor interruptor2 =\n+          SafeFuture.createInterruptor(interruptorFut2, IllegalArgumentException::new);\n+      SafeFuture<Integer> fut0 = new SafeFuture<>();\n+      AsyncExec exec1 = new AsyncExec();\n+      AsyncExec exec2 = new AsyncExec();\n+\n+      SafeFuture<Integer> intFut =\n+          fut0.orInterrupt(interruptor1, interruptor2)\n+              .thenCompose(__ -> exec1.exec())\n+              .orInterrupt(interruptor1, interruptor2)\n+              .thenCompose(__ -> exec2.exec())\n+              .orInterrupt(interruptor1, interruptor2);\n+\n+      public Test() {\n+        assertThat(hasDependents(interruptorFut1)).isTrue();\n+        assertThat(hasDependents(interruptorFut2)).isTrue();\n+        assertThat(hasDependents(fut0)).isTrue();\n+      }\n+\n+      public void assertReleased() {\n+        assertThat(hasDependents(interruptorFut1)).isFalse();\n+        assertThat(hasDependents(interruptorFut2)).isFalse();\n+        assertThat(hasDependents(fut0)).isFalse();\n+      }\n+    }\n+\n+    {", "originalCommit": "7be46ad3a929e2bb2f7771a892464834ecd41226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODY0Mw==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452448643", "bodyText": "(nit) The generally format we tend to use for unit tests is <methodBeingTested_testCase>, would be nice to update these test names to be more descriptive.  For example:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void interruptTest1() throws Exception {\n          \n          \n            \n              public void orInterrupt_completeWithoutFiringInterrupt() throws Exception {", "author": "mbaxter", "createdAt": "2020-07-09T19:42:37Z", "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");\n+  }\n+\n+  @Test\n+  public void orTest1() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest2() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest3() {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.completeExceptionally(new IllegalStateException());\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest1() throws Exception {", "originalCommit": "7be46ad3a929e2bb2f7771a892464834ecd41226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MzM4MA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452463380", "bodyText": "Doesn't look like we use this - seems reasonable to require a custom exception on interruption ...", "author": "mbaxter", "createdAt": "2020-07-09T20:12:39Z", "path": "util/src/main/java/tech/pegasys/teku/util/async/SafeFuture.java", "diffHunk": "@@ -87,6 +88,47 @@ public static void reportExceptions(final CompletionStage<?> future) {\n     }\n   }\n \n+  /**\n+   * Creates a completed {@link SafeFuture} instance if no of supplied interruptors is completed,\n+   * else creates an exceptionally completed {@link SafeFuture} instance\n+   *\n+   * @see #orInterrupt(Interruptor...)\n+   */\n+  public static SafeFuture<Void> notInterrupted(Interruptor... interruptors) {\n+    return SafeFuture.<Void>completedFuture(null).orInterrupt(interruptors);\n+  }\n+\n+  /**\n+   * Create {@link Interruptor} with default exception supplier which creates {@link\n+   * InterruptedException}\n+   *\n+   * @see #createInterruptor(CompletableFuture, Supplier)\n+   */\n+  public static Interruptor createInterruptor(CompletableFuture<?> interruptFuture) {", "originalCommit": "7be46ad3a929e2bb2f7771a892464834ecd41226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwMDY3NA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452500674", "bodyText": "Given this should never happen, could we log an error if it does instead of ignoring?", "author": "ajsutton", "createdAt": "2020-07-09T21:28:43Z", "path": "util/src/main/java/tech/pegasys/teku/util/async/SafeFuture.java", "diffHunk": "@@ -332,4 +374,84 @@ public void finish(final Consumer<T> onSuccess, final Consumer<Throwable> onErro\n   public SafeFuture<T> orTimeout(final long timeout, final TimeUnit unit) {\n     return (SafeFuture<T>) super.orTimeout(timeout, unit);\n   }\n+\n+  @SafeVarargs\n+  @SuppressWarnings(\"unchecked\")\n+  public final SafeFuture<T> or(SafeFuture<T>... others) {\n+    SafeFuture<T>[] futures = Arrays.copyOf(others, others.length + 1);\n+    futures[others.length] = this;\n+    return anyOf(futures).thenApply(o -> (T) o);\n+  }\n+\n+  /**\n+   * Derives a {@link SafeFuture} which yields the same result as this {@link SafeFuture} if no\n+   * {@link Interruptor} was triggered before this future is done.\n+   *\n+   * <p>If any of supplied {@link Interruptor}s is triggered the returned {@link SafeFuture} is\n+   * completed exceptionally. The exception thrown depends on which specific Interruptor was\n+   * triggered\n+   *\n+   * <p>The key feature of this method is that {@code interruptFuture} contained in Interruptor\n+   * doesn't hold the reference to dependent futures after they complete. It's desired to consider\n+   * this for long living interrupting futures to avoid memory leaks\n+   *\n+   * @param interruptors a set of interruptors which futures trigger interruption if complete\n+   *     (normally or exceptionally)\n+   * @see #createInterruptor(CompletableFuture, Supplier)\n+   */\n+  public SafeFuture<T> orInterrupt(Interruptor... interruptors) {\n+    CompletableFuture<?>[] allFuts = new CompletableFuture<?>[interruptors.length + 1];\n+    allFuts[0] = this;\n+    for (int i = 0; i < interruptors.length; i++) {\n+      allFuts[i + 1] = interruptors[i].interruptFuture;\n+    }\n+    SafeFuture<T> ret = new SafeFuture<>();\n+    anyOf(allFuts)\n+        .whenComplete(\n+            (res, err) -> {\n+              if (this.isDone()) {\n+                this.propagateTo(ret);\n+              } else {\n+                for (Interruptor interruptor : interruptors) {\n+                  if (interruptor.interruptFuture.isDone()) {\n+                    try {\n+                      interruptor.getInterruptFuture().get();\n+                      ret.completeExceptionally(interruptor.getExceptionSupplier().get());\n+                    } catch (Exception e) {\n+                      ret.completeExceptionally(e);\n+                    }\n+                  }\n+                }\n+              }\n+            })\n+        .exceptionally(e -> null); // all exceptions are propagated to ret", "originalCommit": "7be46ad3a929e2bb2f7771a892464834ecd41226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMzUwMA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452823500", "bodyText": "This is similar to SafeFuture.propagate in the sense that any exception is propagated to the returned future. So if anyOf completes exceptionally this is a regular situation on this level.\nSame as SafeFuture.propagate added SuppressWarning with explanation comment", "author": "Nashatyrev", "createdAt": "2020-07-10T12:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwMDY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwODkyOQ==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452508929", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Creates a completed {@link SafeFuture} instance if no of supplied interruptors is completed,\n          \n          \n            \n               * Creates a completed {@link SafeFuture} instance if none of the supplied interruptors are completed,", "author": "ajsutton", "createdAt": "2020-07-09T21:47:27Z", "path": "util/src/main/java/tech/pegasys/teku/util/async/SafeFuture.java", "diffHunk": "@@ -87,6 +88,47 @@ public static void reportExceptions(final CompletionStage<?> future) {\n     }\n   }\n \n+  /**\n+   * Creates a completed {@link SafeFuture} instance if no of supplied interruptors is completed,", "originalCommit": "7be46ad3a929e2bb2f7771a892464834ecd41226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "616a6b649a284fc66eddc423c6c288b38a2f4b52", "url": "https://github.com/ConsenSys/teku/commit/616a6b649a284fc66eddc423c6c288b38a2f4b52", "message": "Move test classes out of method", "committedDate": "2020-07-10T12:27:38Z", "type": "commit"}, {"oid": "8857d3387399a1356e964c26bb7099274aaa00d7", "url": "https://github.com/ConsenSys/teku/commit/8857d3387399a1356e964c26bb7099274aaa00d7", "message": "Split and rename tests", "committedDate": "2020-07-10T12:34:24Z", "type": "commit"}, {"oid": "0fd75183daee34cf991f49898b580015df4fce86", "url": "https://github.com/ConsenSys/teku/commit/0fd75183daee34cf991f49898b580015df4fce86", "message": "Remove unused method", "committedDate": "2020-07-10T12:35:36Z", "type": "commit"}, {"oid": "963187eea9bd27db8254adfcfc2a6756d2dd06fa", "url": "https://github.com/ConsenSys/teku/commit/963187eea9bd27db8254adfcfc2a6756d2dd06fa", "message": "Fix the doc wording\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-07-10T12:36:32Z", "type": "commit"}, {"oid": "97bae5a8394ac845e7b1ad05c4b1810147485a92", "url": "https://github.com/ConsenSys/teku/commit/97bae5a8394ac845e7b1ad05c4b1810147485a92", "message": "Merge branch 'fix-rpc-handler-close-future-leak' of https://github.com/Nashatyrev/artemis into fix-rpc-handler-close-future-leak", "committedDate": "2020-07-10T12:36:47Z", "type": "commit"}, {"oid": "2d459fb2702ff673e34e9ccdeb7227dca1e54b23", "url": "https://github.com/ConsenSys/teku/commit/2d459fb2702ff673e34e9ccdeb7227dca1e54b23", "message": "Add FutureReturnValueIgnored warning suppress with comment", "committedDate": "2020-07-10T12:49:23Z", "type": "commit"}, {"oid": "a6f5d4afcfee286fcfd05702f17cedcc35da1b9d", "url": "https://github.com/ConsenSys/teku/commit/a6f5d4afcfee286fcfd05702f17cedcc35da1b9d", "message": "Spotless apply", "committedDate": "2020-07-10T12:53:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r453711189", "bodyText": "If an interrupt fires, don't we still need to close the controller?", "author": "mbaxter", "createdAt": "2020-07-13T14:56:23Z", "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -58,53 +59,28 @@ public RpcHandler(final AsyncRunner asyncRunner, RpcMethod rpcMethod) {\n   @SuppressWarnings(\"unchecked\")\n   public SafeFuture<RpcStream> sendRequest(\n       Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n-    if (connection.closeFuture().isDone()) {\n-      return SafeFuture.failedFuture(new PeerDisconnectedException());\n-    }\n \n-    SafeFuture<RpcStream> streamFuture = new SafeFuture<>();\n+    Interruptor closeInterruptor =\n+        SafeFuture.createInterruptor(connection.closeFuture(), PeerDisconnectedException::new);\n+    Interruptor timeoutInterruptor =\n+        SafeFuture.createInterruptor(\n+            asyncRunner.getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS),\n+            () ->\n+                new StreamTimeoutException(\n+                    \"Timed out waiting to initialize stream for method \" + rpcMethod.getId()));\n \n-    // Complete future if peer disconnects\n-    SafeFuture.of(connection.closeFuture())\n-        .always(() -> streamFuture.completeExceptionally(new PeerDisconnectedException()));\n-    // Complete future if we fail to initialize\n-    asyncRunner\n-        .getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)\n-        .thenAccept(\n-            __ ->\n-                streamFuture.completeExceptionally(\n-                    new StreamTimeoutException(\n-                        \"Timed out waiting to initialize stream for method \" + rpcMethod.getId())))\n-        .reportExceptions();\n-\n-    // Try to initiate stream\n-    SafeFuture.of(\n-            connection\n-                .muxerSession()\n-                .createStream(Multistream.create(this).toStreamHandler())\n-                .getController())\n+    return SafeFuture.notInterrupted(closeInterruptor)\n         .thenCompose(\n-            ctr -> {\n-              ctr.setRequestHandler(handler);\n-              return ctr.getRpcStream()\n-                  .writeBytes(initialPayload)\n-                  .thenApply(f -> ctr.getRpcStream())\n-                  .thenAccept(\n-                      rpcStream -> {\n-                        if (!streamFuture.complete(rpcStream)) {\n-                          // If future was already completed exceptionally, close the controller\n-                          ctr.close();\n-                        }\n-                      });\n-            })\n-        .exceptionally(\n-            err -> {\n-              streamFuture.completeExceptionally(err);\n-              return null;\n-            })\n-        .reportExceptions();\n-\n-    return streamFuture;\n+            __ ->\n+                connection\n+                    .muxerSession()\n+                    .createStream(Multistream.create(this).toStreamHandler())\n+                    .getController())\n+        .orInterrupt(closeInterruptor, timeoutInterruptor)", "originalCommit": "a6f5d4afcfee286fcfd05702f17cedcc35da1b9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NjQ4MA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r454486480", "bodyText": "The controller is anyway closed this or that way, but probably you are right it should be closed here explicitly.\nI'll get back to this as soon as sort out this NPE I posted below. It appeared a bit tricky", "author": "Nashatyrev", "createdAt": "2020-07-14T16:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1MDM3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455150376", "bodyText": "Fixed this by closing the stream, since the controller could be still not created. The Controller.close() should anyway be invoked on Stream.close", "author": "Nashatyrev", "createdAt": "2020-07-15T15:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI0NjYxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455246619", "bodyText": "It seems pretty unlikely we'll actually hit this, but isn't it still possible for us to leave a dangling stream open here if the timeout interrupts before getStream resolves?", "author": "mbaxter", "createdAt": "2020-07-15T18:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NzEwOA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455297108", "bodyText": "It is possible in theory, but the stream is mostly created synchronously (when connection is active) so this situation seems pretty unlikely. In practice this situation can be assumed neglectable, though yes, strictly speaking in theory this is an issue.", "author": "Nashatyrev", "createdAt": "2020-07-15T19:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjA1MA==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455336050", "bodyText": "Would be nice to close this loophole somehow, but I'll leave it up to you if you think we'll never actually hit this case.", "author": "mbaxter", "createdAt": "2020-07-15T20:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ=="}], "type": "inlineReview"}, {"oid": "a013b3efd416279868ba62f3a6c09180ba7c6bfa", "url": "https://github.com/ConsenSys/teku/commit/a013b3efd416279868ba62f3a6c09180ba7c6bfa", "message": "Merge remote-tracking branch 'pegasys/master' into fix-rpc-handler-close-future-leak", "committedDate": "2020-07-13T15:36:29Z", "type": "commit"}, {"oid": "4beacd40b5f5310f932c202f05113021b1c10923", "url": "https://github.com/ConsenSys/teku/commit/4beacd40b5f5310f932c202f05113021b1c10923", "message": "Merge remote-tracking branch 'pegasys/master' into fix-rpc-handler-close-future-leak", "committedDate": "2020-07-15T10:38:10Z", "type": "commit"}, {"oid": "1a67626f3b63bb0e18351ee4090885827c1ff7c4", "url": "https://github.com/ConsenSys/teku/commit/1a67626f3b63bb0e18351ee4090885827c1ff7c4", "message": "When sending RPC request close the created stream if any exception or interruption occurs while sending initial payload", "committedDate": "2020-07-15T10:38:45Z", "type": "commit"}, {"oid": "ba108a5453dc0ea80e9e6b5513ebad45a4321c29", "url": "https://github.com/ConsenSys/teku/commit/ba108a5453dc0ea80e9e6b5513ebad45a4321c29", "message": "Fix SafeFuture.notInterrupted. Add a test", "committedDate": "2020-07-15T14:51:23Z", "type": "commit"}, {"oid": "d392fc5704a647b2aa714c6bc961237e409811ed", "url": "https://github.com/ConsenSys/teku/commit/d392fc5704a647b2aa714c6bc961237e409811ed", "message": "Add RpcHandlerTest", "committedDate": "2020-07-15T15:15:33Z", "type": "commit"}, {"oid": "a0f9f0f1e53b65ec9e5b57b2a8a2f2f9d0e4b3ce", "url": "https://github.com/ConsenSys/teku/commit/a0f9f0f1e53b65ec9e5b57b2a8a2f2f9d0e4b3ce", "message": "Apply spotless", "committedDate": "2020-07-15T15:16:15Z", "type": "commit"}, {"oid": "c0be43c495455dde851d8c7aefc84cb9e5078dcc", "url": "https://github.com/ConsenSys/teku/commit/c0be43c495455dde851d8c7aefc84cb9e5078dcc", "message": "Resolve unhandled future warning", "committedDate": "2020-07-15T17:15:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NzAyNg==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455257026", "bodyText": "nice! \ud83c\udf89", "author": "mbaxter", "createdAt": "2020-07-15T18:29:11Z", "path": "networking/p2p/src/test/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandlerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.p2p.libp2p.rpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.Stream;\n+import io.libp2p.core.StreamPromise;\n+import io.libp2p.core.mux.StreamMuxer.Session;\n+import java.util.concurrent.CompletableFuture;\n+import kotlin.Unit;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.teku.networking.p2p.peer.PeerDisconnectedException;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.teku.networking.p2p.rpc.StreamTimeoutException;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.async.StubAsyncRunner;\n+\n+public class RpcHandlerTest {", "originalCommit": "c0be43c495455dde851d8c7aefc84cb9e5078dcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NzI2NQ==", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455257265", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n          \n          \n            \n                assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n          \n          \n            \n                verify(stream).close();", "author": "mbaxter", "createdAt": "2020-07-15T18:29:31Z", "path": "networking/p2p/src/test/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandlerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.p2p.libp2p.rpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.Stream;\n+import io.libp2p.core.StreamPromise;\n+import io.libp2p.core.mux.StreamMuxer.Session;\n+import java.util.concurrent.CompletableFuture;\n+import kotlin.Unit;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.teku.networking.p2p.peer.PeerDisconnectedException;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.teku.networking.p2p.rpc.StreamTimeoutException;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.async.StubAsyncRunner;\n+\n+public class RpcHandlerTest {\n+\n+  StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+  RpcMethod rpcMethod = mock(RpcMethod.class);\n+  RpcHandler rpcHandler = new RpcHandler(asyncRunner, rpcMethod);\n+\n+  Connection connection = mock(Connection.class);\n+  Session session = mock(Session.class);\n+  StreamPromise<Object> streamPromise =\n+      new StreamPromise<>(new CompletableFuture<>(), new CompletableFuture<>());\n+  CompletableFuture<Unit> closeFuture = new CompletableFuture<>();\n+  SafeFuture<Void> writeFuture = new SafeFuture<>();\n+\n+  Stream stream = mock(Stream.class);\n+  Controller controller = mock(Controller.class);\n+  RpcStream rpcStream = mock(RpcStream.class);\n+  RpcRequestHandler rpcRequestHandler = mock(RpcRequestHandler.class);\n+\n+  @BeforeEach\n+  void init() {\n+    when(connection.muxerSession()).thenReturn(session);\n+    when(session.createStream(any())).thenReturn(streamPromise);\n+    when(connection.closeFuture()).thenReturn(closeFuture);\n+\n+    when(controller.getRpcStream()).thenReturn(rpcStream);\n+    when(rpcStream.writeBytes(any())).thenReturn(writeFuture);\n+  }\n+\n+  @Test\n+  void sendRequest_positiveCase() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    assertThat(future).isNotDone();\n+    streamPromise.getStream().complete(stream);\n+\n+    assertThat(future).isNotDone();\n+    streamPromise.getController().complete(controller);\n+\n+    assertThat(future).isNotDone();\n+    writeFuture.complete(null);\n+\n+    verify(stream, never()).close();\n+    verify(controller, never()).close();\n+    assertThat(future).isCompletedWithValue(rpcStream);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+\n+    // interrupting after completion shouldn't affect anything\n+    closeFuture.complete(null);\n+\n+    verify(stream, never()).close();\n+    verify(controller, never()).close();\n+    assertThat(future).isCompletedWithValue(rpcStream);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_streamClosedWhenConnectionClosedBeforeController() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    streamPromise.getStream().complete(stream);\n+    closeFuture.complete(null);\n+\n+    verify(connection).muxerSession();\n+    verify(controller, never()).getRpcStream();\n+\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(PeerDisconnectedException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_streamClosedWhenConnectionClosedBeforeWrite() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    streamPromise.getStream().complete(stream);\n+    streamPromise.getController().complete(controller);\n+    closeFuture.complete(null);\n+\n+    verify(connection).muxerSession();\n+    verify(controller).getRpcStream();\n+    verify(rpcStream).writeBytes(any());\n+\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(PeerDisconnectedException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_noStreamCreationWhenInitiallyClosed() {\n+    closeFuture.complete(null);\n+\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    verify(connection, never()).muxerSession();\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(PeerDisconnectedException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_streamClosedOnTimeoutBeforeController() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    streamPromise.getStream().complete(stream);\n+    asyncRunner.executeQueuedActions();\n+\n+    verify(connection).muxerSession();\n+    verify(controller, never()).getRpcStream();\n+\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(StreamTimeoutException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);", "originalCommit": "c0be43c495455dde851d8c7aefc84cb9e5078dcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1cbacb7c4ce2cc731386bacd323118fcfd76c3a4", "url": "https://github.com/ConsenSys/teku/commit/1cbacb7c4ce2cc731386bacd323118fcfd76c3a4", "message": "Check that stream was closed in tests", "committedDate": "2020-07-15T19:46:53Z", "type": "commit"}]}