{"pr_number": 1217, "pr_title": "#1161: WIP PR for beacon/block.", "pr_createdAt": "2020-02-23T23:28:50Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1217", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1MjIyMA==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383052220", "bodyText": "nit: we should probably alpha order the endpoints by class name now, so they're easier to find later..", "author": "rolfyone", "createdAt": "2020-02-23T23:54:51Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/BeaconRestApi.java", "diffHunk": "@@ -146,9 +146,9 @@ private void addBeaconHandlers(\n     app.get(\n         BeaconChainHeadHandler.ROUTE, new BeaconChainHeadHandler(chainStorageClient, jsonProvider));\n     app.get(BeaconStateHandler.ROUTE, new BeaconStateHandler(chainStorageClient, jsonProvider));\n-    // TODO: not in Minimal or optional specified set - some are similar to lighthouse\n-    // implementation\n-    handlers.add(new BeaconBlockHandler(chainStorageClient, historicalChainData));\n+    app.get(", "originalCommit": "5040d0fc36c4a2978a549d16132dc6ba8e5c31a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1MjI2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383052266", "bodyText": "remove annotation @NotNull", "author": "rolfyone", "createdAt": "2020-02-23T23:55:30Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,57 +13,71 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n   @Override\n-  public String getPath() {\n-    return \"/beacon/block\";\n-  }\n-\n-  @Override\n-  public Object handleRequest(RequestParams param) {\n-    Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n+  public void handle(@NotNull Context ctx) throws Exception {", "originalCommit": "5040d0fc36c4a2978a549d16132dc6ba8e5c31a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1MjYxMQ==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383052611", "bodyText": "If the block doesn't exist this might get ugly, we might have to do the getBlock, check if its not null, then encode or 404...\na test case around this will show us if its an issue...", "author": "rolfyone", "createdAt": "2020-02-23T23:59:12Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,57 +13,71 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n   @Override\n-  public String getPath() {\n-    return \"/beacon/block\";\n-  }\n-\n-  @Override\n-  public Object handleRequest(RequestParams param) {\n-    Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n+  public void handle(@NotNull Context ctx) throws Exception {\n+    final Map<String, List<String>> queryParamMap = ctx.queryParamMap();\n     if (queryParamMap.containsKey(\"root\")) {\n-      Bytes32 root = Bytes32.fromHexString(param.getQueryParam(\"root\"));\n-      return client.getStore() != null ? client.getStore().getBlock(root) : null;\n+      final Bytes32 root = Bytes32.fromHexString(queryParamMap.get(\"root\").get(0));\n+      if (client.getStore() != null) {\n+        ctx.result(\n+            jsonProvider.objectToJSON(new BeaconBlockResponse(client.getStore().getBlock(root))));", "originalCommit": "5040d0fc36c4a2978a549d16132dc6ba8e5c31a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2NjQ0Mw==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383066443", "bodyText": "I'm thinking this could be where my current fail is.  Will investigate.", "author": "mark-terry", "createdAt": "2020-02-24T02:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1MjYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1NzM2OA==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383057368", "bodyText": "shouldReturnNotFoundWhenParametersNotSpecified\nThis is a similar use case to #1218, at least yours is returning a 404, not 500. could potentially return a 400 in this use case...", "author": "rolfyone", "createdAt": "2020-02-24T00:51:38Z", "path": "data/beaconrestapi/src/test/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandlerTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n+\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.javalin.http.Context;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.provider.JsonProvider;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class BeaconBlockHandlerTest {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final ChainStorageClient storageClient = mock(ChainStorageClient.class);\n+  private final HistoricalChainData historicalChainData = mock(HistoricalChainData.class);\n+  private final Store store = mock(Store.class);\n+  private final Bytes32 blockRoot = Bytes32.random();\n+  private final Context context = mock(Context.class);\n+\n+  private final SignedBeaconBlock signedBeaconBlock =\n+      DataStructureUtil.randomSignedBeaconBlock(1, 1);\n+  private final BeaconBlock beaconBlock = signedBeaconBlock.getMessage();\n+  private final BeaconBlockHandler handler =\n+      new BeaconBlockHandler(storageClient, historicalChainData, jsonProvider);\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenRootQueryAndStoreNull() throws Exception {\n+    final String rootKey = \"0xf22e4ec2\";\n+    final Map<String, List<String>> params = Map.of(\"root\", List.of(rootKey));\n+\n+    when(storageClient.getStore()).thenReturn(null);\n+    when(context.queryParamMap()).thenReturn(params);\n+\n+    handler.handle(context);\n+\n+    verify(context).status(SC_NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenValidParamNotSpecified() throws Exception {", "originalCommit": "5040d0fc36c4a2978a549d16132dc6ba8e5c31a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "865fe74046d61abab77a869bdd790a0f9adf5056", "url": "https://github.com/ConsenSys/teku/commit/865fe74046d61abab77a869bdd790a0f9adf5056", "message": "#1161: PR improvements.", "committedDate": "2020-02-24T13:12:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MTc2OA==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383551768", "bodyText": "the beacon chain block?", "author": "macfarla", "createdAt": "2020-02-24T22:26:14Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,68 +13,117 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n-import java.util.Map;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return a specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return a beacon chain block that matches the provided criteria.\",", "originalCommit": "64fb34f0b82b82185906bcdb3db4fb06427a4f43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MjAwMw==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383552003", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @OpenApiResponse(status = \"400\", description = \"Invalid parameters supplied\"),\n          \n          \n            \n                    @OpenApiResponse(status = \"400\", description = \"Invalid parameter supplied\"),", "author": "macfarla", "createdAt": "2020-02-24T22:26:45Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,68 +13,117 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n-import java.util.Map;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return a specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return a beacon chain block that matches the provided criteria.\",\n+      responses = {\n+        @OpenApiResponse(\n+            status = \"200\",\n+            content = @OpenApiContent(from = BeaconBlockResponse.class)),\n+        @OpenApiResponse(status = \"400\", description = \"Invalid parameters supplied\"),", "originalCommit": "64fb34f0b82b82185906bcdb3db4fb06427a4f43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MjQ4OQ==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383552489", "bodyText": "do we want to give any more info eg one of root or epoch or slot", "author": "macfarla", "createdAt": "2020-02-24T22:27:52Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,68 +13,117 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n-import java.util.Map;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return a specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return a beacon chain block that matches the provided criteria.\",\n+      responses = {\n+        @OpenApiResponse(\n+            status = \"200\",\n+            content = @OpenApiContent(from = BeaconBlockResponse.class)),\n+        @OpenApiResponse(status = \"400\", description = \"Invalid parameters supplied\"),\n+        @OpenApiResponse(status = \"404\", description = \"Specified block not found\")\n+      })\n   @Override\n-  public String getPath() {\n-    return \"/beacon/block\";\n-  }\n+  public void handle(final Context ctx) throws Exception {\n+    try {\n+      if (ctx.queryParamMap().size() > 1) {\n+        throw new IllegalArgumentException(\n+            \"Too many query parameters specified. Please supply only one.\");", "originalCommit": "64fb34f0b82b82185906bcdb3db4fb06427a4f43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1NjA0MA==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383556040", "bodyText": "add a string constant for these, then we can reference them from tests and from here. something like EPOCH_PARAMETER or EPOCH", "author": "rolfyone", "createdAt": "2020-02-24T22:36:26Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,68 +13,117 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n-import java.util.Map;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return a specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),", "originalCommit": "64fb34f0b82b82185906bcdb3db4fb06427a4f43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1NzY3OQ==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383557679", "bodyText": "probably should try to be consistent with the pattern, either when.thenReturn or doReturn.when...", "author": "rolfyone", "createdAt": "2020-02-24T22:40:40Z", "path": "data/beaconrestapi/src/test/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandlerTest.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.empty;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.javalin.http.Context;\n+import io.javalin.http.util.ContextUtil;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.provider.JsonProvider;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class BeaconBlockHandlerTest {\n+  private static final BadRequest BAD_REQUEST =\n+      new BadRequest(\n+          SC_BAD_REQUEST, \"Query parameter missing. Must specify one of root or epoch or slot.\");\n+\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final ChainStorageClient storageClient = mock(ChainStorageClient.class);\n+  private final HistoricalChainData historicalChainData = mock(HistoricalChainData.class);\n+  private final Store store = mock(Store.class);\n+  private final Bytes32 blockRoot = Bytes32.random();\n+  private final Context context = mock(Context.class);\n+\n+  private final SignedBeaconBlock signedBeaconBlock =\n+      DataStructureUtil.randomSignedBeaconBlock(1, 1);\n+  private final BeaconBlockHandler handler =\n+      new BeaconBlockHandler(storageClient, historicalChainData, jsonProvider);\n+  private final Context realContext =\n+      spy(ContextUtil.init(mock(HttpServletRequest.class), mock(HttpServletResponse.class)));\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenRootQueryAndStoreNull() throws Exception {\n+    final String rootKey = \"0xf22e4ec2\";\n+    final Map<String, List<String>> params = Map.of(\"root\", List.of(rootKey));\n+\n+    when(storageClient.getStore()).thenReturn(null);\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(rootKey);\n+\n+    handler.handle(context);\n+\n+    verify(context).result(jsonProvider.objectToJSON(BAD_REQUEST));\n+  }\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenValidParamNotSpecified() throws Exception {\n+    handler.handle(context);\n+    verify(context).result(jsonProvider.objectToJSON(BAD_REQUEST));\n+  }\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenEpochQueryAndBlockNotFound() throws Exception {\n+    final String epochNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"epoch\", List.of(epochNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(epochNum);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(Optional.of(blockRoot));\n+    when(storageClient.getStore()).thenReturn(store);\n+    when(store.getBlock(any())).thenReturn(null);\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(empty()));\n+\n+    handler.handle(context);\n+\n+    verify(context).status(SC_NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenSlotQueryAndBlockNotFound() throws Exception {\n+    final String slotNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"slot\", List.of(slotNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(slotNum);\n+    when(storageClient.getStore()).thenReturn(store);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(Optional.of(blockRoot));\n+    when(store.getBlock(any())).thenReturn(null);\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(empty()));\n+\n+    handler.handle(context);\n+\n+    verify(context).status(SC_NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenEpochQueryAndNoBlockRootAndBlockNotFound() throws Exception {\n+    final String epochNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"epoch\", List.of(epochNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(epochNum);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(empty());\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(empty()));\n+\n+    handler.handle(context);\n+\n+    verify(context).status(SC_NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldReturnNotFoundWhenSlotQueryAndNoBlockRootAndBlockNotFound() throws Exception {\n+    final String slotNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"slot\", List.of(slotNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(slotNum);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(empty());\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(empty()));\n+\n+    handler.handle(context);\n+\n+    verify(context).status(SC_NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldReturnBlockWhenRootParamSpecified() throws Exception {\n+    final String hash = signedBeaconBlock.getParent_root().toHexString();\n+    final Map<String, List<String>> params = Map.of(\"root\", List.of(hash));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(hash);\n+    when(storageClient.getStore()).thenReturn(store);\n+    when(store.getSignedBlock(any())).thenReturn(signedBeaconBlock);\n+\n+    handler.handle(context);\n+\n+    final String jsonResponse =\n+        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n+    verify(context).result(jsonResponse);\n+  }\n+\n+  @Test\n+  public void shouldReturnBlockWhenEpochQuery() throws Exception {\n+    final String epochNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"epoch\", List.of(epochNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(epochNum);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(Optional.of(blockRoot));\n+    when(storageClient.getStore()).thenReturn(store);\n+    when(store.getSignedBlock(any())).thenReturn(signedBeaconBlock);\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(empty()));\n+\n+    handler.handle(context);\n+\n+    final String jsonResponse =\n+        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n+    verify(context).result(jsonResponse);\n+  }\n+\n+  @Test\n+  public void shouldReturnBlockWhenSlotQuery() throws Exception {\n+    final String slotNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"slot\", List.of(slotNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(slotNum);\n+    when(storageClient.getStore()).thenReturn(store);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(Optional.of(blockRoot));\n+    when(store.getSignedBlock(any())).thenReturn(signedBeaconBlock);\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(empty()));\n+\n+    handler.handle(context);\n+\n+    final String jsonResponse =\n+        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n+    verify(context).result(jsonResponse);\n+  }\n+\n+  @Test\n+  public void shouldReturnBlockWhenEpochQueryAndNoBlockRoot() throws Exception {\n+    final String epochNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"epoch\", List.of(epochNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(epochNum);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(empty());\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(signedBeaconBlock)));\n+\n+    handler.handle(context);\n+\n+    final String jsonResponse =\n+        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n+    verify(context).result(jsonResponse);\n+  }\n+\n+  @Test\n+  public void shouldReturnBlockWhenSlotQueryAndNoBlockRoot() throws Exception {\n+    final String slotNum = \"1\";\n+    final Map<String, List<String>> params = Map.of(\"slot\", List.of(slotNum));\n+\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(slotNum);\n+    when(storageClient.getBlockRootBySlot(any())).thenReturn(empty());\n+    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(signedBeaconBlock)));\n+\n+    handler.handle(context);\n+\n+    final String jsonResponse =\n+        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n+    verify(context).result(jsonResponse);\n+  }\n+\n+  @Test\n+  public void shouldFailWhenNoParams() throws Exception {\n+    handler.handle(realContext);\n+\n+    final String actualResponse = realContext.resultString();\n+    final String expectedResponse = jsonProvider.objectToJSON(BAD_REQUEST);\n+\n+    assertThat(actualResponse).isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void shouldFailWithEmptyRootParamValue() throws Exception {\n+    final Map<String, List<String>> params = Map.of(\"root\", emptyList());\n+\n+    doReturn(params).when(realContext).queryParamMap();", "originalCommit": "64fb34f0b82b82185906bcdb3db4fb06427a4f43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5ODI0MQ==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383598241", "bodyText": "realContext is a spy(), which (IIRC) requires the doReturn pattern due to evaluation order.", "author": "mark-terry", "createdAt": "2020-02-25T00:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1NzY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NjU4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r383586581", "bodyText": "validateParams\nLets make this static and in a shared lib, it'll be used a lot.", "author": "rolfyone", "createdAt": "2020-02-25T00:03:19Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,68 +13,117 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n-import java.util.Map;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return a specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return a beacon chain block that matches the provided criteria.\",\n+      responses = {\n+        @OpenApiResponse(\n+            status = \"200\",\n+            content = @OpenApiContent(from = BeaconBlockResponse.class)),\n+        @OpenApiResponse(status = \"400\", description = \"Invalid parameters supplied\"),\n+        @OpenApiResponse(status = \"404\", description = \"Specified block not found\")\n+      })\n   @Override\n-  public String getPath() {\n-    return \"/beacon/block\";\n-  }\n+  public void handle(final Context ctx) throws Exception {\n+    try {\n+      if (ctx.queryParamMap().size() > 1) {\n+        throw new IllegalArgumentException(\n+            \"Too many query parameters specified. Please supply only one.\");\n+      }\n \n-  @Override\n-  public Object handleRequest(RequestParams param) {\n-    Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    if (queryParamMap.containsKey(\"root\")) {\n-      Bytes32 root = Bytes32.fromHexString(param.getQueryParam(\"root\"));\n-      return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    }\n+      if (ctx.queryParamMap().containsKey(\"root\")) {\n+        final Bytes32 root = Bytes32.fromHexString(validateParms(ctx, \"root\"));\n+        if (client.getStore() != null) {\n+          final SignedBeaconBlock block = client.getStore().getSignedBlock(root);\n+          if (block != null) {\n+            ctx.result(jsonProvider.objectToJSON(new BeaconBlockResponse(block)));\n+            return;\n+          }\n+          ctx.status(SC_NOT_FOUND);\n+          return;\n+        }\n+      }\n \n-    UnsignedLong slot;\n-    if (queryParamMap.containsKey(\"epoch\")) {\n-      slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(param.getQueryParam(\"epoch\")));\n-    } else if (queryParamMap.containsKey(\"slot\")) {\n-      slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n-    } else {\n-      return null;\n-    }\n+      final UnsignedLong slot;\n+      if (ctx.queryParamMap().containsKey(\"epoch\")) {\n+        slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(validateParms(ctx, \"epoch\")));\n+      } else if (ctx.queryParamMap().containsKey(\"slot\")) {\n+        slot = UnsignedLong.valueOf(validateParms(ctx, \"slot\"));\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Query parameter missing. Must specify one of root or epoch or slot.\");\n+      }\n \n-    return getBlockBySlot(slot)\n-        .map(\n-            block ->\n-                ImmutableMap.of(\"block\", block, \"blockRoot\", block.hash_tree_root().toHexString()))\n-        .orElse(null);\n+      final Optional<SignedBeaconBlock> blockBySlot = getBlockBySlot(slot);\n+      if (blockBySlot.isPresent()) {\n+        ctx.result(jsonProvider.objectToJSON(new BeaconBlockResponse(blockBySlot.get())));\n+        return;\n+      }\n+      ctx.status(SC_NOT_FOUND);\n+    } catch (final IllegalArgumentException e) {\n+      ctx.result(jsonProvider.objectToJSON(new BadRequest(SC_BAD_REQUEST, e.getMessage())));\n+    }\n   }\n \n-  private Optional<BeaconBlock> getBlockBySlot(UnsignedLong slot) {\n+  private Optional<SignedBeaconBlock> getBlockBySlot(final UnsignedLong slot) {\n     return client\n         .getBlockRootBySlot(slot)\n-        .map(root -> client.getStore().getBlock(root))\n-        .or(\n-            () -> {\n-              Optional<SignedBeaconBlock> signedBeaconBlock =\n-                  historicalChainData.getFinalizedBlockAtSlot(slot).join();\n-              return signedBeaconBlock.map(SignedBeaconBlock::getMessage);\n-            });\n-  };\n+        .map(root -> client.getStore().getSignedBlock(root))\n+        .or(() -> historicalChainData.getFinalizedBlockAtSlot(slot).join());\n+  }\n+\n+  private String validateParms(final Context ctx, final String key) {", "originalCommit": "64fb34f0b82b82185906bcdb3db4fb06427a4f43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "03184079236476d5fb80cdc547c8aeaf102e59df", "url": "https://github.com/ConsenSys/teku/commit/03184079236476d5fb80cdc547c8aeaf102e59df", "message": "#1161: WIP PR for beacon/block.", "committedDate": "2020-02-26T13:54:38Z", "type": "commit"}, {"oid": "526ff2cf197b7a4c2208bac2563b08743dc1b404", "url": "https://github.com/ConsenSys/teku/commit/526ff2cf197b7a4c2208bac2563b08743dc1b404", "message": "#1161: PR suggestions.", "committedDate": "2020-02-26T13:55:54Z", "type": "commit"}, {"oid": "32f43c1b91ab2fcbfd1b682122e182d2e5d5f5b7", "url": "https://github.com/ConsenSys/teku/commit/32f43c1b91ab2fcbfd1b682122e182d2e5d5f5b7", "message": "#1161: Migrated return to SignedBeaconBlock.", "committedDate": "2020-02-26T13:55:55Z", "type": "commit"}, {"oid": "aa956d7c6af5a837c5fe06474692edc1e119399d", "url": "https://github.com/ConsenSys/teku/commit/aa956d7c6af5a837c5fe06474692edc1e119399d", "message": "#1161: PR improvements.", "committedDate": "2020-02-26T13:58:22Z", "type": "commit"}, {"oid": "b11a5f2e2d2a06e6b1fcebf9124a65849781a8de", "url": "https://github.com/ConsenSys/teku/commit/b11a5f2e2d2a06e6b1fcebf9124a65849781a8de", "message": "#1161: Added OpenAPI annotation.", "committedDate": "2020-02-26T13:58:22Z", "type": "commit"}, {"oid": "40d0c4a015ff0d3b73f24e7694895cf1a987216f", "url": "https://github.com/ConsenSys/teku/commit/40d0c4a015ff0d3b73f24e7694895cf1a987216f", "message": "#1161: Added parameter map size validation.", "committedDate": "2020-02-26T13:59:35Z", "type": "commit"}, {"oid": "d1f3ad5eb1930497cc3c00763487569c5bd150b2", "url": "https://github.com/ConsenSys/teku/commit/d1f3ad5eb1930497cc3c00763487569c5bd150b2", "message": "Update data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java\r\n\r\nPR fix.\n\nCo-Authored-By: Sally MacFarlane <sally.macfarlane@consensys.net>", "committedDate": "2020-02-26T13:59:35Z", "type": "commit"}, {"oid": "bea31965f7865e7f48e546f1585c0c3296113187", "url": "https://github.com/ConsenSys/teku/commit/bea31965f7865e7f48e546f1585c0c3296113187", "message": "#1161: PR fixes, updates + merge.", "committedDate": "2020-02-26T14:16:22Z", "type": "commit"}, {"oid": "bea31965f7865e7f48e546f1585c0c3296113187", "url": "https://github.com/ConsenSys/teku/commit/bea31965f7865e7f48e546f1585c0c3296113187", "message": "#1161: PR fixes, updates + merge.", "committedDate": "2020-02-26T14:16:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1MDE0OQ==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r384750149", "bodyText": "you can use all of the constants through here for parameters, tags, response codes", "author": "rolfyone", "createdAt": "2020-02-26T20:36:24Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,71 +13,116 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.EPOCH;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.ROOT;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.SLOT;\n+import static tech.pegasys.artemis.beaconrestapi.RestApiUtils.validateQueryParameter;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return the specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return the beacon chain block that matches the provided criteria.\",\n+      responses = {\n+        @OpenApiResponse(\n+            status = \"200\",\n+            content = @OpenApiContent(from = BeaconBlockResponse.class)),\n+        @OpenApiResponse(status = \"400\", description = \"Invalid parameter supplied\"),\n+        @OpenApiResponse(status = \"404\", description = \"Specified block not found\")", "originalCommit": "bea31965f7865e7f48e546f1585c0c3296113187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1Mjc0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r384752746", "bodyText": "so the store being null here is basically the SC_NO_CONTENT use-case that we have currently...", "author": "rolfyone", "createdAt": "2020-02-26T20:41:41Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,71 +13,116 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.EPOCH;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.ROOT;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.SLOT;\n+import static tech.pegasys.artemis.beaconrestapi.RestApiUtils.validateQueryParameter;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return the specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return the beacon chain block that matches the provided criteria.\",\n+      responses = {\n+        @OpenApiResponse(\n+            status = \"200\",\n+            content = @OpenApiContent(from = BeaconBlockResponse.class)),\n+        @OpenApiResponse(status = \"400\", description = \"Invalid parameter supplied\"),\n+        @OpenApiResponse(status = \"404\", description = \"Specified block not found\")\n+      })\n   @Override\n-  public String getPath() {\n-    return \"/beacon/block\";\n-  }\n+  public void handle(final Context ctx) throws Exception {\n+    try {\n+      if (ctx.queryParamMap().size() > 1) {\n+        throw new IllegalArgumentException(\n+            \"Too many query parameters specified. Please supply only one.\");\n+      }\n \n-  @Override\n-  public Object handleRequest(RequestParams param) {\n-    Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    if (queryParamMap.containsKey(ROOT)) {\n-      Bytes32 root = Bytes32.fromHexString(param.getQueryParam(ROOT));\n-      return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    }\n+      final Map<String, List<String>> queryParamMap = ctx.queryParamMap();\n+      if (ctx.queryParamMap().containsKey(ROOT)) {\n+        final Bytes32 root = Bytes32.fromHexString(validateQueryParameter(queryParamMap, ROOT));\n+        if (client.getStore() != null) {\n+          final SignedBeaconBlock block = client.getStore().getSignedBlock(root);", "originalCommit": "bea31965f7865e7f48e546f1585c0c3296113187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1OTg5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r384759897", "bodyText": "Hrm i think this is probably a bigger problem... We need to probably use the combinedChainDataClient, because this client is only non finalized blocks which is something i found out doing beacon/state.\nThe upshot, is we can build most of the complexity of using chainDataClient v. historicalChainDataClient into the combinedChainDataClient, and then we're just responding to that.\nThe downside is then we really need to be respecting futures, because the storage is async.\nThe better thing might be to complete this task, then raise another to allow /beacon/block to retrieve finalized blocks...", "author": "rolfyone", "createdAt": "2020-02-26T20:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1Mjc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5ODE0NQ==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r384898145", "bodyText": "Agreed - best bet is to always use CombinedChainDataClient for REST APIs.  The ChainStorageClient only has non-finalised blocks, everything else is written to disk and dropped from memory so only available from HistoricalChainDataClient.  CombinedChainDataClient is designed to work out which one you need for you.\nSeparate PR is a sensible approach.   Javalin makes working with async data simple since you can pass a Future to ctx.result. BeaconStateHandler is an example of doing this.", "author": "ajsutton", "createdAt": "2020-02-27T03:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1Mjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2Mjk3MA==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r384762970", "bodyText": "CombinedChainDataClient.getbBlockAtSlotExact", "author": "rolfyone", "createdAt": "2020-02-26T21:01:45Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,71 +13,116 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.EPOCH;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.ROOT;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.SLOT;\n+import static tech.pegasys.artemis.beaconrestapi.RestApiUtils.validateQueryParameter;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return the specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return the beacon chain block that matches the provided criteria.\",\n+      responses = {\n+        @OpenApiResponse(\n+            status = \"200\",\n+            content = @OpenApiContent(from = BeaconBlockResponse.class)),\n+        @OpenApiResponse(status = \"400\", description = \"Invalid parameter supplied\"),\n+        @OpenApiResponse(status = \"404\", description = \"Specified block not found\")\n+      })\n   @Override\n-  public String getPath() {\n-    return \"/beacon/block\";\n-  }\n+  public void handle(final Context ctx) throws Exception {\n+    try {\n+      if (ctx.queryParamMap().size() > 1) {\n+        throw new IllegalArgumentException(\n+            \"Too many query parameters specified. Please supply only one.\");\n+      }\n \n-  @Override\n-  public Object handleRequest(RequestParams param) {\n-    Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    if (queryParamMap.containsKey(ROOT)) {\n-      Bytes32 root = Bytes32.fromHexString(param.getQueryParam(ROOT));\n-      return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    }\n+      final Map<String, List<String>> queryParamMap = ctx.queryParamMap();\n+      if (ctx.queryParamMap().containsKey(ROOT)) {\n+        final Bytes32 root = Bytes32.fromHexString(validateQueryParameter(queryParamMap, ROOT));\n+        if (client.getStore() != null) {\n+          final SignedBeaconBlock block = client.getStore().getSignedBlock(root);\n+          if (block != null) {\n+            ctx.result(jsonProvider.objectToJSON(new BeaconBlockResponse(block)));\n+            return;\n+          }\n+          ctx.status(SC_NOT_FOUND);\n+          return;\n+        }\n+      }\n \n-    UnsignedLong slot;\n-    if (queryParamMap.containsKey(EPOCH)) {\n-      slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(param.getQueryParam(EPOCH)));\n-    } else if (queryParamMap.containsKey(SLOT)) {\n-      slot = UnsignedLong.valueOf(param.getQueryParam(SLOT));\n-    } else {\n-      return null;\n-    }\n+      final UnsignedLong slot;\n+      if (ctx.queryParamMap().containsKey(EPOCH)) {\n+        slot =\n+            compute_start_slot_at_epoch(\n+                UnsignedLong.valueOf(validateQueryParameter(queryParamMap, EPOCH)));\n+      } else if (ctx.queryParamMap().containsKey(SLOT)) {\n+        slot = UnsignedLong.valueOf(validateQueryParameter(queryParamMap, SLOT));\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Query parameter missing. Must specify one of root or epoch or slot.\");\n+      }\n \n-    return getBlockBySlot(slot)\n-        .map(\n-            block ->\n-                ImmutableMap.of(\"block\", block, \"blockRoot\", block.hash_tree_root().toHexString()))\n-        .orElse(null);\n+      final Optional<SignedBeaconBlock> blockBySlot = getBlockBySlot(slot);\n+      if (blockBySlot.isPresent()) {\n+        ctx.result(jsonProvider.objectToJSON(new BeaconBlockResponse(blockBySlot.get())));\n+        return;\n+      }\n+      ctx.status(SC_NOT_FOUND);\n+    } catch (final IllegalArgumentException e) {\n+      ctx.result(jsonProvider.objectToJSON(new BadRequest(e.getMessage())));\n+    }\n   }\n \n-  private Optional<BeaconBlock> getBlockBySlot(UnsignedLong slot) {\n+  private Optional<SignedBeaconBlock> getBlockBySlot(final UnsignedLong slot) {\n     return client\n         .getBlockRootBySlot(slot)\n-        .map(root -> client.getStore().getBlock(root))\n-        .or(\n-            () -> {\n-              Optional<SignedBeaconBlock> signedBeaconBlock =\n-                  historicalChainData.getFinalizedBlockAtSlot(slot).join();\n-              return signedBeaconBlock.map(SignedBeaconBlock::getMessage);\n-            });\n-  };\n+        .map(root -> client.getStore().getSignedBlock(root))\n+        .or(() -> historicalChainData.getFinalizedBlockAtSlot(slot).join());\n+  }", "originalCommit": "bea31965f7865e7f48e546f1585c0c3296113187", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fdf199c2d262d9f67401041152ce084a86b9205a", "url": "https://github.com/ConsenSys/teku/commit/fdf199c2d262d9f67401041152ce084a86b9205a", "message": "Merge branch 'master' into 1161", "committedDate": "2020-02-27T03:28:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5ODc4NA==", "url": "https://github.com/ConsenSys/teku/pull/1217#discussion_r384898784", "bodyText": "Please avoid calling join in production code.  There are some places it can't be avoided and a few places that we do call it and shouldn't, but generally it's better to use the chaining methods (thenApply, thenCompose etc) and not just block the thread potentially forever.", "author": "ajsutton", "createdAt": "2020-02-27T03:44:20Z", "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -13,71 +13,116 @@\n \n package tech.pegasys.artemis.beaconrestapi.beaconhandlers;\n \n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.EPOCH;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.ROOT;\n import static tech.pegasys.artemis.beaconrestapi.RestApiConstants.SLOT;\n+import static tech.pegasys.artemis.beaconrestapi.RestApiUtils.validateQueryParameter;\n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.primitives.UnsignedLong;\n+import io.javalin.http.Context;\n+import io.javalin.http.Handler;\n+import io.javalin.plugin.openapi.annotations.HttpMethod;\n+import io.javalin.plugin.openapi.annotations.OpenApi;\n+import io.javalin.plugin.openapi.annotations.OpenApiContent;\n+import io.javalin.plugin.openapi.annotations.OpenApiParam;\n+import io.javalin.plugin.openapi.annotations.OpenApiResponse;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.beaconrestapi.schema.BadRequest;\n+import tech.pegasys.artemis.beaconrestapi.schema.BeaconBlockResponse;\n import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.provider.JsonProvider;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.HistoricalChainData;\n \n-public class BeaconBlockHandler implements BeaconRestApiHandler {\n+public class BeaconBlockHandler implements Handler {\n \n   private final ChainStorageClient client;\n   private final HistoricalChainData historicalChainData;\n+  public static final String ROUTE = \"/beacon/block\";\n+  private final JsonProvider jsonProvider;\n \n-  public BeaconBlockHandler(ChainStorageClient client, HistoricalChainData historicalChainData) {\n+  public BeaconBlockHandler(\n+      final ChainStorageClient client,\n+      final HistoricalChainData historicalChainData,\n+      final JsonProvider jsonProvider) {\n     this.client = client;\n     this.historicalChainData = historicalChainData;\n+    this.jsonProvider = jsonProvider;\n   }\n \n+  @OpenApi(\n+      path = ROUTE,\n+      method = HttpMethod.GET,\n+      summary = \"Request that the node return the specified beacon chain block.\",\n+      tags = {\"Beacon\"},\n+      queryParams = {\n+        @OpenApiParam(name = \"epoch\", description = \"Query by epoch number (uint64)\"),\n+        @OpenApiParam(name = \"slot\", description = \"Query by slot number (uint64)\"),\n+        @OpenApiParam(name = \"root\", description = \"Query by tree hash root (Bytes32)\")\n+      },\n+      description =\n+          \"Request that the node return the beacon chain block that matches the provided criteria.\",\n+      responses = {\n+        @OpenApiResponse(\n+            status = \"200\",\n+            content = @OpenApiContent(from = BeaconBlockResponse.class)),\n+        @OpenApiResponse(status = \"400\", description = \"Invalid parameter supplied\"),\n+        @OpenApiResponse(status = \"404\", description = \"Specified block not found\")\n+      })\n   @Override\n-  public String getPath() {\n-    return \"/beacon/block\";\n-  }\n+  public void handle(final Context ctx) throws Exception {\n+    try {\n+      if (ctx.queryParamMap().size() > 1) {\n+        throw new IllegalArgumentException(\n+            \"Too many query parameters specified. Please supply only one.\");\n+      }\n \n-  @Override\n-  public Object handleRequest(RequestParams param) {\n-    Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    if (queryParamMap.containsKey(ROOT)) {\n-      Bytes32 root = Bytes32.fromHexString(param.getQueryParam(ROOT));\n-      return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    }\n+      final Map<String, List<String>> queryParamMap = ctx.queryParamMap();\n+      if (ctx.queryParamMap().containsKey(ROOT)) {\n+        final Bytes32 root = Bytes32.fromHexString(validateQueryParameter(queryParamMap, ROOT));\n+        if (client.getStore() != null) {\n+          final SignedBeaconBlock block = client.getStore().getSignedBlock(root);\n+          if (block != null) {\n+            ctx.result(jsonProvider.objectToJSON(new BeaconBlockResponse(block)));\n+            return;\n+          }\n+          ctx.status(SC_NOT_FOUND);\n+          return;\n+        }\n+      }\n \n-    UnsignedLong slot;\n-    if (queryParamMap.containsKey(EPOCH)) {\n-      slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(param.getQueryParam(EPOCH)));\n-    } else if (queryParamMap.containsKey(SLOT)) {\n-      slot = UnsignedLong.valueOf(param.getQueryParam(SLOT));\n-    } else {\n-      return null;\n-    }\n+      final UnsignedLong slot;\n+      if (ctx.queryParamMap().containsKey(EPOCH)) {\n+        slot =\n+            compute_start_slot_at_epoch(\n+                UnsignedLong.valueOf(validateQueryParameter(queryParamMap, EPOCH)));\n+      } else if (ctx.queryParamMap().containsKey(SLOT)) {\n+        slot = UnsignedLong.valueOf(validateQueryParameter(queryParamMap, SLOT));\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Query parameter missing. Must specify one of root or epoch or slot.\");\n+      }\n \n-    return getBlockBySlot(slot)\n-        .map(\n-            block ->\n-                ImmutableMap.of(\"block\", block, \"blockRoot\", block.hash_tree_root().toHexString()))\n-        .orElse(null);\n+      final Optional<SignedBeaconBlock> blockBySlot = getBlockBySlot(slot);\n+      if (blockBySlot.isPresent()) {\n+        ctx.result(jsonProvider.objectToJSON(new BeaconBlockResponse(blockBySlot.get())));\n+        return;\n+      }\n+      ctx.status(SC_NOT_FOUND);\n+    } catch (final IllegalArgumentException e) {\n+      ctx.result(jsonProvider.objectToJSON(new BadRequest(e.getMessage())));\n+    }\n   }\n \n-  private Optional<BeaconBlock> getBlockBySlot(UnsignedLong slot) {\n+  private Optional<SignedBeaconBlock> getBlockBySlot(final UnsignedLong slot) {\n     return client\n         .getBlockRootBySlot(slot)\n-        .map(root -> client.getStore().getBlock(root))\n-        .or(\n-            () -> {\n-              Optional<SignedBeaconBlock> signedBeaconBlock =\n-                  historicalChainData.getFinalizedBlockAtSlot(slot).join();\n-              return signedBeaconBlock.map(SignedBeaconBlock::getMessage);\n-            });\n-  };\n+        .map(root -> client.getStore().getSignedBlock(root))\n+        .or(() -> historicalChainData.getFinalizedBlockAtSlot(slot).join());", "originalCommit": "fdf199c2d262d9f67401041152ce084a86b9205a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff6dc6c12eb51a4b65bd44a2eb64535bb40b1cde", "url": "https://github.com/ConsenSys/teku/commit/ff6dc6c12eb51a4b65bd44a2eb64535bb40b1cde", "message": "#1161: PR fixes.", "committedDate": "2020-02-27T04:25:03Z", "type": "commit"}, {"oid": "d3c496d01d09db09a0dda437043d7811b52aa391", "url": "https://github.com/ConsenSys/teku/commit/d3c496d01d09db09a0dda437043d7811b52aa391", "message": "Merge branch 'master' into 1161", "committedDate": "2020-02-27T05:01:56Z", "type": "commit"}, {"oid": "67d61fb2e6ee790c2fdbbc51326ce64f1ebb3f9c", "url": "https://github.com/ConsenSys/teku/commit/67d61fb2e6ee790c2fdbbc51326ce64f1ebb3f9c", "message": "Merge branch 'master' into 1161", "committedDate": "2020-02-27T05:12:49Z", "type": "commit"}, {"oid": "4a77bf78526b01a98b6bdf78ec150b70f1b1bb83", "url": "https://github.com/ConsenSys/teku/commit/4a77bf78526b01a98b6bdf78ec150b70f1b1bb83", "message": "Merge branch 'master' into 1161", "committedDate": "2020-02-28T02:53:48Z", "type": "commit"}, {"oid": "06d5685ea965bdd288ea5146deb8eb91e85ed47e", "url": "https://github.com/ConsenSys/teku/commit/06d5685ea965bdd288ea5146deb8eb91e85ed47e", "message": "Merge branch 'master' into 1161", "committedDate": "2020-03-02T00:15:06Z", "type": "commit"}]}