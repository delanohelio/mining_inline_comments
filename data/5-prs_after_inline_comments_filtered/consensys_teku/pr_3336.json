{"pr_number": 3336, "pr_title": "TreeNode classes refactor", "pr_createdAt": "2020-11-30T17:13:22Z", "pr_url": "https://github.com/ConsenSys/teku/pull/3336", "timeline": [{"oid": "905fbf8cff10e4512dabc4ebbe244a6eb3cdb746", "url": "https://github.com/ConsenSys/teku/commit/905fbf8cff10e4512dabc4ebbe244a6eb3cdb746", "message": "Draft", "committedDate": "2020-11-11T07:30:18Z", "type": "commit"}, {"oid": "8d1784469949317723ec1b4db06d76b8541023c3", "url": "https://github.com/ConsenSys/teku/commit/8d1784469949317723ec1b4db06d76b8541023c3", "message": "Almost complete SuperLeafNode implementation", "committedDate": "2020-11-12T07:30:54Z", "type": "commit"}, {"oid": "1c35b65fd6f2f68db8662a7060ae0f42e948b598", "url": "https://github.com/ConsenSys/teku/commit/1c35b65fd6f2f68db8662a7060ae0f42e948b598", "message": "Add Vector nad List TypeHints. Add SuperLeafNode test, fix bugs. Adjust SSZ serialize to work with SuperLeafNode", "committedDate": "2020-11-12T17:42:38Z", "type": "commit"}, {"oid": "f7bc2500fdd4fb089c9c36040c41c83104357e1c", "url": "https://github.com/ConsenSys/teku/commit/f7bc2500fdd4fb089c9c36040c41c83104357e1c", "message": "Minor fix to ProfilingRun", "committedDate": "2020-11-18T08:37:35Z", "type": "commit"}, {"oid": "d2c38c4624e58f32566fe8f9c3ae2bd049c592ba", "url": "https://github.com/ConsenSys/teku/commit/d2c38c4624e58f32566fe8f9c3ae2bd049c592ba", "message": "Fix a couple of bugs in SuperLeafNode. Add hash memorize", "committedDate": "2020-11-18T08:38:20Z", "type": "commit"}, {"oid": "8ca242244e452e7049c02afe2a74d6bedeb4d635", "url": "https://github.com/ConsenSys/teku/commit/8ca242244e452e7049c02afe2a74d6bedeb4d635", "message": "Make BeaconState.balances to be handled by SuperLeafNode", "committedDate": "2020-11-18T08:39:33Z", "type": "commit"}, {"oid": "6eb4b51cc5c2e5cab7a6a84049fcbc91a7cb1503", "url": "https://github.com/ConsenSys/teku/commit/6eb4b51cc5c2e5cab7a6a84049fcbc91a7cb1503", "message": "Add test", "committedDate": "2020-11-18T08:40:18Z", "type": "commit"}, {"oid": "f5676ad63b0fe519f5fd54a44b1fd58f08c5054c", "url": "https://github.com/ConsenSys/teku/commit/f5676ad63b0fe519f5fd54a44b1fd58f08c5054c", "message": "Add SuperBranchNode draft impl", "committedDate": "2020-11-18T08:40:35Z", "type": "commit"}, {"oid": "e255a6a0a7d0273906b8fd163fe2072a36ddbb2a", "url": "https://github.com/ConsenSys/teku/commit/e255a6a0a7d0273906b8fd163fe2072a36ddbb2a", "message": "Extract generalized index related operations to a separate class", "committedDate": "2020-11-20T13:48:20Z", "type": "commit"}, {"oid": "30a5dcf870cea5ea6de9d088a45f93010f0acd63", "url": "https://github.com/ConsenSys/teku/commit/30a5dcf870cea5ea6de9d088a45f93010f0acd63", "message": "Initial implementation of SuperBranchNode", "committedDate": "2020-11-20T14:23:30Z", "type": "commit"}, {"oid": "826e9b3a7ab21db58aed7f88f68cf520cea67f8d", "url": "https://github.com/ConsenSys/teku/commit/826e9b3a7ab21db58aed7f88f68cf520cea67f8d", "message": "Fix GIndex function", "committedDate": "2020-11-20T15:56:39Z", "type": "commit"}, {"oid": "ea3ee18e40da535dcc3ebcb24fcce00702faf50b", "url": "https://github.com/ConsenSys/teku/commit/ea3ee18e40da535dcc3ebcb24fcce00702faf50b", "message": "Add TreeNode.iterate method", "committedDate": "2020-11-20T15:59:40Z", "type": "commit"}, {"oid": "eaf4b57c1dd9e80b832eee972088d44f4d34adba", "url": "https://github.com/ConsenSys/teku/commit/eaf4b57c1dd9e80b832eee972088d44f4d34adba", "message": "Move tree nodes iteration functionality from utils to TreeNode implementations", "committedDate": "2020-11-23T11:26:04Z", "type": "commit"}, {"oid": "e7fbb735bd33a4a55e7b97133c8cf8a7952ce78e", "url": "https://github.com/ConsenSys/teku/commit/e7fbb735bd33a4a55e7b97133c8cf8a7952ce78e", "message": "Spotless", "committedDate": "2020-11-23T11:28:02Z", "type": "commit"}, {"oid": "e31dad2040548848bc9cbc6ffbf0d74c37100978", "url": "https://github.com/ConsenSys/teku/commit/e31dad2040548848bc9cbc6ffbf0d74c37100978", "message": "Fix warn", "committedDate": "2020-11-23T13:04:33Z", "type": "commit"}, {"oid": "13a99b31e37204722abcfff70b2ecaaa8a98f148", "url": "https://github.com/ConsenSys/teku/commit/13a99b31e37204722abcfff70b2ecaaa8a98f148", "message": "Fix SuperLeafNode.updated() bug", "committedDate": "2020-11-23T14:03:43Z", "type": "commit"}, {"oid": "ec0d5007e25d45668aca13d6fd401b982d0af0a8", "url": "https://github.com/ConsenSys/teku/commit/ec0d5007e25d45668aca13d6fd401b982d0af0a8", "message": "Merge remote-tracking branch 'origin/master' into feature/backing-tree-size-optimize", "committedDate": "2020-11-23T15:19:31Z", "type": "commit"}, {"oid": "bbebb416cfb24913622765bf2226fc8c702972e4", "url": "https://github.com/ConsenSys/teku/commit/bbebb416cfb24913622765bf2226fc8c702972e4", "message": "Integrate SuperBranchNode to BeaconState.validators", "committedDate": "2020-11-24T11:51:02Z", "type": "commit"}, {"oid": "4ad354fc0e32dd955961e45d8739cbe19f14ba55", "url": "https://github.com/ConsenSys/teku/commit/4ad354fc0e32dd955961e45d8739cbe19f14ba55", "message": "Draft implementation of SszSuperNode", "committedDate": "2020-11-24T18:18:15Z", "type": "commit"}, {"oid": "e313f44e3ff21041e4e1c87c0362be534263ec1d", "url": "https://github.com/ConsenSys/teku/commit/e313f44e3ff21041e4e1c87c0362be534263ec1d", "message": "Merge remote-tracking branch 'origin/master' into feature/backing-tree-size-optimize", "committedDate": "2020-11-25T08:54:50Z", "type": "commit"}, {"oid": "2333dd7e8352b69e31f9204ac3d81c4d3b70331e", "url": "https://github.com/ConsenSys/teku/commit/2333dd7e8352b69e31f9204ac3d81c4d3b70331e", "message": "Add a new type hint", "committedDate": "2020-11-25T09:16:55Z", "type": "commit"}, {"oid": "e8f03ee06ac55385d5057dc9e9b9da4043d04aef", "url": "https://github.com/ConsenSys/teku/commit/e8f03ee06ac55385d5057dc9e9b9da4043d04aef", "message": "Add temp test", "committedDate": "2020-11-25T09:17:21Z", "type": "commit"}, {"oid": "9c592e248d63c5e5be68ad4fa1b3d71f9131abd7", "url": "https://github.com/ConsenSys/teku/commit/9c592e248d63c5e5be68ad4fa1b3d71f9131abd7", "message": "Implement SszSuperNode draft (single ssz bytes for containers sequence)", "committedDate": "2020-11-25T18:39:08Z", "type": "commit"}, {"oid": "c28e0f1de8efe18b1a24aa16e916d8f327d9ed50", "url": "https://github.com/ConsenSys/teku/commit/c28e0f1de8efe18b1a24aa16e916d8f327d9ed50", "message": "Merge remote-tracking branch 'ConsenSys/master' into feature/backing-tree-size-optimize", "committedDate": "2020-11-30T15:32:09Z", "type": "commit"}, {"oid": "f86dd86413e9da93605013662f3971278cb9459b", "url": "https://github.com/ConsenSys/teku/commit/f86dd86413e9da93605013662f3971278cb9459b", "message": "Leave just existing Tree code refactors", "committedDate": "2020-11-30T15:59:55Z", "type": "commit"}, {"oid": "90894133960263cc41f6adceafa8ec4f87a82f98", "url": "https://github.com/ConsenSys/teku/commit/90894133960263cc41f6adceafa8ec4f87a82f98", "message": "Make tree classes refactoring and add javadoc", "committedDate": "2020-11-30T17:02:54Z", "type": "commit"}, {"oid": "d71b44cb9ae219f217323f6aa9420ded4b9107e0", "url": "https://github.com/ConsenSys/teku/commit/d71b44cb9ae219f217323f6aa9420ded4b9107e0", "message": "Spotless", "committedDate": "2020-11-30T17:17:25Z", "type": "commit"}, {"oid": "39cc4da3f23467b9aa5cfd252a9cca45571eec6f", "url": "https://github.com/ConsenSys/teku/commit/39cc4da3f23467b9aa5cfd252a9cca45571eec6f", "message": "Add GIndexUtil javadocs", "committedDate": "2020-11-30T18:20:26Z", "type": "commit"}, {"oid": "9e6614f1d1050fcce7beceaa9500773c2b1abe2f", "url": "https://github.com/ConsenSys/teku/commit/9e6614f1d1050fcce7beceaa9500773c2b1abe2f", "message": "Add GIndexUtil minor test stub", "committedDate": "2020-11-30T18:34:05Z", "type": "commit"}, {"oid": "0ab3a104c37e36049f1387538a4c7ce5becd7281", "url": "https://github.com/ConsenSys/teku/commit/0ab3a104c37e36049f1387538a4c7ce5becd7281", "message": "Add more GIndexUtil tests", "committedDate": "2020-12-01T10:14:47Z", "type": "commit"}, {"oid": "580028c80affa3a6a42b26a28000098ed2e48ad5", "url": "https://github.com/ConsenSys/teku/commit/580028c80affa3a6a42b26a28000098ed2e48ad5", "message": "Add more GIndexUtil tests", "committedDate": "2020-12-01T14:09:07Z", "type": "commit"}, {"oid": "05e69eda4c92d58dfd7faddfc7ba1f16ba456a8d", "url": "https://github.com/ConsenSys/teku/commit/05e69eda4c92d58dfd7faddfc7ba1f16ba456a8d", "message": "Make GIndexUtil package private and changed all runtime argument checks to asserts to mitigate performance drawdown risk", "committedDate": "2020-12-01T14:14:00Z", "type": "commit"}, {"oid": "0a190c56f90cded009bf64445890a2a1a6bf403c", "url": "https://github.com/ConsenSys/teku/commit/0a190c56f90cded009bf64445890a2a1a6bf403c", "message": "Merge branch 'master' into feature/tree-node-refactors", "committedDate": "2020-12-01T14:15:13Z", "type": "commit"}, {"oid": "64afb9c818facbdb91f08b32407c8b6d9a784e01", "url": "https://github.com/ConsenSys/teku/commit/64afb9c818facbdb91f08b32407c8b6d9a784e01", "message": "Cleanup TreeUtil.iterate*() methods", "committedDate": "2020-12-01T14:27:45Z", "type": "commit"}, {"oid": "fca821214a0e9fca58422da937b3c4de91839fda", "url": "https://github.com/ConsenSys/teku/commit/fca821214a0e9fca58422da937b3c4de91839fda", "message": "Move TreeNode.createLeaf/BranchNode() methods to LeafNode/BranchNode classes", "committedDate": "2020-12-01T14:35:32Z", "type": "commit"}, {"oid": "ac3d3bf2376bb91b2e8937efaeda5d8339e9d319", "url": "https://github.com/ConsenSys/teku/commit/ac3d3bf2376bb91b2e8937efaeda5d8339e9d319", "message": "TreeNode.iterate(): refactor params order, add tests", "committedDate": "2020-12-01T14:58:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzOTU3Ng==", "url": "https://github.com/ConsenSys/teku/pull/3336#discussion_r533639576", "bodyText": "Should we assert childDepth >= 0 as well?", "author": "mbaxter", "createdAt": "2020-12-01T18:43:12Z", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/GIndexUtil.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static java.lang.Integer.min;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * Util methods for binary tree generalized indexes manipulations See\n+ * https://github.com/ethereum/eth2.0-specs/blob/v1.0.0/ssz/merkle-proofs.md#generalized-merkle-tree-index\n+ * for more info on generalized indexes\n+ *\n+ * <p>Here the general index is represented by <code>long</code> which is treated as unsigned uint64\n+ * Thus the only illegal generalized index value is <code>0</code>\n+ */\n+class GIndexUtil {\n+\n+  /** See {@link #gIdxCompare(long, long)} */\n+  public enum NodeRelation {\n+    Left,\n+    Right,\n+    Successor,\n+    Predecessor,\n+    Same;\n+\n+    /** <code>gIdxCompare(idx1, idx2) == gIdxCompare(idx2, idx1).inverse()</code> */\n+    public NodeRelation inverse() {\n+      switch (this) {\n+        case Left:\n+          return Right;\n+        case Right:\n+          return Left;\n+        case Predecessor:\n+          return Successor;\n+        case Successor:\n+          return Predecessor;\n+        case Same:\n+          return Same;\n+        default:\n+          throw new IllegalArgumentException(\"Unknown: \" + this);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * The generalized index of either a root tree node or an index of a node relative to the node\n+   * itself. Effectively this is <code>1L</code>\n+   */\n+  static final long SELF_G_INDEX = 1;\n+\n+  /**\n+   * The generalized index (normally an index of non-existing node) of the leftmost possible node\n+   * Effectively this is {@link Long#MIN_VALUE} or <code>0b10000...000L</code> in binary form\n+   */\n+  static final long LEFTMOST_G_INDEX = gIdxLeftmostFrom(SELF_G_INDEX);\n+  /**\n+   * The generalized index (normally an index of non-existing node) of the rightmost possible node\n+   * Effectively this is <code>-1L</code> or <code>0b11111...111L</code> in binary form\n+   */\n+  static final long RIGHTMOST_G_INDEX = gIdxRightmostFrom(SELF_G_INDEX);\n+\n+  /**\n+   * Indicates that a relative generalized index refers to the node itself\n+   *\n+   * @see #SELF_G_INDEX\n+   */\n+  public static boolean gIdxIsSelf(long generalizedIndex) {\n+    checkGIndex(generalizedIndex);\n+    return generalizedIndex == SELF_G_INDEX;\n+  }\n+\n+  /**\n+   * Indicates how the node with generalized index <code>idx1</code> relates to the node with\n+   * generalized index <code>idx2</code>:\n+   *\n+   * <ul>\n+   *   <li>{@link NodeRelation#Left}: idx1 is to the left of idx2\n+   *   <li>{@link NodeRelation#Right}: idx1 is to the right of idx2\n+   *   <li>{@link NodeRelation#Successor}: idx1 is the successor of idx2\n+   *   <li>{@link NodeRelation#Predecessor}: idx1 is the predecessor of idx2\n+   *   <li>{@link NodeRelation#Same}: idx1 is equal to idx2\n+   * </ul>\n+   */\n+  public static NodeRelation gIdxCompare(long idx1, long idx2) {\n+    checkGIndex(idx1);\n+    checkGIndex(idx2);\n+    long anchor1 = Long.highestOneBit(idx1);\n+    long anchor2 = Long.highestOneBit(idx2);\n+    int depth1 = Long.bitCount(anchor1 - 1);\n+    int depth2 = Long.bitCount(anchor2 - 1);\n+    int minDepth = min(depth1, depth2);\n+    long minDepthIdx1 = idx1 >>> (depth1 - minDepth);\n+    long minDepthIdx2 = idx2 >>> (depth2 - minDepth);\n+    if (minDepthIdx1 == minDepthIdx2) {\n+      if (depth1 < depth2) {\n+        return NodeRelation.Predecessor;\n+      } else if (depth1 > depth2) {\n+        return NodeRelation.Successor;\n+      } else {\n+        return NodeRelation.Same;\n+      }\n+    } else {\n+      if (minDepthIdx1 < minDepthIdx2) {\n+        return NodeRelation.Left;\n+      } else {\n+        return NodeRelation.Right;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the depth of the node denoted by the supplied generalized index. E.g. the depth of the\n+   * {@link #SELF_G_INDEX} would be 0\n+   */\n+  public static int gIdxGetDepth(long generalizedIndex) {\n+    checkGIndex(generalizedIndex);\n+    long anchor = Long.highestOneBit(generalizedIndex);\n+    return Long.bitCount(anchor - 1);\n+  }\n+\n+  /**\n+   * Returns the generalized index of the left child of the node with specified generalized index\n+   * E.g. the result when passing {@link #SELF_G_INDEX} would be <code>10</code>\n+   */\n+  public static long gIdxLeftGIndex(long generalizedIndex) {\n+    return gIdxChildGIndex(generalizedIndex, 0, 1);\n+  }\n+\n+  /**\n+   * Returns the generalized index of the right child of the node with specified generalized index\n+   * E.g. the result when passing {@link #SELF_G_INDEX} would be <code>11</code>\n+   */\n+  public static long gIdxRightGIndex(long generalizedIndex) {\n+    return gIdxChildGIndex(generalizedIndex, 1, 1);\n+  }\n+\n+  /**\n+   * More generic variant of methods {@link #gIdxLeftGIndex(long)} {@link #gIdxRightGIndex(long)}\n+   * Calculates the generalized index of a node's <code>childIdx</code> successor at depth <code>\n+   * childDepth</code> (depth relative to the original node). Note that <code>childIdx</code> is not\n+   * the generalized index but index number of child.\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 0, 2) == 100</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 1, 2) == 101</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 2, 2) == 110</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 3, 2) == 111</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 4, 2) is invalid cause there are just 4 successors\n+   *   at depth 2</code>\n+   *   <li><code>gIdxChildGIndex(anyIndex, 0, 1) == gIdxLeftGIndex(anyIndex)</code>\n+   *   <li><code>gIdxChildGIndex(anyIndex, 1, 1) == gIdxRightGIndex(anyIndex)</code>\n+   * </ul>\n+   */\n+  public static long gIdxChildGIndex(long generalizedIndex, int childIdx, int childDepth) {\n+    checkGIndex(generalizedIndex);\n+    assert childDepth >= 0 && childDepth < 64;\n+    assert childIdx >= 0;\n+    assert childIdx < (1 << childDepth);\n+    assert gIdxGetDepth(generalizedIndex) + childDepth < 64;\n+    return (generalizedIndex << childDepth) | childIdx;\n+  }\n+\n+  /**\n+   * Returns the generalized index (normally an index of non-existing node) of the leftmost possible\n+   * successor of this node\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxLeftmostFrom(0b1100) == 0b110000000...00L</code>\n+   *   <li><code>gIdxLeftmostFrom(0b1101) == 0b110100000...00L</code>\n+   * </ul>\n+   */\n+  public static long gIdxLeftmostFrom(long fromGeneralizedIndex) {\n+    checkGIndex(fromGeneralizedIndex);\n+    long highestOneBit = Long.highestOneBit(fromGeneralizedIndex);\n+    if (highestOneBit < 0) {\n+      return fromGeneralizedIndex;\n+    } else {\n+      int nodeDepth = Long.bitCount(highestOneBit - 1);\n+      return fromGeneralizedIndex << (63 - nodeDepth);\n+    }\n+  }\n+\n+  /**\n+   * Returns the generalized index (normally an index of non-existing node) of the rightmost\n+   * possible successor of this node\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxRightmostFrom(0b1100) == 0b110011111...11L</code>\n+   *   <li><code>gIdxRightmostFrom(0b1101) == 0b110111111...11L</code>\n+   * </ul>\n+   */\n+  public static long gIdxRightmostFrom(long fromGeneralizedIndex) {\n+    checkGIndex(fromGeneralizedIndex);\n+    long highestOneBit = Long.highestOneBit(fromGeneralizedIndex);\n+    if (highestOneBit < 0) {\n+      return fromGeneralizedIndex;\n+    } else {\n+      int nodeDepth = Long.bitCount(highestOneBit - 1);\n+      int shiftN = 63 - nodeDepth;\n+      return (fromGeneralizedIndex << shiftN) | ((1L << shiftN) - 1);\n+    }\n+  }\n+\n+  /**\n+   * Returns the index number (not a generalized index) of a node at depth <code>childDepth</code>\n+   * which is a predecessor of or equal to the node at <code>generalizedIndex</code>\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxGetChildIndex(LEFTMOST_G_INDEX, anyDepth) == 0</code>\n+   *   <li><code>gIdxGetChildIndex(0b1100, 2) == 2</code>\n+   *   <li><code>gIdxGetChildIndex(0b1101, 2) == 2</code>\n+   *   <li><code>gIdxGetChildIndex(0b1110, 2) == 3</code>\n+   *   <li><code>gIdxGetChildIndex(0b1111, 2) == 3</code>\n+   *   <li><code>gIdxGetChildIndex(0b11, 2)</code> call would be invalid cause node with index 0b11\n+   *       is at depth 1\n+   * </ul>\n+   */\n+  public static int gIdxGetChildIndex(long generalizedIndex, int childDepth) {\n+    checkGIndex(generalizedIndex);\n+    assert childDepth < 64;\n+\n+    long anchor = Long.highestOneBit(generalizedIndex);\n+    int indexBitCount = Long.bitCount(anchor - 1);\n+    assert indexBitCount >= childDepth;\n+    long generalizedIndexWithoutAnchor = generalizedIndex ^ anchor;\n+    return (int) (generalizedIndexWithoutAnchor >>> (indexBitCount - childDepth));\n+  }\n+\n+  /**\n+   * Returns the generalized index of the node at <code>generalizedIndex</code> relative to its\n+   * predecessor at depth <code>childDepth</code> For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxGetRelativeGIndex(0b1100, 2) == 0b10</code>\n+   *   <li><code>gIdxGetChildIndex(0b1101, 2) == 0b11</code>\n+   *   <li><code>gIdxGetChildIndex(0b1110, 2) == 0b10</code>\n+   *   <li><code>gIdxGetChildIndex(0b1111, 3) == SELF_G_INDEX</code>\n+   *   <li><code>gIdxGetChildIndex(0b11, 2)</code> call would be invalid cause node with index 0b11\n+   *       is at depth 1\n+   * </ul>\n+   */\n+  public static long gIdxGetRelativeGIndex(long generalizedIndex, int childDepth) {\n+    checkGIndex(generalizedIndex);\n+    assert childDepth < 64;", "originalCommit": "ac3d3bf2376bb91b2e8937efaeda5d8339e9d319", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NzA0Mw==", "url": "https://github.com/ConsenSys/teku/pull/3336#discussion_r533657043", "bodyText": "Looks like this is unused", "author": "mbaxter", "createdAt": "2020-12-01T19:12:03Z", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/TreeUpdates.java", "diffHunk": "@@ -105,25 +116,52 @@ private TreeUpdates(List<Long> gIndexes, List<TreeNode> nodes, long prefix, int\n     int idx = Collections.binarySearch(gIndexes, pivotGIndex);\n     int insIdx = idx < 0 ? -idx - 1 : idx;\n     return Pair.of(\n-        new TreeUpdates(\n+        TreeUpdates.create(\n             gIndexes.subList(0, insIdx), nodes.subList(0, insIdx), lPrefix, heightFromLeaf - 1),\n-        new TreeUpdates(\n+        TreeUpdates.create(\n             gIndexes.subList(insIdx, gIndexes.size()),\n             nodes.subList(insIdx, nodes.size()),\n             rPrefix,\n             heightFromLeaf - 1));\n   }\n \n+  public List<TreeUpdates> splitToDepth(int depth) {", "originalCommit": "ac3d3bf2376bb91b2e8937efaeda5d8339e9d319", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5NDEzMA==", "url": "https://github.com/ConsenSys/teku/pull/3336#discussion_r534094130", "bodyText": "Yep, removing it for now", "author": "Nashatyrev", "createdAt": "2020-12-02T11:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NzA0Mw=="}], "type": "inlineReview"}, {"oid": "61744f2f06b953222cf4b6ffbac2c95a283399a6", "url": "https://github.com/ConsenSys/teku/commit/61744f2f06b953222cf4b6ffbac2c95a283399a6", "message": "Add extra assert", "committedDate": "2020-12-02T08:27:49Z", "type": "commit"}, {"oid": "b760def00fb569c59fe76636f6a2ae95b604f3c9", "url": "https://github.com/ConsenSys/teku/commit/b760def00fb569c59fe76636f6a2ae95b604f3c9", "message": "Remove unused methods", "committedDate": "2020-12-02T11:26:08Z", "type": "commit"}, {"oid": "e367668e5c544ec598b6906f56075924e6f6fc51", "url": "https://github.com/ConsenSys/teku/commit/e367668e5c544ec598b6906f56075924e6f6fc51", "message": "Merge branch 'master' into feature/tree-node-refactors", "committedDate": "2020-12-02T11:26:38Z", "type": "commit"}, {"oid": "6846f359da32204e2f08c1970d9b486817931bf0", "url": "https://github.com/ConsenSys/teku/commit/6846f359da32204e2f08c1970d9b486817931bf0", "message": "Merge remote-tracking branch 'origin/feature/tree-node-refactors' into feature/tree-node-refactors", "committedDate": "2020-12-02T11:26:49Z", "type": "commit"}, {"oid": "21be1eb4431c475d6b3af214a2cea580bfa4648d", "url": "https://github.com/ConsenSys/teku/commit/21be1eb4431c475d6b3af214a2cea580bfa4648d", "message": "Spotless", "committedDate": "2020-12-02T11:34:41Z", "type": "commit"}]}