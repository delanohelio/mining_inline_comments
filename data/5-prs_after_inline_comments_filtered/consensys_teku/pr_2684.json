{"pr_number": 2684, "pr_title": "Added import and export for slashing protection data.", "pr_createdAt": "2020-08-28T06:34:33Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2684", "timeline": [{"oid": "a099100c7557a6ae7be9f7fd8396b86e5bab9283", "url": "https://github.com/ConsenSys/teku/commit/a099100c7557a6ae7be9f7fd8396b86e5bab9283", "message": "Added import and export for slashing protection data.\n\n - teku slashing-protection export --data-path=<PATH> --to=<FILE>\n\n - teku slashing-protection import --data-path=<PATH> --from=<FILE>\n\n - --data-path defaults to the default path for teku.\n\n Exporting will only export to the minimal interchange format, as that is all that's stored by teku.\n\n On import, complete or minimal files are supported, and summarised for use by teku. If the genesis_validators_root does not match, the process will halt rather than corrupting existing data. If an existing file is found, the MAX of the exting data and imported data will be stored, to ensure there is no possibility of stepping 'backwards' in slashing protection data.\n\n fixes #2601\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-28T06:30:49Z", "type": "commit"}, {"oid": "9eeadfcb1975e8d5dabbc4ac2ca6e88abe124c49", "url": "https://github.com/ConsenSys/teku/commit/9eeadfcb1975e8d5dabbc4ac2ca6e88abe124c49", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-28T06:36:50Z", "type": "commit"}, {"oid": "e2ad26ddd740a61adaa95e71720f284665e8ad21", "url": "https://github.com/ConsenSys/teku/commit/e2ad26ddd740a61adaa95e71720f284665e8ad21", "message": "pretty print json\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-28T08:26:04Z", "type": "commit"}, {"oid": "eb3177ec919a4e223c24c4669b5e465a7b4c9fa5", "url": "https://github.com/ConsenSys/teku/commit/eb3177ec919a4e223c24c4669b5e465a7b4c9fa5", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-28T08:26:37Z", "type": "commit"}, {"oid": "d3883af67b0f04ccabfb199e01fef693b9107ca0", "url": "https://github.com/ConsenSys/teku/commit/d3883af67b0f04ccabfb199e01fef693b9107ca0", "message": "spotless\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-28T22:29:42Z", "type": "commit"}, {"oid": "8309149015da96df940e011f940141708608c702", "url": "https://github.com/ConsenSys/teku/commit/8309149015da96df940e011f940141708608c702", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-30T21:03:51Z", "type": "commit"}, {"oid": "4544b5e5e628c4054bd9c19a239985585e38e702", "url": "https://github.com/ConsenSys/teku/commit/4544b5e5e628c4054bd9c19a239985585e38e702", "message": "make NEVER_SIGNED be null, and conversion logic associated, as well as go back to using sync writer.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T03:01:19Z", "type": "commit"}, {"oid": "52a0e02188c5f3aba6fefd33775084fa4fa7468d", "url": "https://github.com/ConsenSys/teku/commit/52a0e02188c5f3aba6fefd33775084fa4fa7468d", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-31T03:02:56Z", "type": "commit"}, {"oid": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "url": "https://github.com/ConsenSys/teku/commit/9dbb02d37f6f50ec791669fb938ab5a937317a20", "message": "typo\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T03:24:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MTYyOA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479871628", "bodyText": "This should go via SubcommandLogger.error", "author": "ajsutton", "createdAt": "2020-08-31T03:39:46Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MTg5Mw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479871893", "bodyText": "I'm not convinced the YamlProvider should be dealing with file IO.  I'd expect it to mirror JsonProvider and just do the conversion to/from bytes (potentially to/from InputStream if we wanted to be able to stream the data.", "author": "ajsutton", "createdAt": "2020-08-31T03:41:06Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0MDgzNw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480440837", "bodyText": "i dont mind the concept of passing input streams and output streams, but in terms of the provider dealing with the IO, i kind of think its cleaner... maybe not 100% the way it is now, but for the core processing to just get the data and use it, and this deals with reading/writing the yaml seems like a nice single responsibility...", "author": "rolfyone", "createdAt": "2020-08-31T22:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MjQ5OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479872498", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final String pubkey = file.getName().substring(0, file.getName().length() - 4);\n          \n          \n            \n                  final String pubkey = file.getName().substring(0, file.getName().length() - \".yml\".length());", "author": "ajsutton", "createdAt": "2020-08-31T03:43:49Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());\n+        System.exit(1);\n+      }\n+      final String pubkey = file.getName().substring(0, file.getName().length() - 4);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MjkyOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479872929", "bodyText": "Probably should catch the exception thrown when this filename turns out to not be a valid public key and provide a useful error message that includes the filename.", "author": "ajsutton", "createdAt": "2020-08-31T03:45:36Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());\n+        System.exit(1);\n+      }\n+      final String pubkey = file.getName().substring(0, file.getName().length() - 4);\n+      minimalSigningHistoryList.add(\n+          new MinimalSigningHistory(BLSPubKey.fromHexString(pubkey), slashingProtectionRecord));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MzIxOA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479873218", "bodyText": "Probably would be better to just convert to JSON with jsonProvider.objectToPrettyJSON then write to file rather than using getObjectMapper and having the Jackson specific code leak out to here.", "author": "ajsutton", "createdAt": "2020-08-31T03:47:00Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());\n+        System.exit(1);\n+      }\n+      final String pubkey = file.getName().substring(0, file.getName().length() - 4);\n+      minimalSigningHistoryList.add(\n+          new MinimalSigningHistory(BLSPubKey.fromHexString(pubkey), slashingProtectionRecord));\n+    } catch (IOException e) {\n+      System.err.println(\"Failed to read from file \" + file.toString());\n+      System.exit(1);\n+    }\n+  }\n+\n+  public void saveToFile(final String toFileName) throws IOException {\n+\n+    jsonProvider\n+        .getObjectMapper()\n+        .writerWithDefaultPrettyPrinter()\n+        .writeValue(\n+            new File(toFileName),\n+            new MinimalSlashingProtectionInterchangeFormat(\n+                new Metadata(InterchangeFormat.minimal, UInt64.valueOf(2L), genesisValidatorsRoot),\n+                minimalSigningHistoryList));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MzQzNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479873434", "bodyText": "SubCommandLogger.error", "author": "ajsutton", "createdAt": "2020-08-31T03:48:06Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NDIyMQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479874221", "bodyText": "nit: I'd have this return the result rather than assign to data so the if above is symmetric with both versions assigning to data inline.", "author": "ajsutton", "createdAt": "2020-08-31T03:51:59Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NDYzNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479874635", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        sourceEpoch.orElse(null),\n          \n          \n            \n                        targetEpoch.orElse(null),\n          \n          \n            \n                        sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n          \n          \n            \n                        targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),", "author": "ajsutton", "createdAt": "2020-08-31T03:54:05Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    data =\n+        completeSigningData.stream()\n+            .map(this::minimalSigningHistoryConverter)\n+            .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    SlashingProtectionRecord record =\n+        new SlashingProtectionRecord(\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(null),\n+            targetEpoch.orElse(null),", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NjYzMg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480396632", "bodyText": "Can't access that from this context, it'd be cyclic dependency...", "author": "rolfyone", "createdAt": "2020-08-31T21:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NDYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NTExOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479875119", "bodyText": "SubCommandLogger.display", "author": "ajsutton", "createdAt": "2020-08-31T03:56:20Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    data =\n+        completeSigningData.stream()\n+            .map(this::minimalSigningHistoryConverter)\n+            .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    SlashingProtectionRecord record =\n+        new SlashingProtectionRecord(\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(null),\n+            targetEpoch.orElse(null),\n+            metadata.genesisValidatorsRoot);\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    System.out.println(\"Importing \" + validatorString);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NTY5Nw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479875697", "bodyText": "I'd load all the existing validator records upfront and check they all match prior to starting to apply changes.  Otherwise we risk having some records imported and some not.\nBasically I'd import by reading the incoming records, reading all the existing records, merging the two and writing them out.  It might still fail while writing out because of IO errors but at least you've done all the validation up-front and given yourself a chance.\nAlso SubCommandLogger", "author": "ajsutton", "createdAt": "2020-08-31T03:59:19Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    data =\n+        completeSigningData.stream()\n+            .map(this::minimalSigningHistoryConverter)\n+            .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    SlashingProtectionRecord record =\n+        new SlashingProtectionRecord(\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(null),\n+            targetEpoch.orElse(null),\n+            metadata.genesisValidatorsRoot);\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    System.out.println(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n+    Optional<SlashingProtectionRecord> existingRecord = Optional.empty();\n+    if (outputFile.toFile().exists()) {\n+      try {\n+        existingRecord =\n+            Optional.ofNullable(\n+                yamlProvider.fileToObject(outputFile.toFile(), SlashingProtectionRecord.class));\n+      } catch (IOException e) {\n+        System.err.println(\"Failed to read existing file: \" + outputFile.toString());\n+        System.exit(1);\n+      }\n+    }\n+    if (existingRecord.isPresent()\n+        && metadata.genesisValidatorsRoot.compareTo(existingRecord.get().genesisValidatorsRoot)\n+            != 0) {\n+      System.err.println(\n+          \"Validator \"\n+              + minimalSigningHistory.pubkey.toHexString()\n+              + \" has a different validators signing root to the data being imported\");", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3Nzc3MQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479877771", "bodyText": "Mentioned above, but I'd get rid of these or at most have versions that take InputStream/OutputStream so they don't care where the data is coming from.", "author": "ajsutton", "createdAt": "2020-08-31T04:09:42Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/slashinginterchange/YamlProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data.slashinginterchange;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import java.io.File;\n+import java.io.IOException;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.Bytes32Deserializer;\n+import tech.pegasys.teku.provider.BytesSerializer;\n+\n+public class YamlProvider {\n+  private final ObjectMapper objectMapper;\n+\n+  public YamlProvider() {\n+    this.objectMapper = new ObjectMapper(new YAMLFactory());\n+    addTekuMappers();\n+  }\n+\n+  private void addTekuMappers() {\n+    SimpleModule module = new SimpleModule(\"TekuYaml\", new Version(1, 0, 0, null, null, null));\n+    module.addDeserializer(UInt64.class, new UInt64Deserializer());\n+    module.addSerializer(UInt64.class, new UInt64Serializer());\n+    module.addDeserializer(Bytes32.class, new Bytes32Deserializer());\n+    module.addSerializer(Bytes.class, new BytesSerializer());\n+    objectMapper.registerModule(module).writer(new DefaultPrettyPrinter());\n+  }\n+\n+  public <T> String objectToYaml(T object) throws JsonProcessingException {\n+    return objectMapper.writeValueAsString(object);\n+  }\n+\n+  public <T> T yamlToObject(String json, Class<T> clazz) throws JsonProcessingException {\n+    return objectMapper.readValue(json, clazz);\n+  }\n+\n+  public <T> T fileToObject(File file, Class<T> clazz) throws IOException {\n+    return objectMapper.readValue(file, clazz);\n+  }\n+\n+  public <T> void writeToFile(File file, T object) throws IOException {\n+    objectMapper.writerWithDefaultPrettyPrinter().writeValue(file, object);\n+  }", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3OTA4NQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479879085", "bodyText": "It would make more sense to pass genesis validators root into maySignBlock so that if it is allowed to sign, it just creates a new ValidatorSigningRecord that already holds the right genesis validators root.  It should also refuse to sign if it has a validators root that is different to what is passed in as that indicates that the slashing protection DB is from the wrong chain and something has gone wrong (make sure to log an error message in this case as well as the return or it won't be clear why it refused to sign).", "author": "ajsutton", "createdAt": "2020-08-31T04:16:04Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java", "diffHunk": "@@ -18,50 +18,64 @@\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.BLSPublicKey;\n import tech.pegasys.teku.core.signatures.record.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n \n public class SlashingProtector {\n-\n+  private static final Logger LOG = LogManager.getLogger();\n   private final Map<BLSPublicKey, ValidatorSigningRecord> signingRecords = new HashMap<>();\n-\n   private final SyncDataAccessor dataAccessor;\n+  private final YamlProvider yamlProvider = new YamlProvider();\n   private final Path slashingProtectionBaseDir;\n \n   public SlashingProtector(\n       final SyncDataAccessor dataAccessor, final Path slashingProtectionBaseDir) {\n-    this.dataAccessor = dataAccessor;\n     this.slashingProtectionBaseDir = slashingProtectionBaseDir;\n+    this.dataAccessor = dataAccessor;\n   }\n \n   public synchronized SafeFuture<Boolean> maySignBlock(\n-      final BLSPublicKey validator, final UInt64 slot) {\n+      final BLSPublicKey validator, final ForkInfo forkInfo, final UInt64 slot) {\n     return SafeFuture.of(\n         () -> {\n           final ValidatorSigningRecord signingRecord = loadSigningRecord(validator);\n-          return handleResult(validator, signingRecord.maySignBlock(slot));\n+          return handleResult(\n+              validator, forkInfo.getGenesisValidatorsRoot(), signingRecord.maySignBlock(slot));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMTQ0OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480401448", "bodyText": "we discussed the validation against the existing validators root being a separate ticket?\ni've updated maySignBlock and maySignAttestation to have bytes32 instead of forkInfo come in", "author": "rolfyone", "createdAt": "2020-08-31T21:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3OTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDA3MA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880070", "bodyText": "How did we manage to make this so much more complex?  Can we go back to how we were doing serialisation for ValidatorSigningRecord?  We seem to have wound up with yaml, IO and data model responsibilities scattered all through the code now.", "author": "ajsutton", "createdAt": "2020-08-31T04:21:10Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java", "diffHunk": "@@ -74,15 +88,35 @@ private ValidatorSigningRecord loadSigningRecord(final BLSPublicKey validator)\n     record =\n         dataAccessor\n             .read(validatorRecordPath(validator))\n-            .map(ValidatorSigningRecord::fromBytes)\n+            .map(\n+                val -> {\n+                  try {\n+                    return yamlProvider\n+                        .getObjectMapper()\n+                        .readValue(val.toArray(), SlashingProtectionRecord.class);\n+                  } catch (IOException e) {\n+                    LOG.trace(\n+                        \"error parsing slashing protection file \" + validatorRecordPath(validator),\n+                        e);\n+                  }\n+                  return new SlashingProtectionRecord();\n+                })\n+            .map(ValidatorSigningRecord::fromSlashingProtectionRecord)", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzNzQ1MQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480437451", "bodyText": "this is mostly because i had removed the separate yaml processor that had specific logic for how to export the validatorSigningRecord, and used the one in data. If we want two versions of yaml processor we could go back to the old version and clean that up a bit, but it was also doing things in a weird way... i could clean that up rather than pushing this through the other processor?\nI guess i'd really like to have 1 yaml provider and 1 object definition for the serialized file, and its hard to access it from the import/export commands, so pushing it to one with minimal dependencies so that it could be reused was where i was headed...", "author": "rolfyone", "createdAt": "2020-08-31T22:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDU1Mg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880552", "bodyText": "Would be good to keep these as a simple delegation so that this class is focussed on being the data model and the details of serialisation are handled separately.\nBut they've also wound up only being used by tests which suggests the tests aren't actually testing what the production code now does.", "author": "ajsutton", "createdAt": "2020-08-31T04:23:29Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java", "diffHunk": "@@ -52,11 +60,24 @@ public ValidatorSigningRecord(\n   }\n \n   public static ValidatorSigningRecord fromBytes(final Bytes data) {\n-    return ValidatorSigningRecordSerialization.readRecord(data);\n+    try {\n+      final SlashingProtectionRecord spr =\n+          yamlProvider.getObjectMapper().readValue(data.toArray(), SlashingProtectionRecord.class);\n+      return ValidatorSigningRecord.fromSlashingProtectionRecord(spr);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n   }\n \n   public Bytes toBytes() {\n-    return ValidatorSigningRecordSerialization.writeRecord(this);\n+    try {\n+      return Bytes.wrap(\n+          yamlProvider.getObjectMapper().writeValueAsBytes(this.toSlashingProtectionRecord(null)));\n+    } catch (JsonGenerationException | JsonMappingException e) {\n+      throw new IllegalStateException(\"Failed to serialize ValidatorSigningRecord\", e);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n   }", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzODczMw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480438733", "bodyText": "My original implementation had this all removed pretty much, and the tests actually wrote to file, and checked the file contents. It as closer to production because it was following it more faithfully, but we didn't want to remove the sync data writer, so i went back to this, but i think i preferred the old one more...", "author": "rolfyone", "createdAt": "2020-08-31T22:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDczMQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880731", "bodyText": "We should be consistent with using NEVER_SIGNED rather than using null directly.", "author": "ajsutton", "createdAt": "2020-08-31T04:24:34Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java", "diffHunk": "@@ -92,24 +139,22 @@ public Bytes toBytes() {\n   }\n \n   private boolean isSafeSourceEpoch(final UInt64 sourceEpoch) {\n-    return attestationSourceEpoch.equals(NEVER_SIGNED)\n-        || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;\n+    return attestationSourceEpoch == null || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDkxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880919", "bodyText": "These shouldn't be public as we want to encapsulate the data as much as we can and just have the maySign* methods as the key public API.  They do appear to be unused now though.", "author": "ajsutton", "createdAt": "2020-08-31T04:25:16Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java", "diffHunk": "@@ -92,24 +139,22 @@ public Bytes toBytes() {\n   }\n \n   private boolean isSafeSourceEpoch(final UInt64 sourceEpoch) {\n-    return attestationSourceEpoch.equals(NEVER_SIGNED)\n-        || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;\n+    return attestationSourceEpoch == null || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;\n   }\n \n   private boolean isSafeTargetEpoch(final UInt64 targetEpoch) {\n-    return attestationTargetEpoch.equals(NEVER_SIGNED)\n-        || attestationTargetEpoch.compareTo(targetEpoch) < 0;\n+    return attestationTargetEpoch == null || attestationTargetEpoch.compareTo(targetEpoch) < 0;\n   }\n \n-  UInt64 getBlockSlot() {\n+  public UInt64 getBlockSlot() {\n     return blockSlot;\n   }\n \n-  UInt64 getAttestationSourceEpoch() {\n+  public UInt64 getAttestationSourceEpoch() {\n     return attestationSourceEpoch;\n   }\n \n-  UInt64 getAttestationTargetEpoch() {\n+  public UInt64 getAttestationTargetEpoch() {\n     return attestationTargetEpoch;\n   }", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTMxNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479881314", "bodyText": "This is a human friendly name so:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Mixin(name = \"DataStorage\")\n          \n          \n            \n              @Mixin(name = \"Data Storage\")", "author": "ajsutton", "createdAt": "2020-08-31T04:27:13Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java", "diffHunk": "@@ -149,6 +152,9 @@\n   @Mixin(name = \"Data\")\n   private DataOptions dataOptions;\n \n+  @Mixin(name = \"DataStorage\")", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTkwNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479881904", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                description = \"Export slashing protection database in Minimal format.\",\n          \n          \n            \n                description = \"Export slashing protection database in minimal format.\",", "author": "ajsutton", "createdAt": "2020-08-31T04:30:02Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.cli.slashingprotection;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.util.Strings;\n+import picocli.CommandLine;\n+import tech.pegasys.teku.cli.options.DataOptions;\n+import tech.pegasys.teku.data.SlashingProtectionExporter;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n+\n+@CommandLine.Command(\n+    name = \"export\",\n+    description = \"Export slashing protection database in Minimal format.\",", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NDQ1MA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479884450", "bodyText": "you sure? minimal is the name of the format...", "author": "rolfyone", "createdAt": "2020-08-31T04:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NDgxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479884819", "bodyText": "Docs team might overrule me but even with it being the name of the format it's not a proper noun so doesn't deserve a capital.", "author": "ajsutton", "createdAt": "2020-08-31T04:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MjI0Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479882246", "bodyText": "We should probably display an error an exit if there are no slashing protection records found (ie the directory exists but is empty)", "author": "ajsutton", "createdAt": "2020-08-31T04:31:39Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.cli.slashingprotection;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.util.Strings;\n+import picocli.CommandLine;\n+import tech.pegasys.teku.cli.options.DataOptions;\n+import tech.pegasys.teku.data.SlashingProtectionExporter;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n+\n+@CommandLine.Command(\n+    name = \"export\",\n+    description = \"Export slashing protection database in Minimal format.\",\n+    mixinStandardHelpOptions = true,\n+    abbreviateSynopsis = true,\n+    versionProvider = PicoCliVersionProvider.class,\n+    synopsisHeading = \"%n\",\n+    descriptionHeading = \"%nDescription:%n%n\",\n+    optionListHeading = \"%nOptions:%n\",\n+    footerHeading = \"%n\",\n+    footer = \"Teku is licensed under the Apache License 2.0\")\n+public class ExportCommand implements Runnable {\n+  public static final SubCommandLogger SUB_COMMAND_LOG = new SubCommandLogger();\n+\n+  @CommandLine.Mixin(name = \"Data\")\n+  private DataOptions dataOptions;\n+\n+  @CommandLine.Option(\n+      names = {\"--to\"},\n+      paramLabel = \"<FILENAME>\",\n+      description = \"The file to export the slashing protection database to.\",\n+      required = true,\n+      arity = \"1\")\n+  private String toFileName = Strings.EMPTY;\n+\n+  @Override\n+  public void run() {\n+\n+    final Path slashProtectionPath =\n+        DataOptions.getValidatorsSlashingProtectionPath(dataOptions.getDataPath());\n+    verifySlashingProtectionPathExists(slashProtectionPath);\n+\n+    SlashingProtectionExporter slashingProtectionExporter = new SlashingProtectionExporter();\n+\n+    SUB_COMMAND_LOG.display(\"Reading slashing protection data from: \" + slashProtectionPath);\n+    slashingProtectionExporter.initialise(slashProtectionPath);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3OTc3OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479979778", "bodyText": "I could potentially also output each file that I load? I ended up doing this on import, but maybe i should do it on export also...", "author": "rolfyone", "createdAt": "2020-08-31T08:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MjM1Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479882356", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"Import slashing protection database. Supports Minimal or Complete interchange format.\",\n          \n          \n            \n                    \"Import slashing protection database. Supports minimal or complete interchange format.\",", "author": "ajsutton", "createdAt": "2020-08-31T04:32:16Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ImportCommand.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.cli.slashingprotection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.util.Strings;\n+import picocli.CommandLine;\n+import tech.pegasys.teku.cli.options.DataOptions;\n+import tech.pegasys.teku.data.SlashingProtectionImporter;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n+\n+@CommandLine.Command(\n+    name = \"import\",\n+    description =\n+        \"Import slashing protection database. Supports Minimal or Complete interchange format.\",", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MzYxNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479883615", "bodyText": "Calculating the slashingProtectionPath should stay inside ValidatorClientService.  The ServiceController class should know as little as possible about the details of the service and basically just create and pass the ServiceConfig.", "author": "ajsutton", "createdAt": "2020-08-31T04:38:29Z", "path": "teku/src/main/java/tech/pegasys/teku/services/ServiceController.java", "diffHunk": "@@ -37,7 +39,9 @@ public ServiceController(final ServiceConfig config) {\n     if (config.getConfig().isRemoteValidatorApiEnabled()) {\n       services.add(new RemoteValidatorService(config));\n     } else {\n-      services.add(ValidatorClientService.create(config));\n+      final Path slashingProtectionPath =\n+          DataOptions.getValidatorsSlashingProtectionPath(config.getConfig().getDataPath());\n+      services.add(ValidatorClientService.create(config, slashingProtectionPath));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3Nzk3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479977977", "bodyText": "I had settled on this because DataOptions wasn't available to the validatorClient, and validatorClient wasn't available to the import/export, so I'll have to have a think about how this is all going to link together and come up with another solution i guess.", "author": "rolfyone", "createdAt": "2020-08-31T08:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MzYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNzYzOA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481517638", "bodyText": "Maybe just add a separate item to TekuConfiguration that has the slashing protection path.  Right now it would be calculated off of data dir but then we'd be in a good place to be able to make it a separate CLI arg in the future.", "author": "ajsutton", "createdAt": "2020-09-02T01:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MzYxNQ=="}], "type": "inlineReview"}, {"oid": "ed0521d9708edd5f3432d5dfaa791003a578287d", "url": "https://github.com/ConsenSys/teku/commit/ed0521d9708edd5f3432d5dfaa791003a578287d", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T08:32:13Z", "type": "commit"}, {"oid": "31497fb11449f47719f2f4f4376871a95c7472a0", "url": "https://github.com/ConsenSys/teku/commit/31497fb11449f47719f2f4f4376871a95c7472a0", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T21:30:52Z", "type": "commit"}, {"oid": "2332d9b2e25a1d362ce894e38009409506b89216", "url": "https://github.com/ConsenSys/teku/commit/2332d9b2e25a1d362ce894e38009409506b89216", "message": "merged 2601-signingrecord, and fixed build to work with the new signing record package.\n\nalso added some output and summaries to the command line output.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-01T07:00:13Z", "type": "commit"}, {"oid": "9f19e239c4b52c0f89b8a64e66a9951209808a15", "url": "https://github.com/ConsenSys/teku/commit/9f19e239c4b52c0f89b8a64e66a9951209808a15", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-01T20:25:40Z", "type": "commit"}, {"oid": "afb3d19ea738a63dfdf8bcd7499991070971d066", "url": "https://github.com/ConsenSys/teku/commit/afb3d19ea738a63dfdf8bcd7499991070971d066", "message": "updated interchange version to v.3\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-01T22:14:35Z", "type": "commit"}, {"oid": "457a0940eb6551dbfd9cd8eecb1ce2253f66f5cf", "url": "https://github.com/ConsenSys/teku/commit/457a0940eb6551dbfd9cd8eecb1ce2253f66f5cf", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-01T22:15:00Z", "type": "commit"}, {"oid": "70d80edf2d3ed5d86cf5d5cccc622ae2d41ea20a", "url": "https://github.com/ConsenSys/teku/commit/70d80edf2d3ed5d86cf5d5cccc622ae2d41ea20a", "message": "negative testing for import.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T00:02:03Z", "type": "commit"}, {"oid": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "url": "https://github.com/ConsenSys/teku/commit/e7c50eaf64bd873153414b11f7bec3d9b8aca957", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T00:09:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNzgwNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481507805", "bodyText": "nit: Since we're reading all the bytes at once anyway we can just use:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                try (InputStream input = Files.newInputStream(file.toPath())) {\n          \n          \n            \n                  ValidatorSigningRecord validatorSigningRecord =\n          \n          \n            \n                      ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n          \n          \n            \n                try {\n          \n          \n            \n                  ValidatorSigningRecord validatorSigningRecord =\n          \n          \n            \n                      ValidatorSigningRecord.fromBytes(Bytes.of(Files.readAllBytes(file.toPath)));", "author": "ajsutton", "createdAt": "2020-09-02T00:39:39Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionExporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try (InputStream input = Files.newInputStream(file.toPath())) {\n+      ValidatorSigningRecord validatorSigningRecord =\n+          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwODc3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481508776", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"the genesisValidatorsRoot of \"\n          \n          \n            \n                        \"The genesisValidatorsRoot of \"", "author": "ajsutton", "createdAt": "2020-09-02T00:43:24Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionExporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try (InputStream input = Files.newInputStream(file.toPath())) {\n+      ValidatorSigningRecord validatorSigningRecord =\n+          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n+      if (genesisValidatorsRoot == null\n+          && validatorSigningRecord.getGenesisValidatorsRoot() != null) {\n+        this.genesisValidatorsRoot = validatorSigningRecord.getGenesisValidatorsRoot();\n+      } else if (validatorSigningRecord.getGenesisValidatorsRoot() != null\n+          && !genesisValidatorsRoot.equals(validatorSigningRecord.getGenesisValidatorsRoot())) {\n+        log.exit(\n+            1,\n+            \"the genesisValidatorsRoot of \"", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwODg1NA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481508854", "bodyText": "Not sure why there's a toLowerCase on this.", "author": "ajsutton", "createdAt": "2020-09-02T00:43:41Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionExporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try (InputStream input = Files.newInputStream(file.toPath())) {\n+      ValidatorSigningRecord validatorSigningRecord =\n+          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n+      if (genesisValidatorsRoot == null\n+          && validatorSigningRecord.getGenesisValidatorsRoot() != null) {\n+        this.genesisValidatorsRoot = validatorSigningRecord.getGenesisValidatorsRoot();\n+      } else if (validatorSigningRecord.getGenesisValidatorsRoot() != null\n+          && !genesisValidatorsRoot.equals(validatorSigningRecord.getGenesisValidatorsRoot())) {\n+        log.exit(\n+            1,\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjQ0NA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481532444", "bodyText": "just to guarantee lower case, I can remove it... it was just something i got in the habit of when doing rest api because we always wanted it in lowercase...", "author": "rolfyone", "createdAt": "2020-09-02T01:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwODg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMTI2Mg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481511262", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n          \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();", "author": "ajsutton", "createdAt": "2020-09-02T00:46:46Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMTQwNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481511405", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n          \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();", "author": "ajsutton", "createdAt": "2020-09-02T00:46:57Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMTg2MA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481511860", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n          \n          \n            \n                  if (!INTERCHANGE_VERSION.equals(metadata.interchangeFormatVersion)) {\n          \n      \n    \n    \n  \n\nto avoid potential NullPointerException if the version is missing (Jackson might have caught it already but doesn't hurt to be paranoid)", "author": "ajsutton", "createdAt": "2020-09-02T00:48:40Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjAxNw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481512017", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"Import file \"\n          \n          \n            \n                            + inputFile.toString()\n          \n          \n            \n                            + \" is not format version \"\n          \n          \n            \n                            + INTERCHANGE_VERSION.toString()\n          \n          \n            \n                            + \", cannot continue.\");\n          \n          \n            \n                        \"Import file \"\n          \n          \n            \n                            + inputFile.toString()\n          \n          \n            \n                            + \" has unsupported format version \"\n          \n          \n            \n                            + metadata.interchangeFormatVersion\n          \n          \n            \n                            + \". Required version is \"\n          \n          \n            \n                            + INTERCHANGE_VERSION);", "author": "ajsutton", "createdAt": "2020-09-02T00:49:18Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjUxMg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481512512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n          \n          \n            \n                String validatorString = minimalSigningHistory.pubkey.toUnprefixedHexString().toLowerCase();", "author": "ajsutton", "createdAt": "2020-09-02T00:51:05Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjYzNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481512634", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n          \n          \n            \n                Path outputFile = slashingProtectionPath.resolve(validatorString + \".yml\");", "author": "ajsutton", "createdAt": "2020-09-02T00:51:40Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    log.display(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMzQ1OQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481513459", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  try (InputStream input = Files.newInputStream(outputFile)) {\n          \n          \n            \n                    existingRecord =\n          \n          \n            \n                        Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes())));\n          \n          \n            \n                  try {\n          \n          \n            \n                    existingRecord =\n          \n          \n            \n                        Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(Files.readAllBytes(outputFile)));", "author": "ajsutton", "createdAt": "2020-09-02T00:53:19Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    log.display(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n+    Optional<ValidatorSigningRecord> existingRecord = Optional.empty();\n+    if (outputFile.toFile().exists()) {\n+      try (InputStream input = Files.newInputStream(outputFile)) {\n+        existingRecord =\n+            Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes())));", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNTE1Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481515156", "bodyText": "Actually probably should use SyncDataAccessor here to make sure the change is really persisted to disk.  Likely have to move it to a different module but it's very standalone so that should be easy enough.", "author": "ajsutton", "createdAt": "2020-09-02T00:55:07Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    log.display(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n+    Optional<ValidatorSigningRecord> existingRecord = Optional.empty();\n+    if (outputFile.toFile().exists()) {\n+      try (InputStream input = Files.newInputStream(outputFile)) {\n+        existingRecord =\n+            Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes())));\n+      } catch (IOException e) {\n+        log.exit(1, \"Failed to read existing file: \" + outputFile.toString());\n+      }\n+    }\n+    if (existingRecord.isPresent()\n+        && metadata.genesisValidatorsRoot.compareTo(existingRecord.get().getGenesisValidatorsRoot())\n+            != 0) {\n+      log.exit(\n+          1,\n+          \"Validator \"\n+              + minimalSigningHistory.pubkey.toHexString()\n+              + \" has a different validators signing root to the data being imported\");\n+    }\n+\n+    try (OutputStream out = Files.newOutputStream(outputFile)) {\n+      out.write(\n+          minimalSigningHistory\n+              .toValidatorSigningRecord(existingRecord, metadata.genesisValidatorsRoot)\n+              .toBytes()\n+              .toArray());\n+    } catch (IOException e) {", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjI2OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481516268", "bodyText": "I think these are going to be renamed - probably wind up with a version 4.  Ok to merge as-is but we probably should wait for that change to come through before we really announce this so that we don't have to maintain support for version 3.", "author": "ajsutton", "createdAt": "2020-09-02T00:56:17Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/slashinginterchange/MinimalSigningHistory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data.slashinginterchange;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+public class MinimalSigningHistory {\n+  @JsonProperty(\"pubkey\")\n+  public final BLSPubKey pubkey;\n+\n+  @JsonProperty(\"last_signed_block_slot\")\n+  public final UInt64 lastSignedBlockSlot;\n+\n+  @JsonProperty(\"last_signed_attestation_source_epoch\")\n+  public final UInt64 lastSignedAttestationSourceEpoch;\n+\n+  @JsonProperty(\"last_signed_attestation_target_epoch\")", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY5ODMzNw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481698337", "bodyText": "interesting, but sounds like not a merge issue, so will mark resolved", "author": "rolfyone", "createdAt": "2020-09-02T05:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjI2OA=="}], "type": "inlineReview"}, {"oid": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "url": "https://github.com/ConsenSys/teku/commit/1f09c1fce8dff230cde09070cc23ea8320f7036a", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:35:11Z", "type": "commit"}, {"oid": "75786833b1c3c1ec15e377923e08a5bcceeed9b6", "url": "https://github.com/ConsenSys/teku/commit/75786833b1c3c1ec15e377923e08a5bcceeed9b6", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:37:50Z", "type": "commit"}, {"oid": "627914166a4c205c66ecf2cd12c53c28903f38d9", "url": "https://github.com/ConsenSys/teku/commit/627914166a4c205c66ecf2cd12c53c28903f38d9", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:00Z", "type": "commit"}, {"oid": "24d97258daf97966b13f8d3a23d36876b8ae7a7c", "url": "https://github.com/ConsenSys/teku/commit/24d97258daf97966b13f8d3a23d36876b8ae7a7c", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:15Z", "type": "commit"}, {"oid": "4a17a90feb94e961c04d61be00512a348ea75479", "url": "https://github.com/ConsenSys/teku/commit/4a17a90feb94e961c04d61be00512a348ea75479", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:39Z", "type": "commit"}, {"oid": "ef7344b897003978cfa619a0b840262ace522b10", "url": "https://github.com/ConsenSys/teku/commit/ef7344b897003978cfa619a0b840262ace522b10", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:47Z", "type": "commit"}, {"oid": "08181b921cf76fd2d4c850792be37b4857145b0e", "url": "https://github.com/ConsenSys/teku/commit/08181b921cf76fd2d4c850792be37b4857145b0e", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T02:14:38Z", "type": "commit"}, {"oid": "0ae95c4d890ce0d8e9f97919babd2eae1ae7f3c4", "url": "https://github.com/ConsenSys/teku/commit/0ae95c4d890ce0d8e9f97919babd2eae1ae7f3c4", "message": "Merge branch '2601' of https://github.com/rolfyone/artemis into 2601", "committedDate": "2020-09-02T02:14:54Z", "type": "commit"}, {"oid": "763c14507da9e17d390f028f2d879ad4de9db582", "url": "https://github.com/ConsenSys/teku/commit/763c14507da9e17d390f028f2d879ad4de9db582", "message": "use SyncDataAccessor in import/export operations.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T03:30:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYzODk3OQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481638979", "bodyText": "Since we're creating a new module (which is a good idea), I'd call it :infrastructure:io rather than :data:files.", "author": "ajsutton", "createdAt": "2020-09-02T04:02:42Z", "path": "data/files/src/main/java/tech/pegasys/teku/data/files/SyncDataAccessor.java", "diffHunk": "@@ -11,7 +11,7 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.teku.core.signatures;\n+package tech.pegasys.teku.data.files;", "originalCommit": "763c14507da9e17d390f028f2d879ad4de9db582", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY0MTI0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481641249", "bodyText": "We can just pass in config now and have ValidatorClientService get the slashing protection path from the config itself.", "author": "ajsutton", "createdAt": "2020-09-02T04:05:09Z", "path": "teku/src/main/java/tech/pegasys/teku/services/ServiceController.java", "diffHunk": "@@ -37,7 +38,8 @@ public ServiceController(final ServiceConfig config) {\n     if (config.getConfig().isRemoteValidatorApiEnabled()) {\n       services.add(new RemoteValidatorService(config));\n     } else {\n-      services.add(ValidatorClientService.create(config));\n+      final Path slashingProtectionPath = config.getConfig().getValidatorsSlashingProtectionPath();\n+      services.add(ValidatorClientService.create(config, slashingProtectionPath));", "originalCommit": "763c14507da9e17d390f028f2d879ad4de9db582", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2bdab638cedd5029026af934fa1011ca93995ca3", "url": "https://github.com/ConsenSys/teku/commit/2bdab638cedd5029026af934fa1011ca93995ca3", "message": "rename new package for SyncDataAccessor to infrastructure:io\n\n - also get slashingProtection path from tekuConfig rather than passing into ValidatorClientService.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T04:36:34Z", "type": "commit"}, {"oid": "810bfd8d16d4191b9495ec373bdb11f55527be3e", "url": "https://github.com/ConsenSys/teku/commit/810bfd8d16d4191b9495ec373bdb11f55527be3e", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T04:52:15Z", "type": "commit"}, {"oid": "99efafb5fb82e8ee163205c40c3e7eaf60142978", "url": "https://github.com/ConsenSys/teku/commit/99efafb5fb82e8ee163205c40c3e7eaf60142978", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T09:12:51Z", "type": "commit"}, {"oid": "e0a906950a6d841ec04cd324416ca0dbe0a10a9a", "url": "https://github.com/ConsenSys/teku/commit/e0a906950a6d841ec04cd324416ca0dbe0a10a9a", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T20:01:28Z", "type": "commit"}, {"oid": "d16da80777f6a5068494ec437676e27a8a2814d3", "url": "https://github.com/ConsenSys/teku/commit/d16da80777f6a5068494ec437676e27a8a2814d3", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T21:54:46Z", "type": "commit"}, {"oid": "deb83c4c61cdec1a2eb43323f9ef233de3694e3b", "url": "https://github.com/ConsenSys/teku/commit/deb83c4c61cdec1a2eb43323f9ef233de3694e3b", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T22:20:17Z", "type": "commit"}, {"oid": "cc10af22eb1df1c2e362c841e064f94fb9b8513c", "url": "https://github.com/ConsenSys/teku/commit/cc10af22eb1df1c2e362c841e064f94fb9b8513c", "message": "Apply suggestions from code review\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T22:51:17Z", "type": "commit"}, {"oid": "e4d59728e912bc492b1c4416fa6cbac101bb3ac3", "url": "https://github.com/ConsenSys/teku/commit/e4d59728e912bc492b1c4416fa6cbac101bb3ac3", "message": "fix build\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T23:11:47Z", "type": "commit"}, {"oid": "b448687f8c9e7cbabbb2550c6dc911f1694d5ee4", "url": "https://github.com/ConsenSys/teku/commit/b448687f8c9e7cbabbb2550c6dc911f1694d5ee4", "message": "unit test fix\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T23:20:22Z", "type": "commit"}]}