{"pr_number": 1179, "pr_title": "Micronaut support final", "pr_createdAt": "2020-09-25T10:02:38Z", "pr_url": "https://github.com/resilience4j/resilience4j/pull/1179", "timeline": [{"oid": "db718dfb8f04fa3066fb984fd72021f1d3e212c3", "url": "https://github.com/resilience4j/resilience4j/commit/db718dfb8f04fa3066fb984fd72021f1d3e212c3", "message": "Micronaut support (#1036)", "committedDate": "2020-06-22T09:02:28Z", "type": "commit"}, {"oid": "7c17948c5e2860dda68192b146546f43c3d43e1a", "url": "https://github.com/resilience4j/resilience4j/commit/7c17948c5e2860dda68192b146546f43c3d43e1a", "message": "Added qualifier to resilience4j-micronaut to correct multiple resolved types (#1051)", "committedDate": "2020-06-29T07:34:47Z", "type": "commit"}, {"oid": "6623abc15ea4c685edc1b6454d4191843200a12c", "url": "https://github.com/resilience4j/resilience4j/commit/6623abc15ea4c685edc1b6454d4191843200a12c", "message": "Removed annotation mapper (#1104)", "committedDate": "2020-08-12T06:52:23Z", "type": "commit"}, {"oid": "5ab4e5d73df97788622c5ff1e64d92e6eeb81573", "url": "https://github.com/resilience4j/resilience4j/commit/5ab4e5d73df97788622c5ff1e64d92e6eeb81573", "message": "cleanup and remove unused imports", "committedDate": "2020-09-02T03:50:45Z", "type": "commit"}, {"oid": "bbe2a7ef11e6b1bc44b34db088bd9f55520316cc", "url": "https://github.com/resilience4j/resilience4j/commit/bbe2a7ef11e6b1bc44b34db088bd9f55520316cc", "message": "clean up code and rename test", "committedDate": "2020-09-03T22:09:28Z", "type": "commit"}, {"oid": "419c6143c7342718917725b05b26254f3b3e75d1", "url": "https://github.com/resilience4j/resilience4j/commit/419c6143c7342718917725b05b26254f3b3e75d1", "message": "remove http server for test and clean up imports", "committedDate": "2020-09-14T19:53:51Z", "type": "commit"}, {"oid": "c82679d6220153693cc533c8c994fd28496af44c", "url": "https://github.com/resilience4j/resilience4j/commit/c82679d6220153693cc533c8c994fd28496af44c", "message": "simplify test and added coverage for timelimiter", "committedDate": "2020-09-14T23:24:06Z", "type": "commit"}, {"oid": "62568873c933d9663ba4d8a317269a9d45859a1b", "url": "https://github.com/resilience4j/resilience4j/commit/62568873c933d9663ba4d8a317269a9d45859a1b", "message": "Merge remote-tracking branch 'upstream/master' into micronaut", "committedDate": "2020-09-24T12:06:57Z", "type": "commit"}, {"oid": "031c90268a7ef2a67a32341dd34ecd3c37576cd5", "url": "https://github.com/resilience4j/resilience4j/commit/031c90268a7ef2a67a32341dd34ecd3c37576cd5", "message": "Merge remote-tracking branch 'upstream/micronaut' into rework_cleanup", "committedDate": "2020-09-25T09:49:41Z", "type": "commit"}, {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "url": "https://github.com/resilience4j/resilience4j/commit/e00af2462a8f45c1ad1983e17249824c82a30dd3", "message": "update the package to include micronaut plus cleaning java doc", "committedDate": "2020-09-25T12:40:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786749", "bodyText": "@RobWin @pollend  is that right ?  i guess we need to wrap the call in bulkhead.executeCompletionStage not the result of the proceed ?", "author": "Romeh", "createdAt": "2020-09-28T08:55:14Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MTUzNQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496541535", "bodyText": "Yes, correct.\nPlease see https://github.com/resilience4j/resilience4j/blob/master/resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspect.java#L221-L230", "author": "RobWin", "createdAt": "2020-09-29T08:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NTUwOQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496885509", "bodyText": "The result it is used in an executeCompletionStage on line 104. I write it to an object first to do a null check. so would it just execute the proceeded within the executeCompletionStage? if its null then it will error out right? I guess it shouldn't matter because it will still throw it back to the fallbackCompletable.\nreturn this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);", "author": "pollend", "createdAt": "2020-09-29T16:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786947", "bodyText": "Same comment as above ?", "author": "Romeh", "createdAt": "2020-09-28T08:55:35Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MzU3Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496543577", "bodyText": "No, here it's fine.\nA Publisher is emitting events, when someone subscribes.", "author": "RobWin", "createdAt": "2020-09-29T08:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495788546", "bodyText": "why we are doing the process call here ?", "author": "Romeh", "createdAt": "2020-09-28T08:58:13Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = ThreadPoolBulkheadRegistry.class)\n+public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolBulkheadInterceptor.class);\n+\n+    private final ThreadPoolBulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     * @param beanContext      The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public ThreadPoolBulkheadInterceptor(BeanContext beanContext,\n+                                         ThreadPoolBulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n+            return context.proceed();\n+        }\n+        final String name = opt.get().stringValue().orElse(\"default\");\n+        ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDU4Mw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544583", "bodyText": "Method must be decorated, before it is executed.", "author": "RobWin", "createdAt": "2020-09-29T08:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789037", "bodyText": "why not wrapping the proceed call with circuitBreaker.executeCompletionStage()  ?", "author": "Romeh", "createdAt": "2020-09-28T08:59:00Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDc3MA==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544770", "bodyText": "Same as above", "author": "RobWin", "createdAt": "2020-09-29T08:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTE1Mg==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789152", "bodyText": "Same comment ?!", "author": "Romeh", "createdAt": "2020-09-28T08:59:11Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTQ1Mg==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789452", "bodyText": "Same comment ?!", "author": "Romeh", "createdAt": "2020-09-28T08:59:41Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.ratelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterRegistry;\n+import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = RateLimiterRegistry.class)\n+public class RateLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object, Object> {\n+    private final RateLimiterRegistry rateLimiterRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public RateLimiterInterceptor(BeanContext beanContext, RateLimiterRegistry rateLimiterRegistry) {\n+        this.rateLimiterRegistry = rateLimiterRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RATE_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.RateLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.RateLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"name\").orElse(\"default\");\n+        RateLimiter rateLimiter = this.rateLimiterRegistry.rateLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTU0Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789547", "bodyText": "Same ?!", "author": "Romeh", "createdAt": "2020-09-28T08:59:49Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.ratelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterRegistry;\n+import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = RateLimiterRegistry.class)\n+public class RateLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object, Object> {\n+    private final RateLimiterRegistry rateLimiterRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public RateLimiterInterceptor(BeanContext beanContext, RateLimiterRegistry rateLimiterRegistry) {\n+        this.rateLimiterRegistry = rateLimiterRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RATE_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.RateLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.RateLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"name\").orElse(\"default\");\n+        RateLimiter rateLimiter = this.rateLimiterRegistry.rateLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(rateLimiter.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTc5Mg==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789792", "bodyText": "Same ?!", "author": "Romeh", "createdAt": "2020-09-28T09:00:13Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+\n+    public RetryInterceptor(BeanContext beanContext, RetryRegistry retryRegistry) {\n+        this.retryRegistry = retryRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RETRY.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Retry>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Retry.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"name\").orElse(\"default\");\n+        Retry retry = retryRegistry.retry(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTkwMQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789901", "bodyText": "Same !?", "author": "Romeh", "createdAt": "2020-09-28T09:00:23Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+\n+    public RetryInterceptor(BeanContext beanContext, RetryRegistry retryRegistry) {\n+        this.retryRegistry = retryRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RETRY.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Retry>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Retry.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"name\").orElse(\"default\");\n+        Retry retry = retryRegistry.retry(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(retry.executeCompletionStage(retryExecutorService, () -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDExNw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495790117", "bodyText": "Same ?!", "author": "Romeh", "createdAt": "2020-09-28T09:00:41Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.timelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.timelimiter.TimeLimiter;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.transformer.TimeLimiterTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = TimeLimiterRegistry.class)\n+public class TimeLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+\n+    private final TimeLimiterRegistry timeLimiterRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService timeLimiterExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+    public TimeLimiterInterceptor(BeanContext beanContext, TimeLimiterRegistry timeLimiterRegistry) {\n+        this.beanContext = beanContext;\n+        this.timeLimiterRegistry = timeLimiterRegistry;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.TIME_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.TimeLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class).orElse(\"default\");\n+        TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDI2Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495790267", "bodyText": "Same comment i guess", "author": "Romeh", "createdAt": "2020-09-28T09:00:55Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.timelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.timelimiter.TimeLimiter;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.transformer.TimeLimiterTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = TimeLimiterRegistry.class)\n+public class TimeLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+\n+    private final TimeLimiterRegistry timeLimiterRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService timeLimiterExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+    public TimeLimiterInterceptor(BeanContext beanContext, TimeLimiterRegistry timeLimiterRegistry) {\n+        this.beanContext = beanContext;\n+        this.timeLimiterRegistry = timeLimiterRegistry;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.TIME_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.TimeLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class).orElse(\"default\");\n+        TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(timeLimiter.executeCompletionStage(timeLimiterExecutorService, () -> ((CompletableFuture<?>) result)), context);\n+\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "676da2d940165295c5e20a81e3076628c3e64961", "url": "https://github.com/resilience4j/resilience4j/commit/676da2d940165295c5e20a81e3076628c3e64961", "message": "move proceed into excuteCompletionStage", "committedDate": "2020-09-29T17:05:31Z", "type": "commit"}, {"oid": "c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "url": "https://github.com/resilience4j/resilience4j/commit/c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "message": "enable event listening", "committedDate": "2020-09-29T18:01:49Z", "type": "commit"}, {"oid": "c1f27f6b8e855b01a0e425d2265789223972eec0", "url": "https://github.com/resilience4j/resilience4j/commit/c1f27f6b8e855b01a0e425d2265789223972eec0", "message": "tweak for flowable test case", "committedDate": "2020-09-29T19:41:19Z", "type": "commit"}, {"oid": "4a774192bfd0b024b2b621237da37b7e936865d7", "url": "https://github.com/resilience4j/resilience4j/commit/4a774192bfd0b024b2b621237da37b7e936865d7", "message": "Merge branch 'feature/flowable-test' into feature/tweak-completion-stage", "committedDate": "2020-09-29T19:42:10Z", "type": "commit"}, {"oid": "9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "url": "https://github.com/resilience4j/resilience4j/commit/9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "message": "correct flowable and exception", "committedDate": "2020-09-29T21:30:52Z", "type": "commit"}, {"oid": "bd485881cad4f2d7d27f45ed4568fd2910fab95e", "url": "https://github.com/resilience4j/resilience4j/commit/bd485881cad4f2d7d27f45ed4568fd2910fab95e", "message": "tweak intercept for fallback", "committedDate": "2020-09-29T21:57:36Z", "type": "commit"}, {"oid": "1954c7335d322093e67bf5627178053dcf068edd", "url": "https://github.com/resilience4j/resilience4j/commit/1954c7335d322093e67bf5627178053dcf068edd", "message": "correct recovery for threadpool bulkhead", "committedDate": "2020-09-29T22:04:29Z", "type": "commit"}, {"oid": "e938994915810ec176d1091c682b90a05861082e", "url": "https://github.com/resilience4j/resilience4j/commit/e938994915810ec176d1091c682b90a05861082e", "message": "bump", "committedDate": "2020-10-01T19:12:34Z", "type": "commit"}, {"oid": "58b991464c47c5584304f1c11517ff2e6c8bdc73", "url": "https://github.com/resilience4j/resilience4j/commit/58b991464c47c5584304f1c11517ff2e6c8bdc73", "message": "Merge pull request #1183 from pollend/feature/tweak-completion-stage\n\nfeat(micronaut): update intercept and test cases", "committedDate": "2020-10-02T08:04:51Z", "type": "commit"}, {"oid": "386aa68ef63a85e682b28458e976e85258b4392d", "url": "https://github.com/resilience4j/resilience4j/commit/386aa68ef63a85e682b28458e976e85258b4392d", "message": "remove duplicate code", "committedDate": "2020-10-06T19:24:44Z", "type": "commit"}, {"oid": "a76a6800287e5b14de84b6cb6914f77925911a1b", "url": "https://github.com/resilience4j/resilience4j/commit/a76a6800287e5b14de84b6cb6914f77925911a1b", "message": "clean up imports", "committedDate": "2020-10-06T19:28:06Z", "type": "commit"}, {"oid": "6bc66e039d40f11730c3bc7640f268b4ac3fdc3a", "url": "https://github.com/resilience4j/resilience4j/commit/6bc66e039d40f11730c3bc7640f268b4ac3fdc3a", "message": "correct javadocs", "committedDate": "2020-10-06T19:37:38Z", "type": "commit"}, {"oid": "e9548783f39ea78ff5f2a511a15bdb568bf1d4b5", "url": "https://github.com/resilience4j/resilience4j/commit/e9548783f39ea78ff5f2a511a15bdb568bf1d4b5", "message": "correct bulkhead", "committedDate": "2020-10-06T19:56:57Z", "type": "commit"}, {"oid": "44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "url": "https://github.com/resilience4j/resilience4j/commit/44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "message": "add back null check", "committedDate": "2020-10-06T20:11:58Z", "type": "commit"}, {"oid": "be03fecd0850883f170896b9a0315e84fc308141", "url": "https://github.com/resilience4j/resilience4j/commit/be03fecd0850883f170896b9a0315e84fc308141", "message": "Merge pull request #1190 from pollend/feature/micronaut-fix-duplication\n\nlower code duplication for micronaut", "committedDate": "2020-10-06T20:32:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MDYwNQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501470605", "bodyText": "For this, you may want to consider in Micronaut 2.1 using the new InterceptedMethod API which simplifies handling future/reactive/synchronous cases. See https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/runtime/src/main/java/io/micronaut/retry/intercept/RecoveryInterceptor.java#L79", "author": "graemerocher", "createdAt": "2020-10-08T06:13:20Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.discovery.exceptions.NoAvailableServiceException;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+import io.reactivex.FlowableTransformer;\n+import org.reactivestreams.Publisher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+public abstract class BaseInterceptor {", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTIxMQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471211", "bodyText": "You may want to make these values relative to the built in values in Micronaut https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/aop/src/main/java/io/micronaut/aop/InterceptPhase.java#L43", "author": "graemerocher", "createdAt": "2020-10-08T06:14:53Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.mirconaut.retry.RetryInterceptor;\n+import io.micronaut.aop.Interceptor;\n+\n+/**\n+ * <p>{@link Interceptor} classes implement the {@link io.micronaut.core.order.Ordered} interface\n+ * in order to control the order of execution when multiple interceptors are present.</p>\n+ *\n+ * <p> This class provides a set of phases used for resilience4j</p>\n+ * <p>\n+ * The default order of phases are: <code>Retry ( CircuitBreaker ( RateLimiter ( TimeLimiter ( Bulkhead ( Function ) ) ) ) )</code>\n+ * The order places this at {@link RetryInterceptor} and before {@link io.micronaut.retry.intercept.RecoveryInterceptor}\n+ */\n+public enum ResilienceInterceptPhase {\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RETRY(-60),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    CIRCUIT_BREAKER(-55),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RATE_LIMITER(-50),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    TIME_LIMITER(-45),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    BULKHEAD(-40);", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTU5MQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471591", "bodyText": "For Micronaut 2.0 and above you will need to add @Executable meta annotation to these annotations", "author": "graemerocher", "createdAt": "2020-10-08T06:15:59Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package io.github.resilience4j.mirconaut.annotation;\n+\n+import io.github.resilience4j.mirconaut.bulkhead.BulkheadInterceptor;\n+import io.github.resilience4j.mirconaut.bulkhead.ThreadPoolBulkheadInterceptor;\n+import io.micronaut.aop.Around;\n+import io.micronaut.context.annotation.Type;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * This annotation can be applied to a class or a specific method. Applying it on a class is\n+ * equivalent to applying it on all its public methods.\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Target(value = {ElementType.METHOD, ElementType.TYPE})\n+@Around\n+@Type({BulkheadInterceptor.class, ThreadPoolBulkheadInterceptor.class})\n+@Documented\n+public @interface Bulkhead {", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MjM3NQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501472375", "bodyText": "This thread pool should be shutdown in a @PreDestroy method. Alternatively if you can use one of Micronaut's built in thread pools by injecting for example @Named(TasksExecutors.IO) ScheduledExecutorService executorService", "author": "graemerocher", "createdAt": "2020-10-08T06:18:12Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18f44fd27466086da055aa6b931fece30838b614", "url": "https://github.com/resilience4j/resilience4j/commit/18f44fd27466086da055aa6b931fece30838b614", "message": "Correct resilience4j-micronaut package name (#1195)", "committedDate": "2020-10-08T06:22:52Z", "type": "commit"}, {"oid": "bad74de92dc11dfa15e502ece51804928844371b", "url": "https://github.com/resilience4j/resilience4j/commit/bad74de92dc11dfa15e502ece51804928844371b", "message": "review comments for micronaut integration", "committedDate": "2020-10-08T13:24:02Z", "type": "commit"}, {"oid": "73bb54660f3dde616d46a62904897316316b773a", "url": "https://github.com/resilience4j/resilience4j/commit/73bb54660f3dde616d46a62904897316316b773a", "message": "review comments for micronaut integration", "committedDate": "2020-10-08T13:33:26Z", "type": "commit"}, {"oid": "2312e448c39790e37bc9c7493a4fde3ee68cc537", "url": "https://github.com/resilience4j/resilience4j/commit/2312e448c39790e37bc9c7493a4fde3ee68cc537", "message": "update intercept", "committedDate": "2020-10-08T17:28:57Z", "type": "commit"}, {"oid": "8df034e63c1060c89b38076d496b3605fd134f5f", "url": "https://github.com/resilience4j/resilience4j/commit/8df034e63c1060c89b38076d496b3605fd134f5f", "message": "tweak to assignment", "committedDate": "2020-10-08T17:45:27Z", "type": "commit"}, {"oid": "8670290e4bb5c3c8981b200adad0462b540a7481", "url": "https://github.com/resilience4j/resilience4j/commit/8670290e4bb5c3c8981b200adad0462b540a7481", "message": "fix problem with test not running", "committedDate": "2020-10-08T18:44:47Z", "type": "commit"}, {"oid": "7943edc8eefdce244c09cc44a09ccb92111e65b8", "url": "https://github.com/resilience4j/resilience4j/commit/7943edc8eefdce244c09cc44a09ccb92111e65b8", "message": "Merge pull request #1197 from pollend/feature/rework-intercept\n\nUpdate Micronaut intercept", "committedDate": "2020-10-08T18:55:17Z", "type": "commit"}, {"oid": "d87effab2edfdb3562814b63ee3cd373818ce879", "url": "https://github.com/resilience4j/resilience4j/commit/d87effab2edfdb3562814b63ee3cd373818ce879", "message": "pump the versions", "committedDate": "2020-10-08T18:57:24Z", "type": "commit"}, {"oid": "1f643d71fe6eb6f51065303184e3e7f648be6129", "url": "https://github.com/resilience4j/resilience4j/commit/1f643d71fe6eb6f51065303184e3e7f648be6129", "message": "Adding more test and reverting groovy version plus code imports optimziation", "committedDate": "2020-10-08T19:21:36Z", "type": "commit"}, {"oid": "02b44886ca7309327d17ac828d135bdc8df911c7", "url": "https://github.com/resilience4j/resilience4j/commit/02b44886ca7309327d17ac828d135bdc8df911c7", "message": "Adding more test and reverting groovy version plus code imports optimziation", "committedDate": "2020-10-08T19:30:19Z", "type": "commit"}, {"oid": "acf680cfb9afa7dbb309caaabb577a872d30bcf5", "url": "https://github.com/resilience4j/resilience4j/commit/acf680cfb9afa7dbb309caaabb577a872d30bcf5", "message": "Adding NULL test case for one of reactive types", "committedDate": "2020-10-08T19:37:25Z", "type": "commit"}, {"oid": "51498b4046b0eab4d2a0f251463ccfa272adc939", "url": "https://github.com/resilience4j/resilience4j/commit/51498b4046b0eab4d2a0f251463ccfa272adc939", "message": "rolling back wrong commit", "committedDate": "2020-10-08T19:40:00Z", "type": "commit"}, {"oid": "9544bd2a33074aa039d01e4ddfccc804a5bba578", "url": "https://github.com/resilience4j/resilience4j/commit/9544bd2a33074aa039d01e4ddfccc804a5bba578", "message": "Logging formatting", "committedDate": "2020-10-08T19:51:37Z", "type": "commit"}, {"oid": "1399292fc70afe0555a4ac46dd8e3e2c33e3072e", "url": "https://github.com/resilience4j/resilience4j/commit/1399292fc70afe0555a4ac46dd8e3e2c33e3072e", "message": "feat(micronaut): add non recoverable test cases and replaced UnhandledFallbackException with micronaut Fallback Exception", "committedDate": "2020-10-08T23:17:27Z", "type": "commit"}, {"oid": "b2ede431833cc8398edab494b9abb2cd4df51e1c", "url": "https://github.com/resilience4j/resilience4j/commit/b2ede431833cc8398edab494b9abb2cd4df51e1c", "message": "add fallback spec", "committedDate": "2020-10-08T23:57:11Z", "type": "commit"}, {"oid": "2144e19cc341ba318423f01c7cdcad5f69765797", "url": "https://github.com/resilience4j/resilience4j/commit/2144e19cc341ba318423f01c7cdcad5f69765797", "message": "correct stuck executor service", "committedDate": "2020-10-09T00:37:20Z", "type": "commit"}, {"oid": "544e72cebbf794061e684f45c062dce0c5a0a6bb", "url": "https://github.com/resilience4j/resilience4j/commit/544e72cebbf794061e684f45c062dce0c5a0a6bb", "message": "update executor service", "committedDate": "2020-10-09T00:46:24Z", "type": "commit"}, {"oid": "3b4d95fc0c6676e897c6d6c8c0c6b6bc2e1263e0", "url": "https://github.com/resilience4j/resilience4j/commit/3b4d95fc0c6676e897c6d6c8c0c6b6bc2e1263e0", "message": "Merge pull request #1198 from pollend/fix/add-more-test-cases\n\nfeat(micronaut): add non recoverable test cases and replaced UnhandledFallbackException with micronaut Fallback Exception", "committedDate": "2020-10-09T08:35:36Z", "type": "commit"}, {"oid": "36a8ef1d942206b472ef4e7fbbdff8d7f557a1c2", "url": "https://github.com/resilience4j/resilience4j/commit/36a8ef1d942206b472ef4e7fbbdff8d7f557a1c2", "message": "merging thread pool and Bulkhead interceptors plus more exception handling.", "committedDate": "2020-10-09T09:04:31Z", "type": "commit"}, {"oid": "14b6256c55329001f02868f570f22c8b4d5a3397", "url": "https://github.com/resilience4j/resilience4j/commit/14b6256c55329001f02868f570f22c8b4d5a3397", "message": "Use more idiomatic configuration / cleanup", "committedDate": "2020-10-15T10:14:33Z", "type": "commit"}, {"oid": "027e5370df7ddc540a4eb5face9889c9db408352", "url": "https://github.com/resilience4j/resilience4j/commit/027e5370df7ddc540a4eb5face9889c9db408352", "message": "Merge pull request #1207 from graemerocher/micronaut_final\n\nMicronaut: Use more idiomatic configuration / cleanup", "committedDate": "2020-10-15T11:09:43Z", "type": "commit"}]}