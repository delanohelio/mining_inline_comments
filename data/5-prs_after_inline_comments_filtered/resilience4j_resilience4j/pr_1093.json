{"pr_number": 1093, "pr_title": " Adding Springboot2 SSE ", "pr_createdAt": "2020-07-23T13:31:34Z", "pr_url": "https://github.com/resilience4j/resilience4j/pull/1093", "timeline": [{"oid": "fe3b665a5a8cbb1ec84a5695d882a68ca3398264", "url": "https://github.com/resilience4j/resilience4j/commit/fe3b665a5a8cbb1ec84a5695d882a68ca3398264", "message": " Adding springboot SSE", "committedDate": "2020-07-23T13:23:04Z", "type": "commit"}, {"oid": "5921fd255960a5c57cfb3fea78f9cd76b7e7b784", "url": "https://github.com/resilience4j/resilience4j/commit/5921fd255960a5c57cfb3fea78f9cd76b7e7b784", "message": " Adding thread sleep to buy time to record an event", "committedDate": "2020-07-23T13:51:40Z", "type": "commit"}, {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512", "url": "https://github.com/resilience4j/resilience4j/commit/33133391f0cc254674c12c6c4146ee6c4bb7b512", "message": " Trying to fix CI failure. works locally", "committedDate": "2020-07-23T15:08:47Z", "type": "commit"}, {"oid": "f0304227efa8946df790b90ee0c90728a07c1aa8", "url": "https://github.com/resilience4j/resilience4j/commit/f0304227efa8946df790b90ee0c90728a07c1aa8", "message": "code review comments to include SSE only on the presence of Flux", "committedDate": "2020-07-27T02:02:04Z", "type": "commit"}, {"oid": "eaea558e1bea679f76a10182290ae7f527d63fd9", "url": "https://github.com/resilience4j/resilience4j/commit/eaea558e1bea679f76a10182290ae7f527d63fd9", "message": " rxjava not needed", "committedDate": "2020-07-27T02:05:14Z", "type": "commit"}, {"oid": "64b5831cdcb8054f47b60a422e7e92293216d60d", "url": "https://github.com/resilience4j/resilience4j/commit/64b5831cdcb8054f47b60a422e7e92293216d60d", "message": " Changing it to compileonly", "committedDate": "2020-07-29T15:22:53Z", "type": "commit"}, {"oid": "284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4", "url": "https://github.com/resilience4j/resilience4j/commit/284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4", "message": " Changing it to compileonly", "committedDate": "2020-07-29T15:24:26Z", "type": "commit"}, {"oid": "f3b51bb60ecbd71837948cdae461b9acc73a48a4", "url": "https://github.com/resilience4j/resilience4j/commit/f3b51bb60ecbd71837948cdae461b9acc73a48a4", "message": " Changing it to compileonly", "committedDate": "2020-07-29T16:28:36Z", "type": "commit"}, {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "url": "https://github.com/resilience4j/resilience4j/commit/8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "message": " adding dummy commit to trigger CI", "committedDate": "2020-07-29T22:32:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MzgzNw==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462683837", "bodyText": "I think this doesn't need to be checked.\nCircuitBreakerRegistry create or get when you request a circuitbreaker.\nTherefore, it cannot be null, and it must be the same as the requested name.", "author": "dlsrb6342", "createdAt": "2020-07-30T01:38:27Z", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();\n+        return (cbEvent, cb) -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    new CircuitBreakerHystrixStreamEventsDTO(cbEvent,\n+                        cb.getState(),\n+                        cb.getMetrics(),\n+                        cb.getCircuitBreakerConfig()\n+                    )\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (circuitBreaker == null && !circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "originalCommit": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MzkzNA==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462683934", "bodyText": "I think this doesn't need to be checked.\nCircuitBreakerRegistry create or get when you request a circuitbreaker.\nTherefore, it cannot be null, and it must be the same as the requested name.", "author": "dlsrb6342", "createdAt": "2020-07-30T01:38:50Z", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventDTOFactory;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.Function;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams.\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ */\n+\n+@Endpoint(id = \"stream-circuitbreaker-events\")\n+public class CircuitBreakerServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerServerSideEvent() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return Flux.merge(eventStreams).map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent))\n+            .build()\n+        );\n+    }\n+\n+    private Function<CircuitBreakerEvent, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();\n+        return cbEvent -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    CircuitBreakerEventDTOFactory.createCircuitBreakerEventDTO(cbEvent)\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (circuitBreaker == null && !circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "originalCommit": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4NzgyOQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462687829", "bodyText": "Can be moved to class member variable.", "author": "dlsrb6342", "createdAt": "2020-07-30T01:52:52Z", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventDTOFactory;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.Function;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams.\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ */\n+\n+@Endpoint(id = \"stream-circuitbreaker-events\")\n+public class CircuitBreakerServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerServerSideEvent() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return Flux.merge(eventStreams).map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent))\n+            .build()\n+        );\n+    }\n+\n+    private Function<CircuitBreakerEvent, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();", "originalCommit": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4OTQ5Ng==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462689496", "bodyText": "Can be moved to class member variable.", "author": "dlsrb6342", "createdAt": "2020-07-30T01:58:53Z", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();", "originalCommit": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2936269b83e0babdab35b7091c352a4d8fc1de70", "url": "https://github.com/resilience4j/resilience4j/commit/2936269b83e0babdab35b7091c352a4d8fc1de70", "message": " Testing CI for failures", "committedDate": "2020-08-01T04:31:07Z", "type": "commit"}, {"oid": "b286f3e8c8b4c489dc0c5f1aed8efcfd5fd54601", "url": "https://github.com/resilience4j/resilience4j/commit/b286f3e8c8b4c489dc0c5f1aed8efcfd5fd54601", "message": " Fixing CI failures and refactored to have own auto config", "committedDate": "2020-08-01T21:10:20Z", "type": "commit"}, {"oid": "05e0fd6e624dd786596e0a2d607e55bdeebcd371", "url": "https://github.com/resilience4j/resilience4j/commit/05e0fd6e624dd786596e0a2d607e55bdeebcd371", "message": " Fixing CI failures and refactored to have own auto config", "committedDate": "2020-08-01T21:10:42Z", "type": "commit"}, {"oid": "e1c3b712a90427f08d08efc8ff0bcf3a32a77a54", "url": "https://github.com/resilience4j/resilience4j/commit/e1c3b712a90427f08d08efc8ff0bcf3a32a77a54", "message": "Adding copywrite to all the new classes and refactoring", "committedDate": "2020-08-02T19:14:32Z", "type": "commit"}, {"oid": "6397c56df541cdff423573c7124bef1ba10c57ff", "url": "https://github.com/resilience4j/resilience4j/commit/6397c56df541cdff423573c7124bef1ba10c57ff", "message": " Refactoring to enable with property", "committedDate": "2020-08-03T13:20:58Z", "type": "commit"}, {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890", "url": "https://github.com/resilience4j/resilience4j/commit/4a956551a7e3989acdf8ed052e8bc8411391c890", "message": " remvoing unnecessary formatting and spaces", "committedDate": "2020-08-03T13:25:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NzYyOQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r466097629", "bodyText": "I think this property isn't needed because SSE can be controlled with management.endpoints.stream-circuitbreaker-events.exposure.", "author": "dlsrb6342", "createdAt": "2020-08-06T01:46:55Z", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.circuitbreaker.autoconfigure;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixServerSideEvent;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerServerSideEvent;\n+import io.github.resilience4j.reactor.adapter.ReactorAdapter;\n+import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnAvailableEndpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import reactor.core.publisher.Flux;\n+\n+@Configuration\n+@ConditionalOnClass({CircuitBreaker.class, Endpoint.class})\n+@AutoConfigureAfter(CircuitBreakerAutoConfiguration.class)\n+@ConditionalOnProperty(value = \"resilience4j.circuitBreaker.stream.event.enabled\")", "originalCommit": "4a956551a7e3989acdf8ed052e8bc8411391c890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2Mjg0Mg==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r467262842", "bodyText": "Agreed. Removed the property\nTested locally with \"management.endpoints.web.exposure.exclude: stream-circuitbreaker-events\"", "author": "vijaycse", "createdAt": "2020-08-07T20:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NzYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5ODU1OQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r466098559", "bodyText": "If you make CircuitBreaker from CircuitBreakerRegistry with name, it always have the name that you requested.\nYou don't need to check. I think you can get CircuitBreaker from registry directly not with this function.", "author": "dlsrb6342", "createdAt": "2020-08-06T01:50:34Z", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.stereotype.Component;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final ObjectMapper jsonMapper = new ObjectMapper();\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        return (cbEvent, cb) -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    new CircuitBreakerHystrixStreamEventsDTO(cbEvent,\n+                        cb.getState(),\n+                        cb.getMetrics(),\n+                        cb.getCircuitBreakerConfig()\n+                    )\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (!circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "originalCommit": "4a956551a7e3989acdf8ed052e8bc8411391c890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MjI1OQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r467262259", "bodyText": "yeap. makes sense. pushed my changes", "author": "vijaycse", "createdAt": "2020-08-07T20:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5ODU1OQ=="}], "type": "inlineReview"}, {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe", "url": "https://github.com/resilience4j/resilience4j/commit/634a46875da51e75a3c78e60e2e13ffc13412fbe", "message": " Removed property and removed additional check for CB name", "committedDate": "2020-08-07T20:49:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzYzNQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757635", "bodyText": "Please use AssertJ", "author": "RobWin", "createdAt": "2020-08-13T07:41:10Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "originalCommit": "634a46875da51e75a3c78e60e2e13ffc13412fbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzY4Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757687", "bodyText": "Please use AssertJ", "author": "RobWin", "createdAt": "2020-08-13T07:41:15Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assert (events.size() == 2);", "originalCommit": "634a46875da51e75a3c78e60e2e13ffc13412fbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzcxOA==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757718", "bodyText": "Please use AssertJ", "author": "RobWin", "createdAt": "2020-08-13T07:41:20Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assert (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "originalCommit": "634a46875da51e75a3c78e60e2e13ffc13412fbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1Nzk1Mw==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757953", "bodyText": "Please use AssertJ", "author": "RobWin", "createdAt": "2020-08-13T07:41:43Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = TestApplication.class)\n+public class CircuitBreakerStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "originalCommit": "634a46875da51e75a3c78e60e2e13ffc13412fbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cdb5aee61111c6a6797b99d2927b74b03d9ca517", "url": "https://github.com/resilience4j/resilience4j/commit/cdb5aee61111c6a6797b99d2927b74b03d9ca517", "message": "Added code review comments to use assertJ", "committedDate": "2020-08-13T13:15:58Z", "type": "commit"}, {"oid": "cab178cc71eb5519566de7fcb9f43dec78274152", "url": "https://github.com/resilience4j/resilience4j/commit/cab178cc71eb5519566de7fcb9f43dec78274152", "message": "Merge branch 'master' into springboot2-sse-vrbranch", "committedDate": "2020-08-13T13:21:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NDYzNA==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469974634", "bodyText": "Assertj has a fluent API. You have to do\nassertThat(events.size()).isEqulTo(1);", "author": "RobWin", "createdAt": "2020-08-13T14:02:26Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 1);", "originalCommit": "cab178cc71eb5519566de7fcb9f43dec78274152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyOTQwMg==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r470029402", "bodyText": "Oh.. yeah. I see.. I updated it and pushed it", "author": "vijaycse", "createdAt": "2020-08-13T15:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NDYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyOTU1Mw==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r470029553", "bodyText": "@RobWin", "author": "vijaycse", "createdAt": "2020-08-13T15:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NDYzNA=="}], "type": "inlineReview"}, {"oid": "3d3a9ae0041aefb5832a2fbf36b8ba1f43359528", "url": "https://github.com/resilience4j/resilience4j/commit/3d3a9ae0041aefb5832a2fbf36b8ba1f43359528", "message": "Review Comments to use AssertJ fluent APIs for assertion", "committedDate": "2020-08-13T15:11:01Z", "type": "commit"}, {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "url": "https://github.com/resilience4j/resilience4j/commit/d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "message": "Merge branch 'springboot2-sse-vrbranch' of https://github.com/vijaycse/resilience4j into springboot2-sse-vrbranch", "committedDate": "2020-08-13T15:15:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzQ1Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723457", "bodyText": "Waiting between calls should not be necessary", "author": "RobWin", "createdAt": "2020-08-19T05:42:28Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event", "originalCommit": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzUyNA==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723524", "bodyText": "Waiting between calls should not be necessary", "author": "RobWin", "createdAt": "2020-08-19T05:42:34Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event", "originalCommit": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzNTMzOQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475235339", "bodyText": "Removed it", "author": "vijaycse", "createdAt": "2020-08-23T15:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzU1OA==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723558", "bodyText": "Waiting between calls should not be necessary", "author": "RobWin", "createdAt": "2020-08-19T05:42:37Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event", "originalCommit": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzMzc4OQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475233789", "bodyText": "resolved it", "author": "vijaycse", "createdAt": "2020-08-23T15:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzU4NA==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472743584", "bodyText": "Is it possible to use the WebTestClient  here?\nHere is a guide how to use the WebTestClient for streaming responses:\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/testing-webtestclient.pdf\nThen please use the StepVerifier to subscribe to the stream and verify that the streams emits one event.", "author": "RobWin", "createdAt": "2020-08-19T06:11:49Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "originalCommit": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzODUxNg==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475238516", "bodyText": "WebTestClient on streaming events throws  Timeout on blocking read for 3600 MILLISECOND on exchage()\nmethod. Tried increasing the timeout and everything ..   Googling reveals that this might be a bug for integration tests\n(where  the test written pointing to localhost) thought pointing against Controller class works well.\n\n\n https://github.com/spring-projects/spring-boot/issues/9992. \n\n\n\nThe Thread.Sleep thats needed for subscription  is due to the  difficult to simultaneously publish  the events and  subscribe. Thread.sleep is the hack to make subscribe wait without blocking the pub sub model.  I tried making asyc way of publishing but co ordination b/w  pub and sub is not working consistently. Thread.sleep works all the time so  committed my changes again with some refactoring. Please take a look. I am documenting the observation here so that if anyone has better idea can come up with the solution.\n@RobWin", "author": "vijaycse", "createdAt": "2020-08-23T16:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzg2OA==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r476317868", "bodyText": "Yes, I think the problem is that .exchange() is blocking :(\nInternally it's doing\nClientResponse clientResponse = this.bodySpec.exchange().block(getTimeout());\n\nBecause of some reason there is no clientResponse within that timeout period.", "author": "RobWin", "createdAt": "2020-08-25T09:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzY2Mg==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472743662", "bodyText": "Is it possible to use the WebTestClient here?\nHere is a guide how to use the WebTestClient for streaming responses:\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/testing-webtestclient.pdf\nThen please use the StepVerifier to subscribe to the stream and verify that the streams emits one event.", "author": "RobWin", "createdAt": "2020-08-19T06:11:58Z", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = TestApplication.class)\n+public class CircuitBreakerStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (circuitBreakerEventsAfter.getCircuitBreakerEvents().size()).isGreaterThan(0);\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // pause 1 sec to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "originalCommit": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzODU1Ng==", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475238556", "bodyText": "same a above comment", "author": "vijaycse", "createdAt": "2020-08-23T16:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzY2Mg=="}], "type": "inlineReview"}, {"oid": "33265f41446c1365d1de80d308ef7d74b8766573", "url": "https://github.com/resilience4j/resilience4j/commit/33265f41446c1365d1de80d308ef7d74b8766573", "message": " Removed thread.sleep inbetween methods  code review comments", "committedDate": "2020-08-23T15:40:17Z", "type": "commit"}]}