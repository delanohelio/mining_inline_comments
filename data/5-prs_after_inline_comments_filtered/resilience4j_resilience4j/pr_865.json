{"pr_number": 865, "pr_title": "Adding timelimiter support for ratpack apps", "pr_createdAt": "2020-02-12T20:10:09Z", "pr_url": "https://github.com/resilience4j/resilience4j/pull/865", "timeline": [{"oid": "71e69c4a06cafe97180fd85d53a7059f5634f968", "url": "https://github.com/resilience4j/resilience4j/commit/71e69c4a06cafe97180fd85d53a7059f5634f968", "message": "adding timelimiter support for ratpack apps", "committedDate": "2020-02-12T20:46:14Z", "type": "forcePushed"}, {"oid": "b6e671915718e1ffbbb75347b868fcd489621d45", "url": "https://github.com/resilience4j/resilience4j/commit/b6e671915718e1ffbbb75347b868fcd489621d45", "message": "adding timelimiter support for ratpack apps", "committedDate": "2020-02-12T22:22:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwODQ2Mw==", "url": "https://github.com/resilience4j/resilience4j/pull/865#discussion_r378708463", "bodyText": "In our Spring Boot TimeLimiterAspect we throw an exception if the return type is not supported.\nWe currently do not support a usage of the @TimeLimiter annotation and a basic return types.\nIt could be somehow confusing to a developer that the method is \"implicitly\" executed in a thread pool, but the thread is blocking. I think it would be better if the developer decides it explicitly and uses a  @Bulkhead(type = Type.THREADPOOL) or Promise.\nWhat do you think?", "author": "RobWin", "createdAt": "2020-02-13T08:21:24Z", "path": "resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/timelimiter/TimeLimiterMethodInterceptor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2017 Dan Maas\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.ratpack.timelimiter;\n+\n+import com.google.inject.Inject;\n+import io.github.resilience4j.core.lang.Nullable;\n+import io.github.resilience4j.ratpack.internal.AbstractMethodInterceptor;\n+import io.github.resilience4j.ratpack.recovery.DefaultRecoveryFunction;\n+import io.github.resilience4j.ratpack.recovery.RecoveryFunction;\n+import io.github.resilience4j.reactor.timelimiter.TimeLimiterOperator;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.annotation.TimeLimiter;\n+import org.aopalliance.intercept.MethodInterceptor;\n+import org.aopalliance.intercept.MethodInvocation;\n+import ratpack.exec.Execution;\n+import ratpack.exec.Promise;\n+import ratpack.util.Exceptions;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A {@link MethodInterceptor} to handle all methods annotated with {@link TimeLimiter}. It will\n+ * handle methods that return a {@link Promise}, {@link Flux}, {@link\n+ * Mono}, {@link CompletionStage}, or value.\n+ * <p>\n+ * Given a method like this:\n+ * <pre><code>\n+ *     {@literal @}TimeLimiter(name = \"myService\")\n+ *     public String fancyName(String name) {\n+ *         return \"Sir Captain \" + name;\n+ *     }\n+ * </code></pre>\n+ * each time the {@code #fancyName(String)} method is invoked, the method's execution will pass\n+ * through a a {@link TimeLimiter} according to the given\n+ * config.\n+ * <p>\n+ * The fallbackMethod signature must match either:\n+ * <p>\n+ * 1) The method parameter signature on the annotated method or 2) The method parameter signature\n+ * with a matching exception type as the last parameter on the annotated method\n+ * <p>\n+ * The return value can be a {@link Promise}, {@link CompletionStage}, {@link\n+ * Flux}, {@link Mono}, or an object value. Other\n+ * reactive types are not supported.\n+ * <p>\n+ * If the return value is one of the reactive types listed above, it must match the return value\n+ * type of the annotated method.\n+ */\n+public class TimeLimiterMethodInterceptor extends AbstractMethodInterceptor {\n+\n+    @Inject(optional = true)\n+    @Nullable\n+    private TimeLimiterRegistry registry;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Nullable\n+    @Override\n+    public Object invoke(MethodInvocation invocation) throws Throwable {\n+        TimeLimiter annotation = invocation.getMethod().getAnnotation(TimeLimiter.class);\n+        if (annotation == null) {\n+            annotation = invocation.getMethod().getDeclaringClass()\n+                .getAnnotation(TimeLimiter.class);\n+        }\n+        final RecoveryFunction<?> fallbackMethod = Optional\n+            .ofNullable(createRecoveryFunction(invocation, annotation.fallbackMethod()))\n+            .orElse(new DefaultRecoveryFunction<>());\n+        if (registry == null) {\n+            registry = TimeLimiterRegistry.ofDefaults();\n+        }\n+        io.github.resilience4j.timelimiter.TimeLimiter timeLimiter = registry\n+            .timeLimiter(annotation.name());\n+        Class<?> returnType = invocation.getMethod().getReturnType();\n+        if (Promise.class.isAssignableFrom(returnType)) {\n+            Promise<?> result = (Promise<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterTransformer transformer = TimeLimiterTransformer.of(timeLimiter)\n+                    .recover(fallbackMethod);\n+                result = result.transform(transformer);\n+            }\n+            return result;\n+        } else if (Flux.class.isAssignableFrom(returnType)) {\n+            Flux<?> result = (Flux<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterOperator operator = TimeLimiterOperator.of(timeLimiter);\n+                result = fallbackMethod.onErrorResume(result.transform(operator));\n+            }\n+            return result;\n+        } else if (Mono.class.isAssignableFrom(returnType)) {\n+            Mono<?> result = (Mono<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterOperator operator = TimeLimiterOperator.of(timeLimiter);\n+                result = fallbackMethod.onErrorResume(result.transform(operator));\n+            }\n+            return result;\n+        } else if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            ScheduledExecutorService scheduler = Execution.current().getController().getExecutor();\n+            CompletableFuture<?> future = timeLimiter.executeCompletionStage(scheduler, () -> {\n+                try {\n+                    return (CompletionStage)proceed(invocation);\n+                } catch (Throwable t) {\n+                    final CompletableFuture<?> promise = new CompletableFuture<>();\n+                    promise.completeExceptionally(t);\n+                    return (CompletionStage)promise;\n+                }\n+            }).toCompletableFuture();\n+            completeFailedFuture(new TimeoutException(), fallbackMethod, future);\n+            return future;\n+        } else {\n+            return handleProceedWithException(invocation, timeLimiter, fallbackMethod);", "originalCommit": "b6e671915718e1ffbbb75347b868fcd489621d45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyOTQyNg==", "url": "https://github.com/resilience4j/resilience4j/pull/865#discussion_r379229426", "bodyText": "@RobWin that make sense - I can fix that up", "author": "drmaas", "createdAt": "2020-02-14T02:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwODQ2Mw=="}], "type": "inlineReview"}, {"oid": "0ef8efdf44d3e0d311f5021138ead68e2c5e58fc", "url": "https://github.com/resilience4j/resilience4j/commit/0ef8efdf44d3e0d311f5021138ead68e2c5e58fc", "message": "adding timelimiter support for ratpack apps", "committedDate": "2020-02-14T03:46:23Z", "type": "commit"}, {"oid": "0ef8efdf44d3e0d311f5021138ead68e2c5e58fc", "url": "https://github.com/resilience4j/resilience4j/commit/0ef8efdf44d3e0d311f5021138ead68e2c5e58fc", "message": "adding timelimiter support for ratpack apps", "committedDate": "2020-02-14T03:46:23Z", "type": "forcePushed"}]}