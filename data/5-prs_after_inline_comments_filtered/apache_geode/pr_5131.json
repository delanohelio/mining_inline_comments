{"pr_number": 5131, "pr_title": "GEODE-8144: endpoint identification in servers is not working", "pr_createdAt": "2020-05-19T15:24:05Z", "pr_url": "https://github.com/apache/geode/pull/5131", "timeline": [{"oid": "88e7fd93b5052f7dbfb7e5ec7c3453a0d5825d32", "url": "https://github.com/apache/geode/commit/88e7fd93b5052f7dbfb7e5ec7c3453a0d5825d32", "message": "GEODE-8144: endpoint identification in servers is not working\n\nSet the SNI server-name field in SSL parameters for p2p communications,\nallowing endpoint identification to work properly.\n\nI modified one of the SNI haproxy tests to have keystores with the\nproper subject-alternative-names for p2p communications in the docker\ncontainers and for client/server off-platform communications.  I used\nSai's keystore/truststore construction CertificateMaterial/CertStores\nclasses to generate the stores...\n\n      .sanDnsName(\"geode\") // for inside the docker container\n      .sanDnsName(\"localhost\") // for inside the docker container\n      .sanIpAddress(InetAddress.getByName(\"0.0.0.0\")) // for inside the docker container\n      .sanDnsName(certName) // for client endpoint validation (locator-maeve for instance)", "committedDate": "2020-05-19T15:21:48Z", "type": "commit"}, {"oid": "26827452337899bcccf3211bcb6c089a7e23cbb8", "url": "https://github.com/apache/geode/commit/26827452337899bcccf3211bcb6c089a7e23cbb8", "message": "modified SocketCreator to look for a hostname if one is not present and endpoint verification is enabled\n\nThis fixes some problems when running in docker containers", "committedDate": "2020-05-21T21:16:11Z", "type": "commit"}, {"oid": "3b4c6a7a1ec4a4ccca8df1d137cf3432f328cb26", "url": "https://github.com/apache/geode/commit/3b4c6a7a1ec4a4ccca8df1d137cf3432f328cb26", "message": "removed test shell script", "committedDate": "2020-05-21T22:05:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNDk3OQ==", "url": "https://github.com/apache/geode/pull/5131#discussion_r429004979", "bodyText": "This strikes me as a security issue. Let's say I issued a start server with locators=1.2.3.4, which is bad but stick with me. Then here we lookup 1.2.3.4's PTR record. What if someone has maliciously inserted themselves into my DNS resolution path, easy to do with out greater adoption of DNSSEC. So my reverse lookup finds 1.2.3.4 PTR locator1.malicious.com and adds \"locator1.malicious.com\" to the SNI and proceeds to connect. Then connection is established to what our network stack thinks is 1.2.3.4, but is really our malicious router redirecting the connection. Now the malicious host will respond with a valid signed certificate for \"locator1.malicious.com\" and we will happily verify it. Of course that assumes also that the malicious certificate is signed by someone in our chain of trust. So, not a likely attack vector since we don't trust the root signers by default but not something a service that does trust the roots should ever do.", "author": "pivotal-jbarrett", "createdAt": "2020-05-22T02:00:30Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java", "diffHunk": "@@ -791,7 +792,19 @@ private boolean setServerNames(SSLParameters modifiedParams, HostAndPort addr) {\n       return false;\n     }\n \n-    serverNames.add(new SNIHostName(addr.getHostName()));\n+    String hostName = addr.getHostName();\n+    if (this.sslConfig.doEndpointIdentification()\n+        && InetAddressValidator.getInstance().isValid(hostName)) {\n+      // endpoint validation typically uses a hostname in the sniServer parameter that the handshake\n+      // will compare against the subject alternative addresses in the server's certificate. Here\n+      // we attempt to get a hostname instead of the proffered numeric address\n+      try {\n+        hostName = InetAddress.getByName(hostName).getCanonicalHostName();", "originalCommit": "26827452337899bcccf3211bcb6c089a7e23cbb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTg0NQ==", "url": "https://github.com/apache/geode/pull/5131#discussion_r429315845", "bodyText": "As you mentioned offline, the same malicious entity could inject the IP into their SAN and we would validate that. I don't think this code makes anything any less secure from that standpoint so I am removing my block.", "author": "pivotal-jbarrett", "createdAt": "2020-05-22T15:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNDk3OQ=="}], "type": "inlineReview"}, {"oid": "6dc29fdce755482b3346aee924b7a4eb7872fa61", "url": "https://github.com/apache/geode/commit/6dc29fdce755482b3346aee924b7a4eb7872fa61", "message": "sanction used of getCanonicalHostName() in SocketCreator", "committedDate": "2020-05-22T17:27:26Z", "type": "commit"}]}