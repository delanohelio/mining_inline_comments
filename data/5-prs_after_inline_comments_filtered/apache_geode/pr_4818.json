{"pr_number": 4818, "pr_title": "GEODE-7667: Add a 'clear' gfsh command for PR and RR clear", "pr_createdAt": "2020-03-16T21:46:13Z", "pr_url": "https://github.com/apache/geode/pull/4818", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0NTUwNQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r394545505", "bodyText": "can you try to remove this line?", "author": "gesterzhou", "createdAt": "2020-03-18T18:10:12Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/ClearCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.GfshCommand;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.security.ResourcePermission.Operation;\n+import org.apache.geode.security.ResourcePermission.Resource;\n+\n+public class ClearCommand extends GfshCommand {\n+  public static final String REGION_NOT_FOUND = \"Region <%s> not found in any of the members\";\n+\n+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DATA, CliStrings.TOPIC_GEODE_REGION})\n+  @CliCommand(value = {CliStrings.CLEAR_REGION}, help = CliStrings.CLEAR_REGION_HELP)\n+  public ResultModel remove(\n+      @CliOption(key = {CliStrings.CLEAR_REGION_REGION_NAME}, mandatory = true,\n+          help = CliStrings.CLEAR_REGION_REGION_NAME_HELP,\n+          optionContext = ConverterHint.REGION_PATH) String regionPath) {\n+\n+    Cache cache = getCache();\n+\n+    authorize(Resource.DATA, Operation.WRITE, regionPath);\n+\n+\n+    Region region = cache.getRegion(regionPath);\n+    DataCommandFunction removefn = new DataCommandFunction();\n+    DataCommandResult dataResult;\n+    if (region == null) {\n+      Set<DistributedMember> memberList = findAnyMembersForRegion(regionPath);\n+\n+      if (CollectionUtils.isEmpty(memberList)) {\n+        return new ResultModel().createError(String.format(REGION_NOT_FOUND, regionPath));\n+      }\n+\n+      DataCommandRequest request = new DataCommandRequest();\n+      request.setCommand(CliStrings.REMOVE);\n+      request.setRemoveAllKeys(\"ALL\");\n+      request.setRegionName(regionPath);\n+      dataResult = callFunctionForRegion(request, removefn, memberList);\n+    } else {\n+      dataResult = removefn.remove(null, null, regionPath, \"ALL\",\n+          (InternalCache) cache);\n+    }\n+\n+    // BR: is this needed?\n+    dataResult.setKeyClass(null);", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0NTc5NA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r394545794", "bodyText": "should we use clear() instead of remove() for method name? Is that because the upper level has hard-coded to use remove()?", "author": "gesterzhou", "createdAt": "2020-03-18T18:10:39Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/ClearCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.GfshCommand;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.security.ResourcePermission.Operation;\n+import org.apache.geode.security.ResourcePermission.Resource;\n+\n+public class ClearCommand extends GfshCommand {\n+  public static final String REGION_NOT_FOUND = \"Region <%s> not found in any of the members\";\n+\n+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DATA, CliStrings.TOPIC_GEODE_REGION})\n+  @CliCommand(value = {CliStrings.CLEAR_REGION}, help = CliStrings.CLEAR_REGION_HELP)\n+  public ResultModel remove(", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MjkwNg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r395392906", "bodyText": "REMOVE__MSG__CLEARALL_NOT_SUPPORTED_FOR_PARTITIONREGION  is not true anymore, right?", "author": "agingade", "createdAt": "2020-03-20T00:38:51Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java", "diffHunk": "@@ -1915,6 +1922,9 @@\n   public static final String REMOVE__MSG__REGION_NOT_FOUND = \"Region <{0}> Not Found\";\n   public static final String REMOVE__MSG__KEY_NOT_FOUND_REGION = \"Key is not present in the region\";\n   public static final String REMOVE__MSG__CLEARED_ALL_CLEARS = \"Cleared all keys in the region\";\n+  public static final String REMOVE__MSG__CLEARALL_DEPRECATION_WARNING =\n+      \"Warning: The --all option for the 'remove' command is deprecated. Please\"\n+          + \" use the 'clear region' command instead.\";\n   public static final String REMOVE__MSG__CLEARALL_NOT_SUPPORTED_FOR_PARTITIONREGION =", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MTc3OA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412471778", "bodyText": "I've removed this message.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T20:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MzE1Mw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r395393153", "bodyText": "As Gester suggested; how about using \"clear\" instead of \"remove/all\".", "author": "agingade", "createdAt": "2020-03-20T00:40:07Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/ClearCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.GfshCommand;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.security.ResourcePermission.Operation;\n+import org.apache.geode.security.ResourcePermission.Resource;\n+\n+public class ClearCommand extends GfshCommand {\n+  public static final String REGION_NOT_FOUND = \"Region <%s> not found in any of the members\";\n+\n+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DATA, CliStrings.TOPIC_GEODE_REGION})\n+  @CliCommand(value = {CliStrings.CLEAR_REGION}, help = CliStrings.CLEAR_REGION_HELP)\n+  public ResultModel remove(\n+      @CliOption(key = {CliStrings.CLEAR_REGION_REGION_NAME}, mandatory = true,\n+          help = CliStrings.CLEAR_REGION_REGION_NAME_HELP,\n+          optionContext = ConverterHint.REGION_PATH) String regionPath) {\n+\n+    Cache cache = getCache();\n+\n+    authorize(Resource.DATA, Operation.WRITE, regionPath);\n+\n+\n+    Region region = cache.getRegion(regionPath);\n+    DataCommandFunction removefn = new DataCommandFunction();\n+    DataCommandResult dataResult;\n+    if (region == null) {\n+      Set<DistributedMember> memberList = findAnyMembersForRegion(regionPath);\n+\n+      if (CollectionUtils.isEmpty(memberList)) {\n+        return new ResultModel().createError(String.format(REGION_NOT_FOUND, regionPath));\n+      }\n+\n+      DataCommandRequest request = new DataCommandRequest();\n+      request.setCommand(CliStrings.REMOVE);", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5NDExMg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r395394112", "bodyText": "Can we add clear() instead of using remove()? Till the deprecated remove-all is removed, the remove-all can clear().", "author": "agingade", "createdAt": "2020-03-20T00:45:02Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/functions/DataCommandFunction.java", "diffHunk": "@@ -314,17 +314,13 @@ public DataCommandResult remove(String key, String keyClass, String regionName,\n         }\n       } else {\n         DataPolicy policy = region.getAttributes().getDataPolicy();\n-        if (!policy.withPartitioning()) {\n-          region.clear();\n-          if (logger.isDebugEnabled()) {\n-            logger.debug(\"Cleared all keys in the region - {}\", regionName);\n-          }\n-          return DataCommandResult.createRemoveInfoResult(key, null, null,\n-              CliStrings.format(CliStrings.REMOVE__MSG__CLEARED_ALL_CLEARS, regionName), true);\n-        } else {\n-          return DataCommandResult.createRemoveInfoResult(key, null, null,\n-              CliStrings.REMOVE__MSG__CLEARALL_NOT_SUPPORTED_FOR_PARTITIONREGION, false);\n+        region.clear();", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MjMzMA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412472330", "bodyText": "I agree this could be confusing. I've added clear() as a helper method invoked by remove() when called with the 'ALL' flag to help make the relationship more visible.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T20:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5NDExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMTQyMw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r395721423", "bodyText": "In the JIRA ticket, region is an option. e.g. clear --region=regionName.", "author": "jchen21", "createdAt": "2020-03-20T15:40:01Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java", "diffHunk": "@@ -816,6 +816,13 @@\n   public static final String CLEAR_DEFINED_INDEX__SUCCESS__MSG =\n       \"Index definitions successfully cleared\";\n \n+  /* clear region */\n+  public static final String CLEAR_REGION = \"clear region\";", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MzEzOQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412473139", "bodyText": "I initially tried changing this to 'clear' as described in the ticket but this caused a conflict with the 'clear defined index' command. I've discussed it with Charlie and we decided that 'clear region' is appropriate (and it works around that issue) so I've updated the JIRA ticket/tracker story to reflect this.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T20:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMTQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMzg3Mw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r395723873", "bodyText": "Why this is 16, not 15?", "author": "jchen21", "createdAt": "2020-03-20T15:43:41Z", "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/GfshParserAutoCompletionIntegrationTest.java", "diffHunk": "@@ -381,7 +381,7 @@ public void testObtainHintForData() {\n     String hintArgument = \"data\";\n     String hintsProvided = gfshParserRule.getCommandManager().obtainHint(hintArgument);\n     String[] hintsProvidedArray = hintsProvided.split(lineSeparator());\n-    assertThat(hintsProvidedArray.length).isEqualTo(15);\n+    assertThat(hintsProvidedArray.length).isEqualTo(16);", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MzMzNQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r405883335", "bodyText": "This is an existing test measuring our parsing of gfsh hints. Because a new hint was added for clear, it's now finding one more hint than it was before, but this is an expected difference so I've just updated the tests assertion to reflect that.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-09T00:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMzg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjQxOA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r395886418", "bodyText": "My understanding is that the remove command is deprecated, not just the --all option.", "author": "jchen21", "createdAt": "2020-03-20T20:57:32Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java", "diffHunk": "@@ -1915,6 +1922,9 @@\n   public static final String REMOVE__MSG__REGION_NOT_FOUND = \"Region <{0}> Not Found\";\n   public static final String REMOVE__MSG__KEY_NOT_FOUND_REGION = \"Key is not present in the region\";\n   public static final String REMOVE__MSG__CLEARED_ALL_CLEARS = \"Cleared all keys in the region\";\n+  public static final String REMOVE__MSG__CLEARALL_DEPRECATION_WARNING =\n+      \"Warning: The --all option for the 'remove' command is deprecated. Please\"", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3MzA0MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r405873040", "bodyText": "We can double check this with Charlie, but the new command 'clear' has no way to remove specific entries, while the remove command does. We don't want to deprecate the whole remove command or we would be eventually losing that functionality.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-08T23:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzEwNw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r395887107", "bodyText": "Again the command is clear --region,  --region is the command option. Not clear region.", "author": "jchen21", "createdAt": "2020-03-20T20:59:12Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java", "diffHunk": "@@ -1915,6 +1922,9 @@\n   public static final String REMOVE__MSG__REGION_NOT_FOUND = \"Region <{0}> Not Found\";\n   public static final String REMOVE__MSG__KEY_NOT_FOUND_REGION = \"Key is not present in the region\";\n   public static final String REMOVE__MSG__CLEARED_ALL_CLEARS = \"Cleared all keys in the region\";\n+  public static final String REMOVE__MSG__CLEARALL_DEPRECATION_WARNING =\n+      \"Warning: The --all option for the 'remove' command is deprecated. Please\"\n+          + \" use the 'clear region' command instead.\";", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1ODc4NA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r396558784", "bodyText": "I think we should be putting more values here, to ensure that every bucket has at least one key. Buckets are not fully created until data is put into them, so with only two keys, the system is not in a very realistic state.", "author": "DonalEvans", "createdAt": "2020-03-23T15:55:09Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.VMProvider;\n+\n+\n+public class ClearCommandDUnitTest {\n+  private static final String commandString = CliStrings.CLEAR_REGION;\n+  private static final String REPLICATE_REGION_NAME = \"replicateRegion\";\n+  private static final String PARTITIONED_REGION_NAME = \"partitionedRegion\";\n+  private static final String EMPTY_STRING = \"\";\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private MemberVM locator;\n+  private MemberVM server1;\n+  private MemberVM server2;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    locator = clusterStartupRule.startLocatorVM(0);\n+    server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    gfsh.connectAndVerify(locator);\n+    gfsh.executeAndAssertThat(\"create region --name=\" + REPLICATE_REGION_NAME + \" --type=REPLICATE\")\n+        .statusIsSuccess();\n+    gfsh.executeAndAssertThat(\n+        \"create region --name=\" + PARTITIONED_REGION_NAME + \" --type=PARTITION\").statusIsSuccess();\n+\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + REPLICATE_REGION_NAME, 2);\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + PARTITIONED_REGION_NAME, 2);\n+\n+    VMProvider.invokeInEveryMember(ClearCommandDUnitTest::populateTestRegions, server1, server2);\n+  }\n+\n+  private static void populateTestRegions() {", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTgzMg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r396559832", "bodyText": "These test names could be a little more descriptive by including what the expected outcome of the test is i.e. clearInvalidRegionReturnsError.", "author": "DonalEvans", "createdAt": "2020-03-23T15:56:27Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.VMProvider;\n+\n+\n+public class ClearCommandDUnitTest {\n+  private static final String commandString = CliStrings.CLEAR_REGION;\n+  private static final String REPLICATE_REGION_NAME = \"replicateRegion\";\n+  private static final String PARTITIONED_REGION_NAME = \"partitionedRegion\";\n+  private static final String EMPTY_STRING = \"\";\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private MemberVM locator;\n+  private MemberVM server1;\n+  private MemberVM server2;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    locator = clusterStartupRule.startLocatorVM(0);\n+    server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    gfsh.connectAndVerify(locator);\n+    gfsh.executeAndAssertThat(\"create region --name=\" + REPLICATE_REGION_NAME + \" --type=REPLICATE\")\n+        .statusIsSuccess();\n+    gfsh.executeAndAssertThat(\n+        \"create region --name=\" + PARTITIONED_REGION_NAME + \" --type=PARTITION\").statusIsSuccess();\n+\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + REPLICATE_REGION_NAME, 2);\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + PARTITIONED_REGION_NAME, 2);\n+\n+    VMProvider.invokeInEveryMember(ClearCommandDUnitTest::populateTestRegions, server1, server2);\n+  }\n+\n+  private static void populateTestRegions() {\n+    Cache cache = CacheFactory.getAnyInstance();\n+\n+    Region<String, String> replicateRegion = cache.getRegion(REPLICATE_REGION_NAME);\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n+    replicateRegion.put(\"key1\", \"value1\");\n+    replicateRegion.put(\"key2\", \"value2\");\n+\n+    Region<String, String> partitionedRegion = cache.getRegion(PARTITIONED_REGION_NAME);\n+    partitionedRegion.put(\"key1\", \"value1\");\n+    partitionedRegion.put(\"key2\", \"value2\");\n+  }\n+\n+  @Test\n+  public void clearInvalidRegion() {", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MjE2MQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r396562161", "bodyText": "Consider using CommandStringBuilder to create the gfsh commands, and referencing the CliStrings constants for the command options rather than hard-coding them.", "author": "DonalEvans", "createdAt": "2020-03-23T15:59:21Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.VMProvider;\n+\n+\n+public class ClearCommandDUnitTest {\n+  private static final String commandString = CliStrings.CLEAR_REGION;\n+  private static final String REPLICATE_REGION_NAME = \"replicateRegion\";\n+  private static final String PARTITIONED_REGION_NAME = \"partitionedRegion\";\n+  private static final String EMPTY_STRING = \"\";\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private MemberVM locator;\n+  private MemberVM server1;\n+  private MemberVM server2;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    locator = clusterStartupRule.startLocatorVM(0);\n+    server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    gfsh.connectAndVerify(locator);\n+    gfsh.executeAndAssertThat(\"create region --name=\" + REPLICATE_REGION_NAME + \" --type=REPLICATE\")\n+        .statusIsSuccess();\n+    gfsh.executeAndAssertThat(\n+        \"create region --name=\" + PARTITIONED_REGION_NAME + \" --type=PARTITION\").statusIsSuccess();\n+\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + REPLICATE_REGION_NAME, 2);\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + PARTITIONED_REGION_NAME, 2);\n+\n+    VMProvider.invokeInEveryMember(ClearCommandDUnitTest::populateTestRegions, server1, server2);\n+  }\n+\n+  private static void populateTestRegions() {\n+    Cache cache = CacheFactory.getAnyInstance();\n+\n+    Region<String, String> replicateRegion = cache.getRegion(REPLICATE_REGION_NAME);\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n+    replicateRegion.put(\"key1\", \"value1\");\n+    replicateRegion.put(\"key2\", \"value2\");\n+\n+    Region<String, String> partitionedRegion = cache.getRegion(PARTITIONED_REGION_NAME);\n+    partitionedRegion.put(\"key1\", \"value1\");\n+    partitionedRegion.put(\"key2\", \"value2\");\n+  }\n+\n+  @Test\n+  public void clearInvalidRegion() {\n+    String command = commandString + \" --region=NotAValidRegion\";\n+\n+    gfsh.executeAndAssertThat(command).statusIsError()\n+        .containsOutput(String.format(REGION_NOT_FOUND, \"/NotAValidRegion\"));\n+  }\n+\n+  @Test\n+  public void clearReplicateRegion() {\n+    String command = commandString + \" --region=\" + REPLICATE_REGION_NAME;", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NTE0MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r396585140", "bodyText": "Is there a reason that we're executing and asserting the success of this command? It doesn't seem related to the clear command.", "author": "DonalEvans", "createdAt": "2020-03-23T16:29:31Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.VMProvider;\n+\n+\n+public class ClearCommandDUnitTest {\n+  private static final String commandString = CliStrings.CLEAR_REGION;\n+  private static final String REPLICATE_REGION_NAME = \"replicateRegion\";\n+  private static final String PARTITIONED_REGION_NAME = \"partitionedRegion\";\n+  private static final String EMPTY_STRING = \"\";\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private MemberVM locator;\n+  private MemberVM server1;\n+  private MemberVM server2;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    locator = clusterStartupRule.startLocatorVM(0);\n+    server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    gfsh.connectAndVerify(locator);\n+    gfsh.executeAndAssertThat(\"create region --name=\" + REPLICATE_REGION_NAME + \" --type=REPLICATE\")\n+        .statusIsSuccess();\n+    gfsh.executeAndAssertThat(\n+        \"create region --name=\" + PARTITIONED_REGION_NAME + \" --type=PARTITION\").statusIsSuccess();\n+\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + REPLICATE_REGION_NAME, 2);\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + PARTITIONED_REGION_NAME, 2);\n+\n+    VMProvider.invokeInEveryMember(ClearCommandDUnitTest::populateTestRegions, server1, server2);\n+  }\n+\n+  private static void populateTestRegions() {\n+    Cache cache = CacheFactory.getAnyInstance();\n+\n+    Region<String, String> replicateRegion = cache.getRegion(REPLICATE_REGION_NAME);\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n+    replicateRegion.put(\"key1\", \"value1\");\n+    replicateRegion.put(\"key2\", \"value2\");\n+\n+    Region<String, String> partitionedRegion = cache.getRegion(PARTITIONED_REGION_NAME);\n+    partitionedRegion.put(\"key1\", \"value1\");\n+    partitionedRegion.put(\"key2\", \"value2\");\n+  }\n+\n+  @Test\n+  public void clearInvalidRegion() {\n+    String command = commandString + \" --region=NotAValidRegion\";\n+\n+    gfsh.executeAndAssertThat(command).statusIsError()\n+        .containsOutput(String.format(REGION_NOT_FOUND, \"/NotAValidRegion\"));\n+  }\n+\n+  @Test\n+  public void clearReplicateRegion() {\n+    String command = commandString + \" --region=\" + REPLICATE_REGION_NAME;\n+\n+    gfsh.executeAndAssertThat(\"list regions\").statusIsSuccess();", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NDExNw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r405874117", "bodyText": "This makes the test more readable in the event of a failure (although the assertion of success is probably unnecessary).", "author": "BenjaminPerryRoss", "createdAt": "2020-04-08T23:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NTE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NDc0Mg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r406294742", "bodyText": "I guess I'm not understanding how the list regions command makes things more readable here. We only have two regions, and we already assert that they both exist in the setup phase, so having a list of them here in the even of a failure seems redundant. If they don't both exist by the time we get to calling clear region then the test should have already failed, and if the test fails after or during calling clear region, we already know that it's not because the regions don't exist.", "author": "DonalEvans", "createdAt": "2020-04-09T15:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NTE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MzcxMQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412473711", "bodyText": "I've gone ahead and removed this command/assertion since it's not really necessary.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T20:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxNzI3MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r396617270", "bodyText": "The \"Cleared all keys in the region\" string should ideally be extracted to a constant where it's defined so other places can refer to that rather than hard-coding.", "author": "DonalEvans", "createdAt": "2020-03-23T17:14:17Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.VMProvider;\n+\n+\n+public class ClearCommandDUnitTest {\n+  private static final String commandString = CliStrings.CLEAR_REGION;\n+  private static final String REPLICATE_REGION_NAME = \"replicateRegion\";\n+  private static final String PARTITIONED_REGION_NAME = \"partitionedRegion\";\n+  private static final String EMPTY_STRING = \"\";\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private MemberVM locator;\n+  private MemberVM server1;\n+  private MemberVM server2;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    locator = clusterStartupRule.startLocatorVM(0);\n+    server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    gfsh.connectAndVerify(locator);\n+    gfsh.executeAndAssertThat(\"create region --name=\" + REPLICATE_REGION_NAME + \" --type=REPLICATE\")\n+        .statusIsSuccess();\n+    gfsh.executeAndAssertThat(\n+        \"create region --name=\" + PARTITIONED_REGION_NAME + \" --type=PARTITION\").statusIsSuccess();\n+\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + REPLICATE_REGION_NAME, 2);\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + PARTITIONED_REGION_NAME, 2);\n+\n+    VMProvider.invokeInEveryMember(ClearCommandDUnitTest::populateTestRegions, server1, server2);\n+  }\n+\n+  private static void populateTestRegions() {\n+    Cache cache = CacheFactory.getAnyInstance();\n+\n+    Region<String, String> replicateRegion = cache.getRegion(REPLICATE_REGION_NAME);\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n+    replicateRegion.put(\"key1\", \"value1\");\n+    replicateRegion.put(\"key2\", \"value2\");\n+\n+    Region<String, String> partitionedRegion = cache.getRegion(PARTITIONED_REGION_NAME);\n+    partitionedRegion.put(\"key1\", \"value1\");\n+    partitionedRegion.put(\"key2\", \"value2\");\n+  }\n+\n+  @Test\n+  public void clearInvalidRegion() {\n+    String command = commandString + \" --region=NotAValidRegion\";\n+\n+    gfsh.executeAndAssertThat(command).statusIsError()\n+        .containsOutput(String.format(REGION_NOT_FOUND, \"/NotAValidRegion\"));\n+  }\n+\n+  @Test\n+  public void clearReplicateRegion() {\n+    String command = commandString + \" --region=\" + REPLICATE_REGION_NAME;\n+\n+    gfsh.executeAndAssertThat(\"list regions\").statusIsSuccess();\n+    gfsh.executeAndAssertThat(command).statusIsSuccess();\n+\n+    assertThat(gfsh.getGfshOutput()).contains(\"Cleared all keys in the region\");", "originalCommit": "466cc1b86b3183a2d738467e9cb9c68bdd41dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMwMDUwNQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r406300505", "bodyText": "I know this wasn't something introduced in this commit, but I feel that this naming was a typo and should be REMOVE__MSG__CLEARED_ALL_KEYS", "author": "DonalEvans", "createdAt": "2020-04-09T15:46:12Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java", "diffHunk": "@@ -1924,9 +1924,7 @@\n   public static final String REMOVE__MSG__CLEARED_ALL_CLEARS = \"Cleared all keys in the region\";", "originalCommit": "9cf25a867902099e8f64e76d573c9df4c71a49fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMwMDU1Ng==", "url": "https://github.com/apache/geode/pull/4818#discussion_r406300556", "bodyText": "If we're executing and asserting, we should assert that the command is successful. If we don't care if the command succeeds or not, we should just use execute(). I think that in this case, we probably do care about the status of the command.", "author": "DonalEvans", "createdAt": "2020-04-09T15:46:17Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -70,43 +72,49 @@ private static void populateTestRegions() {\n \n     Region<String, String> replicateRegion = cache.getRegion(REPLICATE_REGION_NAME);\n     replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n-    replicateRegion.put(\"key1\", \"value1\");\n-    replicateRegion.put(\"key2\", \"value2\");\n+    for(int i = 0; i < NUM_ENTRIES; i++) {\n+      replicateRegion.put(\"key\" + i, \"value\" + i);\n+    }\n \n     Region<String, String> partitionedRegion = cache.getRegion(PARTITIONED_REGION_NAME);\n-    partitionedRegion.put(\"key1\", \"value1\");\n-    partitionedRegion.put(\"key2\", \"value2\");\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n+    for(int i = 0; i < NUM_ENTRIES; i++) {\n+      partitionedRegion.put(\"key\" + i, \"value\" + i);\n+    }\n   }\n \n   @Test\n-  public void clearInvalidRegion() {\n-    String command = commandString + \" --region=NotAValidRegion\";\n-\n+  public void clearFailsWhenRegionIsNotFound() {\n+    String invalidRegionName = \"NotAValidRegion\";\n+    String command = new CommandStringBuilder(CliStrings.CLEAR)\n+        .addOption(CliStrings.CLEAR_REGION_NAME, invalidRegionName).getCommandString();\n     gfsh.executeAndAssertThat(command).statusIsError()\n-        .containsOutput(String.format(REGION_NOT_FOUND, \"/NotAValidRegion\"));\n+        .containsOutput(String.format(REGION_NOT_FOUND, \"/\" + invalidRegionName));\n   }\n \n   @Test\n-  public void clearReplicateRegion() {\n-    String command = commandString + \" --region=\" + REPLICATE_REGION_NAME;\n+  public void clearSucceedsWithValidReplicateRegion() {\n+    String command = new CommandStringBuilder(CliStrings.CLEAR)\n+        .addOption(CliStrings.CLEAR_REGION_NAME, REPLICATE_REGION_NAME).getCommandString();\n \n-    gfsh.executeAndAssertThat(\"list regions\").statusIsSuccess();\n+    gfsh.executeAndAssertThat(\"list regions\");\n     gfsh.executeAndAssertThat(command).statusIsSuccess();\n \n-    assertThat(gfsh.getGfshOutput()).contains(\"Cleared all keys in the region\");\n+    assertThat(gfsh.getGfshOutput()).contains(REMOVE__MSG__CLEARED_ALL_CLEARS);\n \n     server1.invoke(() -> verifyAllKeysAreRemoved(REPLICATE_REGION_NAME));\n     server2.invoke(() -> verifyAllKeysAreRemoved(REPLICATE_REGION_NAME));\n   }\n \n \n   @Test\n-  public void clearPartitionedRegion() {\n-    String command = commandString + \" --region=\" + PARTITIONED_REGION_NAME;\n+  public void clearSucceedsWithValidPartitionedRegion() {\n+    String command = new CommandStringBuilder(CliStrings.CLEAR)\n+        .addOption(CliStrings.CLEAR_REGION_NAME, PARTITIONED_REGION_NAME).getCommandString();\n \n-    gfsh.executeAndAssertThat(command).statusIsSuccess();\n+    gfsh.executeAndAssertThat(command);", "originalCommit": "9cf25a867902099e8f64e76d573c9df4c71a49fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MjQ4MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412492480", "bodyText": "This was removed by mistake, it should be back in there now.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMwMDU1Ng=="}], "type": "inlineReview"}, {"oid": "8c779a74f7c3260300751d62dc61f0125268a9f3", "url": "https://github.com/apache/geode/commit/8c779a74f7c3260300751d62dc61f0125268a9f3", "message": "Additional PR request changes", "committedDate": "2020-04-21T04:56:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2NDI3Mw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412364273", "bodyText": "Remove the \"BR\" here.", "author": "DonalEvans", "createdAt": "2020-04-21T17:47:28Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/functions/DataCommandFunction.java", "diffHunk": "@@ -276,7 +276,7 @@ public DataCommandResult remove(String key, String keyClass, String regionName,\n \n     if (StringUtils.isEmpty(removeAllKeys) && (key == null)) {\n       return DataCommandResult.createRemoveResult(null, null, null,\n-          CliStrings.REMOVE__MSG__KEY_EMPTY, false);\n+          \"BR\" + CliStrings.REMOVE__MSG__KEY_EMPTY, false);", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MjYxNw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412492617", "bodyText": "Done", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2NDI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2NjMyNQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412366325", "bodyText": "Shouldn't the clear command be using the clear function instead of remove?", "author": "DonalEvans", "createdAt": "2020-04-21T17:50:29Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/ClearCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.GfshCommand;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.security.ResourcePermission.Operation;\n+import org.apache.geode.security.ResourcePermission.Resource;\n+\n+public class ClearCommand extends GfshCommand {\n+  public static final String REGION_NOT_FOUND = \"Region <%s> not found in any of the members\";\n+\n+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DATA, CliStrings.TOPIC_GEODE_REGION})\n+  @CliCommand(value = {CliStrings.CLEAR}, help = CliStrings.CLEAR_HELP)\n+  public ResultModel clear(\n+      @CliOption(key = {CliStrings.CLEAR_REGION_NAME}, mandatory = true,\n+          help = CliStrings.CLEAR_REGION_NAME_HELP,\n+          optionContext = ConverterHint.REGION_PATH) String regionPath) {\n+\n+    Cache cache = getCache();\n+\n+    authorize(Resource.DATA, Operation.WRITE, regionPath);\n+\n+\n+    Region region = cache.getRegion(regionPath);\n+    DataCommandFunction clearfn = new DataCommandFunction();\n+    DataCommandResult dataResult;\n+    if (region == null) {\n+      Set<DistributedMember> memberList = findAnyMembersForRegion(regionPath);\n+\n+      if (CollectionUtils.isEmpty(memberList)) {\n+        return new ResultModel().createError(String.format(REGION_NOT_FOUND, regionPath));\n+      }\n+\n+      DataCommandRequest request = new DataCommandRequest();\n+      request.setCommand(CliStrings.REMOVE);\n+      request.setRemoveAllKeys(\"ALL\");\n+      request.setRegionName(regionPath);\n+      dataResult = callFunctionForRegion(request, clearfn, memberList);\n+    } else {\n+      dataResult = clearfn.remove(null, null, regionPath, \"ALL\",", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MDUzNA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412480534", "bodyText": "The remove function already has logic for 'clearing' a region (since you can remove --all) so a clear is just a remove with the all flag set. Anil and I discussed this as well and I refactored the remove all code into a 'clear()' method on the function class so it was more obvious where the code for clear was being performed but there were challenges in implementing a new clear function and it would also have involved duplicate code.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T20:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2NjMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3MDI3Ng==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412370276", "bodyText": "This variable is never used.", "author": "DonalEvans", "createdAt": "2020-04-21T17:55:54Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/functions/DataCommandFunction.java", "diffHunk": "@@ -313,22 +313,21 @@ public DataCommandResult remove(String key, String keyClass, String regionName,\n               CliStrings.REMOVE__MSG__KEY_NOT_FOUND_REGION, false);\n         }\n       } else {\n-        DataPolicy policy = region.getAttributes().getDataPolicy();\n-        if (!policy.withPartitioning()) {\n-          region.clear();\n-          if (logger.isDebugEnabled()) {\n-            logger.debug(\"Cleared all keys in the region - {}\", regionName);\n-          }\n-          return DataCommandResult.createRemoveInfoResult(key, null, null,\n-              CliStrings.format(CliStrings.REMOVE__MSG__CLEARED_ALL_CLEARS, regionName), true);\n-        } else {\n-          return DataCommandResult.createRemoveInfoResult(key, null, null,\n-              CliStrings.REMOVE__MSG__CLEARALL_NOT_SUPPORTED_FOR_PARTITIONREGION, false);\n-        }\n+        return clear(region, regionName);\n       }\n     }\n   }\n \n+  public DataCommandResult clear(Region region, String regionName) {\n+    DataPolicy policy = region.getAttributes().getDataPolicy();", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5Mjk0OA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412492948", "bodyText": "I've removed it.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3MDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MTc0MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412391740", "bodyText": "It might be best to rename and move this constant to reflect that going forward, only the clear command should be using the message, since remove --all is now deprecated.", "author": "DonalEvans", "createdAt": "2020-04-21T18:26:46Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java", "diffHunk": "@@ -1914,9 +1921,10 @@\n   public static final String REMOVE__MSG__KEY_EMPTY = \"Key is Null\";\n   public static final String REMOVE__MSG__REGION_NOT_FOUND = \"Region <{0}> Not Found\";\n   public static final String REMOVE__MSG__KEY_NOT_FOUND_REGION = \"Key is not present in the region\";\n-  public static final String REMOVE__MSG__CLEARED_ALL_CLEARS = \"Cleared all keys in the region\";\n-  public static final String REMOVE__MSG__CLEARALL_NOT_SUPPORTED_FOR_PARTITIONREGION =\n-      \"Option --\" + REMOVE__ALL + \" is not supported on partitioned region\";\n+  public static final String REMOVE__MSG__CLEARED_ALL_KEYS = \"Cleared all keys in the region\";", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NjY4Ng==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412476686", "bodyText": "I agree, this could easily be corrected here.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T20:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MTc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNzk2Mg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418127962", "bodyText": "I still think that renaming this to something like \"CLEAR_REGION_CLEARED_ALL_KEYS\" and moving it to the \"clear region\" section of constants would be worthwhile. It seems like a good idea to keep all clear-related stuff in one place.", "author": "DonalEvans", "createdAt": "2020-04-30T16:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MTc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxNTA1Nw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418615057", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-05-01T16:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MjYyMg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412392622", "bodyText": "new is not needed here, since createError is a static call.", "author": "DonalEvans", "createdAt": "2020-04-21T18:28:07Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/ClearCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.GfshCommand;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.security.ResourcePermission.Operation;\n+import org.apache.geode.security.ResourcePermission.Resource;\n+\n+public class ClearCommand extends GfshCommand {\n+  public static final String REGION_NOT_FOUND = \"Region <%s> not found in any of the members\";\n+\n+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DATA, CliStrings.TOPIC_GEODE_REGION})\n+  @CliCommand(value = {CliStrings.CLEAR}, help = CliStrings.CLEAR_HELP)\n+  public ResultModel clear(\n+      @CliOption(key = {CliStrings.CLEAR_REGION_NAME}, mandatory = true,\n+          help = CliStrings.CLEAR_REGION_NAME_HELP,\n+          optionContext = ConverterHint.REGION_PATH) String regionPath) {\n+\n+    Cache cache = getCache();\n+\n+    authorize(Resource.DATA, Operation.WRITE, regionPath);\n+\n+\n+    Region region = cache.getRegion(regionPath);\n+    DataCommandFunction clearfn = new DataCommandFunction();\n+    DataCommandResult dataResult;\n+    if (region == null) {\n+      Set<DistributedMember> memberList = findAnyMembersForRegion(regionPath);\n+\n+      if (CollectionUtils.isEmpty(memberList)) {\n+        return new ResultModel().createError(String.format(REGION_NOT_FOUND, regionPath));", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzAyOQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412493029", "bodyText": "I've removed this.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MjYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NTI5MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412395290", "bodyText": "These tests could be replaced with a single parameterized version, which would prevent code duplication, and also allow easy addition of other region types, such as those using persistence, should the test need to be expanded to cover them.", "author": "DonalEvans", "createdAt": "2020-04-21T18:32:01Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;\n+import static org.apache.geode.management.internal.i18n.CliStrings.REMOVE__MSG__CLEARED_ALL_KEYS;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.VMProvider;\n+\n+\n+public class ClearCommandDUnitTest {\n+  private static final String REPLICATE_REGION_NAME = \"replicateRegion\";\n+  private static final String PARTITIONED_REGION_NAME = \"partitionedRegion\";\n+  private static final String EMPTY_STRING = \"\";\n+  private static final int NUM_ENTRIES = 200;\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private MemberVM locator;\n+  private MemberVM server1;\n+  private MemberVM server2;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    locator = clusterStartupRule.startLocatorVM(0);\n+    server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    gfsh.connectAndVerify(locator);\n+    gfsh.executeAndAssertThat(\"create region --name=\" + REPLICATE_REGION_NAME + \" --type=REPLICATE\")\n+        .statusIsSuccess();\n+    gfsh.executeAndAssertThat(\n+        \"create region --name=\" + PARTITIONED_REGION_NAME + \" --type=PARTITION\").statusIsSuccess();\n+\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + REPLICATE_REGION_NAME, 2);\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + PARTITIONED_REGION_NAME, 2);\n+\n+    VMProvider.invokeInEveryMember(ClearCommandDUnitTest::populateTestRegions, server1, server2);\n+  }\n+\n+  private static void populateTestRegions() {\n+    Cache cache = CacheFactory.getAnyInstance();\n+\n+    Region<String, String> replicateRegion = cache.getRegion(REPLICATE_REGION_NAME);\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n+    for (int i = 0; i < NUM_ENTRIES; i++) {\n+      replicateRegion.put(\"key\" + i, \"value\" + i);\n+    }\n+\n+    Region<String, String> partitionedRegion = cache.getRegion(PARTITIONED_REGION_NAME);\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");\n+    for (int i = 0; i < NUM_ENTRIES; i++) {\n+      partitionedRegion.put(\"key\" + i, \"value\" + i);\n+    }\n+  }\n+\n+  @Test\n+  public void clearFailsWhenRegionIsNotFound() {\n+    String invalidRegionName = \"NotAValidRegion\";\n+    String command = new CommandStringBuilder(CliStrings.CLEAR)\n+        .addOption(CliStrings.CLEAR_REGION_NAME, invalidRegionName).getCommandString();\n+    gfsh.executeAndAssertThat(command).statusIsError()\n+        .containsOutput(String.format(REGION_NOT_FOUND, \"/\" + invalidRegionName));\n+  }\n+\n+  @Test\n+  public void clearSucceedsWithValidReplicateRegion() {\n+    String command = new CommandStringBuilder(CliStrings.CLEAR)\n+        .addOption(CliStrings.CLEAR_REGION_NAME, REPLICATE_REGION_NAME).getCommandString();\n+\n+    gfsh.executeAndAssertThat(command).statusIsSuccess();\n+\n+    assertThat(gfsh.getGfshOutput()).contains(REMOVE__MSG__CLEARED_ALL_KEYS);\n+\n+    server1.invoke(() -> verifyAllKeysAreRemoved(REPLICATE_REGION_NAME));\n+    server2.invoke(() -> verifyAllKeysAreRemoved(REPLICATE_REGION_NAME));\n+  }\n+\n+\n+  @Test\n+  public void clearSucceedsWithValidPartitionedRegion() {\n+    String command = new CommandStringBuilder(CliStrings.CLEAR)\n+        .addOption(CliStrings.CLEAR_REGION_NAME, PARTITIONED_REGION_NAME).getCommandString();\n+\n+    gfsh.executeAndAssertThat(command).statusIsSuccess();\n+\n+    assertThat(gfsh.getGfshOutput()).contains(REMOVE__MSG__CLEARED_ALL_KEYS);\n+\n+    server1.invoke(() -> verifyAllKeysAreRemoved(PARTITIONED_REGION_NAME));\n+    server2.invoke(() -> verifyAllKeysAreRemoved(PARTITIONED_REGION_NAME));\n+  }", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzI0OQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412493249", "bodyText": "This is a good idea, I'll make this parameterized.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NjkzMQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412396931", "bodyText": "Setting the value of result here is redundant, since it will always be assigned in the if/else block below.", "author": "DonalEvans", "createdAt": "2020-04-21T18:34:38Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/RemoveCommand.java", "diffHunk": "@@ -90,7 +90,14 @@ public ResultModel remove(\n     }\n \n     dataResult.setKeyClass(keyClass);\n+    ResultModel result = null;", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTg4MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412495880", "bodyText": "I've removed the redundant initialization.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NzU0NQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412397545", "bodyText": "This method is currently not being used anywhere.", "author": "DonalEvans", "createdAt": "2020-04-21T18:35:42Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/domain/DataCommandResult.java", "diffHunk": "@@ -240,6 +242,16 @@ public static DataCommandResult createRemoveResult(Object inputKey, Object value\n     return result;\n   }\n \n+  public static DataCommandResult createClearResult(Throwable error, String errorString,", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjExNQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412496115", "bodyText": "It was left in by mistake after making and then reverting some changes based on PR feedback. I'll remove this.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5NzU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwMDA3Mw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412400073", "bodyText": "It might be more consistent to either call setHeader here instead of addInfo, or to rename HEADER_INFO_SECTION to WARNING_INFO_SECTION or something similar.", "author": "DonalEvans", "createdAt": "2020-04-21T18:39:32Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/domain/DataCommandResult.java", "diffHunk": "@@ -381,6 +397,12 @@ public ResultModel toResultModel() {\n     }\n \n     ResultModel result = new ResultModel();\n+\n+    if (warningMessage != null && !warningMessage.isEmpty()) {\n+      InfoResultModel info = result.addInfo(HEADER_INFO_SECTION);", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzcxMQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412493711", "bodyText": "I'm reluctant to change the addInfo to setHeader because I want the structure of the output to match remove as closely as possible so I opted to change the name to WARNING_INFO_SECTION as this section isn't used in any other context.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T21:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwMDA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwMzM2MQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412403361", "bodyText": "Is there a particular reason we put a value with an empty string as the key here? Just curious.", "author": "DonalEvans", "createdAt": "2020-04-21T18:44:23Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/ClearCommandDUnitTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;\n+import static org.apache.geode.management.internal.i18n.CliStrings.REMOVE__MSG__CLEARED_ALL_KEYS;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.VMProvider;\n+\n+\n+public class ClearCommandDUnitTest {\n+  private static final String REPLICATE_REGION_NAME = \"replicateRegion\";\n+  private static final String PARTITIONED_REGION_NAME = \"partitionedRegion\";\n+  private static final String EMPTY_STRING = \"\";\n+  private static final int NUM_ENTRIES = 200;\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private MemberVM locator;\n+  private MemberVM server1;\n+  private MemberVM server2;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    locator = clusterStartupRule.startLocatorVM(0);\n+    server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    gfsh.connectAndVerify(locator);\n+    gfsh.executeAndAssertThat(\"create region --name=\" + REPLICATE_REGION_NAME + \" --type=REPLICATE\")\n+        .statusIsSuccess();\n+    gfsh.executeAndAssertThat(\n+        \"create region --name=\" + PARTITIONED_REGION_NAME + \" --type=PARTITION\").statusIsSuccess();\n+\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + REPLICATE_REGION_NAME, 2);\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/\" + PARTITIONED_REGION_NAME, 2);\n+\n+    VMProvider.invokeInEveryMember(ClearCommandDUnitTest::populateTestRegions, server1, server2);\n+  }\n+\n+  private static void populateTestRegions() {\n+    Cache cache = CacheFactory.getAnyInstance();\n+\n+    Region<String, String> replicateRegion = cache.getRegion(REPLICATE_REGION_NAME);\n+    replicateRegion.put(EMPTY_STRING, \"valueForEmptyKey\");", "originalCommit": "99838886619f0cefb0ebcd5d0463a03976eaf1eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4NzAwMw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r412487003", "bodyText": "I was following the pattern set up by the Remove command (since they're very similar) for a lot of these choices and this is the pattern that was used in the DUnit tests for that command. With the value specifically I'm not sure it matters whether it's empty or not but it's easy to change if we think there's value.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-21T20:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwMzM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NzQwNw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r413387407", "bodyText": "I think that several of these renames were accidentally included when changing the Cli string. They should be put back how they were.", "author": "DonalEvans", "createdAt": "2020-04-22T22:55:01Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/RegionReliabilityTestCase.java", "diffHunk": "@@ -1341,7 +1341,7 @@ public void run() {\n       // pass\n     }\n \n-    // CLEAR\n+    // CLEAR_REGION", "originalCommit": "6fc549d065a63d60802b2148eb5e2013220784b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMDI2Mg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r417510262", "bodyText": "Yep, this was a careless rename on my part. I changed these back.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-29T18:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NzQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NzUzOQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r413387539", "bodyText": "Another accidental rename.", "author": "DonalEvans", "createdAt": "2020-04-22T22:55:21Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/ClearRvvLockingDUnitTest.java", "diffHunk": "@@ -51,7 +51,7 @@\n \n /**\n  * Test class to verify proper RVV locking interaction between entry operations such as PUT/REMOVE\n- * and the CLEAR region operation\n+ * and the CLEAR_REGION region operation", "originalCommit": "6fc549d065a63d60802b2148eb5e2013220784b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4Nzc3Mw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r413387773", "bodyText": "More accidental renames in this file.", "author": "DonalEvans", "createdAt": "2020-04-22T22:55:52Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/ClearTXLockingDUnitTest.java", "diffHunk": "@@ -43,19 +43,20 @@\n import org.apache.geode.test.dunit.rules.DistributedRule;\n \n /**\n- * Test class to verify proper locking interaction between transactions and the CLEAR region\n+ * Test class to verify proper locking interaction between transactions and the CLEAR_REGION region", "originalCommit": "6fc549d065a63d60802b2148eb5e2013220784b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4Nzk1Mg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r413387952", "bodyText": "Accidental rename.", "author": "DonalEvans", "createdAt": "2020-04-22T22:56:12Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DiskStoreImpl.java", "diffHunk": "@@ -3509,7 +3509,7 @@ public String toString() {\n       if (de != null) {\n         sb.append(\" key=\").append(de.getKey());\n       } else {\n-        sb.append(\" <END CLEAR>\");\n+        sb.append(\" <END CLEAR_REGION>\");", "originalCommit": "6fc549d065a63d60802b2148eb5e2013220784b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MTM2Mg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r414861362", "bodyText": "This feels like more of an integration test as it's currently written, since it's not directly testing the ClearCommand class but rather how that class is used by gfsh. Instead of using gfsh.executeAndAssertThat, it might better to call ClearCommand.clear() directly and assert on the returned ResultModel.\nIt would also be good to verify that callFunctionForRegion() and clearfn.remove() are called with the expected/correct arguments, rater than just asserting the success/failure of the command, since otherwise the last two test cases end up being indistinguishable in terms of what they're asserting and the actual difference in behaviour between the two code paths isn't being verified.", "author": "DonalEvans", "createdAt": "2020-04-24T21:02:28Z", "path": "geode-gfsh/src/test/java/org/apache/geode/management/internal/cli/commands/ClearCommandTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.i18n.CliStrings.CLEAR_REGION;\n+import static org.apache.geode.management.internal.i18n.CliStrings.CLEAR_REGION_REGION_NAME;\n+import static org.apache.geode.management.internal.cli.commands.ClearCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.test.junit.rules.GfshParserRule;\n+\n+public class ClearCommandTest {", "originalCommit": "977782154b33e2686a0dc949442c1cea2188a771", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwOTA3Mg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r417509072", "bodyText": "Originally I was calling clear directly but that introduce complications with the test needing to hardcode the parsing of ResultModel since we weren't using the gfsh tools that come with the gfsh rule. Ultimately I decided that using the gfsh rule and relying on the gfsh command line parsing to call the the actual method we're testing was the lesser of two evils in that regard.\nI have added the verifications, I agree they improve the quality of the test.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-29T18:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MTg5Ng==", "url": "https://github.com/apache/geode/pull/4818#discussion_r414861896", "bodyText": "It's not necessary to specify the DistributedMember here, since it's implicit in the declaration of the membersList set.", "author": "DonalEvans", "createdAt": "2020-04-24T21:03:25Z", "path": "geode-gfsh/src/test/java/org/apache/geode/management/internal/cli/commands/ClearCommandTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.i18n.CliStrings.CLEAR_REGION;\n+import static org.apache.geode.management.internal.i18n.CliStrings.CLEAR_REGION_REGION_NAME;\n+import static org.apache.geode.management.internal.cli.commands.ClearCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.test.junit.rules.GfshParserRule;\n+\n+public class ClearCommandTest {\n+\n+  @ClassRule\n+  public static GfshParserRule gfsh = new GfshParserRule();\n+\n+  static final String regionName = \"regionName\";\n+  static final String success = \"SUCCESS\";\n+\n+  InternalCache cache;\n+  ClearCommand command;\n+  Region region;\n+  Set<DistributedMember> membersList;\n+  DistributedMember member;\n+  DataCommandResult dataResult;\n+\n+  @Before\n+  public void setup() {\n+    cache = mock(InternalCache.class);\n+    command = spy(new ClearCommand());\n+    region = mock(Region.class);\n+    dataResult = mock(DataCommandResult.class);\n+\n+    membersList = new HashSet<DistributedMember>();", "originalCommit": "977782154b33e2686a0dc949442c1cea2188a771", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwOTY5MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r417509690", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-29T18:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MjM4MA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r414862380", "bodyText": "To prevent compiler warnings, this should probably be Region<Object, Object> and a @SuppressWarnings(\"unchecked\") tag should be added to the setup() method.", "author": "DonalEvans", "createdAt": "2020-04-24T21:04:31Z", "path": "geode-gfsh/src/test/java/org/apache/geode/management/internal/cli/commands/ClearCommandTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.management.internal.i18n.CliStrings.CLEAR_REGION;\n+import static org.apache.geode.management.internal.i18n.CliStrings.CLEAR_REGION_REGION_NAME;\n+import static org.apache.geode.management.internal.cli.commands.ClearCommand.REGION_NOT_FOUND;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.internal.cli.domain.DataCommandRequest;\n+import org.apache.geode.management.internal.cli.domain.DataCommandResult;\n+import org.apache.geode.management.internal.cli.functions.DataCommandFunction;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.test.junit.rules.GfshParserRule;\n+\n+public class ClearCommandTest {\n+\n+  @ClassRule\n+  public static GfshParserRule gfsh = new GfshParserRule();\n+\n+  static final String regionName = \"regionName\";\n+  static final String success = \"SUCCESS\";\n+\n+  InternalCache cache;\n+  ClearCommand command;\n+  Region region;", "originalCommit": "977782154b33e2686a0dc949442c1cea2188a771", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwOTc4NA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r417509784", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-04-29T18:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MjM4MA=="}], "type": "inlineReview"}, {"oid": "a0867b8814e968c1e5a8e73329ad864fe92e626f", "url": "https://github.com/apache/geode/commit/a0867b8814e968c1e5a8e73329ad864fe92e626f", "message": "Added clear command and modified remove functionality to clear PR\n\nAuthored-by: Benjamin Ross <bross@pivotal.io>", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "51e3b47e9d56b3278715402a1c8a21800244ea96", "url": "https://github.com/apache/geode/commit/51e3b47e9d56b3278715402a1c8a21800244ea96", "message": "Fixed spA and rat failures\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "290592d72497647839a6bb8a19c0482ef6d2d9d7", "url": "https://github.com/apache/geode/commit/290592d72497647839a6bb8a19c0482ef6d2d9d7", "message": "Removed unnessessary code", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "402852d8cad2c90cd1fdae90f0771dcef9879d6e", "url": "https://github.com/apache/geode/commit/402852d8cad2c90cd1fdae90f0771dcef9879d6e", "message": "Fixed GfshParser test failure", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "779610b462a131358d6be5491658ae545cf29d41", "url": "https://github.com/apache/geode/commit/779610b462a131358d6be5491658ae545cf29d41", "message": "Changes to address PR feedback", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "c352047409d28b1274c5c22b91d04530130bd3b6", "url": "https://github.com/apache/geode/commit/c352047409d28b1274c5c22b91d04530130bd3b6", "message": "Additional PR request changes", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "6cf3f735c18c4c596e7217d3884fe4ed6b079e0d", "url": "https://github.com/apache/geode/commit/6cf3f735c18c4c596e7217d3884fe4ed6b079e0d", "message": "Spotless", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "c825574438ced15ae9a9e7899be8038a6ae7f824", "url": "https://github.com/apache/geode/commit/c825574438ced15ae9a9e7899be8038a6ae7f824", "message": "Changed 'clear' back to 'clear region'", "committedDate": "2020-04-30T16:17:14Z", "type": "commit"}, {"oid": "4545ae01859d8be8cc6e2b8a96315bd31c413d2d", "url": "https://github.com/apache/geode/commit/4545ae01859d8be8cc6e2b8a96315bd31c413d2d", "message": "Additional PR changes", "committedDate": "2020-04-30T16:17:15Z", "type": "commit"}, {"oid": "f59079f96b63e4f6d9cf74c65428e6a4f9956d0f", "url": "https://github.com/apache/geode/commit/f59079f96b63e4f6d9cf74c65428e6a4f9956d0f", "message": "Add unit test for ClearCommand class", "committedDate": "2020-04-30T16:17:15Z", "type": "commit"}, {"oid": "f84475a9d05870346df76b84a17041b74d0c2a7f", "url": "https://github.com/apache/geode/commit/f84475a9d05870346df76b84a17041b74d0c2a7f", "message": "Additional PR request changes", "committedDate": "2020-04-30T16:17:15Z", "type": "commit"}, {"oid": "f84475a9d05870346df76b84a17041b74d0c2a7f", "url": "https://github.com/apache/geode/commit/f84475a9d05870346df76b84a17041b74d0c2a7f", "message": "Additional PR request changes", "committedDate": "2020-04-30T16:17:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTYwMw==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418125603", "bodyText": "Here. Also consider fixing the formatting on the comment, since spotless has kind of messed it up following the accidental rename.", "author": "DonalEvans", "createdAt": "2020-04-30T16:10:55Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/ClearTXLockingDUnitTest.java", "diffHunk": "@@ -49,13 +49,14 @@\n  * <p>\n  * GEODE-1740: It was observed that operations performed within a transaction were not holding\n  * region modification locks for the duration of commit processing. This lock is used to ensure\n- * region consistency during CLEAR processing. By not holding the lock for the duration of commit\n+ * region consistency during CLEAR_REGION processing. By not holding the lock for the duration of", "originalCommit": "4e0c3df89898777020d61aa08f5914c64a812e94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxNDg3OA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418614878", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-05-01T16:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTY3OQ==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418125679", "bodyText": "Here.", "author": "DonalEvans", "createdAt": "2020-04-30T16:11:02Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/ClearTXLockingDUnitTest.java", "diffHunk": "@@ -49,13 +49,14 @@\n  * <p>\n  * GEODE-1740: It was observed that operations performed within a transaction were not holding\n  * region modification locks for the duration of commit processing. This lock is used to ensure\n- * region consistency during CLEAR processing. By not holding the lock for the duration of commit\n+ * region consistency during CLEAR_REGION processing. By not holding the lock for the duration of\n+ * commit\n  * processing, a window was opened that allowed region operations such as clear to occur in\n  * mid-commit.\n  *\n  * <p>\n  * The fix for GEODE-1740 was to acquire and hold read locks for any region involved in the commit.\n- * This forces CLEAR to wait until commit processing is complete.\n+ * This forces CLEAR_REGION to wait until commit processing is complete.", "originalCommit": "4e0c3df89898777020d61aa08f5914c64a812e94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxNDkxNg==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418614916", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-05-01T16:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTc1NA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418125754", "bodyText": "Here.", "author": "DonalEvans", "createdAt": "2020-04-30T16:11:09Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/ClearTXLockingDUnitTest.java", "diffHunk": "@@ -273,7 +274,7 @@ private void resetArmHook(String rname) {\n   }\n \n   /**\n-   * Wait to be notified it is time to perform region operation (i.e. CLEAR)\n+   * Wait to be notified it is time to perform region operation (i.e. CLEAR_REGION)", "originalCommit": "4e0c3df89898777020d61aa08f5914c64a812e94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxNDk2NA==", "url": "https://github.com/apache/geode/pull/4818#discussion_r418614964", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-05-01T16:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTc1NA=="}], "type": "inlineReview"}, {"oid": "5dd89629fc85c9c7ac80ff9786742720ee1473bb", "url": "https://github.com/apache/geode/commit/5dd89629fc85c9c7ac80ff9786742720ee1473bb", "message": "Additional PR changes", "committedDate": "2020-05-01T16:16:24Z", "type": "commit"}]}