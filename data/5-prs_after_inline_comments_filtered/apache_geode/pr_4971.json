{"pr_number": 4971, "pr_title": "GEODE-7996 Create DUNIT tests for SADD command", "pr_createdAt": "2020-04-17T14:24:53Z", "pr_url": "https://github.com/apache/geode/pull/4971", "timeline": [{"oid": "35d58ea4f95ef2a5740c5a5c95b63336abb39a56", "url": "https://github.com/apache/geode/commit/35d58ea4f95ef2a5740c5a5c95b63336abb39a56", "message": "GEODE-7996 Create DUNIT tests for SADD command", "committedDate": "2020-04-17T14:22:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMxNjU4NQ==", "url": "https://github.com/apache/geode/pull/4971#discussion_r410316585", "bodyText": "I wonder if these hard coded port numbers (6371, 6372, 6373) are what is causing the stressNewTest to fail.\nI think you could instead have the test call AvailablePortHelper.getRandomAvailableTCPPort(3) which would give you back an array of 3 ints", "author": "dschneider-pivotal", "createdAt": "2020-04-17T15:57:34Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/SaddDistDunitTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+public class SaddDistDunitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static final int SET_SIZE = 1000;\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, \"6371\");\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, \"6372\");\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, \"6373\");\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, 6371);", "originalCommit": "35d58ea4f95ef2a5740c5a5c95b63336abb39a56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MjM2NQ==", "url": "https://github.com/apache/geode/pull/4971#discussion_r410452365", "bodyText": "Good idea, I've implemented that and we'll see what the stress test thinks of it.", "author": "ringles", "createdAt": "2020-04-17T20:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMxNjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMzNzAwNQ==", "url": "https://github.com/apache/geode/pull/4971#discussion_r410337005", "bodyText": "I think this method would be clearer if at the top, when you initialize members1 and members2 you also created a list of \"allMembers\" by adding members1 and members2 to it. I think this is better than mutating members1 by adding members2 to it.", "author": "dschneider-pivotal", "createdAt": "2020-04-17T16:32:13Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/SaddDistDunitTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+public class SaddDistDunitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static final int SET_SIZE = 1000;\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, \"6371\");\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, \"6372\");\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, \"6373\");\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, 6371);\n+    jedis2 = new Jedis(LOCAL_HOST, 6372);\n+    jedis3 = new Jedis(LOCAL_HOST, 6373);\n+  }\n+\n+  @Before\n+  public void testSetup() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void should_distributeDataAmongMultipleServers_givenMultipleClients() {\n+\n+    String key = \"key\";\n+\n+    List<String> members = makeMemberList(SET_SIZE, \"member1-\");\n+\n+    jedis1.sadd(key, members.toArray(new String[] {}));\n+\n+    Set<String> result = jedis2.smembers(key);\n+\n+    assertThat(result.toArray()).containsExactlyInAnyOrder(members.toArray());\n+\n+  }\n+\n+  @Test\n+  public void should_distributeDataAmongMultipleServers_givenMultipleClients_AddingDifferentDataToSameSetConcurrently()\n+      throws InterruptedException {\n+\n+    String key = \"key\";\n+\n+    List<String> members1 = makeMemberList(SET_SIZE, \"member1-\");\n+    List<String> members2 = makeMemberList(SET_SIZE, \"member2-\");\n+\n+    Runnable addSetsWithClient1 = makeSADDRunnable(key, members1, jedis1);\n+    Runnable addSetsWithClient2 = makeSADDRunnable(key, members2, jedis2);\n+\n+    runConcurrentThreads(addSetsWithClient1, addSetsWithClient2);\n+\n+    Set<String> results = jedis3.smembers(key);\n+\n+    members1.addAll(members2);", "originalCommit": "35d58ea4f95ef2a5740c5a5c95b63336abb39a56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MjE0NA==", "url": "https://github.com/apache/geode/pull/4971#discussion_r410452144", "bodyText": "I agree, that's clearer. Implemented!", "author": "ringles", "createdAt": "2020-04-17T20:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMzNzAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMzOTE1OA==", "url": "https://github.com/apache/geode/pull/4971#discussion_r410339158", "bodyText": "Add a flavor of this method that has each client adding different members to the set?", "author": "dschneider-pivotal", "createdAt": "2020-04-17T16:36:17Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/SaddDistDunitTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+public class SaddDistDunitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static final int SET_SIZE = 1000;\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, \"6371\");\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, \"6372\");\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, \"6373\");\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, 6371);\n+    jedis2 = new Jedis(LOCAL_HOST, 6372);\n+    jedis3 = new Jedis(LOCAL_HOST, 6373);\n+  }\n+\n+  @Before\n+  public void testSetup() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void should_distributeDataAmongMultipleServers_givenMultipleClients() {\n+\n+    String key = \"key\";\n+\n+    List<String> members = makeMemberList(SET_SIZE, \"member1-\");\n+\n+    jedis1.sadd(key, members.toArray(new String[] {}));\n+\n+    Set<String> result = jedis2.smembers(key);\n+\n+    assertThat(result.toArray()).containsExactlyInAnyOrder(members.toArray());\n+\n+  }\n+\n+  @Test\n+  public void should_distributeDataAmongMultipleServers_givenMultipleClients_AddingDifferentDataToSameSetConcurrently()\n+      throws InterruptedException {\n+\n+    String key = \"key\";\n+\n+    List<String> members1 = makeMemberList(SET_SIZE, \"member1-\");\n+    List<String> members2 = makeMemberList(SET_SIZE, \"member2-\");\n+\n+    Runnable addSetsWithClient1 = makeSADDRunnable(key, members1, jedis1);\n+    Runnable addSetsWithClient2 = makeSADDRunnable(key, members2, jedis2);\n+\n+    runConcurrentThreads(addSetsWithClient1, addSetsWithClient2);\n+\n+    Set<String> results = jedis3.smembers(key);\n+\n+    members1.addAll(members2);\n+    assertThat(results.toArray()).containsExactlyInAnyOrder(members1.toArray());\n+\n+  }\n+\n+  @Test\n+  public void should_distributeDataAmongMultipleServers_givenMultipleClients_AddingSameDataToSameSetConcurrently()\n+      throws InterruptedException {\n+\n+    String key = \"key\";\n+\n+    List<String> members = makeMemberList(SET_SIZE, \"member-\");\n+\n+    Runnable addSetsWithClient1 = makeSADDRunnable(key, members, jedis1);\n+    Runnable addSetsWithClient2 = makeSADDRunnable(key, members, jedis2);\n+\n+    runConcurrentThreads(addSetsWithClient1, addSetsWithClient2);\n+\n+    Set<String> results = jedis3.smembers(key);\n+\n+    assertThat(results.toArray()).containsExactlyInAnyOrder(members.toArray());\n+\n+  }\n+\n+  @Test\n+  public void should_distributeDataAmongMultipleServers_givenMultipleClients_AddingDifferentSetsConcurrently()\n+      throws InterruptedException {\n+\n+    String key1 = \"key1\";\n+    String key2 = \"key2\";\n+\n+    List<String> members1 = makeMemberList(SET_SIZE, \"member1-\");\n+    List<String> members2 = makeMemberList(SET_SIZE, \"member2-\");\n+\n+    Runnable addSetsWithClient1 = makeSADDRunnable(key1, members1, jedis1);\n+    Runnable addSetsWithClient2 = makeSADDRunnable(key2, members2, jedis2);\n+\n+    runConcurrentThreads(addSetsWithClient1, addSetsWithClient2);\n+\n+    Set<String> results1 = jedis3.smembers(key1);\n+    Set<String> results2 = jedis3.smembers(key2);\n+\n+    assertThat(results1.toArray()).containsExactlyInAnyOrder(members1.toArray());\n+    assertThat(results2.toArray()).containsExactlyInAnyOrder(members2.toArray());\n+\n+  }\n+\n+  @Test\n+  public void should_distributeDataAmongMultipleServers_givenTwoSetsOfClients_OperatingOnTheSamSetConcurrently()", "originalCommit": "35d58ea4f95ef2a5740c5a5c95b63336abb39a56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MjAxMg==", "url": "https://github.com/apache/geode/pull/4971#discussion_r410452012", "bodyText": "Done!", "author": "ringles", "createdAt": "2020-04-17T20:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMzOTE1OA=="}], "type": "inlineReview"}, {"oid": "e9aced86413cbb973a49624a47407d3d5b8c0697", "url": "https://github.com/apache/geode/commit/e9aced86413cbb973a49624a47407d3d5b8c0697", "message": "Update with changes from review", "committedDate": "2020-04-17T20:23:30Z", "type": "commit"}, {"oid": "34f235b4e8d83c212c47d7be629c8ef8e1818549", "url": "https://github.com/apache/geode/commit/34f235b4e8d83c212c47d7be629c8ef8e1818549", "message": "Add countdown latch and awaits to better manage concurrency", "committedDate": "2020-04-20T14:06:44Z", "type": "commit"}, {"oid": "62867a2622433a940694b1ee864766d0fc2abdf7", "url": "https://github.com/apache/geode/commit/62867a2622433a940694b1ee864766d0fc2abdf7", "message": "Increase timeout for Jedis communication", "committedDate": "2020-04-20T15:01:40Z", "type": "commit"}, {"oid": "d3410e81e1e33db79ee79396139a334b1fe3f05e", "url": "https://github.com/apache/geode/commit/d3410e81e1e33db79ee79396139a334b1fe3f05e", "message": "Remove unneeded await()s", "committedDate": "2020-04-20T15:45:06Z", "type": "commit"}]}