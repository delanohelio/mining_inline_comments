{"pr_number": 5496, "pr_title": "GEODE-8465: secondary HARegionQueue to sync with primary queue", "pr_createdAt": "2020-09-03T16:45:07Z", "pr_url": "https://github.com/apache/geode/pull/5496", "timeline": [{"oid": "361122c62837645df24f0e121d2811990d97553d", "url": "https://github.com/apache/geode/commit/361122c62837645df24f0e121d2811990d97553d", "message": "GEODE-8465: secondary HARegionQueue to sync with primary queue\n\n  A seconary HARegionQueue will try to sync with primary after GII\n  to remove any events have been already dispatched from primary.", "committedDate": "2020-09-03T16:36:53Z", "type": "commit"}, {"oid": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "url": "https://github.com/apache/geode/commit/dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "message": "fix a NPE by not invoking a test method.", "committedDate": "2020-09-03T17:36:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1NjIzMg==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483156232", "bodyText": "Is it possible that when we get to this point, synchronizeWithPrimaryInProgress is true? Do we want to check its value before continuing, in case another thread has initiated the synchronization already?", "author": "DonalEvans", "createdAt": "2020-09-03T17:54:35Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {\n+    List<EventID> removedEvents = new LinkedList<>();\n+    for (EventID eventId : eventIds) {\n+      if (isRemoved(eventId)) {\n+        removedEvents.add(eventId);\n+      }\n+    }\n+    return removedEvents;\n+  }\n+\n+  boolean isRemoved(EventID eventId) {\n+    DispatchedAndCurrentEvents wrapper = getDispatchedAndCurrentEvents(eventId);\n+    if (wrapper != null && eventId.getSequenceID() > wrapper.lastDispatchedSequenceId) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  DispatchedAndCurrentEvents getDispatchedAndCurrentEvents(EventID eventId) {\n+    ThreadIdentifier tid = getThreadIdentifier(eventId);\n+    return (DispatchedAndCurrentEvents) eventsMap.get(tid);\n+  }\n+\n+  public void synchronizeQueueWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get() || synchronizeWithPrimaryInProgress.get()\n+        || !doneGIIQueueing.get()) {\n+      return;\n+    }\n+\n+    if (primary.getVersionOrdinal() < KnownVersion.GEODE_1_14_0.ordinal()) {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Don't send to primary with version older than KnownVersion.GEODE_1_14_0\");\n+      }\n+      return;\n+    }\n+    runSynchronizationWithPrimary(primary, cache);\n+  }\n+\n+  void runSynchronizationWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    cache.getDistributionManager().getExecutors().getWaitingThreadPool()\n+        .execute(() -> doSynchronizationWithPrimary(primary, cache));\n+  }\n+\n+  synchronized void doSynchronizationWithPrimary(InternalDistributedMember primary,\n+      InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get()) {", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3ODE3Ng==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483278176", "bodyText": "synchronizeWithPrimaryInProgress should not be true at this point. This is a synchronized method, any thread has set the hasSynchronizedWithPrimary to true, should set synchronizeWithPrimaryInProgress to false in the finally block.", "author": "pivotal-eshu", "createdAt": "2020-09-03T22:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1NjIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1ODkyOQ==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483158929", "bodyText": "The IDE warning on this line can be removed by making this Map.Entry<?, ?> entry", "author": "DonalEvans", "createdAt": "2020-09-03T17:59:23Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {\n+    List<EventID> removedEvents = new LinkedList<>();\n+    for (EventID eventId : eventIds) {\n+      if (isRemoved(eventId)) {\n+        removedEvents.add(eventId);\n+      }\n+    }\n+    return removedEvents;\n+  }\n+\n+  boolean isRemoved(EventID eventId) {\n+    DispatchedAndCurrentEvents wrapper = getDispatchedAndCurrentEvents(eventId);\n+    if (wrapper != null && eventId.getSequenceID() > wrapper.lastDispatchedSequenceId) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  DispatchedAndCurrentEvents getDispatchedAndCurrentEvents(EventID eventId) {\n+    ThreadIdentifier tid = getThreadIdentifier(eventId);\n+    return (DispatchedAndCurrentEvents) eventsMap.get(tid);\n+  }\n+\n+  public void synchronizeQueueWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get() || synchronizeWithPrimaryInProgress.get()\n+        || !doneGIIQueueing.get()) {\n+      return;\n+    }\n+\n+    if (primary.getVersionOrdinal() < KnownVersion.GEODE_1_14_0.ordinal()) {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Don't send to primary with version older than KnownVersion.GEODE_1_14_0\");\n+      }\n+      return;\n+    }\n+    runSynchronizationWithPrimary(primary, cache);\n+  }\n+\n+  void runSynchronizationWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    cache.getDistributionManager().getExecutors().getWaitingThreadPool()\n+        .execute(() -> doSynchronizationWithPrimary(primary, cache));\n+  }\n+\n+  synchronized void doSynchronizationWithPrimary(InternalDistributedMember primary,\n+      InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get()) {\n+      return;\n+    }\n+    synchronizeWithPrimaryInProgress.set(true);\n+    int maxChunkSize = 1000;\n+\n+    try {\n+      List<EventID> giiEvents = getGIIEvents();\n+      if (giiEvents.size() == 0) {\n+        hasSynchronizedWithPrimary.set(true);\n+        return;\n+      }\n+      Collection<List<EventID>> chunks = null;\n+\n+      if (giiEvents.size() > maxChunkSize) {\n+        chunks = getChunks(giiEvents, maxChunkSize);\n+      }\n+\n+      if (chunks == null) {\n+        if (!removeDispatchedEvents(primary, cache, giiEvents)) {\n+          return;\n+        }\n+      } else {\n+        for (List<EventID> chunk : chunks) {\n+          if (!removeDispatchedEvents(primary, cache, chunk)) {\n+            return;\n+          }\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"hasSynchronizedWithPrimary has synced with primary {} on queue: {} \", primary,\n+            regionName);\n+      }\n+      hasSynchronizedWithPrimary.set(true);\n+    } finally {\n+      synchronizeWithPrimaryInProgress.set(false);\n+    }\n+  }\n+\n+  Collection<List<EventID>> getChunks(List<EventID> events, int size) {\n+    AtomicInteger counter = new AtomicInteger(0);\n+    return events.stream().collect(Collectors.groupingBy(event -> counter.getAndIncrement() / size))\n+        .values();\n+  }\n+\n+  boolean removeDispatchedEvents(InternalDistributedMember primary, InternalCache cache,\n+      List<EventID> chunkEvents) {\n+    List<EventID> dispatchedEvents = getDispatchedEventsFromPrimary(primary, cache, chunkEvents);\n+\n+    if (dispatchedEvents == null) {\n+      // failed to get events from current primary, need to retry.\n+      return false;\n+    }\n+\n+    for (EventID id : dispatchedEvents) {\n+      if (!removeDispatchedEventAfterSyncWithPrimary(id)) {\n+        // failed to remove all dispatched events, need to retry\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  List<EventID> getDispatchedEventsFromPrimary(InternalDistributedMember primary,\n+      InternalCache cache, List<EventID> chunkEvents) {\n+    return QueueSynchronizationProcessor.getDispatchedEvents(cache.getDistributionManager(),\n+        primary, regionName, chunkEvents);\n+  }\n+\n+  List<EventID> getGIIEvents() {\n+    List<EventID> events = new LinkedList<>();\n+    for (long i = positionBeforeGII; i < positionAfterGII + 1; i++) {\n+      Map.Entry entry = region.getEntry(i);", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2MDIyNw==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483160227", "bodyText": "The use of the uncheckedCast() method here is not necessary, since the instanceof check ensures that the result of entry.getValue() can be safely cast to HAEventWrapper", "author": "DonalEvans", "createdAt": "2020-09-03T18:01:56Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {\n+    List<EventID> removedEvents = new LinkedList<>();\n+    for (EventID eventId : eventIds) {\n+      if (isRemoved(eventId)) {\n+        removedEvents.add(eventId);\n+      }\n+    }\n+    return removedEvents;\n+  }\n+\n+  boolean isRemoved(EventID eventId) {\n+    DispatchedAndCurrentEvents wrapper = getDispatchedAndCurrentEvents(eventId);\n+    if (wrapper != null && eventId.getSequenceID() > wrapper.lastDispatchedSequenceId) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  DispatchedAndCurrentEvents getDispatchedAndCurrentEvents(EventID eventId) {\n+    ThreadIdentifier tid = getThreadIdentifier(eventId);\n+    return (DispatchedAndCurrentEvents) eventsMap.get(tid);\n+  }\n+\n+  public void synchronizeQueueWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get() || synchronizeWithPrimaryInProgress.get()\n+        || !doneGIIQueueing.get()) {\n+      return;\n+    }\n+\n+    if (primary.getVersionOrdinal() < KnownVersion.GEODE_1_14_0.ordinal()) {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Don't send to primary with version older than KnownVersion.GEODE_1_14_0\");\n+      }\n+      return;\n+    }\n+    runSynchronizationWithPrimary(primary, cache);\n+  }\n+\n+  void runSynchronizationWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    cache.getDistributionManager().getExecutors().getWaitingThreadPool()\n+        .execute(() -> doSynchronizationWithPrimary(primary, cache));\n+  }\n+\n+  synchronized void doSynchronizationWithPrimary(InternalDistributedMember primary,\n+      InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get()) {\n+      return;\n+    }\n+    synchronizeWithPrimaryInProgress.set(true);\n+    int maxChunkSize = 1000;\n+\n+    try {\n+      List<EventID> giiEvents = getGIIEvents();\n+      if (giiEvents.size() == 0) {\n+        hasSynchronizedWithPrimary.set(true);\n+        return;\n+      }\n+      Collection<List<EventID>> chunks = null;\n+\n+      if (giiEvents.size() > maxChunkSize) {\n+        chunks = getChunks(giiEvents, maxChunkSize);\n+      }\n+\n+      if (chunks == null) {\n+        if (!removeDispatchedEvents(primary, cache, giiEvents)) {\n+          return;\n+        }\n+      } else {\n+        for (List<EventID> chunk : chunks) {\n+          if (!removeDispatchedEvents(primary, cache, chunk)) {\n+            return;\n+          }\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"hasSynchronizedWithPrimary has synced with primary {} on queue: {} \", primary,\n+            regionName);\n+      }\n+      hasSynchronizedWithPrimary.set(true);\n+    } finally {\n+      synchronizeWithPrimaryInProgress.set(false);\n+    }\n+  }\n+\n+  Collection<List<EventID>> getChunks(List<EventID> events, int size) {\n+    AtomicInteger counter = new AtomicInteger(0);\n+    return events.stream().collect(Collectors.groupingBy(event -> counter.getAndIncrement() / size))\n+        .values();\n+  }\n+\n+  boolean removeDispatchedEvents(InternalDistributedMember primary, InternalCache cache,\n+      List<EventID> chunkEvents) {\n+    List<EventID> dispatchedEvents = getDispatchedEventsFromPrimary(primary, cache, chunkEvents);\n+\n+    if (dispatchedEvents == null) {\n+      // failed to get events from current primary, need to retry.\n+      return false;\n+    }\n+\n+    for (EventID id : dispatchedEvents) {\n+      if (!removeDispatchedEventAfterSyncWithPrimary(id)) {\n+        // failed to remove all dispatched events, need to retry\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  List<EventID> getDispatchedEventsFromPrimary(InternalDistributedMember primary,\n+      InternalCache cache, List<EventID> chunkEvents) {\n+    return QueueSynchronizationProcessor.getDispatchedEvents(cache.getDistributionManager(),\n+        primary, regionName, chunkEvents);\n+  }\n+\n+  List<EventID> getGIIEvents() {\n+    List<EventID> events = new LinkedList<>();\n+    for (long i = positionBeforeGII; i < positionAfterGII + 1; i++) {\n+      Map.Entry entry = region.getEntry(i);\n+      // could be already removed after processing QueueRemovalMessage\n+      if (entry != null && entry.getValue() instanceof HAEventWrapper) {\n+        HAEventWrapper wrapper = uncheckedCast(entry.getValue());", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMzgwMg==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483213802", "bodyText": "The name of this method (and the isRemoved() method below it) are a little confusing to me. It appears that we only check if events have been dispatched by the primary, and the naming up to this point has been consistently only talking about dispatched events. Would it make sense for these methods be renamed to getDispatchedEvents() and isDispatched(), for clarity?", "author": "DonalEvans", "createdAt": "2020-09-03T19:44:03Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyNTk3Ng==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483225976", "bodyText": "This might be better worded as \"After sync with primary for HARegionQueue {}, removing dispatched event with ID {}\"", "author": "DonalEvans", "createdAt": "2020-09-03T20:09:30Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {\n+    List<EventID> removedEvents = new LinkedList<>();\n+    for (EventID eventId : eventIds) {\n+      if (isRemoved(eventId)) {\n+        removedEvents.add(eventId);\n+      }\n+    }\n+    return removedEvents;\n+  }\n+\n+  boolean isRemoved(EventID eventId) {\n+    DispatchedAndCurrentEvents wrapper = getDispatchedAndCurrentEvents(eventId);\n+    if (wrapper != null && eventId.getSequenceID() > wrapper.lastDispatchedSequenceId) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  DispatchedAndCurrentEvents getDispatchedAndCurrentEvents(EventID eventId) {\n+    ThreadIdentifier tid = getThreadIdentifier(eventId);\n+    return (DispatchedAndCurrentEvents) eventsMap.get(tid);\n+  }\n+\n+  public void synchronizeQueueWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get() || synchronizeWithPrimaryInProgress.get()\n+        || !doneGIIQueueing.get()) {\n+      return;\n+    }\n+\n+    if (primary.getVersionOrdinal() < KnownVersion.GEODE_1_14_0.ordinal()) {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Don't send to primary with version older than KnownVersion.GEODE_1_14_0\");\n+      }\n+      return;\n+    }\n+    runSynchronizationWithPrimary(primary, cache);\n+  }\n+\n+  void runSynchronizationWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    cache.getDistributionManager().getExecutors().getWaitingThreadPool()\n+        .execute(() -> doSynchronizationWithPrimary(primary, cache));\n+  }\n+\n+  synchronized void doSynchronizationWithPrimary(InternalDistributedMember primary,\n+      InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get()) {\n+      return;\n+    }\n+    synchronizeWithPrimaryInProgress.set(true);\n+    int maxChunkSize = 1000;\n+\n+    try {\n+      List<EventID> giiEvents = getGIIEvents();\n+      if (giiEvents.size() == 0) {\n+        hasSynchronizedWithPrimary.set(true);\n+        return;\n+      }\n+      Collection<List<EventID>> chunks = null;\n+\n+      if (giiEvents.size() > maxChunkSize) {\n+        chunks = getChunks(giiEvents, maxChunkSize);\n+      }\n+\n+      if (chunks == null) {\n+        if (!removeDispatchedEvents(primary, cache, giiEvents)) {\n+          return;\n+        }\n+      } else {\n+        for (List<EventID> chunk : chunks) {\n+          if (!removeDispatchedEvents(primary, cache, chunk)) {\n+            return;\n+          }\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"hasSynchronizedWithPrimary has synced with primary {} on queue: {} \", primary,\n+            regionName);\n+      }\n+      hasSynchronizedWithPrimary.set(true);\n+    } finally {\n+      synchronizeWithPrimaryInProgress.set(false);\n+    }\n+  }\n+\n+  Collection<List<EventID>> getChunks(List<EventID> events, int size) {\n+    AtomicInteger counter = new AtomicInteger(0);\n+    return events.stream().collect(Collectors.groupingBy(event -> counter.getAndIncrement() / size))\n+        .values();\n+  }\n+\n+  boolean removeDispatchedEvents(InternalDistributedMember primary, InternalCache cache,\n+      List<EventID> chunkEvents) {\n+    List<EventID> dispatchedEvents = getDispatchedEventsFromPrimary(primary, cache, chunkEvents);\n+\n+    if (dispatchedEvents == null) {\n+      // failed to get events from current primary, need to retry.\n+      return false;\n+    }\n+\n+    for (EventID id : dispatchedEvents) {\n+      if (!removeDispatchedEventAfterSyncWithPrimary(id)) {\n+        // failed to remove all dispatched events, need to retry\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  List<EventID> getDispatchedEventsFromPrimary(InternalDistributedMember primary,\n+      InternalCache cache, List<EventID> chunkEvents) {\n+    return QueueSynchronizationProcessor.getDispatchedEvents(cache.getDistributionManager(),\n+        primary, regionName, chunkEvents);\n+  }\n+\n+  List<EventID> getGIIEvents() {\n+    List<EventID> events = new LinkedList<>();\n+    for (long i = positionBeforeGII; i < positionAfterGII + 1; i++) {\n+      Map.Entry entry = region.getEntry(i);\n+      // could be already removed after processing QueueRemovalMessage\n+      if (entry != null && entry.getValue() instanceof HAEventWrapper) {\n+        HAEventWrapper wrapper = uncheckedCast(entry.getValue());\n+        events.add(wrapper.getEventId());\n+      }\n+    }\n+    return events;\n+  }\n+\n+  boolean removeDispatchedEventAfterSyncWithPrimary(EventID id) {\n+    boolean interrupted = Thread.interrupted();\n+    try {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"removing dispatched event after sync with primary on queue {} for {}\",", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTIyMA==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483231220", "bodyText": "This might be better as logger.info(\"HARegionQueue {} was found to be destroyed when attempting to remove dispatched event with ID {} after sync\", regionName, id);", "author": "DonalEvans", "createdAt": "2020-09-03T20:19:30Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {\n+    List<EventID> removedEvents = new LinkedList<>();\n+    for (EventID eventId : eventIds) {\n+      if (isRemoved(eventId)) {\n+        removedEvents.add(eventId);\n+      }\n+    }\n+    return removedEvents;\n+  }\n+\n+  boolean isRemoved(EventID eventId) {\n+    DispatchedAndCurrentEvents wrapper = getDispatchedAndCurrentEvents(eventId);\n+    if (wrapper != null && eventId.getSequenceID() > wrapper.lastDispatchedSequenceId) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  DispatchedAndCurrentEvents getDispatchedAndCurrentEvents(EventID eventId) {\n+    ThreadIdentifier tid = getThreadIdentifier(eventId);\n+    return (DispatchedAndCurrentEvents) eventsMap.get(tid);\n+  }\n+\n+  public void synchronizeQueueWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get() || synchronizeWithPrimaryInProgress.get()\n+        || !doneGIIQueueing.get()) {\n+      return;\n+    }\n+\n+    if (primary.getVersionOrdinal() < KnownVersion.GEODE_1_14_0.ordinal()) {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Don't send to primary with version older than KnownVersion.GEODE_1_14_0\");\n+      }\n+      return;\n+    }\n+    runSynchronizationWithPrimary(primary, cache);\n+  }\n+\n+  void runSynchronizationWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    cache.getDistributionManager().getExecutors().getWaitingThreadPool()\n+        .execute(() -> doSynchronizationWithPrimary(primary, cache));\n+  }\n+\n+  synchronized void doSynchronizationWithPrimary(InternalDistributedMember primary,\n+      InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get()) {\n+      return;\n+    }\n+    synchronizeWithPrimaryInProgress.set(true);\n+    int maxChunkSize = 1000;\n+\n+    try {\n+      List<EventID> giiEvents = getGIIEvents();\n+      if (giiEvents.size() == 0) {\n+        hasSynchronizedWithPrimary.set(true);\n+        return;\n+      }\n+      Collection<List<EventID>> chunks = null;\n+\n+      if (giiEvents.size() > maxChunkSize) {\n+        chunks = getChunks(giiEvents, maxChunkSize);\n+      }\n+\n+      if (chunks == null) {\n+        if (!removeDispatchedEvents(primary, cache, giiEvents)) {\n+          return;\n+        }\n+      } else {\n+        for (List<EventID> chunk : chunks) {\n+          if (!removeDispatchedEvents(primary, cache, chunk)) {\n+            return;\n+          }\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"hasSynchronizedWithPrimary has synced with primary {} on queue: {} \", primary,\n+            regionName);\n+      }\n+      hasSynchronizedWithPrimary.set(true);\n+    } finally {\n+      synchronizeWithPrimaryInProgress.set(false);\n+    }\n+  }\n+\n+  Collection<List<EventID>> getChunks(List<EventID> events, int size) {\n+    AtomicInteger counter = new AtomicInteger(0);\n+    return events.stream().collect(Collectors.groupingBy(event -> counter.getAndIncrement() / size))\n+        .values();\n+  }\n+\n+  boolean removeDispatchedEvents(InternalDistributedMember primary, InternalCache cache,\n+      List<EventID> chunkEvents) {\n+    List<EventID> dispatchedEvents = getDispatchedEventsFromPrimary(primary, cache, chunkEvents);\n+\n+    if (dispatchedEvents == null) {\n+      // failed to get events from current primary, need to retry.\n+      return false;\n+    }\n+\n+    for (EventID id : dispatchedEvents) {\n+      if (!removeDispatchedEventAfterSyncWithPrimary(id)) {\n+        // failed to remove all dispatched events, need to retry\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  List<EventID> getDispatchedEventsFromPrimary(InternalDistributedMember primary,\n+      InternalCache cache, List<EventID> chunkEvents) {\n+    return QueueSynchronizationProcessor.getDispatchedEvents(cache.getDistributionManager(),\n+        primary, regionName, chunkEvents);\n+  }\n+\n+  List<EventID> getGIIEvents() {\n+    List<EventID> events = new LinkedList<>();\n+    for (long i = positionBeforeGII; i < positionAfterGII + 1; i++) {\n+      Map.Entry entry = region.getEntry(i);\n+      // could be already removed after processing QueueRemovalMessage\n+      if (entry != null && entry.getValue() instanceof HAEventWrapper) {\n+        HAEventWrapper wrapper = uncheckedCast(entry.getValue());\n+        events.add(wrapper.getEventId());\n+      }\n+    }\n+    return events;\n+  }\n+\n+  boolean removeDispatchedEventAfterSyncWithPrimary(EventID id) {\n+    boolean interrupted = Thread.interrupted();\n+    try {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"removing dispatched event after sync with primary on queue {} for {}\",\n+            regionName, id);\n+      }\n+      removeDispatchedEvents(id);\n+    } catch (RegionDestroyedException ignore) {\n+      logger.info(\n+          \"Queue found destroyed while processing dispatched sequence ID after syn.\"\n+              + \" The event ID is {} for HARegion with name={}\",\n+          id, regionName);", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNDUxMA==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483234510", "bodyText": "It seems like the arguments for the string format are in the wrong order here. Alternately, this might be better worded as \"HARegionQueue %s encountered an exception when attempting to remove event with ID %s from the queue\", which would have the arguments in the correct order.", "author": "DonalEvans", "createdAt": "2020-09-03T20:24:35Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {\n+    List<EventID> removedEvents = new LinkedList<>();\n+    for (EventID eventId : eventIds) {\n+      if (isRemoved(eventId)) {\n+        removedEvents.add(eventId);\n+      }\n+    }\n+    return removedEvents;\n+  }\n+\n+  boolean isRemoved(EventID eventId) {\n+    DispatchedAndCurrentEvents wrapper = getDispatchedAndCurrentEvents(eventId);\n+    if (wrapper != null && eventId.getSequenceID() > wrapper.lastDispatchedSequenceId) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  DispatchedAndCurrentEvents getDispatchedAndCurrentEvents(EventID eventId) {\n+    ThreadIdentifier tid = getThreadIdentifier(eventId);\n+    return (DispatchedAndCurrentEvents) eventsMap.get(tid);\n+  }\n+\n+  public void synchronizeQueueWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get() || synchronizeWithPrimaryInProgress.get()\n+        || !doneGIIQueueing.get()) {\n+      return;\n+    }\n+\n+    if (primary.getVersionOrdinal() < KnownVersion.GEODE_1_14_0.ordinal()) {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Don't send to primary with version older than KnownVersion.GEODE_1_14_0\");\n+      }\n+      return;\n+    }\n+    runSynchronizationWithPrimary(primary, cache);\n+  }\n+\n+  void runSynchronizationWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    cache.getDistributionManager().getExecutors().getWaitingThreadPool()\n+        .execute(() -> doSynchronizationWithPrimary(primary, cache));\n+  }\n+\n+  synchronized void doSynchronizationWithPrimary(InternalDistributedMember primary,\n+      InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get()) {\n+      return;\n+    }\n+    synchronizeWithPrimaryInProgress.set(true);\n+    int maxChunkSize = 1000;\n+\n+    try {\n+      List<EventID> giiEvents = getGIIEvents();\n+      if (giiEvents.size() == 0) {\n+        hasSynchronizedWithPrimary.set(true);\n+        return;\n+      }\n+      Collection<List<EventID>> chunks = null;\n+\n+      if (giiEvents.size() > maxChunkSize) {\n+        chunks = getChunks(giiEvents, maxChunkSize);\n+      }\n+\n+      if (chunks == null) {\n+        if (!removeDispatchedEvents(primary, cache, giiEvents)) {\n+          return;\n+        }\n+      } else {\n+        for (List<EventID> chunk : chunks) {\n+          if (!removeDispatchedEvents(primary, cache, chunk)) {\n+            return;\n+          }\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"hasSynchronizedWithPrimary has synced with primary {} on queue: {} \", primary,\n+            regionName);\n+      }\n+      hasSynchronizedWithPrimary.set(true);\n+    } finally {\n+      synchronizeWithPrimaryInProgress.set(false);\n+    }\n+  }\n+\n+  Collection<List<EventID>> getChunks(List<EventID> events, int size) {\n+    AtomicInteger counter = new AtomicInteger(0);\n+    return events.stream().collect(Collectors.groupingBy(event -> counter.getAndIncrement() / size))\n+        .values();\n+  }\n+\n+  boolean removeDispatchedEvents(InternalDistributedMember primary, InternalCache cache,\n+      List<EventID> chunkEvents) {\n+    List<EventID> dispatchedEvents = getDispatchedEventsFromPrimary(primary, cache, chunkEvents);\n+\n+    if (dispatchedEvents == null) {\n+      // failed to get events from current primary, need to retry.\n+      return false;\n+    }\n+\n+    for (EventID id : dispatchedEvents) {\n+      if (!removeDispatchedEventAfterSyncWithPrimary(id)) {\n+        // failed to remove all dispatched events, need to retry\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  List<EventID> getDispatchedEventsFromPrimary(InternalDistributedMember primary,\n+      InternalCache cache, List<EventID> chunkEvents) {\n+    return QueueSynchronizationProcessor.getDispatchedEvents(cache.getDistributionManager(),\n+        primary, regionName, chunkEvents);\n+  }\n+\n+  List<EventID> getGIIEvents() {\n+    List<EventID> events = new LinkedList<>();\n+    for (long i = positionBeforeGII; i < positionAfterGII + 1; i++) {\n+      Map.Entry entry = region.getEntry(i);\n+      // could be already removed after processing QueueRemovalMessage\n+      if (entry != null && entry.getValue() instanceof HAEventWrapper) {\n+        HAEventWrapper wrapper = uncheckedCast(entry.getValue());\n+        events.add(wrapper.getEventId());\n+      }\n+    }\n+    return events;\n+  }\n+\n+  boolean removeDispatchedEventAfterSyncWithPrimary(EventID id) {\n+    boolean interrupted = Thread.interrupted();\n+    try {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"removing dispatched event after sync with primary on queue {} for {}\",\n+            regionName, id);\n+      }\n+      removeDispatchedEvents(id);\n+    } catch (RegionDestroyedException ignore) {\n+      logger.info(\n+          \"Queue found destroyed while processing dispatched sequence ID after syn.\"\n+              + \" The event ID is {} for HARegion with name={}\",\n+          id, regionName);\n+    } catch (CancelException ignore) {\n+      return false;\n+    } catch (CacheException e) {\n+      logger.error(String.format(\n+          \"Sync with primary got Exception when removing from the queue. The problem is with event ID, %s for HARegion with name=%s\",\n+          regionName, id),", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzOTczMg==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483239732", "bodyText": "For consistency with other suggested log output changes, this might be better as logger.debug(\"HARegionQueue {} has synced with primary on {}\", regionName, primary);", "author": "DonalEvans", "createdAt": "2020-09-03T20:35:31Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java", "diffHunk": "@@ -3943,4 +3958,165 @@ private static int calculateThreadIdExpiryTime() {\n   public Queue getGiiQueue() {\n     return this.giiQueue;\n   }\n+\n+  List<EventID> getDispatchedOrRemovedEvents(List<EventID> eventIds) {\n+    List<EventID> removedEvents = new LinkedList<>();\n+    for (EventID eventId : eventIds) {\n+      if (isRemoved(eventId)) {\n+        removedEvents.add(eventId);\n+      }\n+    }\n+    return removedEvents;\n+  }\n+\n+  boolean isRemoved(EventID eventId) {\n+    DispatchedAndCurrentEvents wrapper = getDispatchedAndCurrentEvents(eventId);\n+    if (wrapper != null && eventId.getSequenceID() > wrapper.lastDispatchedSequenceId) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  DispatchedAndCurrentEvents getDispatchedAndCurrentEvents(EventID eventId) {\n+    ThreadIdentifier tid = getThreadIdentifier(eventId);\n+    return (DispatchedAndCurrentEvents) eventsMap.get(tid);\n+  }\n+\n+  public void synchronizeQueueWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get() || synchronizeWithPrimaryInProgress.get()\n+        || !doneGIIQueueing.get()) {\n+      return;\n+    }\n+\n+    if (primary.getVersionOrdinal() < KnownVersion.GEODE_1_14_0.ordinal()) {\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Don't send to primary with version older than KnownVersion.GEODE_1_14_0\");\n+      }\n+      return;\n+    }\n+    runSynchronizationWithPrimary(primary, cache);\n+  }\n+\n+  void runSynchronizationWithPrimary(InternalDistributedMember primary, InternalCache cache) {\n+    cache.getDistributionManager().getExecutors().getWaitingThreadPool()\n+        .execute(() -> doSynchronizationWithPrimary(primary, cache));\n+  }\n+\n+  synchronized void doSynchronizationWithPrimary(InternalDistributedMember primary,\n+      InternalCache cache) {\n+    if (hasSynchronizedWithPrimary.get()) {\n+      return;\n+    }\n+    synchronizeWithPrimaryInProgress.set(true);\n+    int maxChunkSize = 1000;\n+\n+    try {\n+      List<EventID> giiEvents = getGIIEvents();\n+      if (giiEvents.size() == 0) {\n+        hasSynchronizedWithPrimary.set(true);\n+        return;\n+      }\n+      Collection<List<EventID>> chunks = null;\n+\n+      if (giiEvents.size() > maxChunkSize) {\n+        chunks = getChunks(giiEvents, maxChunkSize);\n+      }\n+\n+      if (chunks == null) {\n+        if (!removeDispatchedEvents(primary, cache, giiEvents)) {\n+          return;\n+        }\n+      } else {\n+        for (List<EventID> chunk : chunks) {\n+          if (!removeDispatchedEvents(primary, cache, chunk)) {\n+            return;\n+          }\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"hasSynchronizedWithPrimary has synced with primary {} on queue: {} \", primary,", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI0NjI1OQ==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483246259", "bodyText": "The IDE warning for raw use of parameterized class can be removed by using Iterator<Object> here.", "author": "DonalEvans", "createdAt": "2020-09-03T20:49:29Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/QueueRemovalMessageTest.java", "diffHunk": "@@ -212,4 +213,24 @@ public void removeQueueEventReturnsTrueIfRemovalThrowsRejectedExecutionException\n \n     assertThat(queueRemovalMessage.removeQueueEvent(regionName2, regionQueue2, eventID2)).isTrue();\n   }\n+\n+  @Test\n+  public void synchronizeQueueWithPrimaryInvokedAfterProcessEachRegionQueue() {\n+    addToMessagesList();\n+    Iterator iterator = messagesList.iterator();", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI1MTAzMw==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483251033", "bodyText": "If the comments about the naming of getDispatchedOrRemovedEvents() and isRemoved() are applied, this method name should also be changed.", "author": "DonalEvans", "createdAt": "2020-09-03T20:59:36Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI1MjE3MA==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483252170", "bodyText": "These three assertions can be simplified to assertThat(removedEvents).containsExactlyInAnyOrder(id2, id3);", "author": "DonalEvans", "createdAt": "2020-09-03T21:01:59Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> removedEvents;\n+    addEvents();\n+    doReturn(false).when(spy).isRemoved(id1);\n+    doReturn(true).when(spy).isRemoved(id2);\n+    doReturn(true).when(spy).isRemoved(id3);\n+    doReturn(false).when(spy).isRemoved(id4);\n+\n+    removedEvents = spy.getDispatchedOrRemovedEvents(eventIDS);\n+\n+    assertThat(removedEvents.size()).isEqualTo(2);\n+    assertThat(removedEvents.contains(id2));\n+    assertThat(removedEvents.contains(id3));", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI1MjYzMQ==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483252631", "bodyText": "The declaration and assignment of this variable can be moved to the same line.", "author": "DonalEvans", "createdAt": "2020-09-03T21:03:05Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> removedEvents;", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI1MzUzOQ==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483253539", "bodyText": "If the comments about the naming of getDispatchedOrRemovedEvents() and isRemoved() are applied, this method name should also be changed, along with the following 3 test methods.", "author": "DonalEvans", "createdAt": "2020-09-03T21:05:05Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> removedEvents;\n+    addEvents();\n+    doReturn(false).when(spy).isRemoved(id1);\n+    doReturn(true).when(spy).isRemoved(id2);\n+    doReturn(true).when(spy).isRemoved(id3);\n+    doReturn(false).when(spy).isRemoved(id4);\n+\n+    removedEvents = spy.getDispatchedOrRemovedEvents(eventIDS);\n+\n+    assertThat(removedEvents.size()).isEqualTo(2);\n+    assertThat(removedEvents.contains(id2));\n+    assertThat(removedEvents.contains(id3));\n+  }\n+\n+  private void addEvents() {\n+    eventIDS.add(id1);\n+    eventIDS.add(id2);\n+    eventIDS.add(id3);\n+    eventIDS.add(id4);\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfDispatchedAndCurrentEventsAreRemoved() {", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MTEyMA==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483261120", "bodyText": "The IDE warnings for these lines can be removed by using\nRegion.Entry<Object,Object> entry1 = uncheckedCast(mock(Region.Entry.class));\nRegion.Entry<Object,Object> entry2 = uncheckedCast(mock(Region.Entry.class));\nRegion.Entry<Object,Object> entry3 = uncheckedCast(mock(Region.Entry.class));", "author": "DonalEvans", "createdAt": "2020-09-03T21:22:03Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> removedEvents;\n+    addEvents();\n+    doReturn(false).when(spy).isRemoved(id1);\n+    doReturn(true).when(spy).isRemoved(id2);\n+    doReturn(true).when(spy).isRemoved(id3);\n+    doReturn(false).when(spy).isRemoved(id4);\n+\n+    removedEvents = spy.getDispatchedOrRemovedEvents(eventIDS);\n+\n+    assertThat(removedEvents.size()).isEqualTo(2);\n+    assertThat(removedEvents.contains(id2));\n+    assertThat(removedEvents.contains(id3));\n+  }\n+\n+  private void addEvents() {\n+    eventIDS.add(id1);\n+    eventIDS.add(id2);\n+    eventIDS.add(id3);\n+    eventIDS.add(id4);\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfDispatchedAndCurrentEventsAreRemoved() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    doReturn(null).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsFalseIfSequenceIdGreaterThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 99L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isFalse();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdEqualsLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdLessThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(90L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfHasDoneSynchronization() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.hasSynchronizedWithPrimary.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfSynchronizationIsInProgress() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.synchronizeWithPrimaryInProgress.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfGIINotFinished() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfPrimaryHasOlderThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() - 1));\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn(KnownVersion.GEODE_1_14_0.ordinal());\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsLaterThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() + 1));\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void getGIIEventsReturnsCorrectEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> giiEvents;\n+    spy.positionBeforeGII = 1;\n+    spy.positionAfterGII = 4;\n+    HAEventWrapper wrapper1 = mock(HAEventWrapper.class);\n+    HAEventWrapper wrapper2 = mock(HAEventWrapper.class);\n+    when(wrapper1.getEventId()).thenReturn(id1);\n+    when(wrapper2.getEventId()).thenReturn(id2);\n+    Region.Entry entry1 = mock(Region.Entry.class);\n+    Region.Entry entry2 = mock(Region.Entry.class);\n+    Region.Entry entry3 = mock(Region.Entry.class);", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MzQ3Ng==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483263476", "bodyText": "The numbering of things is a little confusing here. Is there a reason that entry3 returns wrapper2  and entry2 returns id3?", "author": "DonalEvans", "createdAt": "2020-09-03T21:27:27Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> removedEvents;\n+    addEvents();\n+    doReturn(false).when(spy).isRemoved(id1);\n+    doReturn(true).when(spy).isRemoved(id2);\n+    doReturn(true).when(spy).isRemoved(id3);\n+    doReturn(false).when(spy).isRemoved(id4);\n+\n+    removedEvents = spy.getDispatchedOrRemovedEvents(eventIDS);\n+\n+    assertThat(removedEvents.size()).isEqualTo(2);\n+    assertThat(removedEvents.contains(id2));\n+    assertThat(removedEvents.contains(id3));\n+  }\n+\n+  private void addEvents() {\n+    eventIDS.add(id1);\n+    eventIDS.add(id2);\n+    eventIDS.add(id3);\n+    eventIDS.add(id4);\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfDispatchedAndCurrentEventsAreRemoved() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    doReturn(null).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsFalseIfSequenceIdGreaterThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 99L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isFalse();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdEqualsLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdLessThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(90L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfHasDoneSynchronization() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.hasSynchronizedWithPrimary.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfSynchronizationIsInProgress() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.synchronizeWithPrimaryInProgress.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfGIINotFinished() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfPrimaryHasOlderThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() - 1));\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn(KnownVersion.GEODE_1_14_0.ordinal());\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsLaterThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() + 1));\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void getGIIEventsReturnsCorrectEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> giiEvents;\n+    spy.positionBeforeGII = 1;\n+    spy.positionAfterGII = 4;\n+    HAEventWrapper wrapper1 = mock(HAEventWrapper.class);\n+    HAEventWrapper wrapper2 = mock(HAEventWrapper.class);\n+    when(wrapper1.getEventId()).thenReturn(id1);\n+    when(wrapper2.getEventId()).thenReturn(id2);\n+    Region.Entry entry1 = mock(Region.Entry.class);\n+    Region.Entry entry2 = mock(Region.Entry.class);\n+    Region.Entry entry3 = mock(Region.Entry.class);\n+    when(entry1.getValue()).thenReturn(wrapper1);\n+    when(entry3.getValue()).thenReturn(wrapper2);\n+    when(entry2.getValue()).thenReturn(id3);", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NDQ3OQ==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483294479", "bodyText": "No particular reason, just want to test non HAEventWrapper in an entry case. To be clear, I change the id3 to an object.", "author": "pivotal-eshu", "createdAt": "2020-09-03T22:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MzQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NDk1Mw==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483294953", "bodyText": "Thanks for all the comments and change recommendations.", "author": "pivotal-eshu", "createdAt": "2020-09-03T22:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MzU1NQ==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483263555", "bodyText": "These three assertions can be simplified to assertThat(giiEvents).containsExactlyInAnyOrder(id1, id2);", "author": "DonalEvans", "createdAt": "2020-09-03T21:27:38Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> removedEvents;\n+    addEvents();\n+    doReturn(false).when(spy).isRemoved(id1);\n+    doReturn(true).when(spy).isRemoved(id2);\n+    doReturn(true).when(spy).isRemoved(id3);\n+    doReturn(false).when(spy).isRemoved(id4);\n+\n+    removedEvents = spy.getDispatchedOrRemovedEvents(eventIDS);\n+\n+    assertThat(removedEvents.size()).isEqualTo(2);\n+    assertThat(removedEvents.contains(id2));\n+    assertThat(removedEvents.contains(id3));\n+  }\n+\n+  private void addEvents() {\n+    eventIDS.add(id1);\n+    eventIDS.add(id2);\n+    eventIDS.add(id3);\n+    eventIDS.add(id4);\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfDispatchedAndCurrentEventsAreRemoved() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    doReturn(null).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsFalseIfSequenceIdGreaterThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 99L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isFalse();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdEqualsLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdLessThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(90L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfHasDoneSynchronization() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.hasSynchronizedWithPrimary.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfSynchronizationIsInProgress() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.synchronizeWithPrimaryInProgress.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfGIINotFinished() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfPrimaryHasOlderThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() - 1));\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn(KnownVersion.GEODE_1_14_0.ordinal());\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsLaterThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() + 1));\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void getGIIEventsReturnsCorrectEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> giiEvents;\n+    spy.positionBeforeGII = 1;\n+    spy.positionAfterGII = 4;\n+    HAEventWrapper wrapper1 = mock(HAEventWrapper.class);\n+    HAEventWrapper wrapper2 = mock(HAEventWrapper.class);\n+    when(wrapper1.getEventId()).thenReturn(id1);\n+    when(wrapper2.getEventId()).thenReturn(id2);\n+    Region.Entry entry1 = mock(Region.Entry.class);\n+    Region.Entry entry2 = mock(Region.Entry.class);\n+    Region.Entry entry3 = mock(Region.Entry.class);\n+    when(entry1.getValue()).thenReturn(wrapper1);\n+    when(entry3.getValue()).thenReturn(wrapper2);\n+    when(entry2.getValue()).thenReturn(id3);\n+\n+    when(haRegion.getEntry(1L)).thenReturn(entry1);\n+    when(haRegion.getEntry(2L)).thenReturn(entry2);\n+    when(haRegion.getEntry(3L)).thenReturn(null);\n+    when(haRegion.getEntry(4L)).thenReturn(entry3);\n+\n+    giiEvents = spy.getGIIEvents();\n+\n+    assertThat(giiEvents.size()).isEqualTo(2);\n+    assertThat(giiEvents.contains(id1));\n+    assertThat(giiEvents.contains(id2));", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2NzM5Nw==", "url": "https://github.com/apache/geode/pull/5496#discussion_r483267397", "bodyText": "Could this 3 be replaced with a calculated value, and the 2 for max chunk size extracted to a variable? I think that eventIDS.size()/maxChunkSize should be the correct value.", "author": "DonalEvans", "createdAt": "2020-09-03T21:36:46Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/HARegionQueueTest.java", "diffHunk": "@@ -183,4 +203,347 @@ public void isQueueInitializedWithWaitReturnsFalseIfNotInitializedAfterWait() th\n \n     verify(spy).waitForInitialized(time);\n   }\n+\n+  @Test\n+  public void getDispatchedOrRemovedEventsReturnsRemovedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> removedEvents;\n+    addEvents();\n+    doReturn(false).when(spy).isRemoved(id1);\n+    doReturn(true).when(spy).isRemoved(id2);\n+    doReturn(true).when(spy).isRemoved(id3);\n+    doReturn(false).when(spy).isRemoved(id4);\n+\n+    removedEvents = spy.getDispatchedOrRemovedEvents(eventIDS);\n+\n+    assertThat(removedEvents.size()).isEqualTo(2);\n+    assertThat(removedEvents.contains(id2));\n+    assertThat(removedEvents.contains(id3));\n+  }\n+\n+  private void addEvents() {\n+    eventIDS.add(id1);\n+    eventIDS.add(id2);\n+    eventIDS.add(id3);\n+    eventIDS.add(id4);\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfDispatchedAndCurrentEventsAreRemoved() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    doReturn(null).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsFalseIfSequenceIdGreaterThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 99L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isFalse();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdEqualsLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(100L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void isRemovedReturnsTrueIfSequenceIdLessThanLastDispatched() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    when(id1.getSequenceID()).thenReturn(90L);\n+    wrapper.lastDispatchedSequenceId = 100L;\n+    doReturn(wrapper).when(spy).getDispatchedAndCurrentEvents(id1);\n+\n+    assertThat(spy.isRemoved(id1)).isTrue();\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfHasDoneSynchronization() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.hasSynchronizedWithPrimary.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfSynchronizationIsInProgress() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.synchronizeWithPrimaryInProgress.set(true);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfGIINotFinished() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void doNotRunSynchronizationWithPrimaryIfPrimaryHasOlderThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() - 1));\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy, never()).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn(KnownVersion.GEODE_1_14_0.ordinal());\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void runSynchronizationWithPrimaryIfPrimaryIsLaterThanGEODE_1_14_0Version() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.doneGIIQueueing.set(true);\n+    when(primary.getVersionOrdinal()).thenReturn((short) (KnownVersion.GEODE_1_14_0.ordinal() + 1));\n+    doNothing().when(spy).runSynchronizationWithPrimary(primary, internalCache);\n+\n+    spy.synchronizeQueueWithPrimary(primary, internalCache);\n+    verify(spy).runSynchronizationWithPrimary(primary, internalCache);\n+  }\n+\n+  @Test\n+  public void getGIIEventsReturnsCorrectEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    List<EventID> giiEvents;\n+    spy.positionBeforeGII = 1;\n+    spy.positionAfterGII = 4;\n+    HAEventWrapper wrapper1 = mock(HAEventWrapper.class);\n+    HAEventWrapper wrapper2 = mock(HAEventWrapper.class);\n+    when(wrapper1.getEventId()).thenReturn(id1);\n+    when(wrapper2.getEventId()).thenReturn(id2);\n+    Region.Entry entry1 = mock(Region.Entry.class);\n+    Region.Entry entry2 = mock(Region.Entry.class);\n+    Region.Entry entry3 = mock(Region.Entry.class);\n+    when(entry1.getValue()).thenReturn(wrapper1);\n+    when(entry3.getValue()).thenReturn(wrapper2);\n+    when(entry2.getValue()).thenReturn(id3);\n+\n+    when(haRegion.getEntry(1L)).thenReturn(entry1);\n+    when(haRegion.getEntry(2L)).thenReturn(entry2);\n+    when(haRegion.getEntry(3L)).thenReturn(null);\n+    when(haRegion.getEntry(4L)).thenReturn(entry3);\n+\n+    giiEvents = spy.getGIIEvents();\n+\n+    assertThat(giiEvents.size()).isEqualTo(2);\n+    assertThat(giiEvents.contains(id1));\n+    assertThat(giiEvents.contains(id2));\n+  }\n+\n+  @Test\n+  public void doSynchronizationWithPrimaryReturnsIfHasDoneSynchronization() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    spy.hasSynchronizedWithPrimary.set(true);\n+\n+    spy.doSynchronizationWithPrimary(primary, internalCache);\n+    verify(spy, never()).getGIIEvents();\n+  }\n+\n+  @Test\n+  public void doSynchronizationWithPrimaryReturnsIfNoGIIEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    int maxChunkSize = 1000;\n+    spy.hasSynchronizedWithPrimary.set(true);\n+    doReturn(new LinkedList<EventID>()).when(spy).getGIIEvents();\n+\n+    spy.doSynchronizationWithPrimary(primary, internalCache);\n+\n+    verify(spy, never()).getChunks(eventIDS, maxChunkSize);\n+    verify(spy, never()).removeDispatchedEvents(primary, internalCache, eventIDS);\n+    assertThat(spy.hasSynchronizedWithPrimary).isTrue();\n+    assertThat(spy.synchronizeWithPrimaryInProgress).isFalse();\n+  }\n+\n+  @Test\n+  public void doSynchronizationWithPrimaryRemoveDispatchedEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    int maxChunkSize = 1000;\n+    addEvents();\n+    doReturn(eventIDS).when(spy).getGIIEvents();\n+    doReturn(true).when(spy).removeDispatchedEvents(primary, internalCache, eventIDS);\n+\n+    spy.doSynchronizationWithPrimary(primary, internalCache);\n+\n+    verify(spy, never()).getChunks(eventIDS, maxChunkSize);\n+    verify(spy).removeDispatchedEvents(primary, internalCache, eventIDS);\n+    assertThat(spy.hasSynchronizedWithPrimary).isTrue();\n+    assertThat(spy.synchronizeWithPrimaryInProgress).isFalse();\n+  }\n+\n+  @Test\n+  public void hasSynchronizedWithPrimaryNotSetIfRemoveDispatchedEventsFails() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    int maxChunkSize = 1000;\n+    addEvents();\n+    doReturn(eventIDS).when(spy).getGIIEvents();\n+    doReturn(false).when(spy).removeDispatchedEvents(primary, internalCache, eventIDS);\n+\n+    spy.doSynchronizationWithPrimary(primary, internalCache);\n+\n+    verify(spy, never()).getChunks(eventIDS, maxChunkSize);\n+    verify(spy).removeDispatchedEvents(primary, internalCache, eventIDS);\n+    assertThat(spy.hasSynchronizedWithPrimary).isFalse();\n+    assertThat(spy.synchronizeWithPrimaryInProgress).isFalse();\n+  }\n+\n+  @Test\n+  public void hasSynchronizedWithPrimaryRemoveChunksIfManyGIIEvents() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    int maxChunkSize = 1000;\n+    for (int i = 0; i < 1100; i++) {\n+      eventIDS.add(mock(EventID.class));\n+    }\n+    createChunks();\n+    doReturn(eventIDS).when(spy).getGIIEvents();\n+    doReturn(chunks).when(spy).getChunks(eventIDS, maxChunkSize);\n+    doReturn(true).when(spy).removeDispatchedEvents(primary, internalCache, chunk1);\n+    doReturn(true).when(spy).removeDispatchedEvents(primary, internalCache, chunk2);\n+\n+    spy.doSynchronizationWithPrimary(primary, internalCache);\n+\n+    verify(spy).getChunks(eventIDS, maxChunkSize);\n+    verify(spy).removeDispatchedEvents(primary, internalCache, chunk1);\n+    verify(spy).removeDispatchedEvents(primary, internalCache, chunk2);\n+    assertThat(spy.hasSynchronizedWithPrimary).isTrue();\n+    assertThat(spy.synchronizeWithPrimaryInProgress).isFalse();\n+  }\n+\n+  private void createChunks() {\n+    chunk1.add(id1);\n+    chunk2.add(id2);\n+    chunks.add(chunk1);\n+    chunks.add(chunk2);\n+  }\n+\n+  @Test\n+  public void hasSynchronizedWithPrimaryNotSetIfRemoveChunksFails() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    int maxChunkSize = 1000;\n+    for (int i = 0; i < 1100; i++) {\n+      eventIDS.add(mock(EventID.class));\n+    }\n+    createChunks();\n+    doReturn(eventIDS).when(spy).getGIIEvents();\n+    doReturn(chunks).when(spy).getChunks(eventIDS, maxChunkSize);\n+    doReturn(true).when(spy).removeDispatchedEvents(primary, internalCache, chunk1);\n+    doReturn(false).when(spy).removeDispatchedEvents(primary, internalCache, chunk2);\n+\n+    spy.doSynchronizationWithPrimary(primary, internalCache);\n+\n+    verify(spy).getChunks(eventIDS, maxChunkSize);\n+    verify(spy).removeDispatchedEvents(primary, internalCache, chunk1);\n+    verify(spy).removeDispatchedEvents(primary, internalCache, chunk2);\n+    assertThat(spy.hasSynchronizedWithPrimary).isFalse();\n+    assertThat(spy.synchronizeWithPrimaryInProgress).isFalse();\n+  }\n+\n+  @Test\n+  public void getChunksReturnsEqualSizedChunks() {\n+    HARegionQueue spy = spy(haRegionQueue);\n+    addEvents();\n+    // add more events\n+    eventIDS.add(mock(EventID.class));\n+    eventIDS.add(mock(EventID.class));\n+\n+    Collection<List<EventID>> myChunks = spy.getChunks(eventIDS, 2);\n+\n+    assertThat(myChunks.size()).isEqualTo(3);", "originalCommit": "dea65c9264ab6ed96e6816d4a94f628cca8d3eef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f41e4292793bfaddc10674bdcce99794200f07ee", "url": "https://github.com/apache/geode/commit/f41e4292793bfaddc10674bdcce99794200f07ee", "message": "fix review comments.", "committedDate": "2020-09-03T22:49:46Z", "type": "commit"}, {"oid": "2ad61ac46b31ec33b1e8ad91d44a6a2b4f07f28d", "url": "https://github.com/apache/geode/commit/2ad61ac46b31ec33b1e8ad91d44a6a2b4f07f28d", "message": "fix review comments", "committedDate": "2020-09-04T00:04:52Z", "type": "commit"}, {"oid": "00185a964b7ee777e6c57f4951520413c3a854a8", "url": "https://github.com/apache/geode/commit/00185a964b7ee777e6c57f4951520413c3a854a8", "message": "Add a delay before performing sync operation to make sure\nthe member has primary queue gets the in-flight operations.", "committedDate": "2020-09-09T00:53:52Z", "type": "commit"}]}