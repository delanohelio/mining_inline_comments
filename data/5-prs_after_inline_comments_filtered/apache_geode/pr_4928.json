{"pr_number": 4928, "pr_title": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers", "pr_createdAt": "2020-04-08T16:26:47Z", "pr_url": "https://github.com/apache/geode/pull/4928", "timeline": [{"oid": "0da146928a640788f5bffefac118a71533305799", "url": "https://github.com/apache/geode/commit/0da146928a640788f5bffefac118a71533305799", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-08T17:53:14Z", "type": "forcePushed"}, {"oid": "83ff91505fa977b46506e7400a6fbaed15ef6a35", "url": "https://github.com/apache/geode/commit/83ff91505fa977b46506e7400a6fbaed15ef6a35", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-09T07:31:55Z", "type": "forcePushed"}, {"oid": "488cf2ec4b1a8320a55ad2018d9afa0dc09fe873", "url": "https://github.com/apache/geode/commit/488cf2ec4b1a8320a55ad2018d9afa0dc09fe873", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-09T09:36:42Z", "type": "forcePushed"}, {"oid": "a8c4c01f982760c62d08c6cb1fb38f751a524e06", "url": "https://github.com/apache/geode/commit/a8c4c01f982760c62d08c6cb1fb38f751a524e06", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-09T09:53:54Z", "type": "forcePushed"}, {"oid": "c2bc5942c90049e6178e5dab502e8ba0a7784dd3", "url": "https://github.com/apache/geode/commit/c2bc5942c90049e6178e5dab502e8ba0a7784dd3", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-10T18:57:32Z", "type": "forcePushed"}, {"oid": "8d149669673a9e6aa9810620efd9bdcfa07f4154", "url": "https://github.com/apache/geode/commit/8d149669673a9e6aa9810620efd9bdcfa07f4154", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-11T07:53:42Z", "type": "forcePushed"}, {"oid": "2a6eac6877fb58a1630ad9bceea6e8f97e3854f5", "url": "https://github.com/apache/geode/commit/2a6eac6877fb58a1630ad9bceea6e8f97e3854f5", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-11T10:59:52Z", "type": "forcePushed"}, {"oid": "dc11a43af87cd9ec917aceb02828f550594bff8e", "url": "https://github.com/apache/geode/commit/dc11a43af87cd9ec917aceb02828f550594bff8e", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-11T14:21:22Z", "type": "forcePushed"}, {"oid": "e8e5ff0c9c52ca186289fadef1b6170284a82f6f", "url": "https://github.com/apache/geode/commit/e8e5ff0c9c52ca186289fadef1b6170284a82f6f", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-04-11T19:14:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NzA3NA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r411587074", "bodyText": "This looks similar to the other peekEventsFromIncompleteTransactions, is there a way to reuse the code?  Although the classes probably already do a lot of duplication ...", "author": "jhuynh1", "createdAt": "2020-04-20T18:11:16Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +441,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,", "originalCommit": "e8e5ff0c9c52ca186289fadef1b6170284a82f6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3OTU5Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r411879596", "bodyText": "You are right, the code is very similar (just as it happens with the peek method) but the structures on which they operate are different:\nOn the SerialGatewaySenderQueue it operates on a set of transactionIds while on the ParallelGatewaySenderQueue it operates on a map of <TransactionId, bucketId>.\nBesides, the difference between the Serial queue and the parallel queue makes it different the access to them. On the parallel you need to pass the bucketId and the partition region. On the serial one, you need to pass the last accessed key so that you do not go through the same elements over and over because those are not removed immediately when peeked from the queue as it happens with the parallel queue.\nAs a consequence I did not find an easy way to reuse code that did not end up making things more complex.", "author": "albertogpz", "createdAt": "2020-04-21T05:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NzA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwMTI0Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r416901247", "bodyText": "Maybe maxRetries should be parameterized.", "author": "boglesby", "createdAt": "2020-04-28T20:28:29Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1277,90 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    int maxRetries = 2;", "originalCommit": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM2OTUyOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r417369529", "bodyText": "I agree. The new commit contains a parameter for this.", "author": "albertogpz", "createdAt": "2020-04-29T14:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwMTI0Nw=="}], "type": "inlineReview"}, {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d", "url": "https://github.com/apache/geode/commit/5556d772491d3167e326343bc73e2d5aaa30a31d", "message": "GEODE-7971: Undo changes on cache*.dtd files unneeded\n\nAlso changed a couple of timeouts in test cases.", "committedDate": "2020-05-04T00:12:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NTc4MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r421245781", "bodyText": "Since creation of 1.13 release is ongoing, I assume that this will go in 1.14 release. Do we need to update this method to toDataPre_GEODE_1_14_0_0", "author": "mivanac", "createdAt": "2020-05-07T05:21:29Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -692,6 +704,17 @@ public int getDSFID() {\n   @Override\n   public void toData(DataOutput out,\n       SerializationContext context) throws IOException {\n+    toDataPre_GEODE_1_13_0_0(out, context);\n+    boolean hasTransaction = this.transactionId != null;\n+    DataSerializer.writeBoolean(hasTransaction, out);\n+    if (hasTransaction) {\n+      DataSerializer.writeBoolean(this.isLastEventInTransaction, out);\n+      context.getSerializer().writeObject(this.transactionId, out);\n+    }\n+  }\n+\n+  public void toDataPre_GEODE_1_13_0_0(DataOutput out,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzYxMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r421353611", "bodyText": "You are right, Mario. I guess I can't do that until version 1.13 is available as I would need the constant for 1.14.", "author": "albertogpz", "createdAt": "2020-05-07T09:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NTc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjEyMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r421246121", "bodyText": "Same comment as above. Do we need to update this method to fromDataPre_GEODE_1_14_0_0?", "author": "mivanac", "createdAt": "2020-05-07T05:22:46Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -725,6 +748,18 @@ protected void serializeKey(DataOutput out,\n   @Override\n   public void fromData(DataInput in,\n       DeserializationContext context) throws IOException, ClassNotFoundException {\n+    fromDataPre_GEODE_1_13_0_0(in, context);\n+    if (version >= Version.GEODE_1_13_0.ordinal()) {\n+      boolean hasTransaction = DataSerializer.readBoolean(in);\n+      if (hasTransaction) {\n+        this.isLastEventInTransaction = DataSerializer.readBoolean(in);\n+        this.transactionId = context.getDeserializer().readObject(in);\n+      }\n+    }\n+  }\n+\n+  public void fromDataPre_GEODE_1_13_0_0(DataInput in, DeserializationContext context)", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzcyMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r421353723", "bodyText": "I agree as above.", "author": "albertogpz", "createdAt": "2020-05-07T09:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422300082", "bodyText": "gemfire_properties.html.md.erb should be updated to include this new property, as well as any other relevant documentation pages.", "author": "DonalEvans", "createdAt": "2020-05-08T18:27:32Z", "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "diffHunk": "@@ -153,6 +155,13 @@\n       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"gateway-connection-retry-interval\", 1000)\n       .intValue();\n \n+  /**\n+   * Number of times to retry to get events for a transaction from the gateway sender queue\n+   */\n+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =\n+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"get-transaction-events-from-queue-retries\",", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1MTY0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422851648", "bodyText": "I did not document this property as I thought it was too internal to be used by clients just as other properties that are not documented. For example: gateway-connection-retry-interval", "author": "albertogpz", "createdAt": "2020-05-11T07:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NzcwOA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423147708", "bodyText": "Perhaps @davebarnes97 can shed some light here, as he knows docs stuff better than me. Do we want to document any properties added, or are some okay to leave hidden from users?", "author": "DonalEvans", "createdAt": "2020-05-11T16:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0OTE1MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r425949151", "bodyText": "Apache Geode is an open-source repo, so nothing is truly hidden from users. However, there are many examples of properties that intentionally go un-mentioned in the User Guide. Such a property should be briefly commented in code, indicating the use for which it is intended and what its limitations are, so curious browsing developers won't get themselves into trouble.", "author": "davebarnes97", "createdAt": "2020-05-15T17:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3Nzk1Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r426877956", "bodyText": "I\n\nApache Geode is an open-source repo, so nothing is truly hidden from users. However, there are many examples of properties that intentionally go un-mentioned in the User Guide. Such a property should be briefly commented in code, indicating the use for which it is intended and what its limitations are, so curious browsing developers won't get themselves into trouble.\n\nI have added a longer description in the comments for the property in my last commit.", "author": "albertogpz", "createdAt": "2020-05-18T20:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjg5MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422306891", "bodyText": "Per the recent discussion on the dev list regarding the use of default methods in interfaces, does this absolutely need to be default?", "author": "DonalEvans", "createdAt": "2020-05-08T18:41:04Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java", "diffHunk": "@@ -307,6 +307,11 @@ void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients, CacheWrit\n \n   void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b);\n \n+  default void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NjY3Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422866672", "bodyText": "It is not. I will remove the default implementation.", "author": "albertogpz", "createdAt": "2020-05-11T08:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0OTk3Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422349973", "bodyText": "Unnecessary semicolon here.", "author": "DonalEvans", "createdAt": "2020-05-08T20:11:46Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtils.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class TXLastEventInTransactionUtils {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  /**\n+   * @param callbacks list of events belonging to a transaction\n+   *\n+   * @return the last event of the transaction.\n+   *         If the regions to which the events belong do not have senders\n+   *         that group transactions it returns null.\n+   *         If the regions to which the\n+   *         events belong have different sets of senders that group transactions\n+   *         then it throws a ServiceConfigurationError exception.\n+   */\n+  public static EntryEventImpl getLastTransactionEvent(List<EntryEventImpl> callbacks,\n+      Cache cache)\n+      throws ServiceConfigurationError {\n+    if (checkNoSendersGroupTransactionEvents(callbacks, cache)) {\n+      return null;\n+    }\n+\n+    List<Set> senderIdsPerEvent = getGroupingSendersPerEvent(callbacks, cache);\n+    if (senderIdsPerEvent.stream().distinct().count() > 1) {\n+      String info = eventsAndSendersPerEventToString(callbacks, senderIdsPerEvent);\n+      throw new ServiceConfigurationError(\n+          \"Not all events go to the same senders that group transactions. \" + info);\n+    } ;", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NzY4Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422867687", "bodyText": "Good eye!", "author": "albertogpz", "createdAt": "2020-05-11T08:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0OTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NzQwNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422357407", "bodyText": "Could this comment be cleaned up?", "author": "DonalEvans", "createdAt": "2020-05-08T20:28:24Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java", "diffHunk": "@@ -862,14 +868,14 @@ private void logEvents(String message, List<GatewaySenderEventImpl> events) {\n               event.getRawCallbackArgument(), this.sender.getMyDSId(), allRemoteDSIds);\n           event.setCallbackArgument(geCallbackArg);\n           GatewaySenderEventImpl pdxSenderEvent =\n-              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP:\n-                                                                                       // event for\n-                                                                                       // pdx type\n-                                                                                       // meta data\n-                                                                                       // so it\n-                                                                                       // should\n-                                                                                       // never be\n-                                                                                       // off-heap\n+              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null, false); // OFFHEAP:\n+          // event for\n+          // pdx type\n+          // meta data\n+          // so it\n+          // should\n+          // never be\n+          // off-heap", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4MjY1MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422882651", "bodyText": "I have put it in a single line above the instance creation sentence. I cannot tell if the comment is significant so I do not know if it can be removed.", "author": "albertogpz", "createdAt": "2020-05-11T08:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NzQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTU4Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361582", "bodyText": "Is there a reason for the formatting changes to the method signatures in this class? If not, they should be returned to how they were.", "author": "DonalEvans", "createdAt": "2020-05-08T20:37:48Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -373,7 +373,8 @@ public static Integer createSecondRemoteLocator(int dsId, int localPort, int rem\n   }\n \n   public static Integer createSecondRemoteLocatorWithAPI(int dsId, int localPort, int remoteLocPort,\n-      String hostnameForClients) throws IOException {\n+      String hostnameForClients)", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4NjQ3Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422886472", "bodyText": "No reason. I did it by mistake. I have reverted the changes.", "author": "albertogpz", "createdAt": "2020-05-11T08:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361948", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:38:32Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -497,7 +498,8 @@ public static void createPersistentReplicatedRegion(String regionName, String se\n   }\n \n   public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n-      String asyncQueueIds, Boolean offHeap) {\n+      String asyncQueueIds,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTQ1MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011450", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk3OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361978", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:38:37Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -519,7 +521,9 @@ public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n   }\n \n   public static void createReplicatedRegionWithSenderAndAsyncEventQueue(String regionName,\n-      String senderIds, String asyncChannelId, Boolean offHeap) {\n+      String senderIds,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTUzNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011534", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjAxMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362012", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:38:41Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -560,7 +564,8 @@ public static void createReplicatedRegion(String regionName, String senderIds, S\n   }\n \n   public static void createAsyncEventQueue(String asyncChannelId, boolean isParallel,\n-      Integer maxMemory, Integer batchSize, boolean isConflation, boolean isPersistent,\n+      Integer maxMemory, Integer batchSize,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTYxNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011614", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA1OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362058", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:38:46Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -589,7 +594,8 @@ public static void createAsyncEventQueue(String asyncChannelId, boolean isParall\n   }\n \n   public static void createPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies, Integer totalNumBuckets,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTY4Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011682", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA5Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362096", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:38:51Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -619,7 +625,8 @@ public static void createPartitionedRegion(String regionName, String senderIds,\n \n   // TODO:OFFHEAP: add offheap flavor\n   public static void createPartitionedRegionWithPersistence(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTc0NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011745", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjEzMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362131", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:38:55Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -647,7 +654,9 @@ public static void createPartitionedRegionWithPersistence(String regionName, Str\n   }\n \n   public static void createColocatedPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, String colocatedWith) {\n+      Integer redundantCopies,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTg0Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011846", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjE5MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362190", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:39:01Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -691,7 +700,8 @@ public static void addAsyncEventQueueThroughAttributesMutator(String regionName,\n   }\n \n   public static void createPartitionedRegionAsAccessor(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTg5NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011895", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjIyOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362229", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:39:06Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -709,7 +719,10 @@ public static void createPartitionedRegionAsAccessor(String regionName, String s\n   }\n \n   public static void createPartitionedRegionWithSerialParallelSenderIds(String regionName,\n-      String serialSenderIds, String parallelSenderIds, String colocatedWith, Boolean offHeap) {\n+      String serialSenderIds,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTk1NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011955", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI1Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362253", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:39:11Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -734,7 +747,8 @@ public static void createPartitionedRegionWithSerialParallelSenderIds(String reg\n   }\n \n   public static void createPersistentPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjAyNg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012026", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI4Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362286", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:39:17Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -764,7 +778,9 @@ public static void createPersistentPartitionedRegion(String regionName, String s\n   }\n \n   public static void createCustomerOrderShipmentPartitionedRegion(String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjA3OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012079", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362376", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:39:29Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -830,7 +846,8 @@ public static void createCustomerOrderShipmentPartitionedRegion(String senderIds\n   }\n \n   public static void createColocatedPartitionedRegions(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjEzMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012132", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362379", "bodyText": "Another possibly unnecessary formatting change.", "author": "DonalEvans", "createdAt": "2020-05-08T20:39:30Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -858,7 +875,8 @@ public static void createColocatedPartitionedRegions(String regionName, String s\n   }\n \n   public static void createColocatedPartitionedRegions2(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjE3Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012172", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5NjM0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422396348", "bodyText": "The currentTime argument can be removed and replaced with a call to System.currentTimeMillis() inside the method.", "author": "DonalEvans", "createdAt": "2020-05-08T22:02:27Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNDY3MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423014670", "bodyText": "Good point", "author": "albertogpz", "createdAt": "2020-05-11T12:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5NjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTE5MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422399190", "bodyText": "A more descriptive name for this variable might be lastEventIsPresentInTransaction.", "author": "DonalEvans", "createdAt": "2020-05-08T22:12:02Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (Map.Entry<TransactionId, Integer> pendingTransaction : incompleteTransactionIdsInBatch\n+        .entrySet()) {\n+      TransactionId transactionId = pendingTransaction.getKey();\n+      int bucketId = pendingTransaction.getValue();\n+      boolean presentLastEventInTransaction = false;", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyMjIwNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423022207", "bodyText": "How about areAllEventsForTransactionInBatch?", "author": "albertogpz", "createdAt": "2020-05-11T13:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2Mjk3Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423162972", "bodyText": "That sounds good, yeah.", "author": "DonalEvans", "createdAt": "2020-05-11T16:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNDA4MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422404081", "bodyText": "A more descriptive name for this variable might be lastEventIsPresentInTransaction.", "author": "DonalEvans", "createdAt": "2020-05-08T22:28:26Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +442,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,\n+      Set<TransactionId> incompleteTransactionIdsInBatch, long lastKey) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (TransactionId transactionId : incompleteTransactionIdsInBatch) {\n+      boolean presentLastEventInTransaction = false;", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyMzQ5NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423023495", "bodyText": "How about areAllEventsForTransactionInBatch?", "author": "albertogpz", "createdAt": "2020-05-11T13:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MzExNQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423163115", "bodyText": "Sounds good.", "author": "DonalEvans", "createdAt": "2020-05-11T16:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNDA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTgyNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422405824", "bodyText": "This try/catch shouldn't be necessary, I think. The test will automatically fail if an exception is thrown. The exception should instead be added to the test method signature.", "author": "DonalEvans", "createdAt": "2020-05-08T22:34:18Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {\n+    ParallelGatewaySenderEventProcessor processor =\n+        ParallelGatewaySenderHelper.createParallelGatewaySenderEventProcessor(this.sender);\n+\n+    TransactionId tx1 = new TXId(null, 1);\n+    TransactionId tx2 = new TXId(null, 2);\n+    TransactionId tx3 = new TXId(null, 3);\n+\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEvent(1, tx1, false);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEvent(2, tx2, false);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEvent(3, tx1, true);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEvent(4, tx2, true);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEvent(5, tx3, false);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEvent(6, tx3, false);\n+    GatewaySenderEventImpl event7 = createMockGatewaySenderEvent(7, tx1, true);\n+\n+    this.bucketRegionQueue\n+        .cleanUpDestroyedTokensAndMarkGIIComplete(InitialImageOperation.GIIStatus.NO_GII);\n+\n+    try {\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(1), event1);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(2), event2);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(3), event3);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(4), event4);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(5), event5);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(6), event6);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(7), event7);\n+\n+    } catch (ForceReattemptException e) {\n+      fail(\"Exception thrown: \" + e);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyNTI5MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423025291", "bodyText": "I agree", "author": "albertogpz", "createdAt": "2020-05-11T13:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzU3MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422407570", "bodyText": "Can this test have a more descriptive name? Test names should ideally describe what is being tested, what the conditions are, and what the expected result is.", "author": "DonalEvans", "createdAt": "2020-05-08T22:40:49Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzODMyMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423038322", "bodyText": "How about testGetElementsMatchingWithHasTransactionIdPredicateAndIsLastEventInTransactionPredicate?\nThe test is testing a generic method getElementsMatching using two predicates.", "author": "albertogpz", "createdAt": "2020-05-11T13:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MzQyOA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423163428", "bodyText": "That works for me", "author": "DonalEvans", "createdAt": "2020-05-11T16:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422407811", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T22:41:49Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2NDg2Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423064866", "bodyText": "How about getLastTransactionEventThrowsExceptionWhenSenderNotFound?", "author": "albertogpz", "createdAt": "2020-05-11T14:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2OTMxMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423169313", "bodyText": "This test doesn't seem to be asserting that an exception is thrown anywhere, so that name would be confusing. Perhaps getLastTransactionEventReturnsNullWhenGroupTransactionEventsIsFalseForAllSenders?", "author": "DonalEvans", "createdAt": "2020-05-11T16:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3ODgzNQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423178835", "bodyText": "I might have added the wrong reply here.\nThe intended proposal was: lastTransactionEventNotFoundWhenNoSenderGroupsTransactions.\nAnyway, I like your proposal so I will stick with it :-)", "author": "albertogpz", "createdAt": "2020-05-11T16:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTA2Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409066", "bodyText": "Can these arrays be declared java-style rather than C-style: String[] listSenderIdsForRegion1_2", "author": "DonalEvans", "createdAt": "2020-05-08T22:46:57Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA3ODIzOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423078239", "bodyText": "The idea was to initialize the data statically which is something you would not be able to do with java-style containers.\nAnyway, I have removed the lists and put the elements in the sets directly.", "author": "albertogpz", "createdAt": "2020-05-11T14:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTI2Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409262", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T22:47:49Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDExNg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423084116", "bodyText": "How about lastTransactionEventFoundWhenAllSendersGroupTransactionEvents?", "author": "albertogpz", "createdAt": "2020-05-11T14:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2OTk2MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423169960", "bodyText": "Sounds good to me", "author": "DonalEvans", "createdAt": "2020-05-11T16:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTU0MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409541", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T22:48:58Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NzcxNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423087714", "bodyText": "How about lastTransactionEventFoundWhenNotAllSendersGroupTransactionEvents?", "author": "albertogpz", "createdAt": "2020-05-11T14:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MDUwMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423170501", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422410048", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T22:51:08Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4ODM4Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423088386", "bodyText": "How about getLastTransactionEventThrowsExceptionWhenNotAllEventsToSameGroupingSenders?", "author": "albertogpz", "createdAt": "2020-05-11T14:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MDk4Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423170982", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA3NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422410075", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T22:51:14Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region7);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    assertThatThrownBy(() -> TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache))\n+        .isInstanceOf(ServiceConfigurationError.class)\n+        .hasMessageContaining(\"Not all events go to the same senders that group transactions\");\n+  }\n+\n+  @Test\n+  public void senderNotFound() throws Exception {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4ODc3Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423088772", "bodyText": "How about getLastTransactionEventThrowsExceptionWhenSenderNotFound?", "author": "albertogpz", "createdAt": "2020-05-11T14:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MTE2OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423171168", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzY2Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413663", "bodyText": "This test name could be more descriptive.", "author": "DonalEvans", "createdAt": "2020-05-08T23:06:47Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEwNTg2MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423105860", "bodyText": "How about this pretty long name peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInMaxSizeBatch?", "author": "albertogpz", "createdAt": "2020-05-11T15:02:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3Mjc2Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423172767", "bodyText": "Sounds good. I will take a long, descriptive test name over a short, vague one any day :)", "author": "DonalEvans", "createdAt": "2020-05-11T16:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzgxNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413814", "bodyText": "This test name could be more descriptive.", "author": "DonalEvans", "createdAt": "2020-05-08T23:07:25Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEwNjEwOA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423106108", "bodyText": "How about peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchByTime?", "author": "albertogpz", "createdAt": "2020-05-11T15:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MzA2NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423173065", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzg0NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413845", "bodyText": "This test name could be more descriptive.", "author": "DonalEvans", "createdAt": "2020-05-08T23:07:36Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEwNjUyNQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423106525", "bodyText": "How about peekDoesNotGetsExtraEventsWhenNotMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchMaxSize?", "author": "albertogpz", "createdAt": "2020-05-11T15:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzg0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MzIzMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423173232", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNjYyNg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422416626", "bodyText": "This method does not need to be static.", "author": "DonalEvans", "createdAt": "2020-05-08T23:20:15Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createGatewaySenderEventImpl(int transactionId,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzExOTg3Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423119876", "bodyText": "That's true. Anyway, do you see any drawback in it being static?", "author": "albertogpz", "createdAt": "2020-05-11T15:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNjYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3NjAxNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423176014", "bodyText": "No drawback, it just keeps things more consistent within the test if all the helper methods follow the same pattern, and none of the other ones are static.", "author": "DonalEvans", "createdAt": "2020-05-11T16:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNjYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzEwOA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417108", "bodyText": "Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.", "author": "DonalEvans", "createdAt": "2020-05-08T23:22:39Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDUxMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144512", "bodyText": "Not really. The value is not relevant in this case where a value for max batch size has been set.\nI have changed it to 100ms.", "author": "albertogpz", "createdAt": "2020-05-11T15:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzE0Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417146", "bodyText": "Another large, apparently arbitrary timeToWait value.", "author": "DonalEvans", "createdAt": "2020-05-08T23:22:56Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDY4OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144689", "bodyText": "Same as above.", "author": "albertogpz", "createdAt": "2020-05-11T15:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzI3Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417273", "bodyText": "Another large, apparently arbitrary timeToWait value.", "author": "DonalEvans", "createdAt": "2020-05-08T23:23:29Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDc2Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144763", "bodyText": "Same as above.", "author": "albertogpz", "createdAt": "2020-05-11T15:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM4MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417380", "bodyText": "Another large, apparently arbitrary timeToWait value.", "author": "DonalEvans", "createdAt": "2020-05-08T23:23:58Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDg2Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144867", "bodyText": "Same as above.", "author": "albertogpz", "createdAt": "2020-05-11T15:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM5Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417393", "bodyText": "Another large, apparently arbitrary timeToWait value.", "author": "DonalEvans", "createdAt": "2020-05-08T23:24:04Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDk2OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144969", "bodyText": "Same as above.", "author": "albertogpz", "createdAt": "2020-05-11T15:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzQ5Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417496", "bodyText": "What is the purpose of waiting here? Thread.sleep() should be avoided in tests as it leads to flakiness, so is there something that can be used with GeodeAwaitility.await() instead?", "author": "DonalEvans", "createdAt": "2020-05-08T23:24:32Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -201,18 +306,40 @@ private BucketRegionQueue mockBucketRegionQueue(final Queue backingList) {\n     // mocked pr region\n     when(mockBucketRegion.getLocalMaxMemory()).thenReturn(100);\n     when(mockBucketRegion.size()).thenReturn(backingList.size());\n-\n     BucketRegionQueue bucketRegionQueue = mock(BucketRegionQueue.class);\n     when(bucketRegionQueue.getPartitionedRegion()).thenReturn(mockBucketRegion);\n-    when(bucketRegionQueue.peek()).thenAnswer((Answer) invocation -> backingList.poll());\n+    when(bucketRegionQueue.peek())\n+        .thenAnswer((Answer) invocation -> pollAndWaitIfNull(backingList));\n+    when(bucketRegionQueue.getElementsMatching(any(), any()))\n+        .thenAnswer((Answer) invocation -> Arrays\n+            .asList(new Object[] {getFirstNotNull(backingList)}));\n     return bucketRegionQueue;\n   }\n \n+  private Object pollAndWaitIfNull(Queue queue) {\n+    Object object = queue.poll();\n+    if (object == null) {\n+      try {\n+        Thread.sleep(10);\n+      } catch (InterruptedException e) {\n+        e.printStackTrace();\n+      }\n+    }", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0OTYyMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423149621", "bodyText": "It is a way to simulate some delay in the arrival of events to the queue. If a null element is found in the queue, some delay is added to the polling execution in order to be used in cases where the batch must be finished, not because the max size was reached but because the peeking took longer than the timeToWait passed.", "author": "albertogpz", "createdAt": "2020-05-11T16:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODMzMA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418330", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T23:28:37Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MDUyOA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423150528", "bodyText": "How about peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInMaxSizeBatch?", "author": "albertogpz", "createdAt": "2020-05-11T16:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjM2NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423182365", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418348", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T23:28:42Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MDkwMA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423150900", "bodyText": "How about peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchByTime?", "author": "albertogpz", "createdAt": "2020-05-11T16:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjUzMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423182532", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM5MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418390", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T23:28:50Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MjA1OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423152059", "bodyText": "How about peekDoesNotGetExtraEventsWhenNotMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchMaxSize?", "author": "albertogpz", "createdAt": "2020-05-11T16:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjgxNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423182817", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T16:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODYyMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418621", "bodyText": "This method doesn't need to be static.", "author": "DonalEvans", "createdAt": "2020-05-08T23:29:53Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MjI4Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423152287", "bodyText": "True. Any drawback?", "author": "albertogpz", "createdAt": "2020-05-11T16:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MzIzMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423183232", "bodyText": "Just for consistency with other helper methods in the class.", "author": "DonalEvans", "createdAt": "2020-05-11T16:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODc4Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418786", "bodyText": "Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.", "author": "DonalEvans", "createdAt": "2020-05-08T23:30:42Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTIwNg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155206", "bodyText": "Not really. The same comment applies here to what was explained for ParallelGatewaySenderQueueJunitTest", "author": "albertogpz", "createdAt": "2020-05-11T16:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODg1OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418858", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "author": "DonalEvans", "createdAt": "2020-05-08T23:31:03Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTM0Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155347", "bodyText": "Same as above.", "author": "albertogpz", "createdAt": "2020-05-11T16:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418911", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "author": "DonalEvans", "createdAt": "2020-05-08T23:31:18Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTQ1Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155452", "bodyText": "Same as above.", "author": "albertogpz", "createdAt": "2020-05-11T16:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418919", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "author": "DonalEvans", "createdAt": "2020-05-08T23:31:22Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTYyOA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155628", "bodyText": "Same as above.", "author": "albertogpz", "createdAt": "2020-05-11T16:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422420152", "bodyText": "Is there a way to test the new behaviour in SerialGatewaySenderQueue without creating an entire LocalRegion object here? Huge amounts of code that doesn't belong to SerialGatewaySenderQueue are being included in this test due to creating a real LocalRegion. If not, then this test should be an integration test rather than a unit test.", "author": "DonalEvans", "createdAt": "2020-05-08T23:37:32Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,\n+      boolean isLastEventInTransaction, Region region) {\n+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);\n+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));\n+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);\n+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);\n+    when(event.getRegion()).thenReturn(region);\n+    return event;\n+  }\n+\n+  private Region createDistributedRegion(String regionName, Cache cache) {\n+    AttributesFactory factory = new AttributesFactory();\n+    factory.setScope(Scope.DISTRIBUTED_ACK);\n+    factory.setDataPolicy(DataPolicy.NORMAL);\n+    RegionAttributes attrs = factory.create();\n+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();\n+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,\n+        new TestStatisticsClock());\n+  }\n+\n+  public class TestLocalRegion extends LocalRegion {\n+    Map map = new ConcurrentHashMap();\n+\n+    public TestLocalRegion(String regionName, RegionAttributes attrs,\n+        LocalRegion parentRegion, InternalCache cache,\n+        InternalRegionArguments internalRegionArgs,\n+        StatisticsClock statisticsClock) {\n+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzczMzc2OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423733769", "bodyText": "I did not find a way to test SerialGatewaySenderQueue without creating a LocalRegion. The thing is the queue is backed up by a Region while in the ParallelGatewaySenderQueue it is an easily mockable class.\nI could try mocking the LocalRegion but not sure how complex the mock would be.\nI will give it a try.\nI checked to see what an alternative integration test would look like but it looked to me it would need a lot of code too and did not find any example to have a clear idea on how to start.\nI think it is best to try to have this as a unit test. Plus, I think it is cool that we also have the JUnit version for the SerialGatewaySenderQueue just as we do with the ParallelGatewaySenderQueue.", "author": "albertogpz", "createdAt": "2020-05-12T13:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5MjQ5MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423892490", "bodyText": "Okay, if it's too much work to mock out the LocalRegion then this test can stay as it is. There are a lot of classes in Geode which are hard to unit test, and this PR isn't about trying to refactor them.", "author": "DonalEvans", "createdAt": "2020-05-12T17:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMjQ2NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423902465", "bodyText": "I managed to mock the LocalRegion without much work. I will push a new commit shortly.", "author": "albertogpz", "createdAt": "2020-05-12T17:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1ODgyMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423958822", "bodyText": "Perfect! Thanks for taking the time to do this.", "author": "DonalEvans", "createdAt": "2020-05-12T18:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzM1Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423357", "bodyText": "This test name could be more descriptive. Also an Exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T23:54:34Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NDA2OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423194068", "bodyText": "How about testReplicatedSerialPropagationWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions?", "author": "albertogpz", "createdAt": "2020-05-11T17:16:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMzMxMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423213311", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-11T17:48:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423597", "bodyText": "This test name could be more descriptive. Also an Exception is never thrown from this method, so the throws can be removed.", "author": "DonalEvans", "createdAt": "2020-05-08T23:55:54Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NDM0OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423194349", "bodyText": "How about testReplicatedSerialPropagationWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "author": "albertogpz", "createdAt": "2020-05-11T17:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxNjA0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423216048", "bodyText": "It might be clearer with \"SendsBatchesWithCompleteTransactions,\" but either would be okay.", "author": "DonalEvans", "createdAt": "2020-05-11T17:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NDk1NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423674955", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T11:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzk5MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423991", "bodyText": "These casts to Integer are redundant.", "author": "DonalEvans", "createdAt": "2020-05-08T23:58:14Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5ODQwNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423198404", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T17:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDc2NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422424765", "bodyText": "This method is deprecated and so should not be used. GeodeAwaitility.await() should be used when tests need to wait for some condition to be met before continuing.", "author": "DonalEvans", "createdAt": "2020-05-09T00:02:20Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NjE0NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423556145", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T08:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDg5NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422424895", "bodyText": "Redundant cast to Integer.", "author": "DonalEvans", "createdAt": "2020-05-09T00:02:59Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NzQ3OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423557478", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T08:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTA1MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425051", "bodyText": "Deprecated method.", "author": "DonalEvans", "createdAt": "2020-05-09T00:03:38Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1ODE4NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423558185", "bodyText": "ok. Changed to vm2.invoke(() -> WANTestBase.validateRegionSize(...)", "author": "albertogpz", "createdAt": "2020-05-12T08:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTEzNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425134", "bodyText": "This test name could be more descriptive.", "author": "DonalEvans", "createdAt": "2020-05-09T00:03:57Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NDkzMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423574933", "bodyText": "How about testReplicatedSerialPropagationWithBatchRedistWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions?\n(world record in length but I could not come up with any shorter :-))", "author": "albertogpz", "createdAt": "2020-05-12T08:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTU0NA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423881544", "bodyText": "Sounds good. I actually got curious about the longest test name in Geode, so I searched, and the record is replicatedRegionWithPersistentSerialAsyncEventQueueAndConflationEnabledShouldNotLooseEventsNorThrowNullPointerExceptionsWhenMemberIsRestartedWhileEventsAreStillOnTheQueue at 170 characters, so you have some way to go if you want to beat that :P", "author": "DonalEvans", "createdAt": "2020-05-12T16:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTE3Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425173", "bodyText": "Redundant cast to Integer.", "author": "DonalEvans", "createdAt": "2020-05-09T00:04:09Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NDk5Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423574996", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T08:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTM4NA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425384", "bodyText": "Thread.sleep() should be avoided in tests as it can lead to flakiness. GeodeAwaitility.await() should be used instead.", "author": "DonalEvans", "createdAt": "2020-05-09T00:05:12Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NTMwMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423575301", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T08:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQwNg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425406", "bodyText": "Deprecated method.", "author": "DonalEvans", "createdAt": "2020-05-09T00:05:20Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NjAwMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423576003", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T08:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQ2OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425469", "bodyText": "This test name could be more descriptive.", "author": "DonalEvans", "createdAt": "2020-05-09T00:05:43Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzE1MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577151", "bodyText": "How about testReplicatedSerialPropagationWithBatchRedistWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "author": "albertogpz", "createdAt": "2020-05-12T09:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTg4MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423881881", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-12T16:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTUwMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425503", "bodyText": "Redundant cast to Integer.", "author": "DonalEvans", "createdAt": "2020-05-09T00:05:54Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzI0MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577241", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTYxNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425614", "bodyText": "Use GeodeAwaitility.await() instead.", "author": "DonalEvans", "createdAt": "2020-05-09T00:06:27Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzQ5Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577492", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTY0Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425646", "bodyText": "Deprecated method.", "author": "DonalEvans", "createdAt": "2020-05-09T00:06:38Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzYzNQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577635", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjA0MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426040", "bodyText": "Since the default unspecified value of group-transaction-events is false, does it need to be specified in the gfsh command here?", "author": "DonalEvans", "createdAt": "2020-05-09T00:08:55Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -155,7 +155,8 @@ public void testCreateDestroyGatewaySender() {\n         + CliStrings.CREATE_GATEWAYSENDER__MAXQUEUEMEMORY + \"=1000\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n-        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\";\n+        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\";", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NTE0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423585148", "bodyText": "It does not. I will remove it.", "author": "albertogpz", "createdAt": "2020-05-12T09:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjI2Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426267", "bodyText": "Specifying the default value here is redundant.", "author": "DonalEvans", "createdAt": "2020-05-09T00:09:57Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -239,6 +241,7 @@ public void testCreateDestroyGatewaySenderWithGatewayEventFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NTUzNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423585534", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjMyMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426321", "bodyText": "Specifying the default value here is redundant.", "author": "DonalEvans", "createdAt": "2020-05-09T00:10:12Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -292,6 +295,7 @@ public void testCreateDestroyGatewaySenderWithGatewayTransportFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NjU1MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423586551", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjUyMA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426520", "bodyText": "Can these comments be cleaned up a bit?", "author": "DonalEvans", "createdAt": "2020-05-09T00:11:13Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -102,15 +108,18 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4ODkwNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423588907", "bodyText": "I have removed them. I do not think they provide any useful information.", "author": "albertogpz", "createdAt": "2020-05-12T09:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY0Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426643", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:11:49Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -137,7 +146,8 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v5List = (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v6List = (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MDA5MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423590091", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY4Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426683", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:11:56Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -159,10 +169,10 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MTc0Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423591742", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjcxNA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426714", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:12:04Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -194,15 +204,18 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MTgyOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423591829", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc2Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426762", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:12:18Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -219,10 +232,10 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MTg5NA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423591894", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc3Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426777", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:12:22Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -254,16 +267,17 @@ public void testPartitionedRegionParallelPropagation_BeforeDispatch() throws Exc\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    // size\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MjA4MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423592080", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjgwMA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426800", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:12:31Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MjI5Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423592293", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjk2Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426966", "bodyText": "This test name could be more descriptive. Also, the throws is not necessary.", "author": "DonalEvans", "createdAt": "2020-05-09T00:13:18Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5NzMyMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423597322", "bodyText": "How about testPRParallelPropagationWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions?", "author": "albertogpz", "createdAt": "2020-05-12T09:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MjUwMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423882501", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-12T16:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzA4NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427085", "bodyText": "Redundant case to Integer.", "author": "DonalEvans", "createdAt": "2020-05-09T00:13:52Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5ODMyMg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423598322", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzIwMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427201", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:14:24Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5OTUzNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423599537", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzI2Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427262", "bodyText": "This test name could be more descriptive. Also, the throws is not needed.", "author": "DonalEvans", "createdAt": "2020-05-09T00:14:45Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTE4MQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601181", "bodyText": "How about testPRParallelPropagationWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "author": "albertogpz", "createdAt": "2020-05-12T09:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4Mjk1Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423882952", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-12T16:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzMxMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427311", "bodyText": "Redundant cast to Integer.", "author": "DonalEvans", "createdAt": "2020-05-09T00:14:58Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTIyNg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601226", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQzNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427437", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:15:43Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTMxNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601317", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQ4Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427483", "bodyText": "This test name could be more descriptive.", "author": "DonalEvans", "createdAt": "2020-05-09T00:15:56Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTcxMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601713", "bodyText": "How about testPRParallelPropagationWithBatchRedistWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions", "author": "albertogpz", "createdAt": "2020-05-12T09:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzExMQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423883111", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-12T16:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzUyOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427529", "bodyText": "Redundant cast to Integer.", "author": "DonalEvans", "createdAt": "2020-05-09T00:16:07Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTc2Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601766", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzU5OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427598", "bodyText": "Use GeodeAwaitlity.await() instead.", "author": "DonalEvans", "createdAt": "2020-05-09T00:16:32Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjM5NA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602394", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY1Nw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427657", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:16:52Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjQ4Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602483", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzcwOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427709", "bodyText": "This test name could be more descriptive.", "author": "DonalEvans", "createdAt": "2020-05-09T00:17:11Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjgzNg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602836", "bodyText": "How about testPRParallelPropagationWithBatchRedistWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "author": "albertogpz", "createdAt": "2020-05-12T09:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzIzMA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423883230", "bodyText": "Sounds good", "author": "DonalEvans", "createdAt": "2020-05-12T16:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzc0OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427748", "bodyText": "Redundant cast to Integer.", "author": "DonalEvans", "createdAt": "2020-05-09T00:17:23Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjkxNQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602915", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-12T09:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg1OA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427858", "bodyText": "Use GeodeAwaitility.await() instead.", "author": "DonalEvans", "createdAt": "2020-05-09T00:17:54Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NDIyMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422994223", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg5Mw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427893", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:18:08Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverInVMs(vm2);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDc0OQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423010749", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkyMA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427920", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:18:17Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -343,15 +653,16 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_Redundancy_3(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(400, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(400,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(400, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDgyNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423010827", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzk1Ng==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427956", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:18:33Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -503,17 +815,16 @@ public void testParallelPropagationWithRemoteRegionDestroy() throws Exception {\n     ArrayList<Integer> v7List =\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", -1));\n \n-\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 1); // batches\n-                                                                                    // distributed :\n-                                                                                    // its quite\n-                                                                                    // possible that\n-                                                                                    // vm4 has\n-                                                                                    // distributed\n-                                                                                    // some of the\n-                                                                                    // batches.\n+    // distributed :\n+    // its quite\n+    // possible that\n+    // vm4 has\n+    // distributed\n+    // some of the\n+    // batches.\n     assertTrue(v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5) >= 1); // batches\n-                                                                                    // redistributed\n+    // redistributed", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDkzOQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423010939", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODAwOA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r422428008", "bodyText": "More untidy comments.", "author": "DonalEvans", "createdAt": "2020-05-09T00:18:43Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -559,17 +868,18 @@ public void testParallelPropagationWithFilter() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(1000, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(1000,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(900, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(800, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                      // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 80); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n     assertEquals(200, v4List.get(6) + v5List.get(6) + v6List.get(6) + v7List.get(6)); // events\n-                                                                                      // filtered\n+    // filtered", "originalCommit": "5556d772491d3167e326343bc73e2d5aaa30a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTAyMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011023", "bodyText": "ok", "author": "albertogpz", "createdAt": "2020-05-11T12:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r423895027", "bodyText": "This new option should be added to the docs for the create gateway-sender gfsh command in create.html.md.erb.", "author": "DonalEvans", "createdAt": "2020-05-12T17:06:07Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "originalCommit": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxODE5NA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r424018194", "bodyText": "Yep", "author": "albertogpz", "createdAt": "2020-05-12T20:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4Mzk5NQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r424083995", "bodyText": "Note that the GatewaySender can be configured via the Java API ... not just through gfsh.  This is where I was hoping to get that check to ensure the user is configuring a valid GatewaySender (Serial GatewaySender).\nAlso, during internal testing with HA (killing servers) we've noticed data inconsistency between WAN Sites with groupTransactionEvents enabled.  In addition, I've seen the primary Serial GatewaySender AEQ not drain (again, with this attribute enabled).\nDo you have any DUnit Tests with HA (to verify that we still have consistency between wan sites and queues being drained when groupTransactionEvents is enabled)?\nWe are still investigating this and will update this PR as we narrow in on the root cause.", "author": "ladyVader", "createdAt": "2020-05-12T23:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNTk5NA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r424315994", "bodyText": "I forgot to add the check for the creation of the GatewaySender via the Java API.\nI have just pushed a new commit with this check in GatewaySenderFactoryImpl.\nRegarding your question about DUnit Tests with HA, I have not written any. I will try to investigate from my side the problems you have encountered.", "author": "albertogpz", "createdAt": "2020-05-13T09:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM0MTA0Mg==", "url": "https://github.com/apache/geode/pull/4928#discussion_r424341042", "bodyText": "I ran both ParallelWANStatsDUnitTest::testParallelPropagationHA() and SerialWANStatsDUnitTest::testReplicatedSerialPropagationHA() but setting group-transaction-events to true in the gateway-senders used and both test cases passed too.", "author": "albertogpz", "createdAt": "2020-05-13T10:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg2OTgyMw==", "url": "https://github.com/apache/geode/pull/4928#discussion_r425869823", "bodyText": "Note that the GatewaySender can be configured via the Java API ... not just through gfsh. This is where I was hoping to get that check to ensure the user is configuring a valid GatewaySender (Serial GatewaySender).\nAlso, during internal testing with HA (killing servers) we've noticed data inconsistency between WAN Sites with groupTransactionEvents enabled. In addition, I've seen the primary Serial GatewaySender AEQ not drain (again, with this attribute enabled).\nDo you have any DUnit Tests with HA (to verify that we still have consistency between wan sites and queues being drained when groupTransactionEvents is enabled)?\nWe are still investigating this and will update this PR as we narrow in on the root cause.\n\nI think I found the problem. There was a bug in the SerialGatewaySenderQueue handling of events that had to be added to the batch in order to complete a transaction that under high load and concurrency caused that some events were not propagated.\nI have added DUnit tests with HA for the serial and parallel gateway senders. The one for the SerialGatewaySender was failing before my fix.\nPlease, let me know if the new commit fixes the problem you encountered.", "author": "albertogpz", "createdAt": "2020-05-15T15:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzMjUwNQ==", "url": "https://github.com/apache/geode/pull/4928#discussion_r427832505", "bodyText": "@ladyVader Any news after the data inconsistency you found after having pushed my fix?", "author": "albertogpz", "createdAt": "2020-05-20T08:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyMDA2MA==", "url": "https://github.com/apache/geode/pull/4928#discussion_r429320060", "bodyText": "Thanks for both the new Exception on misconfiguring the SerialGatewaySender with groupTransactionEvents enabled + dispatcherThreads > 1.\nIn addition, I'm no longer seeing the data inconsistencies or hangs waiting for the primary gateway sender queue to drain.", "author": "ladyVader", "createdAt": "2020-05-22T15:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}], "type": "inlineReview"}, {"oid": "2c9548b8b5b2409a352bf602980f95f3f4b94ce4", "url": "https://github.com/apache/geode/commit/2c9548b8b5b2409a352bf602980f95f3f4b94ce4", "message": "feature/GEODE-7971: Documentation change after review and flaxy test fix", "committedDate": "2020-05-18T19:29:57Z", "type": "forcePushed"}, {"oid": "b9d61a1d04894b64b5c8bb4e97cad667a4ef0699", "url": "https://github.com/apache/geode/commit/b9d61a1d04894b64b5c8bb4e97cad667a4ef0699", "message": "Merge branch 'develop' into feature/GEODE-7971\n\ni#", "committedDate": "2020-05-22T17:40:53Z", "type": "forcePushed"}, {"oid": "241be81ebe0ef9e810693cc7fcd2fc134140905c", "url": "https://github.com/apache/geode/commit/241be81ebe0ef9e810693cc7fcd2fc134140905c", "message": "Merge branch 'develop' into feature/GEODE-7971", "committedDate": "2020-05-22T20:19:09Z", "type": "forcePushed"}, {"oid": "b721d2a270df0ede630a8c8c499a98c110943ef1", "url": "https://github.com/apache/geode/commit/b721d2a270df0ede630a8c8c499a98c110943ef1", "message": "Merge branch 'develop' into feature/GEODE-7971", "committedDate": "2020-05-22T23:13:29Z", "type": "forcePushed"}, {"oid": "4183c3f9727f8f94a16cceaa942fd16400125cb0", "url": "https://github.com/apache/geode/commit/4183c3f9727f8f94a16cceaa942fd16400125cb0", "message": "Merge branch 'develop' into feature/GEODE-7971", "committedDate": "2020-05-23T07:34:39Z", "type": "forcePushed"}, {"oid": "e727fe3181779116ba742cf7a71133847ea71dfc", "url": "https://github.com/apache/geode/commit/e727fe3181779116ba742cf7a71133847ea71dfc", "message": "GEODE-7971: empty commit to retrigger CI", "committedDate": "2020-05-23T17:46:45Z", "type": "forcePushed"}, {"oid": "d499407f1c2723c5487d1ec220f0e59e544ad79b", "url": "https://github.com/apache/geode/commit/d499407f1c2723c5487d1ec220f0e59e544ad79b", "message": "GEODE-7971: empty commit to retrigger CI", "committedDate": "2020-05-23T19:53:37Z", "type": "forcePushed"}, {"oid": "5c5c988a22e6600bfd7ba18635bfff4cc43dac6c", "url": "https://github.com/apache/geode/commit/5c5c988a22e6600bfd7ba18635bfff4cc43dac6c", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.", "committedDate": "2020-05-25T16:17:44Z", "type": "commit"}, {"oid": "35e33f42eb5584038f7f17ca5fdb08646987e459", "url": "https://github.com/apache/geode/commit/35e33f42eb5584038f7f17ca5fdb08646987e459", "message": "GEODE-7971: small fix in gwSenderFactory + extra info on config error", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "3ef15c6c6cb58519ef2b467268093d1448692e98", "url": "https://github.com/apache/geode/commit/3ef15c6c6cb58519ef2b467268093d1448692e98", "message": "GEODE-7971: Add logic for case when batches are redistributed\n\nAlso added parameter for retries when not all\nevents for a transaction can be read from the queue.", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "6276ffba6a792d8231139962728cb4e261e2225c", "url": "https://github.com/apache/geode/commit/6276ffba6a792d8231139962728cb4e261e2225c", "message": "GEODE-7971: Undo changes on cache*.dtd files unneeded\n\nAlso changed a couple of timeouts in test cases.", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "53a62aef853952eab4b147daec8224d3bb350dd9", "url": "https://github.com/apache/geode/commit/53a62aef853952eab4b147daec8224d3bb350dd9", "message": "feature/GEODE-7971: Changes after review", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "f9675b4ef4f4467b31e4ab8dcd99632748de2858", "url": "https://github.com/apache/geode/commit/f9675b4ef4f4467b31e4ab8dcd99632748de2858", "message": "feature/GEODE-7971: Simplify test JUnit test case", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "eaf73c5a3e95dcc5677e3ccca32f4b666f292a5b", "url": "https://github.com/apache/geode/commit/eaf73c5a3e95dcc5677e3ccca32f4b666f292a5b", "message": "GEODE-7971: Update create document and refactor test case", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "a408067e3b7e183cb317ec31dce697d023315a6c", "url": "https://github.com/apache/geode/commit/a408067e3b7e183cb317ec31dce697d023315a6c", "message": "GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.\n\nAlso corrected some documentation errors.", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "549573a52dc5e35cab547343e48057626ddbac7d", "url": "https://github.com/apache/geode/commit/549573a52dc5e35cab547343e48057626ddbac7d", "message": "GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "d063a45d7d8bef09b6c08951467ff021a8d2b120", "url": "https://github.com/apache/geode/commit/d063a45d7d8bef09b6c08951467ff021a8d2b120", "message": "feature/GEODE-7971: Documentation change after review and flaxy test fix", "committedDate": "2020-05-25T16:17:45Z", "type": "commit"}, {"oid": "e1e12ed5c378c0effc94fc3dda21a7ea6d8e214d", "url": "https://github.com/apache/geode/commit/e1e12ed5c378c0effc94fc3dda21a7ea6d8e214d", "message": "GEODE-7971: Doc changes after review", "committedDate": "2020-05-25T16:17:45Z", "type": "forcePushed"}, {"oid": "855e2720570f33072665b19a4be083c96c4b8696", "url": "https://github.com/apache/geode/commit/855e2720570f33072665b19a4be083c96c4b8696", "message": "GEODE-7971: Doc changes after review", "committedDate": "2020-05-26T08:21:19Z", "type": "commit"}, {"oid": "855e2720570f33072665b19a4be083c96c4b8696", "url": "https://github.com/apache/geode/commit/855e2720570f33072665b19a4be083c96c4b8696", "message": "GEODE-7971: Doc changes after review", "committedDate": "2020-05-26T08:21:19Z", "type": "forcePushed"}]}