{"pr_number": 4962, "pr_title": "GEODE-7992: Implement a test class for the EXISTS Redis API command", "pr_createdAt": "2020-04-15T17:38:56Z", "pr_url": "https://github.com/apache/geode/pull/4962", "timeline": [{"oid": "9eb7cc5a5617cb5e74e3504aedbae34ba740be76", "url": "https://github.com/apache/geode/commit/9eb7cc5a5617cb5e74e3504aedbae34ba740be76", "message": "GEODE-7992: Implement a test class for the EXISTS Redis API command", "committedDate": "2020-04-15T17:37:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MjAwNw==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410242007", "bodyText": "Precision is important. :)", "author": "ringles", "createdAt": "2020-04-17T13:59:39Z", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/general/PersistIntegrationTest.java", "diffHunk": "@@ -130,7 +130,7 @@ public void shouldPersistKey_givenKeyWith_geoValue() {\n     String geoKey = \"sicily\";\n     double latitude = 13.361389;\n     double longitude = 38.115556;\n-    String geoMember = \"Palermo Catina\";", "originalCommit": "9eb7cc5a5617cb5e74e3504aedbae34ba740be76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0Mzg3Mg==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410243872", "bodyText": "I don't think it's absolutely critical for this commit, but we probably need to standardize on an approach for (a) spawning and executing threads, and (b) iterated runnables. There's a few different approaches scattered across the tests.", "author": "ringles", "createdAt": "2020-04-17T14:02:30Z", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/general/ExistsIntegrationTest.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.general;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.GemFireCache;\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.GeodeRedisServer;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+\n+public class ExistsIntegrationTest {\n+\n+  public static Jedis jedis;\n+  public static Jedis jedis2;\n+  public static Jedis jedis3;\n+  public static int REDIS_CLIENT_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());;\n+  private static GeodeRedisServer server;\n+  private static GemFireCache cache;\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    CacheFactory cf = new CacheFactory();\n+    cf.set(LOG_LEVEL, \"error\");\n+    cf.set(MCAST_PORT, \"0\");\n+    cf.set(LOCATORS, \"\");\n+    cache = cf.create();\n+    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+    server = new GeodeRedisServer(\"localhost\", port);\n+\n+    server.start();\n+    jedis = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+    jedis2 = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+    jedis3 = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+  }\n+\n+  @After\n+  public void flushAll() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis.close();\n+    jedis2.close();\n+    jedis3.close();\n+    cache.close();\n+    server.shutdown();\n+  }\n+\n+  @Test\n+  public void shouldReturnZero_givenKeyDoesNotExist() {\n+    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenStringExists() {\n+    String stringKey = \"stringKey\";\n+    String stringValue = \"stringValue\";\n+    jedis.set(stringKey, stringValue);\n+\n+    assertThat(jedis.exists(toArray(stringKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenStringDoesNotExist() {\n+    String stringKey = \"stringKey\";\n+    String stringValue = \"stringValue\";\n+    jedis.set(stringKey, stringValue);\n+    jedis.del(stringKey);\n+\n+    assertThat(jedis.exists(toArray(stringKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenSetExists() {\n+    String setKey = \"setKey\";\n+    String setMember = \"setValue\";\n+\n+    jedis.sadd(setKey, setMember);\n+\n+    assertThat(jedis.exists(toArray(setKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenSetDoesNotExist() {\n+    String setKey = \"setKey\";\n+    String setMember = \"setValue\";\n+\n+    jedis.sadd(setKey, setMember);\n+    jedis.del(setKey);\n+\n+    assertThat(jedis.exists(toArray(setKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenSortedSetExists() {\n+    String sortedSetKey = \"sortedSetKey\";\n+    double score = 2.0;\n+    String sortedSetMember = \"sortedSetMember\";\n+\n+    jedis.zadd(sortedSetKey, score, sortedSetMember);\n+\n+    assertThat(jedis.exists(toArray(sortedSetKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenSortedSetDoesNotExist() {\n+    String sortedSetKey = \"sortedSetKey\";\n+    double score = 2.0;\n+    String sortedSetMember = \"sortedSetMember\";\n+\n+    jedis.zadd(sortedSetKey, score, sortedSetMember);\n+    jedis.del(sortedSetKey);\n+\n+    assertThat(jedis.exists(toArray(sortedSetKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenHashExists() {\n+    String hashKey = \"hashKey\";\n+    String hashField = \"hashField\";\n+    String hashValue = \"hashValue\";\n+\n+    jedis.hset(hashKey, hashField, hashValue);\n+\n+    assertThat(jedis.exists(toArray(hashKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenHashDoesNotExist() {\n+    String hashKey = \"hashKey\";\n+    String hashField = \"hashField\";\n+    String hashValue = \"hashValue\";\n+\n+    jedis.hset(hashKey, hashField, hashValue);\n+    jedis.del(hashKey);\n+\n+    assertThat(jedis.exists(toArray(hashKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenGeoExists() {\n+    String geoKey = \"sicily\";\n+    double latitude = 13.361389;\n+    double longitude = 38.115556;\n+    String geoMember = \"Palermo Catania\";\n+\n+    jedis.geoadd(geoKey, latitude, longitude, geoMember);\n+\n+    assertThat(jedis.exists(toArray(geoKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenGeoDoesNotExist() {\n+    String geoKey = \"sicily\";\n+    double latitude = 13.361389;\n+    double longitude = 38.115556;\n+    String geoMember = \"Palermo Catania\";\n+\n+    jedis.geoadd(geoKey, latitude, longitude, geoMember);\n+    jedis.del(geoKey);\n+\n+    assertThat(jedis.exists(toArray(geoKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenHyperLogLogExists() {\n+    String hyperLogLogKey = \"crawled:127.0.0.2\";\n+    String hyperLogLogValue = \"www.insideTheHouse.com\";\n+\n+    jedis.pfadd(hyperLogLogKey, hyperLogLogValue);\n+\n+    assertThat(jedis.exists(toArray(hyperLogLogKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenHyperLogLogDoesNotExist() {\n+    String hyperLogLogKey = \"crawled:127.0.0.2\";\n+    String hyperLogLogValue = \"www.insideTheHouse.com\";\n+\n+    jedis.pfadd(hyperLogLogKey, hyperLogLogValue);\n+    jedis.del(hyperLogLogKey);\n+\n+    assertThat(jedis.exists(toArray(hyperLogLogKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenListExists() {\n+    String listKey = \"listKey\";\n+    String listValue = \"listValue\";\n+\n+    jedis.lpush(listKey, listValue);\n+\n+    assertThat(jedis.exists(toArray(listKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenListDoesNotExist() {\n+    String listKey = \"listKey\";\n+    String listValue = \"listValue\";\n+\n+    jedis.lpush(listKey, listValue);\n+    jedis.del(listKey);\n+\n+    assertThat(jedis.exists(toArray(listKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenBitMapExists() {\n+    String bitMapKey = \"bitMapKey\";\n+    long offset = 1L;\n+    String bitMapValue = \"0\";\n+\n+    jedis.setbit(bitMapKey, offset, bitMapValue);\n+\n+    assertThat(jedis.exists(toArray(bitMapKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenBitMapDoesNotExist() {\n+    String bitMapKey = \"bitMapKey\";\n+    long offset = 1L;\n+    String bitMapValue = \"0\";\n+\n+    jedis.setbit(bitMapKey, offset, bitMapValue);\n+    jedis.del(bitMapKey);\n+\n+    assertThat(jedis.exists(toArray(bitMapKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturnTotalNumber_givenMultipleKeys() {\n+    String key1 = \"key1\";\n+    String key2 = \"key2\";\n+\n+    jedis.set(key1, \"value1\");\n+    jedis.set(key2, \"value2\");\n+\n+    assertThat(jedis.exists(toArray(key1, \"doesNotExist1\", key2, \"doesNotExist2\"))).isEqualTo(2L);\n+  }\n+\n+  @Test\n+  public void shouldCorrectlyVerifyKeysExistConcurrently() throws InterruptedException {\n+    int iterationCount = 5000;\n+    setKeys(jedis, iterationCount);\n+\n+    AtomicLong existsCount = new AtomicLong(0);\n+\n+    Thread thread1 =\n+        new LoopingThread((i) -> existsCount.addAndGet(jedis.exists(toArray(\"key\" + i))),\n+            iterationCount);\n+    Thread thread2 =\n+        new LoopingThread((i) -> existsCount.addAndGet(jedis2.exists(toArray(\"key\" + i))),\n+            iterationCount);\n+\n+    thread1.start();\n+    thread2.start();\n+    thread1.join();\n+    thread2.join();\n+\n+    assertThat(existsCount.get()).isEqualTo(2 * iterationCount);\n+  }\n+\n+  @Test\n+  public void shouldCorrectlyVerifyKeyExistsConcurrentlyWhileDeletingAndSettingKey()\n+      throws InterruptedException {\n+    int iterationCount = 5000;\n+\n+    Thread loopingThread1 = new LoopingThread((i) -> jedis.set(\"key\", \"value\"), iterationCount);\n+    Thread loopingThread2 = new LoopingThread((i) -> jedis2.exists(toArray(\"key\")), iterationCount);\n+    Thread loopingThread3 = new LoopingThread((i) -> jedis3.del(\"key\"), iterationCount);\n+\n+    loopingThread1.start();\n+    loopingThread2.start();\n+    loopingThread3.start();\n+    loopingThread1.join();\n+    loopingThread2.join();\n+    loopingThread3.join();\n+  }\n+\n+  public String[] toArray(String... strings) {\n+    return strings;\n+  }\n+\n+  private void setKeys(Jedis jedis, int iterationCount) {\n+    for (int i = 0; i < iterationCount; i++) {\n+      jedis.set(\"key\" + i, \"value\" + i);\n+    }\n+  }\n+\n+  private void existsKeys(AtomicLong existsCount, Jedis jedis, int iterationCount) {\n+    for (int i = 0; i < iterationCount; i++) {\n+      existsCount.addAndGet(jedis.exists(\"key\" + i, \"doesNotExist\" + i));\n+    }\n+  }\n+\n+  private class LoopingThread extends Thread {", "originalCommit": "9eb7cc5a5617cb5e74e3504aedbae34ba740be76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMyMTUzOQ==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410321539", "bodyText": "I totally agree!  Let's have a techtro!", "author": "sabbey37", "createdAt": "2020-04-17T16:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0Mzg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0NDcwNQ==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410244705", "bodyText": "Do we have stories in the backlog about sorted sets? Looks like we missed this earlier.", "author": "ringles", "createdAt": "2020-04-17T14:03:52Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RegionProvider.java", "diffHunk": "@@ -210,7 +210,7 @@ public boolean removeKey(ByteArrayWrapper key, RedisDataType type, boolean cance\n           return stringsRegion.remove(key) != null;\n         } else if (type == RedisDataType.REDIS_HLL) {\n           return hLLRegion.remove(key) != null;\n-        } else if (type == RedisDataType.REDIS_LIST) {\n+        } else if (type == RedisDataType.REDIS_LIST || type == RedisDataType.REDIS_SORTEDSET) {", "originalCommit": "9eb7cc5a5617cb5e74e3504aedbae34ba740be76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMyMTY5Mw==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410321693", "bodyText": "Added a placeholder for sorted sets.", "author": "sabbey37", "createdAt": "2020-04-17T16:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0NDcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0NTc1OA==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410245758", "bodyText": "I think we're starting five VMs here, but only using three.", "author": "ringles", "createdAt": "2020-04-17T14:05:28Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExistsDUnitTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis.executors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.util.Properties;\n+\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class ExistsDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(5);", "originalCommit": "9eb7cc5a5617cb5e74e3504aedbae34ba740be76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMyMTk2MA==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410321960", "bodyText": "We are.  Thank you for catching that.  I just updated it to 3.", "author": "sabbey37", "createdAt": "2020-04-17T16:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0NTc1OA=="}], "type": "inlineReview"}, {"oid": "4f70ebdc42d4e337e9be6e48de47e49310be2059", "url": "https://github.com/apache/geode/commit/4f70ebdc42d4e337e9be6e48de47e49310be2059", "message": "Updates vmCount in ExistsDUnitTest", "committedDate": "2020-04-17T16:03:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODE0NA==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410348144", "bodyText": "Is this unused? If so delete it", "author": "dschneider-pivotal", "createdAt": "2020-04-17T16:52:52Z", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/general/ExistsIntegrationTest.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.general;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.GemFireCache;\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.GeodeRedisServer;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+\n+public class ExistsIntegrationTest {\n+\n+  public static Jedis jedis;\n+  public static Jedis jedis2;\n+  public static Jedis jedis3;\n+  public static int REDIS_CLIENT_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());;\n+  private static GeodeRedisServer server;\n+  private static GemFireCache cache;\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    CacheFactory cf = new CacheFactory();\n+    cf.set(LOG_LEVEL, \"error\");\n+    cf.set(MCAST_PORT, \"0\");\n+    cf.set(LOCATORS, \"\");\n+    cache = cf.create();\n+    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+    server = new GeodeRedisServer(\"localhost\", port);\n+\n+    server.start();\n+    jedis = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+    jedis2 = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+    jedis3 = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+  }\n+\n+  @After\n+  public void flushAll() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis.close();\n+    jedis2.close();\n+    jedis3.close();\n+    cache.close();\n+    server.shutdown();\n+  }\n+\n+  @Test\n+  public void shouldReturnZero_givenKeyDoesNotExist() {\n+    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenStringExists() {\n+    String stringKey = \"stringKey\";\n+    String stringValue = \"stringValue\";\n+    jedis.set(stringKey, stringValue);\n+\n+    assertThat(jedis.exists(toArray(stringKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenStringDoesNotExist() {\n+    String stringKey = \"stringKey\";\n+    String stringValue = \"stringValue\";\n+    jedis.set(stringKey, stringValue);\n+    jedis.del(stringKey);\n+\n+    assertThat(jedis.exists(toArray(stringKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenSetExists() {\n+    String setKey = \"setKey\";\n+    String setMember = \"setValue\";\n+\n+    jedis.sadd(setKey, setMember);\n+\n+    assertThat(jedis.exists(toArray(setKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenSetDoesNotExist() {\n+    String setKey = \"setKey\";\n+    String setMember = \"setValue\";\n+\n+    jedis.sadd(setKey, setMember);\n+    jedis.del(setKey);\n+\n+    assertThat(jedis.exists(toArray(setKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenSortedSetExists() {\n+    String sortedSetKey = \"sortedSetKey\";\n+    double score = 2.0;\n+    String sortedSetMember = \"sortedSetMember\";\n+\n+    jedis.zadd(sortedSetKey, score, sortedSetMember);\n+\n+    assertThat(jedis.exists(toArray(sortedSetKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenSortedSetDoesNotExist() {\n+    String sortedSetKey = \"sortedSetKey\";\n+    double score = 2.0;\n+    String sortedSetMember = \"sortedSetMember\";\n+\n+    jedis.zadd(sortedSetKey, score, sortedSetMember);\n+    jedis.del(sortedSetKey);\n+\n+    assertThat(jedis.exists(toArray(sortedSetKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenHashExists() {\n+    String hashKey = \"hashKey\";\n+    String hashField = \"hashField\";\n+    String hashValue = \"hashValue\";\n+\n+    jedis.hset(hashKey, hashField, hashValue);\n+\n+    assertThat(jedis.exists(toArray(hashKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenHashDoesNotExist() {\n+    String hashKey = \"hashKey\";\n+    String hashField = \"hashField\";\n+    String hashValue = \"hashValue\";\n+\n+    jedis.hset(hashKey, hashField, hashValue);\n+    jedis.del(hashKey);\n+\n+    assertThat(jedis.exists(toArray(hashKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenGeoExists() {\n+    String geoKey = \"sicily\";\n+    double latitude = 13.361389;\n+    double longitude = 38.115556;\n+    String geoMember = \"Palermo Catania\";\n+\n+    jedis.geoadd(geoKey, latitude, longitude, geoMember);\n+\n+    assertThat(jedis.exists(toArray(geoKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenGeoDoesNotExist() {\n+    String geoKey = \"sicily\";\n+    double latitude = 13.361389;\n+    double longitude = 38.115556;\n+    String geoMember = \"Palermo Catania\";\n+\n+    jedis.geoadd(geoKey, latitude, longitude, geoMember);\n+    jedis.del(geoKey);\n+\n+    assertThat(jedis.exists(toArray(geoKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenHyperLogLogExists() {\n+    String hyperLogLogKey = \"crawled:127.0.0.2\";\n+    String hyperLogLogValue = \"www.insideTheHouse.com\";\n+\n+    jedis.pfadd(hyperLogLogKey, hyperLogLogValue);\n+\n+    assertThat(jedis.exists(toArray(hyperLogLogKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenHyperLogLogDoesNotExist() {\n+    String hyperLogLogKey = \"crawled:127.0.0.2\";\n+    String hyperLogLogValue = \"www.insideTheHouse.com\";\n+\n+    jedis.pfadd(hyperLogLogKey, hyperLogLogValue);\n+    jedis.del(hyperLogLogKey);\n+\n+    assertThat(jedis.exists(toArray(hyperLogLogKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenListExists() {\n+    String listKey = \"listKey\";\n+    String listValue = \"listValue\";\n+\n+    jedis.lpush(listKey, listValue);\n+\n+    assertThat(jedis.exists(toArray(listKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenListDoesNotExist() {\n+    String listKey = \"listKey\";\n+    String listValue = \"listValue\";\n+\n+    jedis.lpush(listKey, listValue);\n+    jedis.del(listKey);\n+\n+    assertThat(jedis.exists(toArray(listKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenBitMapExists() {\n+    String bitMapKey = \"bitMapKey\";\n+    long offset = 1L;\n+    String bitMapValue = \"0\";\n+\n+    jedis.setbit(bitMapKey, offset, bitMapValue);\n+\n+    assertThat(jedis.exists(toArray(bitMapKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenBitMapDoesNotExist() {\n+    String bitMapKey = \"bitMapKey\";\n+    long offset = 1L;\n+    String bitMapValue = \"0\";\n+\n+    jedis.setbit(bitMapKey, offset, bitMapValue);\n+    jedis.del(bitMapKey);\n+\n+    assertThat(jedis.exists(toArray(bitMapKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturnTotalNumber_givenMultipleKeys() {\n+    String key1 = \"key1\";\n+    String key2 = \"key2\";\n+\n+    jedis.set(key1, \"value1\");\n+    jedis.set(key2, \"value2\");\n+\n+    assertThat(jedis.exists(toArray(key1, \"doesNotExist1\", key2, \"doesNotExist2\"))).isEqualTo(2L);\n+  }\n+\n+  @Test\n+  public void shouldCorrectlyVerifyKeysExistConcurrently() throws InterruptedException {\n+    int iterationCount = 5000;\n+    setKeys(jedis, iterationCount);\n+\n+    AtomicLong existsCount = new AtomicLong(0);\n+\n+    Thread thread1 =\n+        new LoopingThread((i) -> existsCount.addAndGet(jedis.exists(toArray(\"key\" + i))),\n+            iterationCount);\n+    Thread thread2 =\n+        new LoopingThread((i) -> existsCount.addAndGet(jedis2.exists(toArray(\"key\" + i))),\n+            iterationCount);\n+\n+    thread1.start();\n+    thread2.start();\n+    thread1.join();\n+    thread2.join();\n+\n+    assertThat(existsCount.get()).isEqualTo(2 * iterationCount);\n+  }\n+\n+  @Test\n+  public void shouldCorrectlyVerifyKeyExistsConcurrentlyWhileDeletingAndSettingKey()\n+      throws InterruptedException {\n+    int iterationCount = 5000;\n+\n+    Thread loopingThread1 = new LoopingThread((i) -> jedis.set(\"key\", \"value\"), iterationCount);\n+    Thread loopingThread2 = new LoopingThread((i) -> jedis2.exists(toArray(\"key\")), iterationCount);\n+    Thread loopingThread3 = new LoopingThread((i) -> jedis3.del(\"key\"), iterationCount);\n+\n+    loopingThread1.start();\n+    loopingThread2.start();\n+    loopingThread3.start();\n+    loopingThread1.join();\n+    loopingThread2.join();\n+    loopingThread3.join();\n+  }\n+\n+  public String[] toArray(String... strings) {\n+    return strings;\n+  }\n+\n+  private void setKeys(Jedis jedis, int iterationCount) {\n+    for (int i = 0; i < iterationCount; i++) {\n+      jedis.set(\"key\" + i, \"value\" + i);\n+    }\n+  }\n+\n+  private void existsKeys(AtomicLong existsCount, Jedis jedis, int iterationCount) {", "originalCommit": "4f70ebdc42d4e337e9be6e48de47e49310be2059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MTc4NQ==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410451785", "bodyText": "thanks, good catch.", "author": "prettyClouds", "createdAt": "2020-04-17T20:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTYwMw==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410349603", "bodyText": "Nothing to assert? Are we just happy that none of the threads throws an exception? If so the method name should communicate this.", "author": "dschneider-pivotal", "createdAt": "2020-04-17T16:55:21Z", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/general/ExistsIntegrationTest.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.general;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.GemFireCache;\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.GeodeRedisServer;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+\n+public class ExistsIntegrationTest {\n+\n+  public static Jedis jedis;\n+  public static Jedis jedis2;\n+  public static Jedis jedis3;\n+  public static int REDIS_CLIENT_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());;\n+  private static GeodeRedisServer server;\n+  private static GemFireCache cache;\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    CacheFactory cf = new CacheFactory();\n+    cf.set(LOG_LEVEL, \"error\");\n+    cf.set(MCAST_PORT, \"0\");\n+    cf.set(LOCATORS, \"\");\n+    cache = cf.create();\n+    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+    server = new GeodeRedisServer(\"localhost\", port);\n+\n+    server.start();\n+    jedis = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+    jedis2 = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+    jedis3 = new Jedis(\"localhost\", port, REDIS_CLIENT_TIMEOUT);\n+  }\n+\n+  @After\n+  public void flushAll() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis.close();\n+    jedis2.close();\n+    jedis3.close();\n+    cache.close();\n+    server.shutdown();\n+  }\n+\n+  @Test\n+  public void shouldReturnZero_givenKeyDoesNotExist() {\n+    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenStringExists() {\n+    String stringKey = \"stringKey\";\n+    String stringValue = \"stringValue\";\n+    jedis.set(stringKey, stringValue);\n+\n+    assertThat(jedis.exists(toArray(stringKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenStringDoesNotExist() {\n+    String stringKey = \"stringKey\";\n+    String stringValue = \"stringValue\";\n+    jedis.set(stringKey, stringValue);\n+    jedis.del(stringKey);\n+\n+    assertThat(jedis.exists(toArray(stringKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenSetExists() {\n+    String setKey = \"setKey\";\n+    String setMember = \"setValue\";\n+\n+    jedis.sadd(setKey, setMember);\n+\n+    assertThat(jedis.exists(toArray(setKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenSetDoesNotExist() {\n+    String setKey = \"setKey\";\n+    String setMember = \"setValue\";\n+\n+    jedis.sadd(setKey, setMember);\n+    jedis.del(setKey);\n+\n+    assertThat(jedis.exists(toArray(setKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenSortedSetExists() {\n+    String sortedSetKey = \"sortedSetKey\";\n+    double score = 2.0;\n+    String sortedSetMember = \"sortedSetMember\";\n+\n+    jedis.zadd(sortedSetKey, score, sortedSetMember);\n+\n+    assertThat(jedis.exists(toArray(sortedSetKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenSortedSetDoesNotExist() {\n+    String sortedSetKey = \"sortedSetKey\";\n+    double score = 2.0;\n+    String sortedSetMember = \"sortedSetMember\";\n+\n+    jedis.zadd(sortedSetKey, score, sortedSetMember);\n+    jedis.del(sortedSetKey);\n+\n+    assertThat(jedis.exists(toArray(sortedSetKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenHashExists() {\n+    String hashKey = \"hashKey\";\n+    String hashField = \"hashField\";\n+    String hashValue = \"hashValue\";\n+\n+    jedis.hset(hashKey, hashField, hashValue);\n+\n+    assertThat(jedis.exists(toArray(hashKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenHashDoesNotExist() {\n+    String hashKey = \"hashKey\";\n+    String hashField = \"hashField\";\n+    String hashValue = \"hashValue\";\n+\n+    jedis.hset(hashKey, hashField, hashValue);\n+    jedis.del(hashKey);\n+\n+    assertThat(jedis.exists(toArray(hashKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenGeoExists() {\n+    String geoKey = \"sicily\";\n+    double latitude = 13.361389;\n+    double longitude = 38.115556;\n+    String geoMember = \"Palermo Catania\";\n+\n+    jedis.geoadd(geoKey, latitude, longitude, geoMember);\n+\n+    assertThat(jedis.exists(toArray(geoKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenGeoDoesNotExist() {\n+    String geoKey = \"sicily\";\n+    double latitude = 13.361389;\n+    double longitude = 38.115556;\n+    String geoMember = \"Palermo Catania\";\n+\n+    jedis.geoadd(geoKey, latitude, longitude, geoMember);\n+    jedis.del(geoKey);\n+\n+    assertThat(jedis.exists(toArray(geoKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenHyperLogLogExists() {\n+    String hyperLogLogKey = \"crawled:127.0.0.2\";\n+    String hyperLogLogValue = \"www.insideTheHouse.com\";\n+\n+    jedis.pfadd(hyperLogLogKey, hyperLogLogValue);\n+\n+    assertThat(jedis.exists(toArray(hyperLogLogKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenHyperLogLogDoesNotExist() {\n+    String hyperLogLogKey = \"crawled:127.0.0.2\";\n+    String hyperLogLogValue = \"www.insideTheHouse.com\";\n+\n+    jedis.pfadd(hyperLogLogKey, hyperLogLogValue);\n+    jedis.del(hyperLogLogKey);\n+\n+    assertThat(jedis.exists(toArray(hyperLogLogKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenListExists() {\n+    String listKey = \"listKey\";\n+    String listValue = \"listValue\";\n+\n+    jedis.lpush(listKey, listValue);\n+\n+    assertThat(jedis.exists(toArray(listKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenListDoesNotExist() {\n+    String listKey = \"listKey\";\n+    String listValue = \"listValue\";\n+\n+    jedis.lpush(listKey, listValue);\n+    jedis.del(listKey);\n+\n+    assertThat(jedis.exists(toArray(listKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturn1_givenBitMapExists() {\n+    String bitMapKey = \"bitMapKey\";\n+    long offset = 1L;\n+    String bitMapValue = \"0\";\n+\n+    jedis.setbit(bitMapKey, offset, bitMapValue);\n+\n+    assertThat(jedis.exists(toArray(bitMapKey))).isEqualTo(1L);\n+  }\n+\n+  @Test\n+  public void shouldReturn0_givenBitMapDoesNotExist() {\n+    String bitMapKey = \"bitMapKey\";\n+    long offset = 1L;\n+    String bitMapValue = \"0\";\n+\n+    jedis.setbit(bitMapKey, offset, bitMapValue);\n+    jedis.del(bitMapKey);\n+\n+    assertThat(jedis.exists(toArray(bitMapKey))).isEqualTo(0L);\n+  }\n+\n+  @Test\n+  public void shouldReturnTotalNumber_givenMultipleKeys() {\n+    String key1 = \"key1\";\n+    String key2 = \"key2\";\n+\n+    jedis.set(key1, \"value1\");\n+    jedis.set(key2, \"value2\");\n+\n+    assertThat(jedis.exists(toArray(key1, \"doesNotExist1\", key2, \"doesNotExist2\"))).isEqualTo(2L);\n+  }\n+\n+  @Test\n+  public void shouldCorrectlyVerifyKeysExistConcurrently() throws InterruptedException {\n+    int iterationCount = 5000;\n+    setKeys(jedis, iterationCount);\n+\n+    AtomicLong existsCount = new AtomicLong(0);\n+\n+    Thread thread1 =\n+        new LoopingThread((i) -> existsCount.addAndGet(jedis.exists(toArray(\"key\" + i))),\n+            iterationCount);\n+    Thread thread2 =\n+        new LoopingThread((i) -> existsCount.addAndGet(jedis2.exists(toArray(\"key\" + i))),\n+            iterationCount);\n+\n+    thread1.start();\n+    thread2.start();\n+    thread1.join();\n+    thread2.join();\n+\n+    assertThat(existsCount.get()).isEqualTo(2 * iterationCount);\n+  }\n+\n+  @Test\n+  public void shouldCorrectlyVerifyKeyExistsConcurrentlyWhileDeletingAndSettingKey()\n+      throws InterruptedException {\n+    int iterationCount = 5000;\n+\n+    Thread loopingThread1 = new LoopingThread((i) -> jedis.set(\"key\", \"value\"), iterationCount);\n+    Thread loopingThread2 = new LoopingThread((i) -> jedis2.exists(toArray(\"key\")), iterationCount);\n+    Thread loopingThread3 = new LoopingThread((i) -> jedis3.del(\"key\"), iterationCount);\n+\n+    loopingThread1.start();\n+    loopingThread2.start();\n+    loopingThread3.start();\n+    loopingThread1.join();\n+    loopingThread2.join();\n+    loopingThread3.join();\n+  }", "originalCommit": "4f70ebdc42d4e337e9be6e48de47e49310be2059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTMyNg==", "url": "https://github.com/apache/geode/pull/4962#discussion_r410455326", "bodyText": "updated, the name. We just wanted to make sure there were no Concurrent Modification Exceptions on any underlying data structures.  Not sure what else to test. thx", "author": "prettyClouds", "createdAt": "2020-04-17T20:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTYwMw=="}], "type": "inlineReview"}, {"oid": "2ec1cf9e23c4ed95ea19a090f5b9dd0e44d99579", "url": "https://github.com/apache/geode/commit/2ec1cf9e23c4ed95ea19a090f5b9dd0e44d99579", "message": "PR cleanup", "committedDate": "2020-04-17T20:33:08Z", "type": "commit"}]}