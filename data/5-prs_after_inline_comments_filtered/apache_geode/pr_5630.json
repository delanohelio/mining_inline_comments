{"pr_number": 5630, "pr_title": "GEODE-8605: Alter Gateway Sender command", "pr_createdAt": "2020-10-15T15:05:07Z", "pr_url": "https://github.com/apache/geode/pull/5630", "timeline": [{"oid": "ca561e06f680c245311b1468adc454e7e321836b", "url": "https://github.com/apache/geode/commit/ca561e06f680c245311b1468adc454e7e321836b", "message": "GEODE-8605: fix for failing integration test", "committedDate": "2020-10-15T17:11:55Z", "type": "forcePushed"}, {"oid": "bc19554ad6cd2ccc5de411c7ed38056f296d4669", "url": "https://github.com/apache/geode/commit/bc19554ad6cd2ccc5de411c7ed38056f296d4669", "message": "GEODE-8605: added test for new function", "committedDate": "2020-10-22T08:52:48Z", "type": "forcePushed"}, {"oid": "e1a53b1597a12afbebabfd921797e8ae30ca4074", "url": "https://github.com/apache/geode/commit/e1a53b1597a12afbebabfd921797e8ae30ca4074", "message": "GEODE-8605: added filter test", "committedDate": "2020-10-27T11:32:49Z", "type": "forcePushed"}, {"oid": "34314f6b7422ac15659496078fd6f859521a3750", "url": "https://github.com/apache/geode/commit/34314f6b7422ac15659496078fd6f859521a3750", "message": "GEODE-8605: added filter test", "committedDate": "2020-10-27T12:32:26Z", "type": "forcePushed"}, {"oid": "8ecc33769979f8336c6e15f1dbbc97aa029b670b", "url": "https://github.com/apache/geode/commit/8ecc33769979f8336c6e15f1dbbc97aa029b670b", "message": "GEODE-8605: update after comments", "committedDate": "2020-10-27T18:57:27Z", "type": "forcePushed"}, {"oid": "425da1885433f52bbd97d329107ab6873d7634d9", "url": "https://github.com/apache/geode/commit/425da1885433f52bbd97d329107ab6873d7634d9", "message": "GEODE-8605: update solution", "committedDate": "2020-11-16T21:11:54Z", "type": "forcePushed"}, {"oid": "2504a3a2baa22b8da86a88936f97b952ab78976d", "url": "https://github.com/apache/geode/commit/2504a3a2baa22b8da86a88936f97b952ab78976d", "message": "GEODE-8605: added setters instead of update", "committedDate": "2020-12-03T21:15:17Z", "type": "forcePushed"}, {"oid": "013344379e43f4c15e729a731a6f4e39338f8502", "url": "https://github.com/apache/geode/commit/013344379e43f4c15e729a731a6f4e39338f8502", "message": "GEODE-8605: added test for SerialGatewaySender", "committedDate": "2020-12-04T22:39:45Z", "type": "forcePushed"}, {"oid": "1909ea65f4ed353b768f131ac95a6e8ed442ae97", "url": "https://github.com/apache/geode/commit/1909ea65f4ed353b768f131ac95a6e8ed442ae97", "message": "GEODE-8605: add option to remove gateway-event-filters", "committedDate": "2020-12-12T20:19:57Z", "type": "forcePushed"}, {"oid": "04fcb2cbee4f89ae3a105b87da1f9999eead701b", "url": "https://github.com/apache/geode/commit/04fcb2cbee4f89ae3a105b87da1f9999eead701b", "message": "GEODE-8605: add option to remove gateway-event-filters", "committedDate": "2020-12-13T22:40:11Z", "type": "forcePushed"}, {"oid": "df4475334938bfcab00bd2663ecf323a26aaf675", "url": "https://github.com/apache/geode/commit/df4475334938bfcab00bd2663ecf323a26aaf675", "message": "GEODE-8605: update of remove filters solution", "committedDate": "2020-12-14T11:42:14Z", "type": "forcePushed"}, {"oid": "9b553da6b58fdc30b5852666293a5f983e20c9b3", "url": "https://github.com/apache/geode/commit/9b553da6b58fdc30b5852666293a5f983e20c9b3", "message": "GEODE-8605: update of remove filters solution", "committedDate": "2020-12-19T08:50:35Z", "type": "forcePushed"}, {"oid": "1b111ff83634bda2b9a143cc855f50eff5588a38", "url": "https://github.com/apache/geode/commit/1b111ff83634bda2b9a143cc855f50eff5588a38", "message": "GEODE-8605: rebase solution", "committedDate": "2021-01-25T17:11:51Z", "type": "forcePushed"}, {"oid": "0d2bddf62441ac7f32a7151bae1212027ff06953", "url": "https://github.com/apache/geode/commit/0d2bddf62441ac7f32a7151bae1212027ff06953", "message": "GEODE-8605: rebase solution", "committedDate": "2021-01-25T17:56:13Z", "type": "forcePushed"}, {"oid": "1cf1a7f0625e38bc292713cb695806531a765f54", "url": "https://github.com/apache/geode/commit/1cf1a7f0625e38bc292713cb695806531a765f54", "message": "GEODE-8605: rebase solution", "committedDate": "2021-01-25T17:57:23Z", "type": "forcePushed"}, {"oid": "dcf2cf94f8d56c6b68e42772e13a10895dd368c7", "url": "https://github.com/apache/geode/commit/dcf2cf94f8d56c6b68e42772e13a10895dd368c7", "message": "GEODE-8605: added serialVersionUID to GatewaySender", "committedDate": "2021-01-28T20:01:00Z", "type": "forcePushed"}, {"oid": "a418d4b575d5b529fcdc0215d7b4f8d5299023dd", "url": "https://github.com/apache/geode/commit/a418d4b575d5b529fcdc0215d7b4f8d5299023dd", "message": "GEODE-8605: added serialVersionUID to GatewaySender", "committedDate": "2021-01-28T21:30:23Z", "type": "forcePushed"}, {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61", "url": "https://github.com/apache/geode/commit/6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61", "message": "GEODE-8605: added test case", "committedDate": "2021-02-04T18:04:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyNzY2NA==", "url": "https://github.com/apache/geode/pull/5630#discussion_r573327664", "bodyText": "You should create a new unit test even for inner-classes. Any class that you make Serializable should also have to unit test coverage to ensure that both seriallization and deserialization succeeds and results in a faithful replica of the original object (shamelessly copied from Effective Java 3rd Ed. Item 86). I recommend using org.apache.commons.lang3.SerializationUtils to simplify the unit testing.", "author": "kirklund", "createdAt": "2021-02-09T23:33:32Z", "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2612,7 +2612,8 @@ public void setOverflowDirectory(String value) {\n   @XmlAccessorType(XmlAccessType.FIELD)\n   @XmlType(name = \"\", propOrder = {\"gatewayEventFilters\", \"gatewayEventSubstitutionFilter\",\n       \"gatewayTransportFilters\"})\n-  public static class GatewaySender {\n+  public static class GatewaySender extends CacheElement {", "originalCommit": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDE5MTM3OA==", "url": "https://github.com/apache/geode/pull/5630#discussion_r580191378", "bodyText": "Removed serialization impacts, so no need for additional tests.", "author": "mivanac", "createdAt": "2021-02-22T11:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyNzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyOTU5NQ==", "url": "https://github.com/apache/geode/pull/5630#discussion_r573329595", "bodyText": "public mutable fields are not good. I guess this class has other such fields so I'll just skip over this class. If it was me, I'd completely rewrite this class to get make all fields private.", "author": "kirklund", "createdAt": "2021-02-09T23:36:22Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -88,6 +88,20 @@\n   public boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  public boolean modifyAlertThreshold = false;", "originalCommit": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDk2Mjk0OQ==", "url": "https://github.com/apache/geode/pull/5630#discussion_r584962949", "bodyText": "+1 to rewrite. Direct access is almost always a bad idea in a multithreaded system.", "author": "mhansonp", "createdAt": "2021-03-01T18:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyOTU5NQ=="}], "type": "inlineReview"}, {"oid": "44c49b66708a378572b71452cfd33f7160a05cec", "url": "https://github.com/apache/geode/commit/44c49b66708a378572b71452cfd33f7160a05cec", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender", "committedDate": "2021-02-15T20:22:52Z", "type": "forcePushed"}, {"oid": "fb0150476ce137eb9b0749de4b2e15a1f3f8df41", "url": "https://github.com/apache/geode/commit/fb0150476ce137eb9b0749de4b2e15a1f3f8df41", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender", "committedDate": "2021-02-15T20:54:29Z", "type": "forcePushed"}, {"oid": "10f9b95d5bc27642bf76bfb10332913e0ee9d5c4", "url": "https://github.com/apache/geode/commit/10f9b95d5bc27642bf76bfb10332913e0ee9d5c4", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender", "committedDate": "2021-02-16T09:33:21Z", "type": "forcePushed"}, {"oid": "f6918015d1efe49f8c905012596d964a878aa776", "url": "https://github.com/apache/geode/commit/f6918015d1efe49f8c905012596d964a878aa776", "message": "GEODE-8605: add setters to GatewaySenderAttributes", "committedDate": "2021-03-02T21:09:22Z", "type": "forcePushed"}, {"oid": "30ac9967be6a5fdbe36c04d06a20f47f13ae100c", "url": "https://github.com/apache/geode/commit/30ac9967be6a5fdbe36c04d06a20f47f13ae100c", "message": "GEODE-8605: add setters to GatewaySenderAttributes", "committedDate": "2021-03-03T09:02:48Z", "type": "forcePushed"}, {"oid": "bf5f2b5da8e7601785d084636309a01c0583eb60", "url": "https://github.com/apache/geode/commit/bf5f2b5da8e7601785d084636309a01c0583eb60", "message": "GEODE-8605: add setters to GatewaySenderAttributes", "committedDate": "2021-03-12T14:45:54Z", "type": "forcePushed"}, {"oid": "e817a31292ad07435ba6f8f162f177d389c7cc15", "url": "https://github.com/apache/geode/commit/e817a31292ad07435ba6f8f162f177d389c7cc15", "message": "GEODE-8605: add setters to GatewaySenderAttributes", "committedDate": "2021-03-12T16:28:29Z", "type": "forcePushed"}, {"oid": "77fe9f06f6b4771d506ca47298127b3e693576b5", "url": "https://github.com/apache/geode/commit/77fe9f06f6b4771d506ca47298127b3e693576b5", "message": "GEODE-8605: small update", "committedDate": "2021-03-13T09:44:34Z", "type": "forcePushed"}, {"oid": "9f80ce7134d96bb3a8c87c6b255e2a9c28f77d3d", "url": "https://github.com/apache/geode/commit/9f80ce7134d96bb3a8c87c6b255e2a9c28f77d3d", "message": "GEODE-8605: small update", "committedDate": "2021-03-17T20:42:27Z", "type": "forcePushed"}, {"oid": "df695e4b637a669815843e5b1a181ce9fbba95ea", "url": "https://github.com/apache/geode/commit/df695e4b637a669815843e5b1a181ce9fbba95ea", "message": "GEODE-8605: small update", "committedDate": "2021-03-18T10:22:59Z", "type": "forcePushed"}, {"oid": "9430438d08a37857ec518fbb0682e99b94b72188", "url": "https://github.com/apache/geode/commit/9430438d08a37857ec518fbb0682e99b94b72188", "message": "GEODE-8605: update after rebase", "committedDate": "2021-03-30T12:21:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzMzA2NA==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604133064", "bodyText": "What is the purpose of these members and the functions to get/set them? I have not found the use in the rest of the code.", "author": "albertogpz", "createdAt": "2021-03-30T14:10:37Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -31,63 +31,201 @@\n   public static final boolean DEFAULT_IS_META_QUEUE = false;\n \n \n-  public int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n+  private int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n \n-  public int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n+  private int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n \n-  public int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n+  private int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n \n-  public int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n+  private int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n \n-  public int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n+  private int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n \n-  public boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n+  private boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n \n-  public boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n+  private boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n \n-  public int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n+  private int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n \n-  public boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n+  private boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n \n-  public String diskStoreName;\n+  private String diskStoreName;\n \n-  public List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n+  private List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n \n-  public ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n+  private ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n \n-  public List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n+  private List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n \n-  public GatewayEventSubstitutionFilter eventSubstitutionFilter;\n+  private GatewayEventSubstitutionFilter eventSubstitutionFilter;\n \n-  public String id;\n+  private String id;\n \n-  public int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n+  private int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n \n-  public LocatorDiscoveryCallback locatorDiscoveryCallback;\n+  private LocatorDiscoveryCallback locatorDiscoveryCallback;\n \n-  public boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n+  private boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n \n-  public OrderPolicy policy;\n+  private OrderPolicy policy;\n \n-  public int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n+  private int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n \n-  public int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n+  private int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n \n-  public boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n+  private boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n \n-  public boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n+  private boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n \n-  public boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n+  private boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n \n-  public boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n+  private boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n \n-  public boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n+  private boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n \n-  public boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n+  private boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n \n-  public boolean enforceThreadsConnectSameReceiver =\n+  private boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  private boolean modifyAlertThreshold = false;\n+\n+  private boolean modifyBatchSize = false;\n+\n+  private boolean modifyBatchTimeInterval = false;\n+\n+  private boolean modifyGroupTransactionEvents = false;\n+\n+  private boolean modifyGatewayEventFilter = false;\n+\n+  private boolean modifyGatewayTransportFilter = false;", "originalCommit": "9430438d08a37857ec518fbb0682e99b94b72188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIwOTc0Ng==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604209746", "bodyText": "Thanks for comments. This is not needed, since it was part of previous solution. I will remove it.", "author": "mivanac", "createdAt": "2021-03-30T15:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzMzA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNjY0MQ==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604136641", "bodyText": "How about something more compact? return gatewayEventFilters != null;", "author": "albertogpz", "createdAt": "2021-03-30T14:14:48Z", "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2689,6 +2689,12 @@ public void setOverflowDirectory(String value) {\n       return this.gatewayEventFilters;\n     }\n \n+    public boolean areGatewayEventFiltersUpdated() {\n+      if (gatewayEventFilters == null)\n+        return false;\n+      return true;", "originalCommit": "9430438d08a37857ec518fbb0682e99b94b72188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIyNzc4Nw==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604227787", "bodyText": "Thanks. Updated.", "author": "mivanac", "createdAt": "2021-03-30T15:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNjY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNzg0Mg==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604137842", "bodyText": "This line is redundant.", "author": "albertogpz", "createdAt": "2021-03-30T14:16:06Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {\n+    CacheConfig.GatewaySender gwsender = null;\n+    InternalConfigurationPersistenceService ccService =\n+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();\n+    if (ccService == null) {\n+      return null;\n+    }\n+\n+    Set<String> groups = ccService.getGroups();\n+    gwsender = null;", "originalCommit": "9430438d08a37857ec518fbb0682e99b94b72188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIyODAwMA==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604228000", "bodyText": "Thanks. Updated.", "author": "mivanac", "createdAt": "2021-03-30T15:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNzg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604172286", "bodyText": "Is it necessary that the sender is paused while the parameters are changed? If it is so, it would have to be said in the documentation. Otherwise, I would remove the pause here and in the other calls where a gateway sender parameter is changed.", "author": "albertogpz", "createdAt": "2021-03-30T14:52:25Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderOperationsDUnitTest.java", "diffHunk": "@@ -1023,6 +1238,268 @@ private void createPartitionedRegions(boolean createAccessors) {\n     vm3.invoke(() -> createPartitionedRegion(regionName, \"ln\", 1, 100, isOffHeap()));\n   }\n \n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {", "originalCommit": "9430438d08a37857ec518fbb0682e99b94b72188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIxNTI5OQ==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604215299", "bodyText": "Yes, pausing of gw sender is implemented internally as a part of command execution (see AlterGatewaySenderFunction). Since here we are using only setter, we must ensure that gw sender is paused.", "author": "mivanac", "createdAt": "2021-03-30T15:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDM3NzAzMQ==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604377031", "bodyText": "What would happen if the sender is not paused? I think the consequences should be documented.", "author": "albertogpz", "createdAt": "2021-03-30T19:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDQwNTQ2Ng==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604405466", "bodyText": "We pause gw sender to prevent any interference with running processes. This was one of comments on RFC. And I am not sure that internal handling in command execution is documented for users. But if everyone agrees that this is needed, I can add.", "author": "mivanac", "createdAt": "2021-03-30T20:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3NjkxMA==", "url": "https://github.com/apache/geode/pull/5630#discussion_r604176910", "bodyText": "Same comment as before on the ParallelGateway sender tests. If it is necessary that the gateway sender is paused while parameters are changed, that would have to be documented. Otherwise, I would remove the pause here and in the other parameter changes, below.", "author": "albertogpz", "createdAt": "2021-03-30T14:57:22Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderAlterOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static java.lang.System.currentTimeMillis;\n+import static java.util.Arrays.asList;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.cache.RegionShortcut.REPLICATE;\n+import static org.apache.geode.cache.wan.GatewaySender.DEFAULT_ORDER_POLICY;\n+import static org.apache.geode.cache.wan.GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPort;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.VM.getCurrentVMNum;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.toArray;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.junit.runners.Parameterized.UseParametersRunnerFactory;\n+\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionDestroyedException;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.cache.wan.GatewayEventFilter;\n+import org.apache.geode.cache.wan.GatewayQueueEvent;\n+import org.apache.geode.cache.wan.GatewayReceiver;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySender.OrderPolicy;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySenderEventProcessor;\n+import org.apache.geode.internal.cache.wan.GatewaySenderException;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySender;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySenderFactory;\n+import org.apache.geode.internal.cache.wan.WANTestBase;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.cache.CacheTestCase;\n+import org.apache.geode.test.junit.categories.WanTest;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;\n+\n+@Category(WanTest.class)\n+@RunWith(Parameterized.class)\n+@UseParametersRunnerFactory(CategoryWithParameterizedRunnerFactory.class)\n+@SuppressWarnings(\"serial\")\n+public class SerialGatewaySenderAlterOperationsDUnitTest extends CacheTestCase {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @Parameters(name = \"{index}: numDispatchers={0}\")\n+  public static Collection<Integer> data() {\n+    return asList(1, 3, 5);\n+  }\n+\n+  @Parameter\n+  public int numDispatchers;\n+\n+  private VM vm0;\n+  private VM vm1;\n+  private VM vm2;\n+  private VM vm3;\n+  private VM vm4;\n+  private VM vm5;\n+  private VM vm6;\n+  private VM vm7;\n+\n+  private String className;\n+\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+\n+  @Before\n+  public void setUp() {\n+    addIgnoredException(\"Broken pipe\");\n+    addIgnoredException(\"Connection refused\");\n+    addIgnoredException(\"Connection reset\");\n+    addIgnoredException(\"could not get remote locator information\");\n+    addIgnoredException(\"Software caused connection abort\");\n+    addIgnoredException(\"Unexpected IOException\");\n+\n+    className = getClass().getSimpleName();\n+\n+    vm0 = getVM(0);\n+    vm1 = getVM(1);\n+    vm2 = getVM(2);\n+    vm3 = getVM(3);\n+    vm4 = getVM(4);\n+    vm5 = getVM(5);\n+    vm6 = getVM(6);\n+    vm7 = getVM(7);\n+\n+    // Stopping the gateway closed the region, which causes this exception to get logged\n+    addIgnoredException(RegionDestroyedException.class);\n+  }\n+\n+  @Test\n+  public void testStartPauseResumeSerialGatewaySenderUpdateAttributes() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    vm4.invoke(() -> pauseSender(\"ln\"));\n+    vm5.invoke(() -> pauseSender(\"ln\"));\n+\n+    vm4.invoke(() -> validateSenderPausedState(\"ln\"));\n+    vm5.invoke(() -> validateSenderPausedState(\"ln\"));\n+\n+    vm4.invoke(() -> doPuts(className + \"_RR\", 1000));\n+\n+    updateBatchSize(50);\n+    updateBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> resumeSender(\"ln\"));\n+    vm5.invoke(() -> resumeSender(\"ln\"));\n+\n+    vm4.invoke(() -> validateSenderResumedState(\"ln\"));\n+    vm5.invoke(() -> validateSenderResumedState(\"ln\"));\n+\n+    checkBatchSize(50);\n+    checkBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+  }\n+\n+  @Test\n+  public void testSerialGatewaySenderUpdateAttributesWhilePutting() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    // Do some puts from both vm4 and vm5 while restarting a sender\n+    AsyncInvocation doPutsInVm4 =\n+        vm4.invokeAsync(() -> doPuts(className + \"_RR\", 1000));\n+\n+    updateBatchSize(50);\n+    updateBatchTimeInterval(200);\n+\n+    doPutsInVm4.await();\n+\n+    checkBatchSize(50);\n+    checkBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+  }\n+\n+  @Test\n+  public void testSerialGatewaySenderUpdateGatewayEventFiltersWhilePutting() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    List<GatewayEventFilter> filters = new ArrayList<>();\n+    filters.add(new MyGatewayEventFilter_AfterAck());\n+    filters.add(new PDXGatewayEventFilter());\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    // Do some puts from both vm4 and vm5 while restarting a sender\n+    AsyncInvocation doPutsInVm4 =\n+        vm4.invokeAsync(() -> doPuts(className + \"_RR\", 5000));\n+\n+    updateBatchSize(40);\n+    updateGatewayEventFilters(filters);\n+\n+    doPutsInVm4.await();\n+\n+    checkBatchSize(40);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 5000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 5000));\n+  }\n+\n+  protected boolean isOffHeap() {\n+    return false;\n+  }\n+\n+  protected void createSenderInVm4() throws IOException {\n+    createSender(\"ln\", 2, true, true, numDispatchers, DEFAULT_ORDER_POLICY);\n+  }\n+\n+  protected void createSenderInVm5() throws IOException {\n+    createSender(\"ln\", 2, true, true, numDispatchers, DEFAULT_ORDER_POLICY);\n+  }\n+\n+  protected final void createSender(String id,\n+      int remoteDsId,\n+      boolean isPersistent,\n+      boolean isManualStart,\n+      int numDispatchers,\n+      OrderPolicy policy) throws IOException {\n+    try (IgnoredException ie = addIgnoredException(\"Could not connect\")) {\n+      File persistentDirectory =\n+          temporaryFolder.newFolder(id + \"_disk_\" + currentTimeMillis() + \"_\" + getCurrentVMNum());\n+      DiskStoreFactory diskStoreFactory = getCache().createDiskStoreFactory();\n+      File[] dirs = new File[] {persistentDirectory};\n+\n+      InternalGatewaySenderFactory gatewaySenderFactory =\n+          (InternalGatewaySenderFactory) getCache().createGatewaySenderFactory();\n+\n+      gatewaySenderFactory.setParallel(false);\n+      gatewaySenderFactory.setMaximumQueueMemory(100);\n+      gatewaySenderFactory.setBatchSize(10);\n+      gatewaySenderFactory.setBatchConflationEnabled(false);\n+      gatewaySenderFactory.setManualStart(isManualStart);\n+      gatewaySenderFactory.setDispatcherThreads(numDispatchers);\n+      gatewaySenderFactory.setOrderPolicy(policy);\n+      gatewaySenderFactory.setSocketBufferSize(DEFAULT_SOCKET_BUFFER_SIZE);\n+\n+      if (isPersistent) {\n+        gatewaySenderFactory.setPersistenceEnabled(true);\n+        gatewaySenderFactory.setDiskStoreName(\n+            diskStoreFactory.setDiskDirs(dirs).create(id).getName());\n+      } else {\n+        DiskStore store = diskStoreFactory.setDiskDirs(dirs).create(id);\n+        gatewaySenderFactory.setDiskStoreName(store.getName());\n+      }\n+\n+      gatewaySenderFactory.create(id, remoteDsId);\n+    }\n+  }\n+\n+  private Properties getDistributedSystemProperties(int locatorPort) {\n+    Properties props = getDistributedSystemProperties();\n+    props.setProperty(MCAST_PORT, \"0\");\n+    props.setProperty(LOCATORS, \"localhost[\" + locatorPort + \"]\");\n+    return props;\n+  }\n+\n+  private void createCache(int locatorPort) {\n+    getCache(getDistributedSystemProperties(locatorPort));\n+  }\n+\n+  private void createReplicatedRegion(String regionName, String senderIds) {\n+    try (IgnoredException ie1 = addIgnoredException(ForceReattemptException.class);\n+        IgnoredException ie2 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie3 = addIgnoredException(InterruptedException.class)) {\n+      RegionFactory regionFactory = getCache().createRegionFactory(REPLICATE);\n+\n+      if (senderIds != null) {\n+        StringTokenizer tokenizer = new StringTokenizer(senderIds, \",\");\n+        while (tokenizer.hasMoreTokens()) {\n+          String senderId = tokenizer.nextToken();\n+          regionFactory.addGatewaySenderId(senderId);\n+        }\n+      }\n+\n+      regionFactory.setDataPolicy(DataPolicy.REPLICATE);\n+      regionFactory.setScope(Scope.DISTRIBUTED_ACK);\n+      regionFactory.setOffHeap(isOffHeap());\n+\n+      regionFactory.create(regionName);\n+    }\n+  }\n+\n+  private void doPuts(String regionName, int count) {\n+    try (IgnoredException ie1 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie2 = addIgnoredException(InterruptedException.class)) {\n+      Region<Number, String> region = getCache().getRegion(SEPARATOR + regionName);\n+      for (int i = 0; i < count; i++) {\n+        region.put(i, \"Value_\" + i);\n+      }\n+    }\n+  }\n+\n+  private void doPuts(String regionName, int from, int count) {\n+    Region<Number, String> region = getCache().getRegion(SEPARATOR + regionName);\n+    for (int i = from; i < count; i++) {\n+      region.put(i, \"Value_\" + i);\n+    }\n+  }\n+\n+  private int createFirstLocatorWithDSId(int systemId) {\n+    stopOldLocator();\n+    int locatorPort = getRandomAvailableTCPPort();\n+    startLocator(systemId, locatorPort, locatorPort, -1, true);\n+    return locatorPort;\n+  }\n+\n+  private int createFirstRemoteLocator(int systemId, int remoteLocatorPort) {\n+    stopOldLocator();\n+    int locatorPort = getRandomAvailableTCPPort();\n+    startLocator(systemId, locatorPort, locatorPort, remoteLocatorPort, true);\n+    return locatorPort;\n+  }\n+\n+  private void startLocator(int systemId, int locatorPort, int startLocatorPort,\n+      int remoteLocatorPort, boolean startServerLocator) {\n+    Properties props = getDistributedSystemProperties();\n+\n+    props.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(systemId));\n+    props.setProperty(MCAST_PORT, \"0\");\n+    props.setProperty(LOCATORS, \"localhost[\" + locatorPort + \"]\");\n+    props.setProperty(START_LOCATOR, \"localhost[\" + startLocatorPort + \"],server=\"\n+        + startServerLocator + \",peer=true,hostname-for-clients=localhost\");\n+\n+    if (remoteLocatorPort != -1) {\n+      props.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + \"]\");\n+    }\n+\n+    // Start start the locator with a LOCATOR_DM_TYPE and not a NORMAL_DM_TYPE\n+    System.setProperty(InternalLocator.FORCE_LOCATOR_DM_TYPE, \"true\");\n+    try {\n+      getSystem(props);\n+    } finally {\n+      System.clearProperty(InternalLocator.FORCE_LOCATOR_DM_TYPE);\n+    }\n+  }\n+\n+  private void stopOldLocator() {\n+    if (Locator.hasLocator()) {\n+      Locator.getLocator().stop();\n+    }\n+  }\n+\n+  private InternalGatewaySender findInternalGatewaySender(String senderId) {\n+    return (InternalGatewaySender) findGatewaySender(senderId, true);\n+  }\n+\n+  private GatewaySender findGatewaySender(String senderId) {\n+    return findGatewaySender(senderId, true);\n+  }\n+\n+  private GatewaySender findGatewaySender(String senderId, boolean assertNotNull) {\n+    Set<GatewaySender> senders = getCache().getGatewaySenders();\n+    GatewaySender sender = null;\n+    for (GatewaySender s : senders) {\n+      if (s.getId().equals(senderId)) {\n+        sender = s;\n+        break;\n+      }\n+    }\n+\n+    if (assertNotNull) {\n+      assertThat(sender).isNotNull();\n+    }\n+\n+    return sender;\n+  }\n+\n+  private void startSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class);\n+        IgnoredException ie3 = addIgnoredException(InterruptedException.class)) {\n+      findGatewaySender(senderId).start();\n+    }\n+  }\n+\n+  private void pauseSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+      sender.pause();\n+      sender.getEventProcessor().waitForDispatcherToPause();\n+    }\n+  }\n+\n+  private void resumeSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      findGatewaySender(senderId).resume();\n+    }\n+  }\n+\n+  private void stopSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+\n+      AbstractGatewaySenderEventProcessor eventProcessor = sender.getEventProcessor();\n+\n+      sender.stop();\n+\n+      if (eventProcessor instanceof ConcurrentSerialGatewaySenderEventProcessor) {\n+        ConcurrentSerialGatewaySenderEventProcessor concurrentEventProcessor =\n+            (ConcurrentSerialGatewaySenderEventProcessor) eventProcessor;\n+        Set<RegionQueue> queues = concurrentEventProcessor.getQueues();\n+        for (RegionQueue queue : queues) {\n+          if (queue instanceof SerialGatewaySenderQueue) {\n+            assertThat(((SerialGatewaySenderQueue) queue).isRemovalThreadAlive())\n+                .isFalse();\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private int createReceiver() throws IOException {\n+    int receiverPort = getRandomAvailableTCPPort();\n+\n+    GatewayReceiverFactory gatewayReceiverFactory = getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setStartPort(receiverPort);\n+    gatewayReceiverFactory.setEndPort(receiverPort);\n+    gatewayReceiverFactory.setManualStart(true);\n+\n+    GatewayReceiver receiver = gatewayReceiverFactory.create();\n+    receiver.start();\n+\n+    return receiverPort;\n+  }\n+\n+  private void validateRegionSize(String regionName, int regionSize) {\n+    try (IgnoredException ie1 = addIgnoredException(CacheClosedException.class);\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      Region region = getCache().getRegion(SEPARATOR + regionName);\n+\n+      await()\n+          .untilAsserted(() -> {\n+            assertThat(region.keySet()).hasSize(regionSize);\n+          });\n+    }\n+  }\n+\n+  private void validateQueueContents(String senderId, int regionSize) {\n+    try (IgnoredException ie1 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie2 = addIgnoredException(InterruptedException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+\n+      if (sender.isParallel()) {\n+        RegionQueue regionQueue = sender.getQueues().toArray(new RegionQueue[1])[0];\n+        await()\n+            .untilAsserted(() -> {\n+              assertThat(regionQueue.size())\n+                  .isEqualTo(regionSize);\n+            });\n+\n+      } else {\n+        Set<RegionQueue> queues = sender.getQueues();\n+        await()\n+            .untilAsserted(() -> {\n+              int size = 0;\n+              for (RegionQueue queue : queues) {\n+                size += queue.size();\n+              }\n+              assertThat(size)\n+                  .isEqualTo(regionSize);\n+            });\n+      }\n+    }\n+  }\n+\n+  private void validateSenderPausedState(String senderId) {\n+    GatewaySender sender = findGatewaySender(senderId);\n+\n+    assertThat(sender.isPaused())\n+        .isTrue();\n+  }\n+\n+  private void validateSenderResumedState(String senderId) {\n+    GatewaySender sender = findGatewaySender(senderId);\n+\n+    assertThat(sender.isPaused())\n+        .isFalse();\n+    assertThat(sender.isRunning())\n+        .isTrue();\n+  }\n+\n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {\n+        sender.pause();\n+        paused = true;", "originalCommit": "9430438d08a37857ec518fbb0682e99b94b72188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTA5MTY1MQ==", "url": "https://github.com/apache/geode/pull/5630#discussion_r605091651", "bodyText": "Can this be renamed to findGatewaySenderConfiguration or something more explicit?", "author": "boglesby", "createdAt": "2021-03-31T17:34:04Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {", "originalCommit": "174e17590ffb320f23d9a5fba706e739f409fc40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTA5MTc5Mg==", "url": "https://github.com/apache/geode/pull/5630#discussion_r605091792", "bodyText": "This cast is not necessary.", "author": "boglesby", "createdAt": "2021-03-31T17:34:17Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {\n+    CacheConfig.GatewaySender gwsender = null;\n+    InternalConfigurationPersistenceService ccService =\n+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();", "originalCommit": "174e17590ffb320f23d9a5fba706e739f409fc40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg3ODUwNw==", "url": "https://github.com/apache/geode/pull/5630#discussion_r605878507", "bodyText": "A new way to do this is to use ClassName[]. The gfsh parser will parse the comma separated list and any initialization json and put them into this ClassName array for you. See AlterRegionCommand for examples.", "author": "jinmeiliao", "createdAt": "2021-04-01T18:56:26Z", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,", "originalCommit": "174e17590ffb320f23d9a5fba706e739f409fc40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTM1NzUzOA==", "url": "https://github.com/apache/geode/pull/5630#discussion_r609357538", "bodyText": "Thanks for comments. Updated.", "author": "mivanac", "createdAt": "2021-04-08T06:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg3ODUwNw=="}], "type": "inlineReview"}, {"oid": "ad87607ef90248b63d999749b2df0da8a9d129ab", "url": "https://github.com/apache/geode/commit/ad87607ef90248b63d999749b2df0da8a9d129ab", "message": "GEODE-8605: Alter Gateway Sender command", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "8015da3bf0c5e925ddea533bb9c526a881265424", "url": "https://github.com/apache/geode/commit/8015da3bf0c5e925ddea533bb9c526a881265424", "message": "GEODE-8605: fix for failing integration test", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "dd1886c9430c19c5b3577c1008123bcdd8b5e1b4", "url": "https://github.com/apache/geode/commit/dd1886c9430c19c5b3577c1008123bcdd8b5e1b4", "message": "GEODE-8605: added distributed test", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "9b2ca734617883dd0391a6976e69fb17de8b4f23", "url": "https://github.com/apache/geode/commit/9b2ca734617883dd0391a6976e69fb17de8b4f23", "message": "GEODE-8605: update stability of distributed tests", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "538737cd5305271e2d5045da4ff8392072144eeb", "url": "https://github.com/apache/geode/commit/538737cd5305271e2d5045da4ff8392072144eeb", "message": "GEODE-8605: added documentation impacts", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "745efbf72edad6275e1afb65fb495ee343cb0781", "url": "https://github.com/apache/geode/commit/745efbf72edad6275e1afb65fb495ee343cb0781", "message": "GEODE-8605: added test for new function", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "d2c58e5758ed715ddbb34587638cab79deb9d95a", "url": "https://github.com/apache/geode/commit/d2c58e5758ed715ddbb34587638cab79deb9d95a", "message": "GEODE-8605: added filter test", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "80409500ab7ba5c08a2c8203bff60cdfa8e7c1b5", "url": "https://github.com/apache/geode/commit/80409500ab7ba5c08a2c8203bff60cdfa8e7c1b5", "message": "GEODE-8605: update after comments", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "09f491d08d94ec91ba3a9b802fb75806c60abab9", "url": "https://github.com/apache/geode/commit/09f491d08d94ec91ba3a9b802fb75806c60abab9", "message": "GEODE-8605: update solution", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "c9d2bf4a7f71317528a71c019158e0d871eb69e2", "url": "https://github.com/apache/geode/commit/c9d2bf4a7f71317528a71c019158e0d871eb69e2", "message": "GEODE-8605: add test for parallel gw sender", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "05fb8c0bf2c9b80a41ef9178abb5f76ab7176f5c", "url": "https://github.com/apache/geode/commit/05fb8c0bf2c9b80a41ef9178abb5f76ab7176f5c", "message": "GEODE-8605: added setters instead of update", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "c9caceb72e00fa77d4226e449c6f9d28abd908d4", "url": "https://github.com/apache/geode/commit/c9caceb72e00fa77d4226e449c6f9d28abd908d4", "message": "GEODE-8605: added ParallelGatewaySender tests", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "2d9af7eee77c6c99cb982977028071a2bac49d71", "url": "https://github.com/apache/geode/commit/2d9af7eee77c6c99cb982977028071a2bac49d71", "message": "GEODE-8605: added test for SerialGatewaySender", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "e0c356cdf5f5631e08e2f10ac0c9e045401702cb", "url": "https://github.com/apache/geode/commit/e0c356cdf5f5631e08e2f10ac0c9e045401702cb", "message": "GEODE-8605: update solution", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "d240f9f961c2a5aaf5cf49933ec036ebbcbe1658", "url": "https://github.com/apache/geode/commit/d240f9f961c2a5aaf5cf49933ec036ebbcbe1658", "message": "GEODE-8605: add option to remove gateway-event-filters", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "b1d8158bf5d6088a47842081bc4e57c7c368697c", "url": "https://github.com/apache/geode/commit/b1d8158bf5d6088a47842081bc4e57c7c368697c", "message": "GEODE-8605: update of remove filters solution", "committedDate": "2021-04-02T07:42:08Z", "type": "commit"}, {"oid": "2b2dcfbfacb550905a76be70c5859a472c8b3266", "url": "https://github.com/apache/geode/commit/2b2dcfbfacb550905a76be70c5859a472c8b3266", "message": "GEODE-8605: rebase solution", "committedDate": "2021-04-02T07:42:09Z", "type": "commit"}, {"oid": "f4901476d7fa830dbe7d555d5fbb40d3b23eb884", "url": "https://github.com/apache/geode/commit/f4901476d7fa830dbe7d555d5fbb40d3b23eb884", "message": "GEODE-8605: added serialVersionUID to GatewaySender", "committedDate": "2021-04-02T07:42:09Z", "type": "commit"}, {"oid": "0abfae9d3630139ea775d75f97ab39b3b7a286ca", "url": "https://github.com/apache/geode/commit/0abfae9d3630139ea775d75f97ab39b3b7a286ca", "message": "GEODE-8605: added test case", "committedDate": "2021-04-02T07:42:09Z", "type": "commit"}, {"oid": "7dae1cff7debe0c80e915dbdc2bdade33a0499ea", "url": "https://github.com/apache/geode/commit/7dae1cff7debe0c80e915dbdc2bdade33a0499ea", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender", "committedDate": "2021-04-02T07:42:09Z", "type": "commit"}, {"oid": "7e1e38dbcce30c12bfc923713f27d5f1294034f3", "url": "https://github.com/apache/geode/commit/7e1e38dbcce30c12bfc923713f27d5f1294034f3", "message": "GEODE-8605: add setters to GatewaySenderAttributes", "committedDate": "2021-04-02T07:42:09Z", "type": "commit"}, {"oid": "8d5ebbec6bfdca4fb24f4c9a1a69de74b3a91ac4", "url": "https://github.com/apache/geode/commit/8d5ebbec6bfdca4fb24f4c9a1a69de74b3a91ac4", "message": "GEODE-8605: small update", "committedDate": "2021-04-02T07:42:09Z", "type": "commit"}, {"oid": "31b00db23e56b19d0d8d639901d232903229e703", "url": "https://github.com/apache/geode/commit/31b00db23e56b19d0d8d639901d232903229e703", "message": "GEODE-8605: update after rebase", "committedDate": "2021-04-02T07:42:10Z", "type": "commit"}, {"oid": "e60ac37d8736337af5964628fab3057f6e68eb3f", "url": "https://github.com/apache/geode/commit/e60ac37d8736337af5964628fab3057f6e68eb3f", "message": "GEODE-8605: update after comments", "committedDate": "2021-04-02T07:42:10Z", "type": "commit"}, {"oid": "0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "url": "https://github.com/apache/geode/commit/0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "message": "GEODE-8605: update after comments without atomic change", "committedDate": "2021-04-02T17:46:16Z", "type": "commit"}, {"oid": "0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "url": "https://github.com/apache/geode/commit/0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "message": "GEODE-8605: update after comments without atomic change", "committedDate": "2021-04-02T17:46:16Z", "type": "forcePushed"}]}