{"pr_number": 5257, "pr_title": "GEODE-8251: make sure Configuration can be deserialized post 1.12.", "pr_createdAt": "2020-06-16T17:43:43Z", "pr_url": "https://github.com/apache/geode/pull/5257", "timeline": [{"oid": "244adb718b26d4ca477feffc319fc45cfabbd38e", "url": "https://github.com/apache/geode/commit/244adb718b26d4ca477feffc319fc45cfabbd38e", "message": "GEODE-8251: make sure Configuration can be deserialized post 1.12.\n\nCo-authoried-by: Alberto Gomez <alberto.gomez@est.tech>", "committedDate": "2020-06-17T00:25:11Z", "type": "commit"}, {"oid": "1a0cbbf9339d75b8c48c4d99399367720463bb8a", "url": "https://github.com/apache/geode/commit/1a0cbbf9339d75b8c48c4d99399367720463bb8a", "message": "fix test", "committedDate": "2020-06-17T00:25:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MjU2Mw==", "url": "https://github.com/apache/geode/pull/5257#discussion_r441382563", "bodyText": "Why start from this version? Is the upgrade from previous versions not supported?", "author": "albertogpz", "createdAt": "2020-06-17T08:43:45Z", "path": "geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeWithGfshDUnitTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.rollingupgrade;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import org.apache.geode.internal.UniquePortSupplier;\n+import org.apache.geode.test.compiler.ClassBuilder;\n+import org.apache.geode.test.junit.categories.BackwardCompatibilityTest;\n+import org.apache.geode.test.junit.rules.gfsh.GfshExecution;\n+import org.apache.geode.test.junit.rules.gfsh.GfshRule;\n+import org.apache.geode.test.junit.rules.gfsh.GfshScript;\n+import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;\n+import org.apache.geode.test.version.TestVersion;\n+import org.apache.geode.test.version.VersionManager;\n+\n+/**\n+ * This test iterates through the versions of Geode and executes client compatibility with\n+ * the current version of Geode.\n+ */\n+@Category({BackwardCompatibilityTest.class})\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(CategoryWithParameterizedRunnerFactory.class)\n+public class RollingUpgradeWithGfshDUnitTest {\n+  private final UniquePortSupplier portSupplier = new UniquePortSupplier();\n+  private final String oldVersion;\n+\n+  @Parameterized.Parameters(name = \"{0}\")\n+  public static Collection<String> data() {\n+    List<String> result = VersionManager.getInstance().getVersionsWithoutCurrent();\n+    result.removeIf(s -> TestVersion.compare(s, \"1.10.0\") < 0);", "originalCommit": "3d586cf3beefc5f4aab4e226fbb27539aaf1b60e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4NjQxNA==", "url": "https://github.com/apache/geode/pull/5257#discussion_r441586414", "bodyText": "There is no change in the the Configuration object except in 1.12, so only to test a few version before it and after it. Start from 1.10 just to save a few test cycles, but we can test the previous ones.", "author": "jinmeiliao", "createdAt": "2020-06-17T14:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MjU2Mw=="}], "type": "inlineReview"}, {"oid": "95d42c7ba902d0c29e2f1ad32b7496a1a632d650", "url": "https://github.com/apache/geode/commit/95d42c7ba902d0c29e2f1ad32b7496a1a632d650", "message": "only provide the environemnt variable in upgrade tests", "committedDate": "2020-06-17T17:27:07Z", "type": "forcePushed"}, {"oid": "1e5eef5e378b331dcfe73148f8b18cc1b30627ae", "url": "https://github.com/apache/geode/commit/1e5eef5e378b331dcfe73148f8b18cc1b30627ae", "message": "only provide the environemnt variable in upgrade tests", "committedDate": "2020-06-17T18:25:31Z", "type": "commit"}, {"oid": "1e5eef5e378b331dcfe73148f8b18cc1b30627ae", "url": "https://github.com/apache/geode/commit/1e5eef5e378b331dcfe73148f8b18cc1b30627ae", "message": "only provide the environemnt variable in upgrade tests", "committedDate": "2020-06-17T18:25:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5OTM5Nw==", "url": "https://github.com/apache/geode/pull/5257#discussion_r442399397", "bodyText": "You accidentally have the license header in this class twice.", "author": "kirklund", "createdAt": "2020-06-18T17:47:48Z", "path": "geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeWithGfshDUnitTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.rollingupgrade;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license", "originalCommit": "1e5eef5e378b331dcfe73148f8b18cc1b30627ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMTc5MQ==", "url": "https://github.com/apache/geode/pull/5257#discussion_r442401791", "bodyText": "Is there a subclass? I'd like to see these protected methods be private if possible.", "author": "kirklund", "createdAt": "2020-06-18T17:52:02Z", "path": "geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeWithGfshDUnitTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.rollingupgrade;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import org.apache.geode.internal.UniquePortSupplier;\n+import org.apache.geode.test.compiler.ClassBuilder;\n+import org.apache.geode.test.junit.categories.BackwardCompatibilityTest;\n+import org.apache.geode.test.junit.rules.gfsh.GfshExecution;\n+import org.apache.geode.test.junit.rules.gfsh.GfshRule;\n+import org.apache.geode.test.junit.rules.gfsh.GfshScript;\n+import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;\n+import org.apache.geode.test.version.TestVersion;\n+import org.apache.geode.test.version.VersionManager;\n+\n+/**\n+ * This test iterates through the versions of Geode and executes client compatibility with\n+ * the current version of Geode.\n+ */\n+@Category({BackwardCompatibilityTest.class})\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(CategoryWithParameterizedRunnerFactory.class)\n+public class RollingUpgradeWithGfshDUnitTest {\n+  private final UniquePortSupplier portSupplier = new UniquePortSupplier();\n+  private final String oldVersion;\n+\n+  @Parameterized.Parameters(name = \"{0}\")\n+  public static Collection<String> data() {\n+    List<String> result = VersionManager.getInstance().getVersionsWithoutCurrent();\n+    result.removeIf(s -> TestVersion.compare(s, \"1.10.0\") < 0);\n+    return result;\n+  }\n+\n+  @Rule\n+  public GfshRule oldGfsh;\n+\n+  @Rule\n+  public GfshRule currentGfsh = new GfshRule();\n+\n+  @Rule\n+  public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  public RollingUpgradeWithGfshDUnitTest(String version) {\n+    oldVersion = version;\n+    oldGfsh = new GfshRule(oldVersion);\n+  }\n+\n+  @Test\n+  public void testRollingUpgradeWithDeployment() throws Exception {\n+    int locatorPort = portSupplier.getAvailablePort();\n+    int locatorJmxPort = portSupplier.getAvailablePort();\n+    int locator2Port = portSupplier.getAvailablePort();\n+    int locator2JmxPort = portSupplier.getAvailablePort();\n+    int server1Port = portSupplier.getAvailablePort();\n+    int server2Port = portSupplier.getAvailablePort();\n+\n+    GfshExecution startupExecution =\n+        GfshScript.of(startLocatorCommand(\"loc1\", locatorPort, locatorJmxPort, -1))\n+            .and(startLocatorCommand(\"loc2\", locator2Port, locator2JmxPort, locatorPort))\n+            .and(startServerCommand(\"server1\", server1Port, locatorPort))\n+            .and(startServerCommand(\"server2\", server2Port, locatorPort))\n+            .and(deployDirCommand())\n+            .execute(oldGfsh);\n+\n+    // doing rolling upgrades\n+    oldGfsh.stopLocator(startupExecution, \"loc1\");\n+    GfshScript.of(startLocatorCommand(\"loc1\", locatorPort, locatorJmxPort, locator2Port))\n+        .execute(currentGfsh);\n+    verifyListDeployed(locatorPort);\n+\n+    oldGfsh.stopLocator(startupExecution, \"loc2\");\n+    GfshScript.of(startLocatorCommand(\"loc2\", locator2Port, locator2JmxPort, locatorPort))\n+        .execute(currentGfsh);\n+    verifyListDeployed(locator2Port);\n+\n+    // make sure servers can do rolling upgrade too\n+    oldGfsh.stopServer(startupExecution, \"server1\");\n+    GfshScript.of(startServerCommand(\"server1\", server1Port, locatorPort)).execute(currentGfsh);\n+\n+    oldGfsh.stopServer(startupExecution, \"server2\");\n+    GfshScript.of(startServerCommand(\"server2\", server2Port, locatorPort)).execute(currentGfsh);\n+  }\n+\n+  private void verifyListDeployed(int locatorPort) {\n+    GfshExecution list_deployed = GfshScript.of(\"connect --locator=localhost[\" + locatorPort + \"]\")\n+        .and(\"list deployed\").execute(currentGfsh);\n+    assertThat(list_deployed.getOutputText()).contains(\"DeployCommandsDUnit1.jar\")\n+        .contains(\"server1\").contains(\"server2\");\n+    currentGfsh.execute(\"disconnect\");\n+  }\n+\n+  private String deployDirCommand() throws IOException {\n+    ClassBuilder classBuilder = new ClassBuilder();\n+    File jarsDir = tempFolder.newFolder();\n+    String jarName1 = \"DeployCommandsDUnit1.jar\";\n+    File jar1 = new File(jarsDir, jarName1);\n+    String class1 = \"DeployCommandsDUnitA\";\n+    classBuilder.writeJarFromName(class1, jar1);\n+    return \"deploy --dir=\" + jarsDir.getAbsolutePath();\n+  }\n+\n+  protected String startServerCommand(String name, int port, int connectedLocatorPort) {", "originalCommit": "1e5eef5e378b331dcfe73148f8b18cc1b30627ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMjg4OQ==", "url": "https://github.com/apache/geode/pull/5257#discussion_r442402889", "bodyText": "Optional: all JDK classes put serialVersionUID at the bottom of the class. I usually do this to try and be consistent but obviously doesn't matter much.", "author": "kirklund", "createdAt": "2020-06-18T17:54:00Z", "path": "geode-management/src/main/java/org/apache/geode/management/configuration/AbstractConfiguration.java", "diffHunk": "@@ -47,7 +47,7 @@\n @Experimental\n public abstract class AbstractConfiguration<R extends RuntimeInfo>\n     implements Identifiable<String>, JsonSerializable {\n-\n+  private static final long serialVersionUID = -6612840641128145954L;", "originalCommit": "1e5eef5e378b331dcfe73148f8b18cc1b30627ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "14c087c0f6da7f9cfeffe49acad42ef3ad70feaa", "url": "https://github.com/apache/geode/commit/14c087c0f6da7f9cfeffe49acad42ef3ad70feaa", "message": "review udpates", "committedDate": "2020-06-18T20:45:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTk5OQ==", "url": "https://github.com/apache/geode/pull/5257#discussion_r442519999", "bodyText": "Will it actually start listening on a random available port, because it is set to 0?", "author": "jchen21", "createdAt": "2020-06-18T21:45:43Z", "path": "geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java", "diffHunk": "@@ -1185,6 +1185,8 @@ Properties getLocatorProperties(String locatorsString, boolean enableCC) {\n     props.setProperty(DistributionConfig.LOCATORS_NAME, locatorsString);\n     props.setProperty(DistributionConfig.LOG_LEVEL_NAME, DUnitLauncher.logLevel);\n     props.setProperty(DistributionConfig.ENABLE_CLUSTER_CONFIGURATION_NAME, enableCC + \"\");\n+    // do not start http service to avoid port conflict between upgrade tests\n+    props.setProperty(DistributionConfig.HTTP_SERVICE_PORT_NAME, \"0\");", "originalCommit": "14c087c0f6da7f9cfeffe49acad42ef3ad70feaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzEzMg==", "url": "https://github.com/apache/geode/pull/5257#discussion_r442533132", "bodyText": "here 0 means do not start.", "author": "jinmeiliao", "createdAt": "2020-06-18T22:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODIxMw==", "url": "https://github.com/apache/geode/pull/5257#discussion_r442528213", "bodyText": "Better verifyListDeployed after rolling upgrade the servers.", "author": "jchen21", "createdAt": "2020-06-18T22:06:43Z", "path": "geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeWithGfshDUnitTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.rollingupgrade;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import org.apache.geode.internal.UniquePortSupplier;\n+import org.apache.geode.test.compiler.ClassBuilder;\n+import org.apache.geode.test.junit.categories.BackwardCompatibilityTest;\n+import org.apache.geode.test.junit.rules.gfsh.GfshExecution;\n+import org.apache.geode.test.junit.rules.gfsh.GfshRule;\n+import org.apache.geode.test.junit.rules.gfsh.GfshScript;\n+import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;\n+import org.apache.geode.test.version.TestVersion;\n+import org.apache.geode.test.version.VersionManager;\n+\n+/**\n+ * This test iterates through the versions of Geode and executes client compatibility with\n+ * the current version of Geode.\n+ */\n+@Category({BackwardCompatibilityTest.class})\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(CategoryWithParameterizedRunnerFactory.class)\n+public class RollingUpgradeWithGfshDUnitTest {\n+  private final UniquePortSupplier portSupplier = new UniquePortSupplier();\n+  private final String oldVersion;\n+\n+  @Parameterized.Parameters(name = \"{0}\")\n+  public static Collection<String> data() {\n+    List<String> result = VersionManager.getInstance().getVersionsWithoutCurrent();\n+    result.removeIf(s -> TestVersion.compare(s, \"1.10.0\") < 0);\n+    return result;\n+  }\n+\n+  @Rule\n+  public GfshRule oldGfsh;\n+\n+  @Rule\n+  public GfshRule currentGfsh = new GfshRule();\n+\n+  @Rule\n+  public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  public RollingUpgradeWithGfshDUnitTest(String version) {\n+    oldVersion = version;\n+    oldGfsh = new GfshRule(oldVersion);\n+  }\n+\n+  @Test\n+  public void testRollingUpgradeWithDeployment() throws Exception {\n+    int locatorPort = portSupplier.getAvailablePort();\n+    int locatorJmxPort = portSupplier.getAvailablePort();\n+    int locator2Port = portSupplier.getAvailablePort();\n+    int locator2JmxPort = portSupplier.getAvailablePort();\n+    int server1Port = portSupplier.getAvailablePort();\n+    int server2Port = portSupplier.getAvailablePort();\n+\n+    GfshExecution startupExecution =\n+        GfshScript.of(startLocatorCommand(\"loc1\", locatorPort, locatorJmxPort, -1))\n+            .and(startLocatorCommand(\"loc2\", locator2Port, locator2JmxPort, locatorPort))\n+            .and(startServerCommand(\"server1\", server1Port, locatorPort))\n+            .and(startServerCommand(\"server2\", server2Port, locatorPort))\n+            .and(deployDirCommand())\n+            .execute(oldGfsh);\n+\n+    // doing rolling upgrades\n+    oldGfsh.stopLocator(startupExecution, \"loc1\");\n+    GfshScript.of(startLocatorCommand(\"loc1\", locatorPort, locatorJmxPort, locator2Port))\n+        .execute(currentGfsh);\n+    verifyListDeployed(locatorPort);\n+\n+    oldGfsh.stopLocator(startupExecution, \"loc2\");\n+    GfshScript.of(startLocatorCommand(\"loc2\", locator2Port, locator2JmxPort, locatorPort))\n+        .execute(currentGfsh);\n+    verifyListDeployed(locator2Port);\n+\n+    // make sure servers can do rolling upgrade too\n+    oldGfsh.stopServer(startupExecution, \"server1\");\n+    GfshScript.of(startServerCommand(\"server1\", server1Port, locatorPort)).execute(currentGfsh);", "originalCommit": "14c087c0f6da7f9cfeffe49acad42ef3ad70feaa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}