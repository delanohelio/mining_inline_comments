{"pr_number": 5623, "pr_title": "GEODE-8607: Adding some test API to get oldest tombstone", "pr_createdAt": "2020-10-14T17:01:07Z", "pr_url": "https://github.com/apache/geode/pull/5623", "timeline": [{"oid": "ff4295f40f418dcae801ced1cbd245872158e3c8", "url": "https://github.com/apache/geode/commit/ff4295f40f418dcae801ced1cbd245872158e3c8", "message": "GEODE-8607: Adding some test API to get oldest tombstone", "committedDate": "2020-10-14T16:59:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzODUzNQ==", "url": "https://github.com/apache/geode/pull/5623#discussion_r504938535", "bodyText": "The peek could return null...\nWill it be a good enough to return version timestamp instead of delta...The caller can calculate delta with different time mechanism (using cacheTime or currentTime).\nAlso, will it be helpful if the tombstone.toString() info is returned...It has all the information associated with tombstone.", "author": "agingade", "createdAt": "2020-10-14T20:01:22Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/TombstoneService.java", "diffHunk": "@@ -450,6 +450,11 @@ boolean testHook_forceExpiredTombstoneGC(int count, long timeout, TimeUnit unit)\n \n     @Override\n     protected void beforeSleepChecks() {}\n+\n+    @Override\n+    public long getOldestTombstoneTimeDelta() {\n+      return tombstones.peek().getVersionTimeStamp() - cacheTime.cacheTimeMillis();", "originalCommit": "ff4295f40f418dcae801ced1cbd245872158e3c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2OTU2Ng==", "url": "https://github.com/apache/geode/pull/5623#discussion_r504969566", "bodyText": "I figured that it was one extra step that will always be done, but I will change it.", "author": "mhansonp", "createdAt": "2020-10-14T21:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzODUzNQ=="}], "type": "inlineReview"}, {"oid": "9e297c7a2f020a0071ac842691c59ee77dfd9e19", "url": "https://github.com/apache/geode/commit/9e297c7a2f020a0071ac842691c59ee77dfd9e19", "message": "GEODE-8607: Cleanup of tests to get rid of deprecation", "committedDate": "2020-10-16T19:08:45Z", "type": "commit"}, {"oid": "e854c8901923dbae5448eba07ee1a8d822d4eb6c", "url": "https://github.com/apache/geode/commit/e854c8901923dbae5448eba07ee1a8d822d4eb6c", "message": "GEODE-8607: new method to only get timestamp", "committedDate": "2020-10-16T20:45:15Z", "type": "commit"}, {"oid": "ff24efa3cb5bf059cab74bfa2420a170dc795df9", "url": "https://github.com/apache/geode/commit/ff24efa3cb5bf059cab74bfa2420a170dc795df9", "message": "GEODE-8607: Minor cleanup, to make the new test like the old", "committedDate": "2020-10-16T21:05:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1MzE3Mg==", "url": "https://github.com/apache/geode/pull/5623#discussion_r509453172", "bodyText": "Change the test name to start with lower-case test?", "author": "kirklund", "createdAt": "2020-10-21T17:02:47Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/versions/TombstoneDUnitTest.java", "diffHunk": "@@ -15,127 +15,226 @@\n package org.apache.geode.internal.cache.versions;\n \n import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.Assert.assertEquals;\n \n import java.io.Serializable;\n+import java.util.Arrays;\n import java.util.Properties;\n import java.util.concurrent.CountDownLatch;\n \n+import org.junit.After;\n+import org.junit.Rule;\n import org.junit.Test;\n \n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n import org.apache.geode.cache.Region;\n import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n import org.apache.geode.distributed.internal.ClusterDistributionManager;\n import org.apache.geode.distributed.internal.DistributionMessage;\n import org.apache.geode.distributed.internal.DistributionMessageObserver;\n import org.apache.geode.internal.cache.DestroyOperation;\n import org.apache.geode.internal.cache.DistributedTombstoneOperation;\n+import org.apache.geode.internal.cache.InternalCache;\n import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TombstoneService;\n import org.apache.geode.test.dunit.AsyncInvocation;\n-import org.apache.geode.test.dunit.Host;\n+import org.apache.geode.test.dunit.NetworkUtils;\n import org.apache.geode.test.dunit.VM;\n-import org.apache.geode.test.dunit.cache.internal.JUnit4CacheTestCase;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n \n \n-public class TombstoneDUnitTest extends JUnit4CacheTestCase {\n+public class TombstoneDUnitTest implements Serializable {\n+  private static final long serialVersionUID = 2992716917694662945L;\n+  private static Cache cache;\n+  private static Region<String, String> region;\n+  final String REGION_NAME = \"TestRegion\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @After\n+  public void close() {\n+    for (VM vm : Arrays.asList(VM.getVM(0), VM.getVM(1))) {\n+      vm.invoke(() -> {\n+        region = null;\n+        if (cache != null) {\n+          cache.close();\n+        }\n+      });\n+    }\n+  }\n \n   @Test\n-  public void testTombstoneGcMessagesBetweenPersistnentAndNonPersistentRegion() {\n-    Host host = Host.getHost(0);\n-    VM vm0 = host.getVM(0);\n-    VM vm1 = host.getVM(1);\n+  public void testTombstoneGcMessagesBetweenPersistentAndNonPersistentRegion() {\n+    VM vm0 = VM.getVM(0);\n+    VM vm1 = VM.getVM(1);\n \n     vm0.invoke(() -> {\n-      createRegion(\"TestRegion\", true);\n-      Region<String, String> region = getCache().getRegion(\"TestRegion\");\n+      createCacheAndRegion(RegionShortcut.REPLICATE_PERSISTENT);\n       region.put(\"K1\", \"V1\");\n       region.put(\"K2\", \"V2\");\n     });\n \n-    vm1.invoke(() -> {\n-      createRegion(\"TestRegion\", false);\n-    });\n+    vm1.invoke(() -> createCacheAndRegion(RegionShortcut.REPLICATE));\n \n     vm0.invoke(() -> {\n       // Send tombstone gc message to vm1.\n-      Region<String, String> region = getCache().getRegion(\"TestRegion\");\n       region.destroy(\"K1\");\n-      assertEquals(1, getGemfireCache().getCachePerfStats().getTombstoneCount());\n-      performGC();\n+      assertEquals(1, ((InternalCache) cache).getCachePerfStats().getTombstoneCount());\n+      performGC(1);\n     });\n \n     vm1.invoke(() -> {\n       // After processing tombstone message from vm0. The tombstone count should be 0.\n       waitForTombstoneCount(0);\n-      assertEquals(0, getGemfireCache().getCachePerfStats().getTombstoneCount());\n+      assertEquals(0, ((InternalCache) cache).getCachePerfStats().getTombstoneCount());\n \n       // Send tombstone gc message to vm0.\n-      Region<String, String> region = getCache().getRegion(\"TestRegion\");\n       region.destroy(\"K2\");\n-      performGC();\n+      performGC(1);\n     });\n \n     vm0.invoke(() -> {\n       // After processing tombstone message from vm0. The tombstone count should be 0.\n       waitForTombstoneCount(0);\n-      assertEquals(0, getGemfireCache().getCachePerfStats().getTombstoneCount());\n+      assertEquals(0, ((InternalCache) cache).getCachePerfStats().getTombstoneCount());\n     });\n   }\n \n   @Test\n-  public void testTombstonesWithLowerVersionThanTheRecordedVersionGetsGCed() throws Exception {\n-    Host host = Host.getHost(0);\n-    VM vm0 = host.getVM(0);\n-    VM vm1 = host.getVM(1);\n+  public void TestGetOldestTombstoneTimeReplicate() {", "originalCommit": "ff24efa3cb5bf059cab74bfa2420a170dc795df9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1MzU3OA==", "url": "https://github.com/apache/geode/pull/5623#discussion_r509453578", "bodyText": "props.setProperty is more correct than using the Map interface method put.", "author": "kirklund", "createdAt": "2020-10-21T17:03:28Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/versions/TombstoneDUnitTest.java", "diffHunk": "@@ -15,127 +15,226 @@\n package org.apache.geode.internal.cache.versions;\n \n import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.Assert.assertEquals;\n \n import java.io.Serializable;\n+import java.util.Arrays;\n import java.util.Properties;\n import java.util.concurrent.CountDownLatch;\n \n+import org.junit.After;\n+import org.junit.Rule;\n import org.junit.Test;\n \n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n import org.apache.geode.cache.Region;\n import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n import org.apache.geode.distributed.internal.ClusterDistributionManager;\n import org.apache.geode.distributed.internal.DistributionMessage;\n import org.apache.geode.distributed.internal.DistributionMessageObserver;\n import org.apache.geode.internal.cache.DestroyOperation;\n import org.apache.geode.internal.cache.DistributedTombstoneOperation;\n+import org.apache.geode.internal.cache.InternalCache;\n import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TombstoneService;\n import org.apache.geode.test.dunit.AsyncInvocation;\n-import org.apache.geode.test.dunit.Host;\n+import org.apache.geode.test.dunit.NetworkUtils;\n import org.apache.geode.test.dunit.VM;\n-import org.apache.geode.test.dunit.cache.internal.JUnit4CacheTestCase;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n \n \n-public class TombstoneDUnitTest extends JUnit4CacheTestCase {\n+public class TombstoneDUnitTest implements Serializable {\n+  private static final long serialVersionUID = 2992716917694662945L;\n+  private static Cache cache;\n+  private static Region<String, String> region;\n+  final String REGION_NAME = \"TestRegion\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @After\n+  public void close() {\n+    for (VM vm : Arrays.asList(VM.getVM(0), VM.getVM(1))) {\n+      vm.invoke(() -> {\n+        region = null;\n+        if (cache != null) {\n+          cache.close();\n+        }\n+      });\n+    }\n+  }\n \n   @Test\n-  public void testTombstoneGcMessagesBetweenPersistnentAndNonPersistentRegion() {\n-    Host host = Host.getHost(0);\n-    VM vm0 = host.getVM(0);\n-    VM vm1 = host.getVM(1);\n+  public void testTombstoneGcMessagesBetweenPersistentAndNonPersistentRegion() {\n+    VM vm0 = VM.getVM(0);\n+    VM vm1 = VM.getVM(1);\n \n     vm0.invoke(() -> {\n-      createRegion(\"TestRegion\", true);\n-      Region<String, String> region = getCache().getRegion(\"TestRegion\");\n+      createCacheAndRegion(RegionShortcut.REPLICATE_PERSISTENT);\n       region.put(\"K1\", \"V1\");\n       region.put(\"K2\", \"V2\");\n     });\n \n-    vm1.invoke(() -> {\n-      createRegion(\"TestRegion\", false);\n-    });\n+    vm1.invoke(() -> createCacheAndRegion(RegionShortcut.REPLICATE));\n \n     vm0.invoke(() -> {\n       // Send tombstone gc message to vm1.\n-      Region<String, String> region = getCache().getRegion(\"TestRegion\");\n       region.destroy(\"K1\");\n-      assertEquals(1, getGemfireCache().getCachePerfStats().getTombstoneCount());\n-      performGC();\n+      assertEquals(1, ((InternalCache) cache).getCachePerfStats().getTombstoneCount());\n+      performGC(1);\n     });\n \n     vm1.invoke(() -> {\n       // After processing tombstone message from vm0. The tombstone count should be 0.\n       waitForTombstoneCount(0);\n-      assertEquals(0, getGemfireCache().getCachePerfStats().getTombstoneCount());\n+      assertEquals(0, ((InternalCache) cache).getCachePerfStats().getTombstoneCount());\n \n       // Send tombstone gc message to vm0.\n-      Region<String, String> region = getCache().getRegion(\"TestRegion\");\n       region.destroy(\"K2\");\n-      performGC();\n+      performGC(1);\n     });\n \n     vm0.invoke(() -> {\n       // After processing tombstone message from vm0. The tombstone count should be 0.\n       waitForTombstoneCount(0);\n-      assertEquals(0, getGemfireCache().getCachePerfStats().getTombstoneCount());\n+      assertEquals(0, ((InternalCache) cache).getCachePerfStats().getTombstoneCount());\n     });\n   }\n \n   @Test\n-  public void testTombstonesWithLowerVersionThanTheRecordedVersionGetsGCed() throws Exception {\n-    Host host = Host.getHost(0);\n-    VM vm0 = host.getVM(0);\n-    VM vm1 = host.getVM(1);\n+  public void TestGetOldestTombstoneTimeReplicate() {\n+    VM server1 = VM.getVM(0);\n+    VM server2 = VM.getVM(1);\n+\n+    server1.invoke(() -> {\n+      createCacheAndRegion(RegionShortcut.REPLICATE_PERSISTENT);\n+      region.put(\"K1\", \"V1\");\n+      region.put(\"K2\", \"V2\");\n+    });\n+\n+    server2.invoke(() -> createCacheAndRegion(RegionShortcut.REPLICATE));\n+\n+    server1.invoke(() -> {\n+      // Send tombstone gc message to vm1.\n+      region.destroy(\"K1\");\n+\n+      TombstoneService.TombstoneSweeper tombstoneSweeper =\n+          ((InternalCache) cache).getTombstoneService().getSweeper((LocalRegion) region);\n+\n+      assertThat(tombstoneSweeper.getOldestTombstoneTime()).isGreaterThan(0)\n+          .isLessThan(((InternalCache) cache).cacheTimeMillis());\n+      performGC(1);\n+      assertThat(tombstoneSweeper.getOldestTombstoneTime()).isEqualTo(0);\n+    });\n+  }\n+\n+  @Test\n+  public void TestGetOldestTombstoneTimeNonReplicate() {\n+    VM client = VM.getVM(0);\n+    VM server = VM.getVM(1);\n+\n+    // Fire up the server and put in some data that is deletable\n+    server.invoke(() -> {\n+      createCacheAndRegion(RegionShortcut.REPLICATE);\n+      cache.addCacheServer().start();\n+      for (int i = 0; i < 1000; i++) {\n+        region.put(\"K\" + i, \"V\" + i);\n+      }\n+    });\n \n-    createCache(vm0);\n-    createCache(vm1);\n+    String locatorHost = NetworkUtils.getServerHostName();\n+    int locatorPort = DistributedRule.getLocatorPort();\n+    // Use the client to remove and entry, thus creating a tombstone\n+    client.invoke(() -> {\n+      createClientCacheAndRegion(locatorHost, locatorPort);\n+      region.remove(\"K3\");\n+    });\n+\n+    // Validate that a tombstone was created and that it has a timestamp that is valid,\n+    // Then GC and validate there is no oldest tombstone.\n+    server.invoke(() -> {\n+      TombstoneService.TombstoneSweeper tombstoneSweeper =\n+          ((InternalCache) cache).getTombstoneService().getSweeper((LocalRegion) region);\n+\n+      assertThat(tombstoneSweeper.getOldestTombstoneTime()).isGreaterThan(0)\n+          .isLessThan(((InternalCache) cache).cacheTimeMillis());\n+      performGC(1);\n+      assertThat(tombstoneSweeper.getOldestTombstoneTime()).isEqualTo(0);\n+    });\n+  }\n+\n+  @Test\n+  public void testTombstonesWithLowerVersionThanTheRecordedVersionGetsGCed() throws Exception {\n+    VM vm0 = VM.getVM(0);\n+    VM vm1 = VM.getVM(1);\n+    Properties props = DistributedRule.getDistributedSystemProperties();\n+    props.put(\"conserve-sockets\", \"false\");", "originalCommit": "ff24efa3cb5bf059cab74bfa2420a170dc795df9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2f0a27b5d9bb5f605c02ade51e0e5b552eb91355", "url": "https://github.com/apache/geode/commit/2f0a27b5d9bb5f605c02ade51e0e5b552eb91355", "message": "GEODE-8607: new code for getting the oldest tombstone", "committedDate": "2020-10-21T17:22:00Z", "type": "commit"}]}