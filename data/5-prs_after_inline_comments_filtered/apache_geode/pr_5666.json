{"pr_number": 5666, "pr_title": "GEODE-8652: Allow NioSslEngine.close() to Bypass Locks", "pr_createdAt": "2020-10-24T00:45:33Z", "pr_url": "https://github.com/apache/geode/pull/5666", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMxMzYzNQ==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512313635", "bodyText": "no need to modify SocketCloser.java in this pr", "author": "dschneider-pivotal", "createdAt": "2020-10-26T22:45:51Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/SocketCloser.java", "diffHunk": "@@ -41,6 +44,7 @@\n  * This max threads can be configured using the \"p2p.ASYNC_CLOSE_POOL_MAX_THREADS\" system property.\n  */\n public class SocketCloser {\n+  private static final Logger logger = LogService.getLogger();", "originalCommit": "bb722678b005675f9bc2d7fab6f862215fd9f987", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NzEzMw==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512967133", "bodyText": "removed this unneeded log line", "author": "Bill", "createdAt": "2020-10-27T19:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMxMzYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4Nzc0OA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512787748", "bodyText": "the return value from this method is never used", "author": "bschuchardt", "createdAt": "2020-10-27T15:24:24Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/ByteBufferSharingImpl.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.net;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.internal.net.BufferPool.BufferType;\n+\n+/**\n+ * An {@link AutoCloseable} meant to be acquired in a try-with-resources statement. The resource (a\n+ * {@link ByteBuffer}) is available (for reading and modification) in the scope of the\n+ * try-with-resources.\n+ */\n+class ByteBufferSharingImpl implements ByteBufferSharing {\n+\n+  static class LockAttemptTimedOut extends Exception {\n+  }\n+\n+  private final Lock lock;\n+  private final AtomicBoolean isClosed;\n+  // mutable because in general our ByteBuffer may need to be resized (grown or compacted)\n+  private ByteBuffer buffer;\n+  private final BufferType bufferType;\n+  private final AtomicInteger counter;\n+  private final BufferPool bufferPool;\n+\n+  /**\n+   * This constructor is for use only by the owner of the shared resource (a {@link ByteBuffer}).\n+   *\n+   * A resource owner must invoke {@link #alias()} once for each reference that escapes (is passed\n+   * to an external object or is returned to an external caller.)\n+   *\n+   * This constructor acquires no lock. The reference count will be 1 after this constructor\n+   * completes.\n+   */\n+  ByteBufferSharingImpl(final ByteBuffer buffer, final BufferType bufferType,\n+      final BufferPool bufferPool) {\n+    this.buffer = buffer;\n+    this.bufferType = bufferType;\n+    this.bufferPool = bufferPool;\n+    lock = new ReentrantLock();\n+    counter = new AtomicInteger(1);\n+    isClosed = new AtomicBoolean(false);\n+  }\n+\n+  /**\n+   * The destructor. Called by the resource owner to undo the work of the constructor.\n+   */\n+  void destruct() {\n+    if (isClosed.compareAndSet(false, true)) {\n+      dropReference();\n+    }\n+  }\n+\n+  /**\n+   * This method is for use only by the owner of the shared resource. It's used for handing out\n+   * references to the shared resource. So it does reference counting and also acquires a lock.\n+   *\n+   * Resource owners call this method as the last thing before returning a reference to the caller.\n+   * That caller binds that reference to a variable in a try-with-resources statement and relies on\n+   * the AutoCloseable protocol to invoke close() on the object at the end of the block.\n+   */\n+  ByteBufferSharing alias() {\n+    lock.lock();\n+    addReference();\n+    return this;\n+  }\n+\n+  /**\n+   * This variant throws {@link LockAttemptTimedOut} if it can't acquire the lock in time.\n+   */\n+  ByteBufferSharing alias(final long time, final TimeUnit unit) throws LockAttemptTimedOut {\n+    try {\n+      if (!lock.tryLock(time, unit)) {\n+        throw new LockAttemptTimedOut();\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new LockAttemptTimedOut();\n+    }\n+    addReference();\n+    return this;\n+  }\n+\n+  @Override\n+  public ByteBuffer getBuffer() throws IOException {\n+    if (isClosed.get()) {\n+      throw new IOException(\"NioSslEngine has been closed\");\n+    } else {\n+      return buffer;\n+    }\n+  }\n+\n+  @Override\n+  public ByteBuffer expandWriteBufferIfNeeded(final int newCapacity) throws IOException {\n+    return buffer = bufferPool.expandWriteBufferIfNeeded(bufferType, getBuffer(), newCapacity);\n+  }\n+\n+  @Override\n+  public void close() {\n+    dropReference();\n+    lock.unlock();\n+  }\n+\n+  private int addReference() {\n+    return counter.incrementAndGet();\n+  }\n+\n+  private int dropReference() {", "originalCommit": "e04624cefb29974f550579c347ea601c0f9dd86e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc5NDI1Ng==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512794256", "bodyText": "If the buffer is released to the BufferPool shouldn't this impl be marked as \"closed\"?", "author": "bschuchardt", "createdAt": "2020-10-27T15:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4Nzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkzMzk0Nw==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512933947", "bodyText": "This is a private method. We know, in this method, that if usages == 0 that destruct() has been called (in the past), since: the constructor started us with counter.get() == 1 and addReference() is called for every alias call.\nBecause we know destruct has been called we know that isClosed.get() is already true.", "author": "Bill", "createdAt": "2020-10-27T18:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4Nzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2NTgyNA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r514565824", "bodyText": "What @bschuchardt's comment made me concerned about, is the prospect of a \"client\" of a ByteBufferSharing (ByteBufferSharingImpl particularly), calling close() too many times i.e. more than once.\nTurns our there was a bug there. In the version of the code he commented on, if a client called close() twice then the reference count was decremented on the second call, even though it was already 0 (leaving it at -1.) You can imagine the bad things that happen in that state.\nThe latest commit adds a test for this bug (ByteBufferSharingImplTest) and also fixes the bug.", "author": "Bill", "createdAt": "2020-10-29T21:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4Nzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxMDU1Mw==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512810553", "bodyText": "Can we name this something more pertinent, like \"createReference\"?  The name \"alias\" doesn't tell me that this method is creating a reference that needs to be released.", "author": "bschuchardt", "createdAt": "2020-10-27T15:49:37Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/ByteBufferSharingImpl.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.net;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.internal.net.BufferPool.BufferType;\n+\n+/**\n+ * An {@link AutoCloseable} meant to be acquired in a try-with-resources statement. The resource (a\n+ * {@link ByteBuffer}) is available (for reading and modification) in the scope of the\n+ * try-with-resources.\n+ */\n+class ByteBufferSharingImpl implements ByteBufferSharing {\n+\n+  static class LockAttemptTimedOut extends Exception {\n+  }\n+\n+  private final Lock lock;\n+  private final AtomicBoolean isClosed;\n+  // mutable because in general our ByteBuffer may need to be resized (grown or compacted)\n+  private ByteBuffer buffer;\n+  private final BufferType bufferType;\n+  private final AtomicInteger counter;\n+  private final BufferPool bufferPool;\n+\n+  /**\n+   * This constructor is for use only by the owner of the shared resource (a {@link ByteBuffer}).\n+   *\n+   * A resource owner must invoke {@link #alias()} once for each reference that escapes (is passed\n+   * to an external object or is returned to an external caller.)\n+   *\n+   * This constructor acquires no lock. The reference count will be 1 after this constructor\n+   * completes.\n+   */\n+  ByteBufferSharingImpl(final ByteBuffer buffer, final BufferType bufferType,\n+      final BufferPool bufferPool) {\n+    this.buffer = buffer;\n+    this.bufferType = bufferType;\n+    this.bufferPool = bufferPool;\n+    lock = new ReentrantLock();\n+    counter = new AtomicInteger(1);\n+    isClosed = new AtomicBoolean(false);\n+  }\n+\n+  /**\n+   * The destructor. Called by the resource owner to undo the work of the constructor.\n+   */\n+  void destruct() {\n+    if (isClosed.compareAndSet(false, true)) {\n+      dropReference();\n+    }\n+  }\n+\n+  /**\n+   * This method is for use only by the owner of the shared resource. It's used for handing out\n+   * references to the shared resource. So it does reference counting and also acquires a lock.\n+   *\n+   * Resource owners call this method as the last thing before returning a reference to the caller.\n+   * That caller binds that reference to a variable in a try-with-resources statement and relies on\n+   * the AutoCloseable protocol to invoke close() on the object at the end of the block.\n+   */\n+  ByteBufferSharing alias() {", "originalCommit": "e04624cefb29974f550579c347ea601c0f9dd86e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NzYyMw==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512967623", "bodyText": "renamed open() for symmetry with close()", "author": "Bill", "createdAt": "2020-10-27T19:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxMDU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxMzU4MA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512813580", "bodyText": "please address this new TODO", "author": "bschuchardt", "createdAt": "2020-10-27T15:52:57Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -315,50 +317,48 @@ public ByteBuffer ensureWrappedCapacity(int amount, ByteBuffer wrappedBuffer,\n   }\n \n   @Override\n-  public ByteBuffer readAtLeast(SocketChannel channel, int bytes,\n+  public ByteBufferSharing readAtLeast(SocketChannel channel, int bytes,\n       ByteBuffer wrappedBuffer) throws IOException {\n-    if (peerAppData.capacity() > bytes) {\n-      // we already have a buffer that's big enough\n-      if (peerAppData.capacity() - peerAppData.position() < bytes) {\n-        peerAppData.compact();\n-        peerAppData.flip();\n-      }\n-    }\n+    try (final ByteBufferSharing inputSharing = shareInputBuffer()) {\n \n-    while (peerAppData.remaining() < bytes) {\n-      wrappedBuffer.limit(wrappedBuffer.capacity());\n-      int amountRead = channel.read(wrappedBuffer);\n-      if (amountRead < 0) {\n-        throw new EOFException();\n+      ByteBuffer peerAppData = inputSharing.getBuffer();\n+\n+      if (peerAppData.capacity() > bytes) {\n+        // we already have a buffer that's big enough\n+        if (peerAppData.capacity() - peerAppData.position() < bytes) {\n+          peerAppData.compact();\n+          peerAppData.flip();\n+        }\n       }\n-      if (amountRead > 0) {\n-        wrappedBuffer.flip();\n-        // prep the decoded buffer for writing\n-        peerAppData.compact();\n-        peerAppData = unwrap(wrappedBuffer);\n-        // done writing to the decoded buffer - prep it for reading again\n-        peerAppData.flip();\n+\n+      while (peerAppData.remaining() < bytes) {\n+        wrappedBuffer.limit(wrappedBuffer.capacity());\n+        int amountRead = channel.read(wrappedBuffer);\n+        if (amountRead < 0) {\n+          throw new EOFException();\n+        }\n+        if (amountRead > 0) {\n+          wrappedBuffer.flip();\n+          // prep the decoded buffer for writing\n+          peerAppData.compact();\n+          try (final ByteBufferSharing inputSharing2 = unwrap(wrappedBuffer)) {\n+            // done writing to the decoded buffer - prep it for reading again\n+            final ByteBuffer peerAppDataNew = inputSharing2.getBuffer();\n+            peerAppDataNew.flip();\n+            peerAppData = peerAppDataNew; // loop needs new reference!\n+          }\n+        }\n       }\n+      return shareInputBuffer();\n     }\n-    return peerAppData;\n   }\n \n   @Override\n-  public ByteBuffer getUnwrappedBuffer(ByteBuffer wrappedBuffer) {\n-    return peerAppData;\n-  }\n-\n-  /**\n-   * ensures that the unwrapped buffer associated with the given wrapped buffer has\n-   * sufficient capacity for the given amount of bytes. This may compact the\n-   * buffer or it may return a new buffer.\n-   */\n-  public ByteBuffer ensureUnwrappedCapacity(int amount) {\n-    // for TTLS the app-data buffers do not need to be tracked direct-buffers since we\n-    // do not use them for I/O operations\n-    peerAppData =\n-        bufferPool.expandReadBufferIfNeeded(TRACKED_RECEIVER, peerAppData, amount);\n-    return peerAppData;\n+  public ByteBufferSharing getUnwrappedBuffer(ByteBuffer wrappedBuffer) {\n+    /*\n+     * TODO: it can't be right that we ignore the wrappedBuffer parameter here!", "originalCommit": "e04624cefb29974f550579c347ea601c0f9dd86e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2Nzk4MA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512967980", "bodyText": "Resolved and removed. We eliminated the parameter entirely.", "author": "Bill", "createdAt": "2020-10-27T19:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxMzU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxNjUwMg==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512816502", "bodyText": "I like how you've removed the need for this method", "author": "bschuchardt", "createdAt": "2020-10-27T15:56:17Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -368,17 +368,15 @@ public void doneReadingDirectAck(ByteBuffer unwrappedBuffer) {\n     // read-operations\n   }\n \n-  @Override", "originalCommit": "e04624cefb29974f550579c347ea601c0f9dd86e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2OTA2MA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r512969060", "bodyText": "thanks!", "author": "Bill", "createdAt": "2020-10-27T19:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxNjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzA1NQ==", "url": "https://github.com/apache/geode/pull/5666#discussion_r513623055", "bodyText": "This method should throw an exception, not return a ByteBufferSharing with a null buffer.", "author": "bschuchardt", "createdAt": "2020-10-28T17:16:40Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioPlainEngine.java", "diffHunk": "@@ -121,8 +121,12 @@ public void doneReading(ByteBuffer unwrappedBuffer) {\n   }\n \n   @Override\n-  public ByteBuffer getUnwrappedBuffer(ByteBuffer wrappedBuffer) {\n-    return wrappedBuffer;\n+  public ByteBufferSharing getUnwrappedBuffer() {\n+    return shareBuffer(null);", "originalCommit": "834481296e35735218e5fa9310e774ed9ff5b223", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NTU4Nw==", "url": "https://github.com/apache/geode/pull/5666#discussion_r513655587", "bodyText": "This suggestion seems intuitive enough, however, where this is called from Connection.readAck() we rely on the current \"no-op\" behavior. If we were to throw here then it would break readAck() using the NioPlainEngine.\nThe only other place we call getUnwrappedBuffer() is from clearSSLInputBuffer() and in that case we know we are dealing with the NioSslEngine (not the NioPlainEngine.) We considered moving this method from the interface to the (NioSslEngine) implementation (and leaving it off NioPlainEngine entirely.) That would have been fine for clearSSLInputBuffer but would have left us with ugliness in the readAck() call site.", "author": "Bill", "createdAt": "2020-10-28T18:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNDMxOA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r513804318", "bodyText": "can you have it wrap an empty buffer instead of null?", "author": "bschuchardt", "createdAt": "2020-10-28T22:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2OTkzMA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r514569930", "bodyText": "done!", "author": "Bill", "createdAt": "2020-10-29T21:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzA1NQ=="}], "type": "inlineReview"}, {"oid": "b0a257f473d8c16b8a91148942edb40066c00de8", "url": "https://github.com/apache/geode/commit/b0a257f473d8c16b8a91148942edb40066c00de8", "message": "GEODE-8652: NioSslEngine.close() to Bypasses Locks\n\n- NioSslEngine.close() to proceed even if readers (or writers) are\n  operating on its ByteBuffers, allowing Connection.close() to close\n  its socket and proceed.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>", "committedDate": "2020-10-28T17:39:39Z", "type": "commit"}, {"oid": "b0a257f473d8c16b8a91148942edb40066c00de8", "url": "https://github.com/apache/geode/commit/b0a257f473d8c16b8a91148942edb40066c00de8", "message": "GEODE-8652: NioSslEngine.close() to Bypasses Locks\n\n- NioSslEngine.close() to proceed even if readers (or writers) are\n  operating on its ByteBuffers, allowing Connection.close() to close\n  its socket and proceed.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>", "committedDate": "2020-10-28T17:39:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDk0OA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r513984948", "bodyText": "Will this \"synchronized\" sync with wrap() method's shareOutputBuffer?\nwrap() and close() have to sync with each other, otherwise it will encounter bug Gem-3116.", "author": "gesterzhou", "createdAt": "2020-10-29T05:29:28Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -368,17 +365,15 @@ public void doneReadingDirectAck(ByteBuffer unwrappedBuffer) {\n     // read-operations\n   }\n \n-  @Override\n-  public synchronized boolean isClosed() {\n-    return closed;\n-  }\n-\n   @Override\n   public synchronized void close(SocketChannel socketChannel) {", "originalCommit": "b0a257f473d8c16b8a91148942edb40066c00de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4MTU1Mg==", "url": "https://github.com/apache/geode/pull/5666#discussion_r514581552", "bodyText": "The close() method is a critical section. And after a thread has exited that critical section, the next thread entering it will skip all the actual close logic.\nThere is no possible interference between the close logic and e.g. wrap(), specifically in their use of the output buffer a.k.a. myNetData (the ByteBuffer managed by outputSharing) because both wrap() and close() acquire a reference to that buffer via ByteBufferSharingImpl.open() and ByteBufferSharingImpl.open(long time, TimeUnit unit) respectively. Those methods call lock()/tryLock(long time, TimeUnit unit) on the ReentrantLock before returning.\nDoes that help?", "author": "Bill", "createdAt": "2020-10-29T21:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDk0OA=="}], "type": "inlineReview"}, {"oid": "c44db3f68f108ebebecbc36391a70489b4743d82", "url": "https://github.com/apache/geode/commit/c44db3f68f108ebebecbc36391a70489b4743d82", "message": "added tests", "committedDate": "2020-10-29T20:52:12Z", "type": "commit"}, {"oid": "7d30664795920a72ba02d0d969b64ef7943a9b36", "url": "https://github.com/apache/geode/commit/7d30664795920a72ba02d0d969b64ef7943a9b36", "message": "embed empty ByteBuffer instead of null", "committedDate": "2020-10-29T21:09:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5OTE2MQ==", "url": "https://github.com/apache/geode/pull/5666#discussion_r514599161", "bodyText": "i appreciate the buffer naming with their respective directions\nmaybe in the future this decoration can be extended to the uses of peerAppData and 'myNetData`  just to reduce cognitive load and increase readability", "author": "echobravopapa", "createdAt": "2020-10-29T22:16:23Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -40,48 +40,48 @@\n import org.apache.logging.log4j.Logger;\n \n import org.apache.geode.GemFireIOException;\n-import org.apache.geode.annotations.internal.MakeImmutable;\n+import org.apache.geode.annotations.VisibleForTesting;\n import org.apache.geode.internal.net.BufferPool.BufferType;\n+import org.apache.geode.internal.net.ByteBufferSharingImpl.OpenAttemptTimedOut;\n import org.apache.geode.logging.internal.log4j.api.LogService;\n \n \n /**\n- * NioSslEngine uses an SSLEngine to bind SSL logic to a data source. This class is not thread\n- * safe. Its use should be confined to one thread or should be protected by external\n- * synchronization.\n+ * NioSslEngine uses an SSLEngine to bind SSL logic to a data source. This class is not thread safe.\n+ * Its use should be confined to one thread or should be protected by external synchronization.\n  */\n public class NioSslEngine implements NioFilter {\n   private static final Logger logger = LogService.getLogger();\n \n-  // this variable requires the MakeImmutable annotation but the buffer is empty and\n-  // not really modifiable\n-  @MakeImmutable\n-  private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);\n-\n   private final BufferPool bufferPool;\n \n   private boolean closed;\n \n   SSLEngine engine;\n \n   /**\n-   * myNetData holds bytes wrapped by the SSLEngine\n+   * holds bytes wrapped by the SSLEngine; a.k.a. myNetData", "originalCommit": "7d30664795920a72ba02d0d969b64ef7943a9b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMDUwOA==", "url": "https://github.com/apache/geode/pull/5666#discussion_r514600508", "bodyText": "this probably warrants a comment for posterity...", "author": "echobravopapa", "createdAt": "2020-10-29T22:19:57Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -368,17 +365,15 @@ public void doneReadingDirectAck(ByteBuffer unwrappedBuffer) {\n     // read-operations\n   }\n \n-  @Override\n-  public synchronized boolean isClosed() {\n-    return closed;\n-  }\n-\n   @Override\n   public synchronized void close(SocketChannel socketChannel) {\n     if (closed) {\n       return;\n     }\n-    try {\n+    closed = true;\n+    inputSharing.destruct();\n+    try (final ByteBufferSharing outputSharing = shareOutputBuffer(1, TimeUnit.MINUTES)) {", "originalCommit": "7d30664795920a72ba02d0d969b64ef7943a9b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMDkxMQ==", "url": "https://github.com/apache/geode/pull/5666#discussion_r514600911", "bodyText": "much cleaner, like it!", "author": "echobravopapa", "createdAt": "2020-10-29T22:20:57Z", "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -405,14 +400,13 @@ public synchronized void close(SocketChannel socketChannel) {\n       // we can't send a close message if the channel is closed\n     } catch (IOException e) {\n       throw new GemFireIOException(\"exception closing SSL session\", e);\n+    } catch (final OpenAttemptTimedOut _unused) {\n+      logger.info(String.format(\"Couldn't get output lock in time, eliding TLS close message\"));\n+      if (!engine.isOutboundDone()) {\n+        engine.closeOutbound();\n+      }\n     } finally {\n-      ByteBuffer netData = myNetData;\n-      ByteBuffer appData = peerAppData;\n-      myNetData = null;\n-      peerAppData = EMPTY_BUFFER;\n-      bufferPool.releaseBuffer(TRACKED_SENDER, netData);\n-      bufferPool.releaseBuffer(TRACKED_RECEIVER, appData);\n-      this.closed = true;\n+      outputSharing.destruct();", "originalCommit": "7d30664795920a72ba02d0d969b64ef7943a9b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}