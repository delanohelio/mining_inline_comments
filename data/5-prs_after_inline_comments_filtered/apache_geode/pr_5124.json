{"pr_number": 5124, "pr_title": "GEODE-7678 (2nd PR) - Support for cache-listener and client-notification for Partitioned Region Clear operation ", "pr_createdAt": "2020-05-15T23:19:05Z", "pr_url": "https://github.com/apache/geode/pull/5124", "timeline": [{"oid": "efe4cf8fa2b058263d6b5eb010d88b2affa1aec8", "url": "https://github.com/apache/geode/commit/efe4cf8fa2b058263d6b5eb010d88b2affa1aec8", "message": "GEODE-7678: Add support for cache listener and client notification for PR clear\n\nThe changes are made to PR clear messaging and locking mechanism to preserve\ncache-listener and client-events ordering during concurrent cache operation\nwhile clear in progress.", "committedDate": "2020-05-15T22:12:51Z", "type": "commit"}, {"oid": "2b733af0783157203469a61964121c0e6f6c83fb", "url": "https://github.com/apache/geode/commit/2b733af0783157203469a61964121c0e6f6c83fb", "message": "run spotlessApply", "committedDate": "2020-05-15T22:14:55Z", "type": "commit"}, {"oid": "f3161e2174d097e1703fcf04230f3f8d8261d449", "url": "https://github.com/apache/geode/commit/f3161e2174d097e1703fcf04230f3f8d8261d449", "message": "Add new message class into serializer text.\nAdd check for client interests with local filter.", "committedDate": "2020-05-15T22:15:33Z", "type": "commit"}, {"oid": "d83b4b68fc85907e8772b287c223fad24d228732", "url": "https://github.com/apache/geode/commit/d83b4b68fc85907e8772b287c223fad24d228732", "message": "Handle member departure during clear.\nAdded wait for secondary buckets to become primary.", "committedDate": "2020-05-15T22:16:07Z", "type": "commit"}, {"oid": "bd2a582acf74c1488a6bacddd43e0207ed1f6194", "url": "https://github.com/apache/geode/commit/bd2a582acf74c1488a6bacddd43e0207ed1f6194", "message": "Incorporate review comments.\nAdd PartitionedRegionPartialClearException.java\nAdd check to verify primary buckets are available for all the local secondary buckets before clear.", "committedDate": "2020-05-15T22:29:19Z", "type": "commit"}, {"oid": "35f377954254acc4ee97a13c982b1df733f41663", "url": "https://github.com/apache/geode/commit/35f377954254acc4ee97a13c982b1df733f41663", "message": "run spA", "committedDate": "2020-05-15T22:30:23Z", "type": "commit"}, {"oid": "b861b9cf498fe92f770358744b935cd7be1e97b5", "url": "https://github.com/apache/geode/commit/b861b9cf498fe92f770358744b935cd7be1e97b5", "message": "Add review comments\nAdd validation to check the buckets cleared after clear completed on all nodes.\nThrow CacheWriterException during netSearch timeout failure with cache write.", "committedDate": "2020-05-15T22:32:58Z", "type": "commit"}, {"oid": "77b8493cea70d4e076cdd10212acc17b0debd777", "url": "https://github.com/apache/geode/commit/77b8493cea70d4e076cdd10212acc17b0debd777", "message": "Remove unused fields", "committedDate": "2020-05-15T22:33:28Z", "type": "commit"}, {"oid": "8b40cf029c3c1afbab3a161283a4c09e04ec7225", "url": "https://github.com/apache/geode/commit/8b40cf029c3c1afbab3a161283a4c09e04ec7225", "message": "Remove processException() which was just invoking method from super class.", "committedDate": "2020-05-15T22:33:45Z", "type": "commit"}, {"oid": "e68cc4f3293dfc37712b8795e1052ae8effa8646", "url": "https://github.com/apache/geode/commit/e68cc4f3293dfc37712b8795e1052ae8effa8646", "message": "Changes based on review comments", "committedDate": "2020-05-15T22:34:13Z", "type": "commit"}, {"oid": "8922c0180ca5fd37873bff3e8acc5d8ba38a871a", "url": "https://github.com/apache/geode/commit/8922c0180ca5fd37873bff3e8acc5d8ba38a871a", "message": "Resolve merge issue", "committedDate": "2020-05-15T22:52:31Z", "type": "commit"}, {"oid": "a69c94d76878033cb798a83720ef70326a3523c1", "url": "https://github.com/apache/geode/commit/a69c94d76878033cb798a83720ef70326a3523c1", "message": "Add review comments", "committedDate": "2020-05-15T23:13:57Z", "type": "commit"}, {"oid": "79be7df81e200c9eadef151b361d0d1468a16bb4", "url": "https://github.com/apache/geode/commit/79be7df81e200c9eadef151b361d0d1468a16bb4", "message": "Split test to persistent and non-persistent", "committedDate": "2020-05-16T04:14:36Z", "type": "commit"}, {"oid": "ee106f8d2e3c7badd8d1d6e3b58784f4435a4db6", "url": "https://github.com/apache/geode/commit/ee106f8d2e3c7badd8d1d6e3b58784f4435a4db6", "message": "run spA", "committedDate": "2020-05-16T04:18:55Z", "type": "commit"}, {"oid": "988f1f61a70bfda29f565e1421df705473554e78", "url": "https://github.com/apache/geode/commit/988f1f61a70bfda29f565e1421df705473554e78", "message": "Changes to restart the PR pipeline", "committedDate": "2020-05-18T19:13:01Z", "type": "commit"}, {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "url": "https://github.com/apache/geode/commit/845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "message": "Change the expected destroy events.", "committedDate": "2020-05-19T01:08:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2ODg0OA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427468848", "bodyText": "Should this line be uncommented or removed?", "author": "jchen21", "createdAt": "2020-05-19T17:19:13Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/PRCacheListenerDistributedTest.java", "diffHunk": "@@ -38,28 +45,60 @@\n @SuppressWarnings(\"serial\")\n public class PRCacheListenerDistributedTest extends ReplicateCacheListenerDistributedTest {\n \n-  @Parameters(name = \"{index}: redundancy={0}\")\n-  public static Iterable<Integer> data() {\n-    return Arrays.asList(0, 3);\n+  @Parameters\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(new Object[][] {\n+        {1, Boolean.FALSE},\n+        // {3, Boolean.TRUE},", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwODA5Ng==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427608096", "bodyText": "Good catch. Have uncommented the test param.", "author": "agingade", "createdAt": "2020-05-19T21:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2ODg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjE1NQ==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427476155", "bodyText": "I am not sure why we need a new reference here.", "author": "jchen21", "createdAt": "2020-05-19T17:30:17Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithExpirationDUnitTest.java", "diffHunk": "@@ -408,22 +394,21 @@ public void clearShouldFailWhenCoordinatorMemberIsBouncedAndExpirationTasksShoul\n   @TestCaseName(\"[{index}] {method}(Coordinator:{0}, RegionType:{1})\")\n   public void clearShouldSucceedAndRemoveRegisteredExpirationTasksWhenNonCoordinatorMemberIsBounced(\n       TestVM coordinatorVM, RegionShortcut regionShortcut) {\n-    final int entries = 1500;\n+    final int entries = 500;\n+\n+    RegionShortcut rs = regionShortcut;", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNTQyNQ==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427615425", "bodyText": "The lambda expression later in the code expects the passed parameters to be final.", "author": "agingade", "createdAt": "2020-05-19T21:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Nzk4MA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427477980", "bodyText": "I think you mean It's instead of Its.", "author": "jchen21", "createdAt": "2020-05-19T17:33:03Z", "path": "geode-core/src/main/java/org/apache/geode/cache/Region.java", "diffHunk": "@@ -1302,7 +1302,10 @@ Object selectValue(String queryPredicate) throws FunctionDomainException, TypeMi\n    * @see java.util.Map#clear()\n    * @see CacheListener#afterRegionClear\n    * @see CacheWriter#beforeRegionClear\n-   * @throws UnsupportedOperationException If the region is a partitioned region\n+   * @throws PartitionedRegionPartialClearException when data is partially cleared on partitioned\n+   *         region. Its caller responsibility to handle the partial data clear either by retrying", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjgwMQ==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427616801", "bodyText": "Fixed it.", "author": "agingade", "createdAt": "2020-05-19T21:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Nzk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDQ5MQ==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427480491", "bodyText": "My understanding is if it is locked already, release the write locks for clear. I think the ! should be removed.", "author": "jchen21", "createdAt": "2020-05-19T17:36:54Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -575,16 +575,23 @@ public void cmnClearRegion(RegionEventImpl regionEvent, boolean cacheWrite, bool\n     // get rvvLock\n     Set<InternalDistributedMember> participants =\n         getCacheDistributionAdvisor().adviseInvalidateRegion();\n+    boolean isLockedAlready = this.partitionedRegion.getPartitionedRegionClear()\n+        .isLockedForListenerAndClientNotification();\n+\n     try {\n-      obtainWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {\n+        obtainWriteLocksForClear(regionEvent, participants);\n+      }\n       // no need to dominate my own rvv.\n       // Clear is on going here, there won't be GII for this member\n       clearRegionLocally(regionEvent, cacheWrite, null);\n       distributeClearOperation(regionEvent, rvv, participants);\n \n       // TODO: call reindexUserDataRegion if there're lucene indexes\n     } finally {\n-      releaseWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjIyMg==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427616222", "bodyText": "If you look into the line where the lock is taken its based on the \"if(!isLockedAlready)\" the same logic is used to unlock the lock.", "author": "agingade", "createdAt": "2020-05-19T21:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjU4OQ==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427486589", "bodyText": "LocalRegionDataView. checkSupportsRegionClear() does nothing. The other data views, including transactions related data views throw exception. Is it expected?", "author": "jchen21", "createdAt": "2020-05-19T17:46:31Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -2493,4 +2500,11 @@ void updateSenderIdMonitor() {\n   void checkSameSenderIdsAvailableOnAllNodes() {\n     // nothing needed on a bucket region\n   }\n+\n+  @Override\n+  protected void basicClear(RegionEventImpl regionEvent) {\n+    getDataView().checkSupportsRegionClear();", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODI1OA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427618258", "bodyText": "For bucket region, we don't need it. Have removed it.", "author": "agingade", "createdAt": "2020-05-19T21:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NDY1Mg==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427494652", "bodyText": "If this section of code is not used, it's better to remove it.", "author": "jchen21", "createdAt": "2020-05-19T17:58:54Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -2148,69 +2150,71 @@ public void writeToDisk() {\n     throw new UnsupportedOperationException();\n   }\n \n-  @Override\n-  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite) {\n-    final boolean isDebugEnabled = logger.isDebugEnabled();\n-    synchronized (clearLock) {\n-      final DistributedLockService lockService = getPartitionedRegionLockService();\n-      try {\n-        lockService.lock(\"_clearOperation\" + this.getFullPath().replace('/', '_'), -1, -1);\n-      } catch (IllegalStateException e) {\n-        lockCheckReadiness();\n-        throw e;\n-      }\n-      try {\n-        if (cache.isCacheAtShutdownAll()) {\n-          throw cache.getCacheClosedException(\"Cache is shutting down\");\n-        }\n-\n-        // do cacheWrite\n-        cacheWriteBeforeRegionClear(regionEvent);\n-\n-        // create ClearPRMessage per bucket\n-        List<ClearPRMessage> clearMsgList = createClearPRMessages(regionEvent.getEventId());\n-        for (ClearPRMessage clearPRMessage : clearMsgList) {\n-          int bucketId = clearPRMessage.getBucketId();\n-          checkReadiness();\n-          long sendMessagesStartTime = 0;\n-          if (isDebugEnabled) {\n-            sendMessagesStartTime = System.currentTimeMillis();\n-          }\n-          try {\n-            sendClearMsgByBucket(bucketId, clearPRMessage);\n-          } catch (PartitionOfflineException poe) {\n-            // TODO add a PartialResultException\n-            logger.info(\"PR.sendClearMsgByBucket encountered PartitionOfflineException at bucket \"\n-                + bucketId, poe);\n-          } catch (Exception e) {\n-            logger.info(\"PR.sendClearMsgByBucket encountered exception at bucket \" + bucketId, e);\n-          }\n-\n-          if (isDebugEnabled) {\n-            long now = System.currentTimeMillis();\n-            logger.debug(\"PR.sendClearMsgByBucket for bucket {} took {} ms\", bucketId,\n-                (now - sendMessagesStartTime));\n-          }\n-          // TODO add psStats\n-        }\n-      } finally {\n-        try {\n-          lockService.unlock(\"_clearOperation\" + this.getFullPath().replace('/', '_'));\n-        } catch (IllegalStateException e) {\n-          lockCheckReadiness();\n-        }\n-      }\n-\n-      // notify bridge clients at PR level\n-      regionEvent.setEventType(EnumListenerEvent.AFTER_REGION_CLEAR);\n-      boolean hasListener = hasListener();\n-      if (hasListener) {\n-        dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n-      }\n-      notifyBridgeClients(regionEvent);\n-      logger.info(\"Partitioned region {} finsihed clear operation.\", this.getFullPath());\n-    }\n-  }\n+  /* @Override */", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMTc2OA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427621768", "bodyText": "removed.", "author": "agingade", "createdAt": "2020-05-19T21:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NDY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NzY5MA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427497690", "bodyText": "This seems to be duplicate. The super class already has an ArrayList of recipients.", "author": "jchen21", "createdAt": "2020-05-19T18:03:42Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDY2OA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427504668", "bodyText": "The implementation can use super.toString() and append fields specific to this class.", "author": "jchen21", "createdAt": "2020-05-19T18:15:09Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMzM5Nw==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427613397", "bodyText": "Thats not right; the class extending should be overriding the method and call super if any super fields needs to be included. If you look into other inheriting classes they have implemented their own toString().", "author": "agingade", "createdAt": "2020-05-19T21:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1MzMxOQ==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427653319", "bodyText": "This toString() actually is missing the sender field.\nThe super.toString() already contain the class name, procesorId and exception. Only bucketsCleared has to be added here.  I was trying to say something like:\n    @Override\n    public String toString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(super.toString());\n      sb.append(\" bucketsCleared \").append(this.bucketsCleared);\n      return sb.toString();\n    }", "author": "jchen21", "createdAt": "2020-05-19T23:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODc1Ng==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427508756", "bodyText": "Is the deleted test case covered else where? Or it no longer valid?", "author": "jchen21", "createdAt": "2020-05-19T18:21:48Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -221,22 +220,6 @@ public void clearShouldNotThrowUnsupportedOperationException() {\n     spyPartitionedRegion.clear();\n   }\n \n-  @Test(expected = CacheClosedException.class)\n-  public void clearShouldThrowCacheClosedExceptionIfShutdownAll() {", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTI3MQ==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427611271", "bodyText": "This is based on the earlier clear messaging. Thats not valid anymore.", "author": "agingade", "createdAt": "2020-05-19T21:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODg1MA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427508850", "bodyText": "Is the deleted test case covered else where? Or it no longer valid?", "author": "jchen21", "createdAt": "2020-05-19T18:21:57Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -249,28 +232,6 @@ public void createClearPRMessagesShouldCreateMessagePerBucket() {\n     assertThat(msgs.size()).isEqualTo(3);\n   }\n \n-  @Test\n-  public void sendEachMessagePerBucket() {", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMDc2NA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427610764", "bodyText": "This is testing the old way of messaging; where message is sent per bucket. That is not true anymore.", "author": "agingade", "createdAt": "2020-05-19T21:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjczOA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427522738", "bodyText": "This method never returns false. It always returns true. So there is no need to do the if check.", "author": "jchen21", "createdAt": "2020-05-19T18:45:38Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjgyNA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427522824", "bodyText": "This method never returns false. It always returns true. So there is no need to do the if check.", "author": "jchen21", "createdAt": "2020-05-19T18:45:45Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {", "originalCommit": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMDI2NA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427610264", "bodyText": "Thats not true; if the region is not destroyed, it returns false. line#1892 in LocalRegion.java.", "author": "agingade", "createdAt": "2020-05-19T21:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjgyNA=="}], "type": "inlineReview"}, {"oid": "2cd7c2ee1ef32759cf9d9f29905ba6fd74fbdd5f", "url": "https://github.com/apache/geode/commit/2cd7c2ee1ef32759cf9d9f29905ba6fd74fbdd5f", "message": "Uncomment the test parameter", "committedDate": "2020-05-19T21:22:05Z", "type": "commit"}, {"oid": "6316dbb74978e078b062da25c82ab5345ee4178a", "url": "https://github.com/apache/geode/commit/6316dbb74978e078b062da25c82ab5345ee4178a", "message": "Addressing review comments.", "committedDate": "2020-05-19T21:56:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MTg0Nw==", "url": "https://github.com/apache/geode/pull/5124#discussion_r427681847", "bodyText": "The sender field is missing.", "author": "jchen21", "createdAt": "2020-05-20T00:53:46Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(getRecipients() != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuffer sb = new StringBuffer();\n+      sb.append(\"PartitionedRegionClearReplyMessage \").append(\"processorid=\")", "originalCommit": "6316dbb74978e078b062da25c82ab5345ee4178a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMjU2MA==", "url": "https://github.com/apache/geode/pull/5124#discussion_r428312560", "bodyText": "Fixed.", "author": "agingade", "createdAt": "2020-05-20T21:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MTg0Nw=="}], "type": "inlineReview"}, {"oid": "cda2de8ba2f9ee74acfe13ffbf1029561c0ca0ce", "url": "https://github.com/apache/geode/commit/cda2de8ba2f9ee74acfe13ffbf1029561c0ca0ce", "message": "Add review comment with toString()", "committedDate": "2020-05-20T19:47:58Z", "type": "commit"}]}