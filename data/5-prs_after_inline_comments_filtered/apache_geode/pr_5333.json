{"pr_number": 5333, "pr_title": "GEODE-8323: Process QueueRemovalMessage after queue initialized.", "pr_createdAt": "2020-07-01T03:35:05Z", "pr_url": "https://github.com/apache/geode/pull/5333", "timeline": [{"oid": "be1aa4857e3dd816be24ba4c060349f25cb6cf25", "url": "https://github.com/apache/geode/commit/be1aa4857e3dd816be24ba4c060349f25cb6cf25", "message": "GEODE-8323: Process QueueRemovalMessage after queue initialized.", "committedDate": "2020-07-01T03:29:45Z", "type": "commit"}, {"oid": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856", "url": "https://github.com/apache/geode/commit/f4ee69ee0d03e6a86f59ff6d1866c002f15a1856", "message": "Do not change the toData method to avoid serialization change.", "committedDate": "2020-07-01T17:14:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0NTM1NA==", "url": "https://github.com/apache/geode/pull/5333#discussion_r449145354", "bodyText": "This test name is a little misleading. It might be better as \"getOwnerWithWaitReturnsNullIfNotInitializedWithWait\"", "author": "DonalEvans", "createdAt": "2020-07-02T16:46:14Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/HARegionTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.statistics.StatisticsClockFactory.disabledClock;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.EvictionAction;\n+import org.apache.geode.cache.EvictionAlgorithm;\n+import org.apache.geode.cache.EvictionAttributes;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.internal.cache.ha.HARegionQueue;\n+\n+public class HARegionTest {\n+  private HARegion region;\n+\n+  private final InternalCache cache = mock(InternalCache.class, RETURNS_DEEP_STUBS);\n+  private final RegionAttributes attributes = mock(RegionAttributes.class, RETURNS_DEEP_STUBS);\n+  private final EvictionAttributes evictionAttributes =\n+      mock(EvictionAttributes.class, RETURNS_DEEP_STUBS);\n+\n+  @Before\n+  public void setup() {\n+    when(attributes.getEvictionAttributes()).thenReturn(evictionAttributes);\n+    when(attributes.getLoadFactor()).thenReturn(0.75f);\n+    when(attributes.getConcurrencyLevel()).thenReturn(16);\n+    when(evictionAttributes.getAlgorithm()).thenReturn(EvictionAlgorithm.NONE);\n+    when(evictionAttributes.getAction()).thenReturn(EvictionAction.NONE);\n+    Set<String> asyncEventQueueIds = Collections.singleton(\"id\");\n+    when(attributes.getAsyncEventQueueIds()).thenReturn(asyncEventQueueIds);\n+    region = new HARegion(\"HARegionTest_region\", attributes, null, cache, disabledClock());\n+  }\n+\n+  @Test\n+  public void getOwnerWithWaitReturnsHARegionQueueIfInitializedWithWait() throws Exception {\n+    long timeout = 1;\n+    HARegionQueue queue = mock(HARegionQueue.class);\n+    when(queue.isQueueInitializedWithWait(timeout)).thenReturn(true);\n+\n+    region.setOwner(queue);\n+\n+    assertThat(region.getOwnerWithWait(timeout)).isEqualTo(queue);\n+  }\n+\n+  @Test\n+  public void getOwnerWithWaitReturnsHARegionQueueIfNotInitializedWithWait() throws Exception {", "originalCommit": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1MzUyNA==", "url": "https://github.com/apache/geode/pull/5333#discussion_r449153524", "bodyText": "Can the two sizes here be extracted to constants, since they're referenced in multiple tests?", "author": "DonalEvans", "createdAt": "2020-07-02T17:01:32Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/QueueRemovalMessageTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.ha;\n+\n+import static org.apache.geode.util.internal.UncheckedUtils.uncheckedCast;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.cache.EntryNotFoundException;\n+import org.apache.geode.cache.RegionDestroyedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.HARegion;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class QueueRemovalMessageTest {\n+  private QueueRemovalMessage queueRemovalMessage;\n+  private List<Object> messagesList;\n+\n+  private final ClusterDistributionManager dm = mock(ClusterDistributionManager.class);\n+  private final InternalCache cache = mock(InternalCache.class);\n+  private final String regionName1 = \"region1\";\n+  private final String regionName2 = \"region2\";\n+  private final HARegion region1 = mock(HARegion.class);\n+  private final HARegion region2 = mock(HARegion.class);\n+  private final HARegionQueue regionQueue1 = mock(HARegionQueue.class);\n+  private final HARegionQueue regionQueue2 = mock(HARegionQueue.class);\n+  private final EventID eventID1 = mock(EventID.class);\n+  private final EventID eventID2 = mock(EventID.class);\n+  private final EventID eventID3 = mock(EventID.class);\n+\n+\n+  @Before\n+  public void setup() {\n+    queueRemovalMessage = spy(new QueueRemovalMessage());\n+    messagesList = new LinkedList<>();\n+    queueRemovalMessage.setMessagesList(messagesList);\n+\n+    long maxWaitTimeForInitialization = 30000;\n+    when(cache.getRegion(regionName1)).thenReturn(uncheckedCast(region1));\n+    when(cache.getRegion(regionName2)).thenReturn(uncheckedCast(region2));\n+    when(region1.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue1);\n+    when(region2.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue2);\n+    when(regionQueue1.isQueueInitialized()).thenReturn(true);\n+    when(regionQueue2.isQueueInitialized()).thenReturn(true);\n+  }\n+\n+  @Test\n+  public void messageProcessInvokesProcessRegionQueues() {\n+    when(dm.getCache()).thenReturn(cache);\n+\n+    queueRemovalMessage.process(dm);\n+\n+    verify(queueRemovalMessage).processRegionQueues(eq(cache), any(Iterator.class));\n+  }\n+\n+  @Test\n+  public void processRegionQueuesCanProcessEachRegionQueue() {\n+    addToMessagesList();\n+    Iterator iterator = messagesList.iterator();\n+\n+    queueRemovalMessage.processRegionQueues(cache, iterator);\n+\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName1, 1, regionQueue1);\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName2, 2, regionQueue2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName1, regionQueue1, eventID1);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID3);\n+  }\n+\n+  private void addToMessagesList() {\n+    messagesList.add(regionName1);\n+    messagesList.add(1);\n+    messagesList.add(eventID1);\n+    messagesList.add(regionName2);\n+    messagesList.add(2);", "originalCommit": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1Mzk4MQ==", "url": "https://github.com/apache/geode/pull/5333#discussion_r449153981", "bodyText": "Small typo here, I think this should be \"canProcessRegionQueuesWhenHARegionQueueIsNotInitialized'", "author": "DonalEvans", "createdAt": "2020-07-02T17:02:31Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/QueueRemovalMessageTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.ha;\n+\n+import static org.apache.geode.util.internal.UncheckedUtils.uncheckedCast;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.cache.EntryNotFoundException;\n+import org.apache.geode.cache.RegionDestroyedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.HARegion;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class QueueRemovalMessageTest {\n+  private QueueRemovalMessage queueRemovalMessage;\n+  private List<Object> messagesList;\n+\n+  private final ClusterDistributionManager dm = mock(ClusterDistributionManager.class);\n+  private final InternalCache cache = mock(InternalCache.class);\n+  private final String regionName1 = \"region1\";\n+  private final String regionName2 = \"region2\";\n+  private final HARegion region1 = mock(HARegion.class);\n+  private final HARegion region2 = mock(HARegion.class);\n+  private final HARegionQueue regionQueue1 = mock(HARegionQueue.class);\n+  private final HARegionQueue regionQueue2 = mock(HARegionQueue.class);\n+  private final EventID eventID1 = mock(EventID.class);\n+  private final EventID eventID2 = mock(EventID.class);\n+  private final EventID eventID3 = mock(EventID.class);\n+\n+\n+  @Before\n+  public void setup() {\n+    queueRemovalMessage = spy(new QueueRemovalMessage());\n+    messagesList = new LinkedList<>();\n+    queueRemovalMessage.setMessagesList(messagesList);\n+\n+    long maxWaitTimeForInitialization = 30000;\n+    when(cache.getRegion(regionName1)).thenReturn(uncheckedCast(region1));\n+    when(cache.getRegion(regionName2)).thenReturn(uncheckedCast(region2));\n+    when(region1.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue1);\n+    when(region2.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue2);\n+    when(regionQueue1.isQueueInitialized()).thenReturn(true);\n+    when(regionQueue2.isQueueInitialized()).thenReturn(true);\n+  }\n+\n+  @Test\n+  public void messageProcessInvokesProcessRegionQueues() {\n+    when(dm.getCache()).thenReturn(cache);\n+\n+    queueRemovalMessage.process(dm);\n+\n+    verify(queueRemovalMessage).processRegionQueues(eq(cache), any(Iterator.class));\n+  }\n+\n+  @Test\n+  public void processRegionQueuesCanProcessEachRegionQueue() {\n+    addToMessagesList();\n+    Iterator iterator = messagesList.iterator();\n+\n+    queueRemovalMessage.processRegionQueues(cache, iterator);\n+\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName1, 1, regionQueue1);\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName2, 2, regionQueue2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName1, regionQueue1, eventID1);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID3);\n+  }\n+\n+  private void addToMessagesList() {\n+    messagesList.add(regionName1);\n+    messagesList.add(1);\n+    messagesList.add(eventID1);\n+    messagesList.add(regionName2);\n+    messagesList.add(2);\n+    messagesList.add(eventID2);\n+    messagesList.add(eventID3);\n+  }\n+\n+  @Test\n+  public void canProcessRegionQueuesWithoutHARegionInCache() {\n+    addToMessagesList();\n+    Iterator iterator = messagesList.iterator();\n+    when(cache.getRegion(regionName1)).thenReturn(null);\n+\n+    queueRemovalMessage.processRegionQueues(cache, iterator);\n+\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName1, 1, null);\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName2, 2, regionQueue2);\n+    verify(queueRemovalMessage, never()).removeQueueEvent(regionName1, regionQueue1, eventID1);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID3);\n+  }\n+\n+  @Test\n+  public void canProcessRegionQueuesWithoutHARegionQueueIsNotInitialized() {", "originalCommit": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e2c9f2ddea387d6018ac1722cdb90a433b6b0b43", "url": "https://github.com/apache/geode/commit/e2c9f2ddea387d6018ac1722cdb90a433b6b0b43", "message": "fix review comments.", "committedDate": "2020-07-06T20:09:00Z", "type": "commit"}]}