{"pr_number": 4590, "pr_title": "GEODE-7698: Extracting a superclass of InternalDistributedMember", "pr_createdAt": "2020-01-14T00:18:53Z", "pr_url": "https://github.com/apache/geode/pull/4590", "timeline": [{"oid": "59b6bd25154235bc98117ec03fdb42c40cbd3cd4", "url": "https://github.com/apache/geode/commit/59b6bd25154235bc98117ec03fdb42c40cbd3cd4", "message": "Check for IP address rather than SocketCreator.resolve_dns in addFixedToString\n\nInternalDistributedMember has a dependency on this mutable static flag\nin it's to string, which is not ideal. It looks like the intention was\nto only shorten the hostname if it is dns name, not an ip address.", "committedDate": "2020-01-14T00:01:05Z", "type": "commit"}, {"oid": "055392146d20b758dce47f1a720a769541859d6f", "url": "https://github.com/apache/geode/commit/055392146d20b758dce47f1a720a769541859d6f", "message": "Remove unecessary use of SocketCreator during IDM deserialization\n\nWe were using flags and methods on SocketCreator to either change or\ncache the hostName that we read off the wire from the remote member. We\ndon't want to do either of those things during deserialiation, we should\njust keep the hostname we read as is.", "committedDate": "2020-01-14T00:01:05Z", "type": "commit"}, {"oid": "a11b58897bbf88b99c32375749da31793390c84e", "url": "https://github.com/apache/geode/commit/a11b58897bbf88b99c32375749da31793390c84e", "message": "GEODE-7698: Extracting a superclass of InternalDistributedMember\n\nWe need a concrete MemberIdentifier implementation in geode-membership\nto test membership.\n\nExtracting a superclass of InternalDistributedMember,\nMemberIdentifierImpl, which contains pretty much all of the\nInternalDistributedMember logic. InternalDistributedMember now just\nextends that class and implements DistributedMember.", "committedDate": "2020-01-14T00:17:31Z", "type": "commit"}, {"oid": "18a8ce33afd85cbea4e37c1ef72701ab2b2d1cbf", "url": "https://github.com/apache/geode/commit/18a8ce33afd85cbea4e37c1ef72701ab2b2d1cbf", "message": "Fixing merge conflicts with geode-membership module change\n\nUpdating the expected POM, and fixing dependencies", "committedDate": "2020-01-14T01:09:17Z", "type": "commit"}, {"oid": "caef2bb397bf0377e14d0b311679c992a015152b", "url": "https://github.com/apache/geode/commit/caef2bb397bf0377e14d0b311679c992a015152b", "message": "Fixing integration test failure\n\nThis test is still using IDM, so it can't have a factory that creates\nMemberIdentifierImpl.", "committedDate": "2020-01-14T01:14:21Z", "type": "commit"}, {"oid": "7161fb131fb0b6adc6cbab5c7f636ba690fcbafb", "url": "https://github.com/apache/geode/commit/7161fb131fb0b6adc6cbab5c7f636ba690fcbafb", "message": "Fixing backwards compability of InternalDistributedMember\n\nThis class needs to directly implement the fromData_Pre_XXX methods.", "committedDate": "2020-01-14T19:23:07Z", "type": "commit"}, {"oid": "0c34a84949121f304f997d634da0d69b198c1f0f", "url": "https://github.com/apache/geode/commit/0c34a84949121f304f997d634da0d69b198c1f0f", "message": "Updating sanctioned serializables", "committedDate": "2020-01-14T22:04:52Z", "type": "commit"}, {"oid": "55501f85e181fcb42ab1bf4d9cdee104a1f26c4d", "url": "https://github.com/apache/geode/commit/55501f85e181fcb42ab1bf4d9cdee104a1f26c4d", "message": "Check the resolve_dns flag before generating HA region queue name\n\nBefore the previous changes to InternalDistributedMember, we were flipping the\nhostname field to be an IP address when we deserialized the IDM, based on the\nresolve_dns flag.\n\nIt looks like this was required to keep the HA region queue name generated from\naddFixedToString to match between old versions and the current version - the\nregion name should have an IP address if network partition detection is\nenabled.", "committedDate": "2020-01-14T23:00:01Z", "type": "commit"}, {"oid": "65c0720feb1369f53b34bdb1a30ab5aad56ae442", "url": "https://github.com/apache/geode/commit/65c0720feb1369f53b34bdb1a30ab5aad56ae442", "message": "Run this concourse!", "committedDate": "2020-01-15T00:56:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0ODI0Mg==", "url": "https://github.com/apache/geode/pull/4590#discussion_r366648242", "bodyText": "Nice how having to call super forced us to put the extra logic into a method (getInetAddress).", "author": "Bill", "createdAt": "2020-01-15T00:49:25Z", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/InternalDistributedMember.java", "diffHunk": "@@ -244,19 +128,21 @@ public InternalDistributedMember(String i, int p) {\n    */\n \n   public InternalDistributedMember(ServerLocation location) {\n+    super(MemberDataBuilder.newBuilder(getInetAddress(location), location.getHostName())", "originalCommit": "55501f85e181fcb42ab1bf4d9cdee104a1f26c4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0OTU5OQ==", "url": "https://github.com/apache/geode/pull/4590#discussion_r366649599", "bodyText": "is the reason for this change conscious uncoupling from the MemberIdentifierFactoryImpl class?", "author": "Bill", "createdAt": "2020-01-15T00:54:49Z", "path": "geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java", "diffHunk": "@@ -142,7 +144,18 @@ public void initMocks(boolean enableNetworkPartition, boolean useTestGMSJoinLeav\n     when(services.getCancelCriterion()).thenReturn(stopper);\n     when(services.getManager()).thenReturn(manager);\n     when(services.getHealthMonitor()).thenReturn(healthMonitor);\n-    when(services.getMemberFactory()).thenReturn(new MemberIdentifierFactoryImpl());\n+    when(services.getMemberFactory())\n+        .thenReturn(new MemberIdentifierFactory<InternalDistributedMember>() {\n+          @Override\n+          public InternalDistributedMember create(MemberData memberInfo) {\n+            return new InternalDistributedMember(memberInfo);", "originalCommit": "55501f85e181fcb42ab1bf4d9cdee104a1f26c4d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxODgxMQ==", "url": "https://github.com/apache/geode/pull/4590#discussion_r367018811", "bodyText": "Basically. This test is still using InternalDistributedMember. So it needs a MemberIdentifierFactory that produces an IDM. I changed MemberIdentifierFactoryImpl to produce MemberIdentiferImpl.\nOnce we totally fix this test to just use MemberIdentefierImpl, we can go back to the MemberIdentiferFactoryImpl.", "author": "upthewaterspout", "createdAt": "2020-01-15T17:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0OTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MTc1NA==", "url": "https://github.com/apache/geode/pull/4590#discussion_r366651754", "bodyText": "ah I see why you moved this logic here from InternalDataSerializer: the latter is in geode-core and our new MemberIdentifierImpl is down in geode-membership and can't depend on stuff in core \u2713", "author": "Bill", "createdAt": "2020-01-15T01:03:53Z", "path": "geode-serialization/src/main/java/org/apache/geode/internal/serialization/StaticSerialization.java", "diffHunk": "@@ -494,4 +494,64 @@ public static void writePrimitiveClass(Class c, DataOutput out) throws IOExcepti\n             String.format(\"unexpected typeCode: %s\", typeCode));\n     }\n   }\n+", "originalCommit": "65c0720feb1369f53b34bdb1a30ab5aad56ae442", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MzMzMg==", "url": "https://github.com/apache/geode/pull/4590#discussion_r366653332", "bodyText": "now be a good time to give this method a meaningful name", "author": "Bill", "createdAt": "2020-01-15T01:10:20Z", "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MemberIdentifierImpl.java", "diffHunk": "@@ -0,0 +1,978 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal.membership.api;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.EOFException;\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import org.apache.commons.validator.routines.InetAddressValidator;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.internal.serialization.DataSerializableFixedID;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.internal.serialization.StaticSerialization;\n+import org.apache.geode.internal.serialization.UnsupportedSerializationVersionException;\n+import org.apache.geode.internal.serialization.Version;\n+\n+/**\n+ * An implementation of {@link MemberIdentifier}\n+ */\n+public class MemberIdentifierImpl implements MemberIdentifier, DataSerializableFixedID {\n+  /** serialization bit flag */\n+  private static final int NPD_ENABLED_BIT = 0x1;\n+  /** serialization bit flag */\n+  private static final int COORD_ENABLED_BIT = 0x2;\n+  /** partial ID bit flag */\n+  private static final int PARTIAL_ID_BIT = 0x4;\n+  /** product version bit flag */\n+  private static final int VERSION_BIT = 0x8;\n+  /** The versions in which this message was modified */\n+  @Immutable\n+  private static final Version[] dsfidVersions = new Version[] {\n+      Version.GFE_71, Version.GFE_90};\n+  private MemberData memberData; // the underlying member object\n+  /**\n+   * whether this is a partial member ID (without roles, durable attributes). We use partial IDs in\n+   * EventID objects to reduce their size. It would be better to use canonical IDs but there is\n+   * currently no central mechanism that would allow that for both server and client identifiers\n+   */\n+  private boolean isPartial;\n+  /**\n+   * Unique tag (such as randomly generated bytes) to help enforce uniqueness. Note: this should be\n+   * displayable.\n+   */\n+  private String uniqueTag = null;\n+  private transient Version versionObj = Version.CURRENT;\n+\n+  public MemberIdentifierImpl() {}\n+\n+  public MemberIdentifierImpl(\n+      MemberData memberData, String uniqueTag) {\n+    this.memberData = memberData;\n+    this.isPartial = memberData.isPartial();\n+    this.uniqueTag = uniqueTag;\n+\n+    short version = memberData.getVersionOrdinal();\n+    try {\n+      this.versionObj = Version.fromOrdinal(version);\n+    } catch (UnsupportedSerializationVersionException e) {\n+      this.versionObj = Version.CURRENT;\n+    }\n+  }\n+\n+  public int getVmPid() {\n+    return memberData.getProcessId();\n+  }\n+\n+  public void setDurableTimeout(int newValue) {\n+    memberData.setDurableTimeout(newValue);\n+  }\n+\n+  public void setDurableId(String id) {\n+    memberData.setDurableId(id);\n+  }\n+\n+  /**\n+   * Replace the current member data with the given member data. This can be used to fill out an\n+   * InternalDistributedMember that was created from a partial data created by\n+   * readEssentialData.\n+   *\n+   * @param m the replacement member data\n+   */\n+  public void setMemberData(MemberData m) {\n+    this.memberData = m;\n+  }\n+\n+  /**\n+   * Return the underlying host address\n+   *\n+   * @return the underlying host address\n+   */\n+  public InetAddress getInetAddress() {\n+    return memberData.getInetAddress();\n+  }\n+\n+  /**\n+   * Return the underlying port (membership port)\n+   *\n+   * @return the underlying membership port\n+   */\n+  public int getMembershipPort() {\n+    return memberData.getMembershipPort();\n+  }\n+\n+  @Override\n+  public short getVersionOrdinal() {\n+    return versionObj == null ? memberData.getVersionOrdinal() : versionObj.ordinal();\n+  }\n+\n+  /**\n+   * Returns the port on which the direct channel runs\n+   */\n+  public int getDirectChannelPort() {\n+    assert !this.isPartial;\n+    return memberData.getDirectChannelPort();\n+  }\n+\n+  /**\n+   * [GemStone] Returns the kind of VM that hosts the distribution manager with this address.\n+   *\n+   * @see MemberIdentifier#NORMAL_DM_TYPE\n+   */\n+  public int getVmKind() {\n+    return memberData.getVmKind();\n+  }\n+\n+  @Override\n+  public int getMemberWeight() {\n+    return memberData.getMemberWeight();\n+  }\n+\n+  /**\n+   * Returns the membership view ID that this member was born in. For backward compatibility reasons\n+   * this is limited to 16 bits.\n+   */\n+  public int getVmViewId() {\n+    return memberData.getVmViewId();\n+  }\n+\n+  @Override\n+  public boolean preferredForCoordinator() {\n+    return memberData.isPreferredForCoordinator();\n+  }\n+\n+  @Override\n+  public List<String> getGroups() {\n+    return Collections.unmodifiableList(Arrays.asList(memberData.getGroups()));\n+  }\n+\n+  @Override\n+  public void setVmViewId(int p) {\n+    memberData.setVmViewId(p);\n+    cachedToString = null;\n+  }\n+\n+  @Override\n+  public void setPreferredForCoordinator(boolean preferred) {\n+    memberData.setPreferredForCoordinator(preferred);\n+    cachedToString = null;\n+  }\n+\n+  @Override\n+  public void setDirectChannelPort(int dcPort) {\n+    memberData.setDirectChannelPort(dcPort);\n+    cachedToString = null;\n+  }\n+\n+  @Override\n+  public void setVmKind(int dmType) {\n+    memberData.setVmKind(dmType);\n+    cachedToString = null;\n+  }\n+\n+  protected void setGroups(String[] newGroups) {\n+    this.memberData.setGroups(newGroups);\n+    cachedToString = null;\n+  }\n+\n+  /**\n+   * Returns the name of this member's distributed system connection or null if no name was\n+   * specified.\n+   */\n+  public String getName() {\n+    String result = memberData.getName();\n+    if (result == null) {\n+      result = \"\";\n+    }\n+    return result;\n+  }\n+\n+  public int compare(MemberIdentifierImpl other) {\n+    return this.compareTo(other, false, true);\n+  }\n+\n+  protected int compareTo(MemberIdentifierImpl other, boolean compareMemberData,\n+      boolean compareViewIds) {\n+    int myPort = getMembershipPort();\n+    int otherPort = other.getMembershipPort();\n+    if (myPort < otherPort)\n+      return -1;\n+    if (myPort > otherPort)\n+      return 1;\n+\n+    InetAddress myAddr = getInetAddress();\n+    InetAddress otherAddr = other.getInetAddress();\n+\n+    // Discard null cases\n+    if (myAddr == null && otherAddr == null) {\n+      return 0;\n+    } else if (myAddr == null) {\n+      return -1;\n+    } else if (otherAddr == null)\n+      return 1;\n+\n+    byte[] myBytes = myAddr.getAddress();\n+    byte[] otherBytes = otherAddr.getAddress();\n+\n+    if (myBytes != otherBytes) {\n+      for (int i = 0; i < myBytes.length; i++) {\n+        if (i >= otherBytes.length)\n+          return -1; // same as far as they go, but shorter...\n+        if (myBytes[i] < otherBytes[i])\n+          return -1;\n+        if (myBytes[i] > otherBytes[i])\n+          return 1;\n+      }\n+      if (myBytes.length > otherBytes.length)\n+        return 1; // same as far as they go, but longer...\n+    }\n+\n+    String myName = getName();\n+    String otherName = other.getName();\n+    if (!(other.isPartial || this.isPartial)) {\n+      if (myName == null && otherName == null) {\n+        // do nothing\n+      } else if (myName == null) {\n+        return -1;\n+      } else if (otherName == null) {\n+        return 1;\n+      } else {\n+        int i = myName.compareTo(otherName);\n+        if (i != 0) {\n+          return i;\n+        }\n+      }\n+    }\n+\n+    if (this.uniqueTag == null && other.uniqueTag == null) {\n+      if (compareViewIds) {\n+        // not loners, so look at P2P view ID\n+        int thisViewId = getVmViewId();\n+        int otherViewId = other.getVmViewId();\n+        if (thisViewId >= 0 && otherViewId >= 0) {\n+          if (thisViewId < otherViewId) {\n+            return -1;\n+          } else if (thisViewId > otherViewId) {\n+            return 1;\n+          } // else they're the same, so continue\n+        }\n+      }\n+    } else if (this.uniqueTag == null) {\n+      return -1;\n+    } else if (other.uniqueTag == null) {\n+      return 1;\n+    } else {\n+      int i = this.uniqueTag.compareTo(other.uniqueTag);\n+      if (i != 0) {\n+        return i;\n+      }\n+    }\n+\n+    if (compareMemberData && this.memberData != null && other.memberData != null) {\n+      return this.memberData.compareAdditionalData(other.memberData);\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  /**\n+   * An InternalDistributedMember created for a test or via readEssentialData will be a Partial ID,\n+   * possibly not having ancillary info like \"name\".\n+   *\n+   * @return true if this is a partial ID\n+   */\n+  public boolean isPartial() {\n+    return isPartial;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj) {\n+      return true;\n+    }\n+    // GemStone fix for 29125\n+    if (!(obj instanceof MemberIdentifierImpl)) {\n+      return false;\n+    }\n+    MemberIdentifierImpl other = (MemberIdentifierImpl) obj;\n+\n+    int myPort = getMembershipPort();\n+    int otherPort = other.getMembershipPort();\n+    if (myPort != otherPort) {\n+      return false;\n+    }\n+\n+    InetAddress myAddr = getInetAddress();\n+    InetAddress otherAddr = other.getInetAddress();\n+    if (myAddr == null && otherAddr == null) {\n+      return true;\n+    } else if (!Objects.equals(myAddr, otherAddr)) {\n+      return false;\n+    }\n+\n+    if (!isPartial() && !other.isPartial()) {\n+      if (!Objects.equals(getName(), other.getName())) {\n+        return false;\n+      }\n+    }\n+\n+    if (this.uniqueTag == null && other.uniqueTag == null) {\n+      // not loners, so look at P2P view ID\n+      int thisViewId = getVmViewId();\n+      int otherViewId = other.getVmViewId();\n+      if (thisViewId >= 0 && otherViewId >= 0) {\n+        if (thisViewId != otherViewId) {\n+          return false;\n+        } // else they're the same, so continue\n+      }\n+    } else if (!Objects.equals(this.uniqueTag, other.uniqueTag)) {\n+      return false;\n+    }\n+\n+    if (this.memberData != null && other.memberData != null) {\n+      if (0 != this.memberData.compareAdditionalData(other.memberData)) {\n+        return false;\n+      }\n+    }\n+\n+    // purposely avoid checking roles\n+    // @todo Add durableClientAttributes to equals\n+\n+    return true;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = 0;\n+    result = result + memberData.getInetAddress().hashCode();\n+    result = result + getMembershipPort();\n+    return result;\n+  }\n+\n+  private String shortName(String hostname) {\n+    if (hostname == null)\n+      return \"<null inet_addr hostname>\";\n+    int index = hostname.indexOf('.');\n+\n+    if (index > 0 && !Character.isDigit(hostname.charAt(0)))\n+      return hostname.substring(0, index);\n+    else\n+      return hostname;\n+  }\n+\n+\n+  /** the cached string description of this object */\n+  private transient String cachedToString;\n+\n+  @Override\n+  public String toString() {\n+    String result = cachedToString;\n+    if (result == null) {\n+      final StringBuilder sb = new StringBuilder();\n+      addFixedToString(sb, false);\n+\n+      // add version if not current\n+      short version = memberData.getVersionOrdinal();\n+      if (version != Version.CURRENT.ordinal()) {\n+        sb.append(\"(version:\").append(Version.toString(version)).append(')');\n+      }\n+\n+      // leave out Roles on purpose\n+\n+      result = sb.toString();\n+      cachedToString = result;\n+    }\n+    return result;\n+  }\n+\n+  public void addFixedToString(StringBuilder sb, boolean useIpAddress) {", "originalCommit": "65c0720feb1369f53b34bdb1a30ab5aad56ae442", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1NDE0Mw==", "url": "https://github.com/apache/geode/pull/4590#discussion_r366654143", "bodyText": "gawd this (class) really goes into the membership API. That makes everything this class does part of the membership contract right?\nclass inheritance coming home to roost. I guess the alternative is to put a factory in the API and hide this impl in the membership module implementation package. Then InternalDistributedMember would have a MemberIdentifierImpl through a MemberIdentifierreference.\nProblem with that idea is that MemberIdentifierImpl has a ton of methods not on MemberIdentifier. That implies we'd need another, wider, interface to implement those methods (maybe a sub-interface of MemberIdentifier) ugh.\nsorry for the stream of consciousness feedback. I'll try to hone it and get back to you\u2026", "author": "Bill", "createdAt": "2020-01-15T01:13:45Z", "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MemberIdentifierImpl.java", "diffHunk": "@@ -0,0 +1,978 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal.membership.api;", "originalCommit": "65c0720feb1369f53b34bdb1a30ab5aad56ae442", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}