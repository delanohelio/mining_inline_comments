{"pr_number": 5743, "pr_title": "GEODE-8623: Retry getting local host if it fails.", "pr_createdAt": "2020-11-12T21:17:46Z", "pr_url": "https://github.com/apache/geode/pull/5743", "timeline": [{"oid": "385c82003da7f5610d3408d0e7f7ff1e44f72794", "url": "https://github.com/apache/geode/commit/385c82003da7f5610d3408d0e7f7ff1e44f72794", "message": "GEODE-8623: Retry getting local host if it fails.", "committedDate": "2020-11-12T21:15:16Z", "type": "commit"}, {"oid": "e3956b0ca99d794fdc1c473a2ed9160b89d6391e", "url": "https://github.com/apache/geode/commit/e3956b0ca99d794fdc1c473a2ed9160b89d6391e", "message": "review comments\n* add sleep between retries", "committedDate": "2020-11-12T21:48:40Z", "type": "forcePushed"}, {"oid": "e1b6856f6b01b38983f87d6cd12f59745824d3f1", "url": "https://github.com/apache/geode/commit/e1b6856f6b01b38983f87d6cd12f59745824d3f1", "message": "review comments\n* add sleep between retries", "committedDate": "2020-11-12T22:14:03Z", "type": "commit"}, {"oid": "e1b6856f6b01b38983f87d6cd12f59745824d3f1", "url": "https://github.com/apache/geode/commit/e1b6856f6b01b38983f87d6cd12f59745824d3f1", "message": "review comments\n* add sleep between retries", "committedDate": "2020-11-12T22:14:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNTM0NQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r522525345", "bodyText": "Sleeping doesn't feel like the responsibility of a clock.", "author": "pivotal-jbarrett", "createdAt": "2020-11-13T00:25:28Z", "path": "geode-common/src/main/java/org/apache/geode/internal/Retry.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+\n+/**\n+ * Utility class for retrying operations.\n+ */\n+public class Retry {\n+\n+  interface Clock {\n+    long nanoTime();\n+\n+    void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedException;\n+  }\n+\n+  private static class SteadyClock implements Clock {\n+    @Override\n+    public long nanoTime() {\n+      return System.nanoTime();\n+    }\n+\n+    @Override\n+    public void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedException {", "originalCommit": "e1b6856f6b01b38983f87d6cd12f59745824d3f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MjIwNQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r522552205", "bodyText": "We can give it another name, like Timer? This is an internal interface made accessible for testing purposes, so I am not too concerned about the naming or break it into another interface.", "author": "jinmeiliao", "createdAt": "2020-11-13T01:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNTM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4OTE5OQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r523289199", "bodyText": "We've been using two separate interfaces in other places in Geode where we do this, and I'd recommend it here too. Lemme go find an example\u2026 Ah yes, have a look at PrimaryHandler which has Sleeper and MillisecondProvider interfaces. Hmm looks like PrimaryHandler.processRequest() might benefit from this Retry class eventually!", "author": "Bill", "createdAt": "2020-11-13T23:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNTM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjEyNA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r522526124", "bodyText": "Is TimeUnit intended to cover both time values? I think its more readable to have TimeUnit param for each so it reads as \"(1, SECOND, 4,  SECOND)\" rather than \"(1, 4, SECOND)\".", "author": "pivotal-jbarrett", "createdAt": "2020-11-13T00:27:48Z", "path": "geode-common/src/main/java/org/apache/geode/internal/Retry.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+\n+/**\n+ * Utility class for retrying operations.\n+ */\n+public class Retry {\n+\n+  interface Clock {\n+    long nanoTime();\n+\n+    void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedException;\n+  }\n+\n+  private static class SteadyClock implements Clock {\n+    @Override\n+    public long nanoTime() {\n+      return System.nanoTime();\n+    }\n+\n+    @Override\n+    public void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedException {\n+      Thread.sleep(MILLISECONDS.convert(sleepTime, sleepTimeUnit));\n+    }\n+  }\n+\n+  private static final SteadyClock steadyClock = new SteadyClock();\n+\n+  /**\n+   * Try the supplier function until the predicate is true or timeout occurs.\n+   *\n+   * @param timeout to retry for\n+   * @param interval time between each try\n+   * @param timeUnit to retry for\n+   * @param supplier to execute until predicate is true or times out\n+   * @param predicate to test for retry\n+   * @param <T> type of return value\n+   * @return value from supplier after it passes predicate or times out.\n+   */\n+  public static <T> T tryFor(long timeout,\n+      long interval,\n+      TimeUnit timeUnit,\n+      Supplier<T> supplier,\n+      Predicate<T> predicate) throws TimeoutException, InterruptedException {\n+    return tryFor(timeout, interval, timeUnit, supplier, predicate, steadyClock);\n+  }\n+\n+  @VisibleForTesting\n+  static <T> T tryFor(long timeout,\n+      long interval,\n+      TimeUnit timeUnit,", "originalCommit": "e1b6856f6b01b38983f87d6cd12f59745824d3f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MjUzOQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r522552539", "bodyText": "It is meant to cover both time values, but if you think it's readable otherwise....", "author": "jinmeiliao", "createdAt": "2020-11-13T01:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjEyNA=="}], "type": "inlineReview"}, {"oid": "7ad348d3a30b31742355f8483dc503c917ca8752", "url": "https://github.com/apache/geode/commit/7ad348d3a30b31742355f8483dc503c917ca8752", "message": "review comments\n* rename and add parameter", "committedDate": "2020-11-13T06:04:15Z", "type": "commit"}, {"oid": "7ad348d3a30b31742355f8483dc503c917ca8752", "url": "https://github.com/apache/geode/commit/7ad348d3a30b31742355f8483dc503c917ca8752", "message": "review comments\n* rename and add parameter", "committedDate": "2020-11-13T06:04:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg==", "url": "https://github.com/apache/geode/pull/5743#discussion_r522701506", "bodyText": "The sleep should happen for min(interval, until - now) otherwise you could sleep past the timeout.", "author": "pivotal-jbarrett", "createdAt": "2020-11-13T06:59:09Z", "path": "geode-common/src/main/java/org/apache/geode/internal/Retry.java", "diffHunk": "@@ -47,45 +47,44 @@ public void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedExce\n     }\n   }\n \n-  private static final SteadyClock steadyClock = new SteadyClock();\n+  private static final SteadyTimer steadyClock = new SteadyTimer();\n \n   /**\n    * Try the supplier function until the predicate is true or timeout occurs.\n    *\n    * @param timeout to retry for\n+   * @param timeoutUnit the unit for timeout\n    * @param interval time between each try\n-   * @param timeUnit to retry for\n+   * @param intervalUnit the unit for interval\n    * @param supplier to execute until predicate is true or times out\n    * @param predicate to test for retry\n    * @param <T> type of return value\n    * @return value from supplier after it passes predicate or times out.\n    */\n-  public static <T> T tryFor(long timeout,\n-      long interval,\n-      TimeUnit timeUnit,\n+  public static <T> T tryFor(long timeout, TimeUnit timeoutUnit,\n+      long interval, TimeUnit intervalUnit,\n       Supplier<T> supplier,\n       Predicate<T> predicate) throws TimeoutException, InterruptedException {\n-    return tryFor(timeout, interval, timeUnit, supplier, predicate, steadyClock);\n+    return tryFor(timeout, timeoutUnit, interval, intervalUnit, supplier, predicate, steadyClock);\n   }\n \n   @VisibleForTesting\n-  static <T> T tryFor(long timeout,\n-      long interval,\n-      TimeUnit timeUnit,\n+  static <T> T tryFor(long timeout, TimeUnit timeoutUnit,\n+      long interval, TimeUnit intervalUnit,\n       Supplier<T> supplier,\n       Predicate<T> predicate,\n-      Clock clock) throws TimeoutException, InterruptedException {\n-    long until = clock.nanoTime() + NANOSECONDS.convert(timeout, timeUnit);\n+      Timer timer) throws TimeoutException, InterruptedException {\n+    long until = timer.nanoTime() + NANOSECONDS.convert(timeout, timeoutUnit);\n \n     T value;\n     do {\n       value = supplier.get();\n       if (predicate.test(value)) {\n         return value;\n       } else {\n-        clock.sleep(interval, timeUnit);\n+        timer.sleep(interval, intervalUnit);", "originalCommit": "7ad348d3a30b31742355f8483dc503c917ca8752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNTc0MQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r523035741", "bodyText": "Yes, but this extra calculation only affects the last iteration, and either we sleep past the timeout or exactly at the timeout, we would exit the loop anyway. I wouldn't mind sleeping for some extra time in the last iteration if we can make the code simpler.", "author": "jinmeiliao", "createdAt": "2020-11-13T15:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDc5NQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r523044795", "bodyText": "Also, we sleep at the end only to delay the return of the failed predicate state. Sleeping min time and then continue after guards against sleeping past the timeout and gives the opportunity of the predicate to go pass before returning. No point in sleeping if we are just going to fall through the while block immediately, we aren't trying to delay the return but rather the execution of the code block.", "author": "pivotal-jbarrett", "createdAt": "2020-11-13T16:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzMwOTA4NQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r523309085", "bodyText": "I am not sure I follow here. if we sleep past the timeout then we won't execute the predicate anymore, it would just end the while loop with TimeoutException.\nAssuming the supplier and predicate can execute at a negligible period, timeout is 10 sec and sleep time is 3 sec. Sleeping in min time would sleep for 3,3,3,1, while sleeping for just the sleeping period is 3,3,3,3. What I am saying is the optimization only affects the last iteration and the only effect is that we throw the TimeoutException exactly at the timeout instead of past the timeout. The benefit is minimal AFAIK, unless I am missing something extraordinarily important.", "author": "jinmeiliao", "createdAt": "2020-11-14T01:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYwMDMzOQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r524600339", "bodyText": "The last iteration is the problem, why sleep to delay the return. Either just return because it would timeout at its regular interval or reduce the interval and try again before timing out. Either way there is no point I delaying the results in the last iteration as this implementation does.", "author": "pivotal-jbarrett", "createdAt": "2020-11-16T21:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYxNTg0Nw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r524615847", "bodyText": "what I am saying is that even it reduces the interval it wouldn't try again, it will always just throw TimeoutException in the end.", "author": "jinmeiliao", "createdAt": "2020-11-16T21:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYzNDc3Mg==", "url": "https://github.com/apache/geode/pull/5743#discussion_r524634772", "bodyText": "The example @jinmeiliao gave covers use-cases where the number of iterations is potentially large. Those are cases where time to run predicate + time to run supplier + sleep interval << timeout.\nThere are other use-cases where that relation does not hold. In those cases perhaps we will only execute the body of the loop once. Imagine time to run predicate + time to run supplier + sleep interval (=roughly-equal-to=) timeout i.e. the timeout interval is roughly of the same magnitude as the other work to be done each time through the loop. In that case, @pivotal-jbarrett's concern about overshooting the timeout seem more important. This second scenario seems to me to be worth the effort of the added complexity of calculating sleepTime = min(interval, until - now) and returning immediately if that's less-than-or-equal-to zero.", "author": "Bill", "createdAt": "2020-11-16T21:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxMjk1OA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r525312958", "bodyText": "@Bill Your example is a special case where the LAST iteration is the ONLY iteration. The extra computing only makes a difference in the LAST iteration and only when it throws a TimeoutException.\nI will try to make my case one more time, if after this, you guys still insist, I will rest my case.\n\nWithout the extra calculation, we would NEVER delay a normal return, we will only delay a TimeoutException by a little bit (maximum the rest period). Since we are going to timeout anyway, I don't really care about this little extra wait time.\nThe extra calculation only make a difference in the last iteration when it's about to reach a timeout, for all the previous loops, it's a waste of time and an extra call to the timer.getTime().\nuntil - now could be negative, so instead of the one liner timer.sleep(interval, intervalUnit), we need to make extra calculation and and if/else block, which completely take the beauty, simplicity and readability out of the code. Personally I think the detriment overweights the benefit.\n\nBut if you guys still think otherwise, do let me know. I will make the change. @Bill @pivotal-jbarrett", "author": "jinmeiliao", "createdAt": "2020-11-17T16:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MjE5MA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r526342190", "bodyText": "I don't think any extra call is needed to implement the proposal @jinmeiliao. The call to timer.nanoTime() can be done in the body of the loop and the result can be used in the body and in the while() condition I think . I still feel like the added code complexity is worth it since the whole point of making a stand-alone Retry utility like this is to be able to use it in many situations.", "author": "Bill", "createdAt": "2020-11-18T18:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA5OTMyNQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527099325", "bodyText": "No, we can't reuse timer.nanoTime() since it will be different time at the time of calculation.\nI am still not convinced, but I will go ahead and make the change and let you guys decide.", "author": "jinmeiliao", "createdAt": "2020-11-19T18:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyNDUyNQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527124525", "bodyText": "would something like this work:", "author": "Bill", "createdAt": "2020-11-19T18:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMDY1OQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527130659", "bodyText": "I think this will run the supplier and predicate one more time than the previous implementation.\nUsing my previous example of 10 seconds timeout and 3 seconds sleep (supplier and predicate execution time 0 and predicate always returns false), I am supposed to throw the TimeoutException after sleeping for the last 1 second , but your implementation will run supplier/predicate one more time and then throw.", "author": "jinmeiliao", "createdAt": "2020-11-19T19:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NDY5MA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527144690", "bodyText": "Agreed. With this approach we never return directly after a sleep. (That's what @pivotal-jbarrett meant above when he said \"No point in sleeping if we are just going to fall through the while block immediately, we aren't trying to delay the return but rather the execution of the code block\") We always return immediately after testing the predicate. It is different, but I don't think it's wrong.\nIf we are bothering to sleep, it makes sense to give the predicate one last try before returning. Otherwise why did we sleep?", "author": "Bill", "createdAt": "2020-11-19T19:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NjAxNw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527166017", "bodyText": "I think I get your point, we already wasted some time, why don't we give it another try? It all boils down to what you think is right or tolerable.", "author": "jinmeiliao", "createdAt": "2020-11-19T20:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTUyMw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527185523", "bodyText": "you know if we change your implementation a little bit, instead of if (sleepNanos > 0) we change it to if(sleepNanos == intervalNanos), I think this would be best.", "author": "jinmeiliao", "createdAt": "2020-11-19T20:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5ODU2MQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527198561", "bodyText": "Ok, I think my last commit combines the good points of both implementation. Thanks for all the points and nudges.", "author": "jinmeiliao", "createdAt": "2020-11-19T21:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcwMTUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MTIxNQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r523291215", "bodyText": "so cool!", "author": "Bill", "createdAt": "2020-11-13T23:53:49Z", "path": "geode-common/src/main/java/org/apache/geode/internal/inet/LocalHostUtil.java", "diffHunk": "@@ -54,19 +59,27 @@\n   private static final boolean useLinkLocalAddresses =\n       Boolean.getBoolean(USE_LINK_LOCAL_ADDRESSES_PROPERTY);\n \n-  /**\n-   * we cache localHost to avoid bug #40619, access-violation in native code\n-   */\n-  private static final InetAddress localHost;\n-\n   /**\n    * all classes should use this variable to determine whether to use IPv4 or IPv6 addresses\n    */\n   @MakeNotStatic\n   private static boolean useIPv6Addresses = !Boolean.getBoolean(\"java.net.preferIPv4Stack\")\n       && Boolean.getBoolean(\"java.net.preferIPv6Addresses\");\n \n-  static {\n+  /**\n+   * Resolves local host. Will retry if resolution fails.\n+   *\n+   * @return local host if resolved otherwise null.\n+   */\n+  private static InetAddress tryToResolveLocalHost() {\n+    try {\n+      return tryFor(60, SECONDS, 1, SECONDS, LocalHostUtil::resolveLocalHost, Objects::nonNull);", "originalCommit": "7ad348d3a30b31742355f8483dc503c917ca8752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3eb958505fb986de09fc1fe7fae085f9ad61e760", "url": "https://github.com/apache/geode/commit/3eb958505fb986de09fc1fe7fae085f9ad61e760", "message": "make the last iteration sleep less than interval if necessary", "committedDate": "2020-11-19T19:19:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NzIxMw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527147213", "bodyText": "I recommend testing the condition after the conversion to milliseconds since e.g. NANOSECONDS.toMillis(1) == 0", "author": "Bill", "createdAt": "2020-11-19T19:35:03Z", "path": "geode-common/src/main/java/org/apache/geode/internal/Retry.java", "diffHunk": "@@ -32,18 +31,21 @@\n   interface Timer {\n     long nanoTime();\n \n-    void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedException;\n+    void sleep(long sleepTimeInNano) throws InterruptedException;\n   }\n \n-  private static class SteadyTimer implements Timer {\n+  static class SteadyTimer implements Timer {\n     @Override\n     public long nanoTime() {\n       return System.nanoTime();\n     }\n \n     @Override\n-    public void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedException {\n-      Thread.sleep(MILLISECONDS.convert(sleepTime, sleepTimeUnit));\n+    public void sleep(long sleepTimeInNano) throws InterruptedException {\n+      // avoid throwing IllegalArgumentException\n+      if (sleepTimeInNano > 0) {\n+        Thread.sleep(NANOSECONDS.toMillis(sleepTimeInNano));", "originalCommit": "3eb958505fb986de09fc1fe7fae085f9ad61e760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NjUyNA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527166524", "bodyText": "good point.", "author": "jinmeiliao", "createdAt": "2020-11-19T20:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0Nzk5Mw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527147993", "bodyText": "I recommend converting this outside the loop since it never changes.", "author": "Bill", "createdAt": "2020-11-19T19:36:21Z", "path": "geode-common/src/main/java/org/apache/geode/internal/Retry.java", "diffHunk": "@@ -82,7 +84,9 @@ public void sleep(long sleepTime, TimeUnit sleepTimeUnit) throws InterruptedExce\n       if (predicate.test(value)) {\n         return value;\n       } else {\n-        timer.sleep(interval, intervalUnit);\n+        long sleepTimeInNano =\n+            Math.min(NANOSECONDS.convert(interval, intervalUnit), until - timer.nanoTime());", "originalCommit": "3eb958505fb986de09fc1fe7fae085f9ad61e760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NjM4OA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527166388", "bodyText": "no, it changes, only in the last iteration though.", "author": "jinmeiliao", "createdAt": "2020-11-19T20:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0Nzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4Nzg3Mg==", "url": "https://github.com/apache/geode/pull/5743#discussion_r528887872", "bodyText": "ah yes!", "author": "Bill", "createdAt": "2020-11-23T17:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0Nzk5Mw=="}], "type": "inlineReview"}, {"oid": "3327c7e9be36f072c67faef3fdfd2d8210dbc1a8", "url": "https://github.com/apache/geode/commit/3327c7e9be36f072c67faef3fdfd2d8210dbc1a8", "message": "review changes", "committedDate": "2020-11-19T20:10:58Z", "type": "commit"}, {"oid": "5c8d9dfdef48d155b45bb9ccf2bab06b19b89c72", "url": "https://github.com/apache/geode/commit/5c8d9dfdef48d155b45bb9ccf2bab06b19b89c72", "message": "do not sleep if the time is less than the allotted sleep time", "committedDate": "2020-11-19T21:04:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527892343", "bodyText": "There is no need to sleep for the full interval (intervalNano) if until - timer.nanoTime() is smaller.\nI recommend (again), as have others, that the code sleep for the minimum time required. We understand that Thread.sleep() does not make real-time guarantees. Nevertheless, this code would be more robust and accurate if it was coded that way.\nSomething like this:", "author": "Bill", "createdAt": "2020-11-20T18:24:01Z", "path": "geode-common/src/main/java/org/apache/geode/internal/Retry.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+\n+/**\n+ * Utility class for retrying operations.\n+ */\n+public class Retry {\n+\n+  interface Timer {\n+    long nanoTime();\n+\n+    void sleep(long sleepTimeInNano) throws InterruptedException;\n+  }\n+\n+  static class SteadyTimer implements Timer {\n+    @Override\n+    public long nanoTime() {\n+      return System.nanoTime();\n+    }\n+\n+    @Override\n+    public void sleep(long sleepTimeInNano) throws InterruptedException {\n+      long millis = NANOSECONDS.toMillis(sleepTimeInNano);\n+      // avoid throwing IllegalArgumentException\n+      if (millis > 0) {\n+        Thread.sleep(millis);\n+      }\n+    }\n+  }\n+\n+  private static final SteadyTimer steadyClock = new SteadyTimer();\n+\n+  /**\n+   * Try the supplier function until the predicate is true or timeout occurs.\n+   *\n+   * @param timeout to retry for\n+   * @param timeoutUnit the unit for timeout\n+   * @param interval time between each try\n+   * @param intervalUnit the unit for interval\n+   * @param supplier to execute until predicate is true or times out\n+   * @param predicate to test for retry\n+   * @param <T> type of return value\n+   * @return value from supplier after it passes predicate or times out.\n+   */\n+  public static <T> T tryFor(long timeout, TimeUnit timeoutUnit,\n+      long interval, TimeUnit intervalUnit,\n+      Supplier<T> supplier,\n+      Predicate<T> predicate) throws TimeoutException, InterruptedException {\n+    return tryFor(timeout, timeoutUnit, interval, intervalUnit, supplier, predicate, steadyClock);\n+  }\n+\n+  @VisibleForTesting\n+  static <T> T tryFor(long timeout, TimeUnit timeoutUnit,\n+      long interval, TimeUnit intervalUnit,\n+      Supplier<T> supplier,\n+      Predicate<T> predicate,\n+      Timer timer) throws TimeoutException, InterruptedException {\n+    long until = timer.nanoTime() + NANOSECONDS.convert(timeout, timeoutUnit);\n+    long intervalNano = NANOSECONDS.convert(interval, intervalUnit);\n+\n+    T value;\n+    for (;;) {\n+      value = supplier.get();\n+      if (predicate.test(value)) {\n+        return value;\n+      } else {\n+        // if there is still more time left after we sleep for interval period, then sleep and retry\n+        // otherwise break out and throw TimeoutException\n+        if ((timer.nanoTime() + intervalNano) < until) {", "originalCommit": "5c8d9dfdef48d155b45bb9ccf2bab06b19b89c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAzNjA4OA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r528036088", "bodyText": "@Bill per our offline meetings, can I merge this now?", "author": "jinmeiliao", "createdAt": "2020-11-21T00:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg5NzIyOA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r528897228", "bodyText": "I think a user of the Retry class would (rightly) expect tryFor() to keep trying if timeout has not yet been reached.\nComputing sleepNanos gives good results when intervalUnit is greater than (timeoutUnit - supplier time - predicate time). Without sleepNanos, that scenario results in no retries at all which I think most users of the Retry class would find counterintuitive.\nFailing to compute sleepNanos introduces an error. That error is directly proportional to interval and the relative error (error / timeout) grows as interval grows relative to timeout.\nComputing sleepNanos is simple and cheap. It gives better accuracy and meets user expectations in all cases. Unless you foresee some problem computing sleepNanos I still recommend doing it.", "author": "Bill", "createdAt": "2020-11-23T18:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEzNTE5NQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r529135195", "bodyText": "I think a user of the Retry class would (rightly) expect tryFor() to keep trying if timeout has not yet been reached.\nComputing sleepNanos gives good results when intervalUnit is greater than (timeoutUnit - supplier time - predicate time). Without sleepNanos, that scenario results in no retries at all which I think most users of the Retry class would find counterintuitive.\n\nSo if say timeout is 5 second, supplier and predicate takes 3 seconds, and interval is 3 seconds, I won't expect there would be any retries at all. I don't think this is counterintuitive.\n\nFailing to compute sleepNanos introduces an error. That error is directly proportional to interval and the relative error (error / timeout) grows as interval grows relative to timeout.\nComputing sleepNanos is simple and cheap. It gives better accuracy and meets user expectations in all cases. Unless you foresee some problem computing sleepNanos I still recommend doing it.", "author": "jinmeiliao", "createdAt": "2020-11-24T02:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MjE4MA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r529972180", "bodyText": "A user of tryFor() does not know (usually cannot know) how much clock time their supplier and predicate will take. So they won't be able to do the reasoning you just did there. I think what they'll usually do is try to pick timeout much larger than the (supplier+predicate) time.\nWe can presume that they will usually try to set timeout long enough so that at least one retry (two tries) can happen. If we lettimeout mean: keep trying until timeout has elapsed, then the \"error\" term I referred to in my previous comment is the difference between timeout and the actual time of the final attempt. As a user I'd expect tryFor() to make a reasonable effort to minimize that error.\nMaybe it would help if, in my proposal,interval was interpreted as \"typical sleep time\". For all but the last iteration interval is the actual sleep time. Usually, in the last interval (under my proposal) sleepNanos will be less than maximumSleepTime.\nIs there some reason why you object to (usually) sleeping a shorter time before the final try? Do you think that calling min() and capturing the result in a variable (sleepNanos) is overly burdensome? Do you see any value in making some effort to make the timing of the actual final attempt correspond to timeout?", "author": "Bill", "createdAt": "2020-11-24T22:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NjA0Nw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r529976047", "bodyText": "what's the point of sleeping if we know we are going to reach timeout after sleeping and throw a TimeoutException?", "author": "jinmeiliao", "createdAt": "2020-11-24T23:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4MTMxMw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r529981313", "bodyText": "After each sleep() (in my proposal) we go back to the top of the loop and execute the supplier and the predicate again. We only break (and throw the exception) if ! (sleepNanos > 0))", "author": "Bill", "createdAt": "2020-11-24T23:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEyMDU1Mw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r530120553", "bodyText": "A user of tryFor() does not know (usually cannot know) how much clock time their supplier and predicate will take. So they won't be able to do the reasoning you just did there. I think what they'll usually do is try to pick timeout much larger than the (supplier+predicate) time.\nWe can presume that they will usually try to set timeout long enough so that at least one retry (two tries) can happen. If we lettimeout mean: keep trying until timeout has elapsed, then the \"error\" term I referred to in my previous comment is the difference between timeout and the actual time of the final attempt. As a user I'd expect tryFor() to make a reasonable effort to minimize that error.\n\nNo matter how long the timeout to be or how short the interval to be, a user can NOT \"reasonably\" assume two tries should happen at all. Even if I set timeout to be 100 seconds, and interval to be 1 second, there are plenty of chances that I could try only one time and the timeout period has already elapsed.\n\nMaybe it would help if, in my proposal,interval was interpreted as \"typical sleep time\". For all but the last iteration interval is the actual sleep time. Usually, in the last interval (under my proposal) sleepNanos will be less than maximumSleepTime.\nIs there some reason why you object to (usually) sleeping a shorter time before the final try? Do you think that calling min() and capturing the result in a variable (sleepNanos) is overly burdensome? Do you see any value in making some effort to make the timing of the actual final attempt correspond to timeout?\n\nMy objection is :\n\nthere is no point in sleeping if we know we are going to timeout at the end of sleep.\nIt feels even more counter-intuitive that we know we've already reached the end of the timeout period and then still go ahead and try again. It's actually wrong.", "author": "jinmeiliao", "createdAt": "2020-11-25T05:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1ODAyMA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r530558020", "bodyText": "I don't understand (1). In my proposal we never time out at the end of a sleep. After a sleep we always try the supplier and predicate again. In cases where the predicate returns false forever, we would always sleep and then try the predicate and then break (and throw the exception.)\nIn cases where the predicate returns false forever, our final attempt is made as close to the timeout as possible (given the limitations of Java thread scheduling). This is exactly what a user expects.", "author": "Bill", "createdAt": "2020-11-25T18:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU3NjAyMA==", "url": "https://github.com/apache/geode/pull/5743#discussion_r530576020", "bodyText": "In cases where the predicate returns false forever, our final attempt is made as close to the timeout as possible (given the limitations of Java thread scheduling). This is exactly what a user expects.\n\nIn your proposal, at your final attempt, you calculated what's the time left till timeout, then you sleep till timeout. Our differences lie at this point afterwards, I think that since we are already at timeout point we should throw exception, but you think we should try again. I don't think \"trying again\" is \"exactly what a user expects\", since I certainly didn't expect that.\nLet's just list out the choices here and decide what's the \"most\" reasonable thing to do. Say our interval is 3 seconds, and there are only 2 seconds left after our last call to the supplier and the predicate is still false,  At this point, we can do either of the following:\n\nthrow timeout immediately (my implementation)\nsleep for 2 seconds till timeout and throw timeout (since 2 is what's left till timeout)\nsleep for 3 seconds and throw timeout (since 3 is what user has specified as interval)\nsleep for 2 seconds till timeout and then try again (your suggestion)\n\nIn the above 4, my opinion is 4 is the least reasonable, and 1 has some optimization among the first 3.", "author": "jinmeiliao", "createdAt": "2020-11-25T18:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NzY5Ng==", "url": "https://github.com/apache/geode/pull/5743#discussion_r532847696", "bodyText": "The usage of Retry (as it stands) in this PR, by tryToResolveLocalHost() is fine:\ntryFor(60, SECONDS, 1, SECONDS\u2026\nThe difference between (1) and (4) in this case is at most:\n(1) last retry at 59 seconds\n(4) last retry at 60 seconds\nIf the purpose of this PR were to make the best possible Retry utility, I might be inclined to continue the deliberation. But since the purpose of this PR is to retry resolving the localhost address, and the PR does that, my work is done here.\nIn the interest of forward progress, I withdraw my change request on this PR.", "author": "Bill", "createdAt": "2020-11-30T19:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5MjM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5NTEwMw==", "url": "https://github.com/apache/geode/pull/5743#discussion_r527895103", "bodyText": "By making sleep() take nanosecond units, every implementation (like the one below) has to make the conversion and handle any problems.\nI recommend making this method take millisecond units since that's what Thread.sleep() takes. This simplifies every implementation, and, perhaps more importantly, moves the error-handling logic up into the tryFor() method, making that method more robust.", "author": "Bill", "createdAt": "2020-11-20T18:28:56Z", "path": "geode-common/src/main/java/org/apache/geode/internal/Retry.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+\n+/**\n+ * Utility class for retrying operations.\n+ */\n+public class Retry {\n+\n+  interface Timer {\n+    long nanoTime();\n+\n+    void sleep(long sleepTimeInNano) throws InterruptedException;", "originalCommit": "5c8d9dfdef48d155b45bb9ccf2bab06b19b89c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMzc3MQ==", "url": "https://github.com/apache/geode/pull/5743#discussion_r532833771", "bodyText": "After talking to @jinmeiliao and thinking about this some more I think the current implementation (nanosecond units) is ok.", "author": "Bill", "createdAt": "2020-11-30T19:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5NTEwMw=="}], "type": "inlineReview"}]}