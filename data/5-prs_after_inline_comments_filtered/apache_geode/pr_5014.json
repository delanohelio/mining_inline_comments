{"pr_number": 5014, "pr_title": "GEODE-8035: Parallel Disk Store Recovery when Cluster Restarts", "pr_createdAt": "2020-04-28T20:35:01Z", "pr_url": "https://github.com/apache/geode/pull/5014", "timeline": [{"oid": "bf3276805d04c7269951728848f4d0a46b9d267a", "url": "https://github.com/apache/geode/commit/bf3276805d04c7269951728848f4d0a46b9d267a", "message": "Add parallel stream for disk store recovery\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-21T17:53:42Z", "type": "commit"}, {"oid": "87fd8d9818986168ed9d3dfc1a15df4e16cf1a0c", "url": "https://github.com/apache/geode/commit/87fd8d9818986168ed9d3dfc1a15df4e16cf1a0c", "message": "More parallel stream\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-21T21:08:49Z", "type": "commit"}, {"oid": "07490d14c79298edcbdc7dd37198d6b67183ee70", "url": "https://github.com/apache/geode/commit/07490d14c79298edcbdc7dd37198d6b67183ee70", "message": "spotlessApply\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-21T21:24:05Z", "type": "commit"}, {"oid": "ce2159090f1487d81086772d0bceb32c69078455", "url": "https://github.com/apache/geode/commit/ce2159090f1487d81086772d0bceb32c69078455", "message": "Temporarily remove the synchronized block\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-21T22:44:29Z", "type": "commit"}, {"oid": "d6240e59378ec3ae479d8f38875c5f007a27db13", "url": "https://github.com/apache/geode/commit/d6240e59378ec3ae479d8f38875c5f007a27db13", "message": "spotlessApply\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-21T22:50:21Z", "type": "commit"}, {"oid": "8737b1ddde8bd59040d362fd4f35793bfe6bcdda", "url": "https://github.com/apache/geode/commit/8737b1ddde8bd59040d362fd4f35793bfe6bcdda", "message": "Replace synchronized block with CountDownLatch\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-24T19:41:35Z", "type": "commit"}, {"oid": "9af1c9195b2c04fc4679ed72123b2d2a2b9686fc", "url": "https://github.com/apache/geode/commit/9af1c9195b2c04fc4679ed72123b2d2a2b9686fc", "message": "Revert some code\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-24T19:45:37Z", "type": "commit"}, {"oid": "b9c7ecfc37fe1e4befef516371fa97a231519a0f", "url": "https://github.com/apache/geode/commit/b9c7ecfc37fe1e4befef516371fa97a231519a0f", "message": "Code clean up\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-28T16:27:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDQ1NQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r416930455", "bodyText": "Would it be possible to put a bound on the number of threads used here? In cases with large numbers of disk stores this might cause resource issues if unbounded, but maybe we never have so many disk stores that it will matter.", "author": "DonalEvans", "createdAt": "2020-04-28T21:21:10Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/xmlcache/CacheCreation.java", "diffHunk": "@@ -521,12 +521,12 @@ void create(InternalCache cache)\n \n     cache.initializePdxRegistry();\n \n-    for (DiskStore diskStore : diskStores.values()) {\n+    diskStores.values().parallelStream().forEach(diskStore -> {", "originalCommit": "b9c7ecfc37fe1e4befef516371fa97a231519a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NjMwMw==", "url": "https://github.com/apache/geode/pull/5014#discussion_r416956303", "bodyText": "In Geode use case, it won't be large number of diskstore. The worst case is less than region number.", "author": "gesterzhou", "createdAt": "2020-04-28T22:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NTI2Mw==", "url": "https://github.com/apache/geode/pull/5014#discussion_r417655263", "bodyText": "Parallel stream by default uses ForkJoinPool with parallelism equals the number of processors.", "author": "jchen21", "createdAt": "2020-04-29T22:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTEyNQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r416931125", "bodyText": "This comment is no longer entirely accurate.", "author": "DonalEvans", "createdAt": "2020-04-28T21:22:21Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DiskStoreFactoryImpl.java", "diffHunk": "@@ -144,7 +144,10 @@ public DiskStore create(String name) {\n     // As a simple fix for 41290, only allow one DiskStore to be created\n     // at a time per cache by syncing on the cache.", "originalCommit": "b9c7ecfc37fe1e4befef516371fa97a231519a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMDY1NQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r418320655", "bodyText": "Agree.", "author": "jchen21", "createdAt": "2020-04-30T22:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzA2MA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r416937060", "bodyText": "I think there is a small possibility of a race condition causing an NPE here if the latch associated with diskStoreName is removed after the first get() call. Would it be possible to change this method to use only one get() call?", "author": "DonalEvans", "createdAt": "2020-04-28T21:33:17Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -1086,6 +1088,32 @@ public static GemFireCacheImpl getForPdx(String reason) {\n     clientMetadataService = clientMetadataServiceFactory.apply(this);\n   }\n \n+  public void lockDiskStore(String diskStoreName) {\n+    CountDownLatch countDownLatch = diskStoreLatches.get(diskStoreName);\n+    if (countDownLatch == null) {\n+      countDownLatch = diskStoreLatches.putIfAbsent(diskStoreName, new CountDownLatch(1));\n+      if (countDownLatch != null) {\n+        try {\n+          countDownLatch.await();\n+        } catch (InterruptedException e) {\n+          throw new InternalGemFireError(e);\n+        }\n+      }\n+    } else {\n+      try {\n+        countDownLatch.await();\n+      } catch (InterruptedException e) {\n+        throw new InternalGemFireError(e);\n+      }\n+    }\n+  }\n+\n+  public void unlockDiskStore(String diskStoreName) {\n+    if (diskStoreLatches.get(diskStoreName) != null) {\n+      diskStoreLatches.get(diskStoreName).countDown();\n+    }", "originalCommit": "b9c7ecfc37fe1e4befef516371fa97a231519a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1OTE2Nw==", "url": "https://github.com/apache/geode/pull/5014#discussion_r417159167", "bodyText": "I second @DonalEvans's comments here, could we use computeIfPresent or something similar?.\nAs a side note, if somebody invokes unlockDiskStore before calling lockDiskStore for exactly the same diskName first (aka the entry is null), shouldn't we throw an exception directly as the caller is using the API in a wrong way?.", "author": "jujoramos", "createdAt": "2020-04-29T08:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1MTU3NA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r417651574", "bodyText": "Agree. There could be an NPE.", "author": "jchen21", "createdAt": "2020-04-29T22:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAyMjA4NQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419022085", "bodyText": "@jujoramos if the entry is null, we can't tell whether it is because the disk store is removed, or somebody invokes unlockDiskStore before lockDiskStore. We don't want to throw an exception, when the entry is null because the disk store is removed. I would  prefer not throwing an exception when the entry is null.", "author": "jchen21", "createdAt": "2020-05-02T23:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MTYwMg==", "url": "https://github.com/apache/geode/pull/5014#discussion_r417151602", "bodyText": "Can you the methods lockDiskStore and unlockDiskStore to the InternalCache interface instead?. It's cleaner as we won't need to cast to GemFireCacheImpl, besides that, we could use these methods in the future from other parts of the code.", "author": "jujoramos", "createdAt": "2020-04-29T08:33:40Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DiskStoreFactoryImpl.java", "diffHunk": "@@ -165,6 +168,10 @@ public DiskStore create(String name) {\n           creation.addDiskStore(result);\n         }\n       }\n+    } finally {\n+      if (this.cache instanceof GemFireCacheImpl) {\n+        ((GemFireCacheImpl) this.cache).unlockDiskStore(name);\n+      }", "originalCommit": "b9c7ecfc37fe1e4befef516371fa97a231519a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMDUxOQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r418320519", "bodyText": "If lockDiskStoreand unlockDiskStore are moved to InternalCache, all the classes that implement the interface have to implement lockDiskStoreand unlockDiskStore. However, only GemFireCacheImpl actually needs lockDiskStoreand unlockDiskStore. I don't think CacheCreation and InternalCacheForClientAccess need them.", "author": "jchen21", "createdAt": "2020-04-30T22:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MTYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzOTAxMg==", "url": "https://github.com/apache/geode/pull/5014#discussion_r418339012", "bodyText": "OK. Let's use the default implementation in InternalCache.", "author": "jchen21", "createdAt": "2020-04-30T23:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MTYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1NTU1NA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r417155554", "bodyText": "The above can be simplified with something like:\npublic void lockDiskStore(String diskStoreName) {\n\tCountDownLatch latch = JavaWorkarounds.computeIfAbsent(diskStoreLatches, diskStoreName, k -> new CountDownLatch(1));\n\n\ttry {\n\t\tcountDownLatch.await();\n\t} catch (InterruptedException e) {\n\t\tthrow new InternalGemFireError(e);\n\t}\n}", "author": "jujoramos", "createdAt": "2020-04-29T08:40:44Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -1086,6 +1088,32 @@ public static GemFireCacheImpl getForPdx(String reason) {\n     clientMetadataService = clientMetadataServiceFactory.apply(this);\n   }\n \n+  public void lockDiskStore(String diskStoreName) {\n+    CountDownLatch countDownLatch = diskStoreLatches.get(diskStoreName);\n+    if (countDownLatch == null) {\n+      countDownLatch = diskStoreLatches.putIfAbsent(diskStoreName, new CountDownLatch(1));\n+      if (countDownLatch != null) {\n+        try {\n+          countDownLatch.await();\n+        } catch (InterruptedException e) {\n+          throw new InternalGemFireError(e);\n+        }\n+      }\n+    } else {\n+      try {\n+        countDownLatch.await();\n+      } catch (InterruptedException e) {\n+        throw new InternalGemFireError(e);\n+      }\n+    }\n+  }", "originalCommit": "b9c7ecfc37fe1e4befef516371fa97a231519a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1MDc0NA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r417650744", "bodyText": "In your simplified code, all thread will await(), which is not correct.", "author": "jchen21", "createdAt": "2020-04-29T22:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1NTU1NA=="}], "type": "inlineReview"}, {"oid": "88a77fc173c32a3771df54235f9c04a4905ab134", "url": "https://github.com/apache/geode/commit/88a77fc173c32a3771df54235f9c04a4905ab134", "message": "Fix the code that could introduce NPE\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-30T22:32:13Z", "type": "commit"}, {"oid": "e7d57a5aaf5c1bc8894e5211a232da34c07c0bec", "url": "https://github.com/apache/geode/commit/e7d57a5aaf5c1bc8894e5211a232da34c07c0bec", "message": "Use default implementation in InternalCache\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-30T23:10:11Z", "type": "commit"}, {"oid": "0388205c1d73bf7a1e8d430b633cd9a28715d008", "url": "https://github.com/apache/geode/commit/0388205c1d73bf7a1e8d430b633cd9a28715d008", "message": "Minor fix\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-30T23:14:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r418363668", "bodyText": "How is the exception handled?", "author": "agingade", "createdAt": "2020-05-01T00:34:26Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/xmlcache/CacheCreation.java", "diffHunk": "@@ -521,12 +521,12 @@ void create(InternalCache cache)\n \n     cache.initializePdxRegistry();\n \n-    for (DiskStore diskStore : diskStores.values()) {\n+    diskStores.values().parallelStream().forEach(diskStore -> {\n       DiskStoreAttributesCreation creation = (DiskStoreAttributesCreation) diskStore;\n       if (creation != pdxRegDSC) {\n         createDiskStore(creation, cache);\n       }\n-    }\n+    });", "originalCommit": "0388205c1d73bf7a1e8d430b633cd9a28715d008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2ODk3OA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r418368978", "bodyText": "Need to add unit/integration tests for both cases, with multiple and single thread trying to create disk-stores.", "author": "agingade", "createdAt": "2020-05-01T00:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAyMDIyOQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419020229", "bodyText": "I am not sure which exception you are talking about. I don't see parallelStream() and forEach() introduce new exception, based on the Javadoc.\nFor test coverage, there are quite a few existing tests that already cover the single thread or multiple disk stores cases. We don't have to add new tests for that.\nFor multi-thread test, it is a very tricky one. The purpose of this pull request is to introduce parallel disk recovery and improve the performance. We can assert that the stream should be parallel using isParallel(). Or we can scan the logs and make sure there are multiple thread IDs that recover the disk stores. But it doesn't serve the purpose of testing performance improvement. It doesn't guarantee that disk recovery is parallel, even if we can assert that the stream is parallel or there are multiple threads that recover the disk store. For example, if we keep the synchronized block in DiskStoreFactoryImple line 147, the disk stores recovery will be sequential, even though there are multiple threads recovering the disk stores.", "author": "jchen21", "createdAt": "2020-05-02T23:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NjQ3Mw==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419046473", "bodyText": "Based on the DiskStoreFactory.create() it can throw IllegalArgumentException; probably IOException based on the disk read failures. In case there are multiple disk-store failures, we will leave the parallel stream to throw the exception or we will capture all the exception and throw a single exception with all the disk=store names in it...\nI was thinking from unit test level; if there are already tests covering the new code. No need of new tests.", "author": "agingade", "createdAt": "2020-05-03T04:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzU5MA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419807590", "bodyText": "If all the disk store is on the same disk-mount (or same disk controller) doing it in the multi thread may be slower (due to read seek jumping from one location to other). In that case, is it a good idea to have default behavior to be single threaded and have system property to use multiple thread or visa versa.\nUser may configure different disk store on the same disk-controller, to isolate the region persistent files, which is commonly done.", "author": "agingade", "createdAt": "2020-05-05T00:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2Mzg2Ng==", "url": "https://github.com/apache/geode/pull/5014#discussion_r421863866", "bodyText": "The system property is added. Tests are added as well.", "author": "jchen21", "createdAt": "2020-05-08T00:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3ODk1MA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423278950", "bodyText": "Can we move this code block to helper method...The create() is becoming too long...", "author": "agingade", "createdAt": "2020-05-11T19:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI4MDI5Mg==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423280292", "bodyText": "How about test where one/two of the recovery thread throws IllegalArgumentException...", "author": "agingade", "createdAt": "2020-05-11T19:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2OTYzNA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423969634", "bodyText": "Refactored the code block to helper method. Done.", "author": "jchen21", "createdAt": "2020-05-12T19:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3MDcyMQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423970721", "bodyText": "I am not sure which method throws IllegalArgumentException. To the best of my knowledge, the new code I introduced does not throw IllegalArgumentException. If existing code throws IllegalArgumentException, it is beyond the scope of this JIRA.", "author": "jchen21", "createdAt": "2020-05-12T19:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NDY1OA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r418364658", "bodyText": "Is get() required, when using putIfAbsent()? putIfAbsent will return either null or old value.", "author": "agingade", "createdAt": "2020-05-01T00:38:29Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -1086,6 +1088,35 @@ public static GemFireCacheImpl getForPdx(String reason) {\n     clientMetadataService = clientMetadataServiceFactory.apply(this);\n   }\n \n+  @Override\n+  public void lockDiskStore(String diskStoreName) {\n+    CountDownLatch countDownLatch = diskStoreLatches.get(diskStoreName);", "originalCommit": "0388205c1d73bf7a1e8d430b633cd9a28715d008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAxODIwNQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419018205", "bodyText": "Good point! I will make the change per your suggestion.", "author": "jchen21", "createdAt": "2020-05-02T22:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NDY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NzU0Mw==", "url": "https://github.com/apache/geode/pull/5014#discussion_r418367543", "bodyText": "Based on the previous comment for 41290; it seems there was a need to create disk-store one at a time.\nFrom the comment its not clear, if its when the disk-stores are created through java API or cache xml (ClusterConfig).\nWhy do we need to change the synchronization...Here the disk-stores are just added into the map and reading from the disk happens in the CacheCreation.java.", "author": "agingade", "createdAt": "2020-05-01T00:50:28Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DiskStoreFactoryImpl.java", "diffHunk": "@@ -141,10 +141,9 @@ DiskStoreImpl createOwnedByRegion(String name, boolean isOwnedByPR,\n   @Override\n   public DiskStore create(String name) {\n     this.attrs.name = name;\n-    // As a simple fix for 41290, only allow one DiskStore to be created\n-    // at a time per cache by syncing on the cache.\n     DiskStore result;\n-    synchronized (this.cache) {\n+    try {", "originalCommit": "0388205c1d73bf7a1e8d430b633cd9a28715d008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAxODExMg==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419018112", "bodyText": "Before I created this pull request, I actually looked into 41290, which was created more than 10 years ago. It was a totally different implementation. 41290 is no longer a concern.\nWe do need to remove the synchronization, in order to make the disk store recovery parallel. This synchronized block not only adds disk stores into the map, but also reads the disks, please see initializeDiskStore(dsi); in line 157. initializeDiskStore() eventually invokes Oplog.recoverCrf() and Oplog.readKrf(). Without removing the synchronization, the disk store can only be recovered one at a time.", "author": "jchen21", "createdAt": "2020-05-02T22:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NzU0Mw=="}], "type": "inlineReview"}, {"oid": "b535e4ace05e747ffff3059dc53bf13e4ec7bca5", "url": "https://github.com/apache/geode/commit/b535e4ace05e747ffff3059dc53bf13e4ec7bca5", "message": "Remove unnecessary ConcurrentMap.get()\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-02T23:26:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzU0NA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419567544", "bodyText": "putIfAbsent returns the old value (if any) or null. Are you trying to await() on the old Latch or the new one you just put in the ConcurrentMap?", "author": "kirklund", "createdAt": "2020-05-04T16:33:33Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -1086,6 +1088,27 @@ public static GemFireCacheImpl getForPdx(String reason) {\n     clientMetadataService = clientMetadataServiceFactory.apply(this);\n   }\n \n+  @Override\n+  public void lockDiskStore(String diskStoreName) {\n+    CountDownLatch countDownLatch =\n+        diskStoreLatches.putIfAbsent(diskStoreName, new CountDownLatch(1));\n+    if (countDownLatch != null) {\n+      try {\n+        countDownLatch.await();", "originalCommit": "b535e4ace05e747ffff3059dc53bf13e4ec7bca5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3ODQ4MA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r419578480", "bodyText": "It will await() on the old latch. More specifically, the first thread will put a new CountDownLatch in the map. The other threads will await() on the latch that the first thread put in the map.", "author": "jchen21", "createdAt": "2020-05-04T16:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzU0NA=="}], "type": "inlineReview"}, {"oid": "11bbce31d1eaf26c405dfac2efa039c5fb0ee646", "url": "https://github.com/apache/geode/commit/11bbce31d1eaf26c405dfac2efa039c5fb0ee646", "message": "Add a unit test for GemFireCacheImpl\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-05T21:19:18Z", "type": "commit"}, {"oid": "4df132765993b0a0124e9382f4fe6d0a8059c258", "url": "https://github.com/apache/geode/commit/4df132765993b0a0124e9382f4fe6d0a8059c258", "message": "DUnit test for parallel disk store recovery\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-06T01:08:43Z", "type": "commit"}, {"oid": "d5d5abfed8faf24ce35ce56cf27438a72c20cb6d", "url": "https://github.com/apache/geode/commit/d5d5abfed8faf24ce35ce56cf27438a72c20cb6d", "message": "Revert \"DUnit test for parallel disk store recovery\"\n\nThis reverts commit 4df132765993b0a0124e9382f4fe6d0a8059c258.", "committedDate": "2020-05-06T05:06:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NTc2MQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r420945761", "bodyText": "I recommend replacing ExecutorService with ExecutorServiceRule. You can limit the rule to a specific number of threads if you need to otherwise it defaults to as many threads as tasks that you submit:\n@Rule\npublic ExecutorServiceRule executorServiceRule = new ExecutorServiceRule();\n\nThe Rule will automatically do shutdown etc during tearDown().\nIf you await on the Futures, then any assertion failures will be thrown causing the test to fail:\nFuture<Void> doLockUnlock = executorService.submit(() -> {\n  try {\n    assertThat(gemFireCacheImpl.doLockDiskStore(diskStoreName)).isTrue();\n  } finally {\n    assertThat(gemFireCacheImpl. doUnlockDiskStore(diskStoreName)).isTrue();\n  }\n}\n\ndoLockUnlock.get(GeodeAwaitility.getTimeout().toMillis(), TimeUnit.MILLISECONDS);", "author": "kirklund", "createdAt": "2020-05-06T16:58:22Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/GemFireCacheImplTest.java", "diffHunk": "@@ -620,6 +625,40 @@ public void getCacheServers_isCanonical() {\n         .isSameAs(gemFireCacheImpl.getCacheServers());\n   }\n \n+  @Test\n+  public void testLockDiskStore() throws InterruptedException {\n+    int nThread = 10;\n+    String diskStoreName = \"MyDiskStore\";\n+    AtomicInteger nTrue = new AtomicInteger();\n+    AtomicInteger nFalse = new AtomicInteger();\n+    ExecutorService executorService = Executors.newFixedThreadPool(nThread);", "originalCommit": "d5d5abfed8faf24ce35ce56cf27438a72c20cb6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODI5OQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r420998299", "bodyText": "I had thought about using ExecutorServiceRule. However, the return value of doLockDiskStore() is non-deterministic. I can't assert the return value of individual thread. I can only count and assert the number of returning values when all threads are done. I am not sure how ExecutorServiceRule will serve this test case.", "author": "jchen21", "createdAt": "2020-05-06T18:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NTc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjM4MQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422262381", "bodyText": "I recommend using ExecutorServiceRule for several reasons. Most important is that it always performs tearDown (ie shutdownNow) even if the test blows up before invoking executorService.shutdown();", "author": "kirklund", "createdAt": "2020-05-08T17:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NTc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3MTEyOQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422271129", "bodyText": "Another alternative is to extract your executorService as a field so that shutdown or shutdownNow is always invoked even if the test has a failure:\nprivate ExecutorService executorService;\n\n@Before\npublic void setUp() {\n  executorService = Executors.newCachedThreadPool();\n}\n\n@After\npublic void tearDown() {\n  executorService.shutdownNow();\n}", "author": "kirklund", "createdAt": "2020-05-08T17:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NTc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3MTgwMQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423971801", "bodyText": "I have changed new test in GemFireCacheImplTest to use ExecutorServiceRule.", "author": "jchen21", "createdAt": "2020-05-12T19:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NTc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NzE3MQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r420947171", "bodyText": "If you use the Rule, you shouldn't need this or the shutdown. In general, you should however use GeodeAwaitility.getTimeout() instead of Long.MAX_VALUE.", "author": "kirklund", "createdAt": "2020-05-06T17:00:22Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/GemFireCacheImplTest.java", "diffHunk": "@@ -620,6 +625,40 @@ public void getCacheServers_isCanonical() {\n         .isSameAs(gemFireCacheImpl.getCacheServers());\n   }\n \n+  @Test\n+  public void testLockDiskStore() throws InterruptedException {\n+    int nThread = 10;\n+    String diskStoreName = \"MyDiskStore\";\n+    AtomicInteger nTrue = new AtomicInteger();\n+    AtomicInteger nFalse = new AtomicInteger();\n+    ExecutorService executorService = Executors.newFixedThreadPool(nThread);\n+    IntStream.range(0, nThread).forEach(tid -> {\n+      executorService.submit(() -> {\n+        try {\n+          boolean lockResult = gemFireCacheImpl.doLockDiskStore(diskStoreName);\n+          if (lockResult) {\n+            nTrue.incrementAndGet();\n+          } else {\n+            nFalse.incrementAndGet();\n+          }\n+        } finally {\n+          boolean unlockResult = gemFireCacheImpl.doUnlockDiskStore(diskStoreName);\n+          if (unlockResult) {\n+            nTrue.incrementAndGet();\n+          } else {\n+            nFalse.incrementAndGet();\n+          }\n+        }\n+      });\n+    });\n+    executorService.shutdown();\n+    executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);", "originalCommit": "d5d5abfed8faf24ce35ce56cf27438a72c20cb6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5MjA2OQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r420992069", "bodyText": "Will change it.", "author": "jchen21", "createdAt": "2020-05-06T18:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3MTk5NQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423971995", "bodyText": "Done.", "author": "jchen21", "createdAt": "2020-05-12T19:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NzE3MQ=="}], "type": "inlineReview"}, {"oid": "82aa312b41aca18fc2c729e6d46d14b0ed962f14", "url": "https://github.com/apache/geode/commit/82aa312b41aca18fc2c729e6d46d14b0ed962f14", "message": "Improve the unit test in GemFireCacheImplTest\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-06T18:32:25Z", "type": "commit"}, {"oid": "309944e95a61279f9a0fb606836379306af74d9c", "url": "https://github.com/apache/geode/commit/309944e95a61279f9a0fb606836379306af74d9c", "message": "Merge branch 'develop' into disk-recovery-perf-2", "committedDate": "2020-05-06T22:08:58Z", "type": "commit"}, {"oid": "bb5a4634c9df8626f0f45a11b1167e1766530b51", "url": "https://github.com/apache/geode/commit/bb5a4634c9df8626f0f45a11b1167e1766530b51", "message": "DUnit test for parallel disk store recovery\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-07T19:13:11Z", "type": "commit"}, {"oid": "5cf1fdc39b52ed554a432bae47ed3d9b2c21b39e", "url": "https://github.com/apache/geode/commit/5cf1fdc39b52ed554a432bae47ed3d9b2c21b39e", "message": "Limit the oplog size\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-07T21:01:52Z", "type": "commit"}, {"oid": "99d030342bc90fbeee14ba8a5b86a4b3839ea3c9", "url": "https://github.com/apache/geode/commit/99d030342bc90fbeee14ba8a5b86a4b3839ea3c9", "message": "System property for parallel or sequential disk store recovery\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-07T23:51:07Z", "type": "commit"}, {"oid": "023d64b15b24daa875e0f6a3c25a9c0bb2e1fb80", "url": "https://github.com/apache/geode/commit/023d64b15b24daa875e0f6a3c25a9c0bb2e1fb80", "message": "Fix a NPE\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-08T00:33:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1ODI0Mg==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422258242", "bodyText": "The Green Team provided a presentation and recommendations for DUnit tests that result in tests that are easy for other developers to maintain. One important recommendation is to use the Geode User APIs directly instead of using any sort of API replacement/wrapper including ClusterStartupRule. See The Green Report (if you don't have access please let me know -- I'm happy to share it with anyone).\nBasically, if a Rule or Wrapper hides anything about configuring, starting, stopping, or doing anything with Geode then we should not use it because it obscures Geode.", "author": "kirklund", "createdAt": "2020-05-08T17:02:54Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/ParallelDiskStoreRecoveryDUnitTest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+\n+import java.util.concurrent.Future;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class ParallelDiskStoreRecoveryDUnitTest {\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule();", "originalCommit": "023d64b15b24daa875e0f6a3c25a9c0bb2e1fb80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2NjY1OA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422366658", "bodyText": "Here's The Green Report on the Apache Geode Wiki: https://cwiki.apache.org/confluence/display/GEODE/The+Green+Report", "author": "kirklund", "createdAt": "2020-05-08T20:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1ODI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NDI2Mg==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423974262", "bodyText": "Thanks for the references! I have address all three issues:\n\nRemoved the use ClusterStartupRule.\nUses ExecutorServiceRule instead of ExecutorService.\nRemoved default empty interface methods.", "author": "jchen21", "createdAt": "2020-05-12T19:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1ODI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDAwMQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422260001", "bodyText": "Our coding standard has always disallowed declaration of multiple fields on one line. This may have slipped with Patrick setup spotless for Geode, but there was never a group discussion on the dev-list to get rid of this style requirement.", "author": "kirklund", "createdAt": "2020-05-08T17:06:34Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/ParallelDiskStoreRecoveryDUnitTest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+\n+import java.util.concurrent.Future;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class ParallelDiskStoreRecoveryDUnitTest {\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule();\n+\n+  @Rule\n+  public ExecutorServiceRule executorServiceRule = new ExecutorServiceRule();\n+\n+  private MemberVM locator, server1, server2;", "originalCommit": "023d64b15b24daa875e0f6a3c25a9c0bb2e1fb80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjQ3Mw==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422286473", "bodyText": "Will change it.", "author": "jchen21", "createdAt": "2020-05-08T17:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3MjI3Ng==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423972276", "bodyText": "Done.", "author": "jchen21", "createdAt": "2020-05-12T19:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2NTMwNA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422265304", "bodyText": "Does this needs to be before \"try\"? if lock throws exception without locking we may be trying to unlock it...", "author": "agingade", "createdAt": "2020-05-08T17:17:42Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DiskStoreFactoryImpl.java", "diffHunk": "@@ -141,10 +141,9 @@ DiskStoreImpl createOwnedByRegion(String name, boolean isOwnedByPR,\n   @Override\n   public DiskStore create(String name) {\n     this.attrs.name = name;\n-    // As a simple fix for 41290, only allow one DiskStore to be created\n-    // at a time per cache by syncing on the cache.\n     DiskStore result;\n-    synchronized (this.cache) {\n+    try {\n+      this.cache.lockDiskStore(name);", "originalCommit": "023d64b15b24daa875e0f6a3c25a9c0bb2e1fb80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4OTY5OQ==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422289699", "bodyText": "The unlock in the finally block does nothing, if the lock fails. The unlock is essentially a CountDownLatch.countDown(). If the current count is greater than zero then it is decremented. If the current count equals zero then nothing happens.", "author": "jchen21", "createdAt": "2020-05-08T18:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2NTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3MDMyNg==", "url": "https://github.com/apache/geode/pull/5014#discussion_r422270326", "bodyText": "Adding it here, makes it a distribution config setup...For system property you need to add in \"SystemPropertyHelper\". Look into \"EVICTION_SCAN_MAX_THREADS\" as an example.\nAlso, tests to verify the system property setting are working as expected....", "author": "agingade", "createdAt": "2020-05-08T17:27:29Z", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfigImpl.java", "diffHunk": "@@ -668,6 +668,8 @@\n    */\n   private int threadMonitorTimeLimit = DEFAULT_THREAD_MONITOR_TIME_LIMIT;\n \n+  private boolean parallelDiskStoreRecovery = DEFAULT_PARALLEL_DISK_STORE_RECOVERY;", "originalCommit": "023d64b15b24daa875e0f6a3c25a9c0bb2e1fb80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3MjY4NA==", "url": "https://github.com/apache/geode/pull/5014#discussion_r423972684", "bodyText": "This is done, including the new tests.", "author": "jchen21", "createdAt": "2020-05-12T19:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3MDMyNg=="}], "type": "inlineReview"}, {"oid": "8bdc563929efff1d9dea231b96cc569ddfe47bc0", "url": "https://github.com/apache/geode/commit/8bdc563929efff1d9dea231b96cc569ddfe47bc0", "message": "Using ExecutorServiceRule\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-08T17:54:09Z", "type": "commit"}, {"oid": "242bbf0eca876e3d88d3116fe539bef9f3242223", "url": "https://github.com/apache/geode/commit/242bbf0eca876e3d88d3116fe539bef9f3242223", "message": "Revert \"Fix a NPE\"\n\nThis reverts commit 023d64b15b24daa875e0f6a3c25a9c0bb2e1fb80.", "committedDate": "2020-05-11T18:27:42Z", "type": "commit"}, {"oid": "a0f52a1418eacc0a4cdd19f8a026cc788bfef6f8", "url": "https://github.com/apache/geode/commit/a0f52a1418eacc0a4cdd19f8a026cc788bfef6f8", "message": "Revert \"System property for parallel or sequential disk store recovery\"\n\nThis reverts commit 99d030342bc90fbeee14ba8a5b86a4b3839ea3c9.", "committedDate": "2020-05-11T18:29:37Z", "type": "commit"}, {"oid": "8c46cf350cb9198a1aa69fd109b2056f71011a1a", "url": "https://github.com/apache/geode/commit/8c46cf350cb9198a1aa69fd109b2056f71011a1a", "message": "Add system property parallelDiskStoreRecovery\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-11T19:24:06Z", "type": "commit"}, {"oid": "9951301a933a171a557ff22c06d493f87b2a5e1a", "url": "https://github.com/apache/geode/commit/9951301a933a171a557ff22c06d493f87b2a5e1a", "message": "spotlessApply\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-11T19:30:04Z", "type": "commit"}, {"oid": "3d8ad8a16f00a685cf4c1388409fef5975b154bf", "url": "https://github.com/apache/geode/commit/3d8ad8a16f00a685cf4c1388409fef5975b154bf", "message": "spotlessApply\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-11T19:31:46Z", "type": "commit"}, {"oid": "bde412ec70f288750c2bf2188e1f52055df52623", "url": "https://github.com/apache/geode/commit/bde412ec70f288750c2bf2188e1f52055df52623", "message": "Remove default empty implementation in the interface\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-11T19:36:48Z", "type": "commit"}, {"oid": "1490b7277637eb2a7e72e25920a29826a1113b5d", "url": "https://github.com/apache/geode/commit/1490b7277637eb2a7e72e25920a29826a1113b5d", "message": "Clear specific system properties at the end of test\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-11T21:21:25Z", "type": "commit"}, {"oid": "ec4b3f4bd8236bc6d6c8583ae8917fb9caa8f91e", "url": "https://github.com/apache/geode/commit/ec4b3f4bd8236bc6d6c8583ae8917fb9caa8f91e", "message": "Fix build failure\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-11T21:29:30Z", "type": "commit"}, {"oid": "650f1d91d3bc3f48399d59165a8ba098f4d03bdf", "url": "https://github.com/apache/geode/commit/650f1d91d3bc3f48399d59165a8ba098f4d03bdf", "message": "Refactor the dunit test\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-12T19:06:53Z", "type": "commit"}, {"oid": "dba3f46bf53a7974e8aafa94b48313490ce5b7e0", "url": "https://github.com/apache/geode/commit/dba3f46bf53a7974e8aafa94b48313490ce5b7e0", "message": "Add documentation of the new system property\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-14T21:31:23Z", "type": "commit"}, {"oid": "34147f73bd79d8183216b7f32673fafaedce23ab", "url": "https://github.com/apache/geode/commit/34147f73bd79d8183216b7f32673fafaedce23ab", "message": "Minor refactoring\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-05-14T22:00:41Z", "type": "commit"}]}