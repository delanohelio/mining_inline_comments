{"pr_number": 5620, "pr_title": "GEODE-8293: fix activeCQCount has negative value after close/stop cq for PR", "pr_createdAt": "2020-10-13T12:19:29Z", "pr_url": "https://github.com/apache/geode/pull/5620", "timeline": [{"oid": "9e2a0a233231ff83a8570523718ae17087288263", "url": "https://github.com/apache/geode/commit/9e2a0a233231ff83a8570523718ae17087288263", "message": "GEODE-8293: fix activeCQCount negative value", "committedDate": "2020-10-13T12:18:35Z", "type": "commit"}, {"oid": "0e15cda98297d2c705c19d67733360784df43a31", "url": "https://github.com/apache/geode/commit/0e15cda98297d2c705c19d67733360784df43a31", "message": "document changes", "committedDate": "2020-11-02T07:49:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjMwOA==", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386308", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "author": "kohlmu-pivotal", "createdAt": "2020-11-03T01:40:57Z", "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+\n+    checkActiveCqCount(server1, 0);\n+    checkActiveCqCount(server2, 0);\n+  }\n+\n+  @Test\n+  public void testCloseCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));", "originalCommit": "0e15cda98297d2c705c19d67733360784df43a31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjM4Ng==", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386386", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "author": "kohlmu-pivotal", "createdAt": "2020-11-03T01:41:15Z", "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+\n+    checkActiveCqCount(server1, 0);\n+    checkActiveCqCount(server2, 0);\n+  }\n+\n+  @Test\n+  public void testCloseCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // close cq\n+    qs.closeCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));", "originalCommit": "0e15cda98297d2c705c19d67733360784df43a31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjM5Mg==", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386392", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "author": "kohlmu-pivotal", "createdAt": "2020-11-03T01:41:17Z", "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+\n+    checkActiveCqCount(server1, 0);\n+    checkActiveCqCount(server2, 0);\n+  }\n+\n+  @Test\n+  public void testCloseCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // close cq\n+    qs.closeCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+  }\n+\n+  private class TestCqListener implements CqListener, Serializable {\n+    public int onEventCalls = 0;\n+\n+    @Override\n+    public void onEvent(CqEvent aCqEvent) {\n+      onEventCalls++;\n+    }\n+\n+    @Override\n+    public void onError(CqEvent aCqEvent) {}\n+\n+    @Override\n+    public void close() {}\n+  }\n+\n+  private static void populateRegion(int startingId, int endingId) {\n+    Region exampleRegion = getCache().getRegion(\"region\");\n+    for (int i = startingId; i < endingId; i++) {\n+      exampleRegion.put(\"\" + i, new Portfolio(i));\n+    }\n+  }\n+\n+  private ClientCache createClientCache(Integer locator1Port) {\n+    ClientCacheFactory ccf = new ClientCacheFactory();\n+    ccf.addPoolLocator(\"localhost\", locator1Port);\n+    ccf.setPoolSubscriptionEnabled(true);\n+    return ccf.create();\n+  }\n+\n+  private void checkActiveCqCount(MemberVM vm, int expectedResult) {\n+    vm.invoke(() -> {\n+      QueryService queryService = getCache().getQueryService();\n+      CqServiceStatistics cqServiceStats = queryService.getCqStatistics();\n+      await()", "originalCommit": "0e15cda98297d2c705c19d67733360784df43a31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjQ0OA==", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386448", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "author": "kohlmu-pivotal", "createdAt": "2020-11-03T01:41:31Z", "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));", "originalCommit": "0e15cda98297d2c705c19d67733360784df43a31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjQ3Nw==", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386477", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "author": "kohlmu-pivotal", "createdAt": "2020-11-03T01:41:36Z", "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));", "originalCommit": "0e15cda98297d2c705c19d67733360784df43a31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjgxMA==", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386810", "bodyText": "Please rename ccn to cacheClientNotifier... Just small changes to increase the code cleanliness.", "author": "kohlmu-pivotal", "createdAt": "2020-11-03T01:43:09Z", "path": "geode-cq/src/main/java/org/apache/geode/cache/query/cq/internal/ServerCQImpl.java", "diffHunk": "@@ -203,7 +203,7 @@ public void registerCq(ClientProxyMembershipID p_clientProxyId, CacheClientNotif\n     this.updateCqCreateStats();\n \n     // Initialize the state of CQ.\n-    if (this.cqState.getState() != p_cqState) {\n+    if (this.cqState.getState() != p_cqState || ccn == null) {", "originalCommit": "0e15cda98297d2c705c19d67733360784df43a31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85a1c975b590c10d1bfeadb65b9b2948cd673eec", "url": "https://github.com/apache/geode/commit/85a1c975b590c10d1bfeadb65b9b2948cd673eec", "message": "add small changes", "committedDate": "2020-11-03T06:46:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxMzM3OQ==", "url": "https://github.com/apache/geode/pull/5620#discussion_r517013379", "bodyText": "Please use longer variable names", "author": "kohlmu-pivotal", "createdAt": "2020-11-03T23:23:37Z", "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;", "originalCommit": "85a1c975b590c10d1bfeadb65b9b2948cd673eec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "29cdef6c3d5af1e66f9cc7fb1417b5112cb5b505", "url": "https://github.com/apache/geode/commit/29cdef6c3d5af1e66f9cc7fb1417b5112cb5b505", "message": "change variable names in test", "committedDate": "2020-11-04T10:32:46Z", "type": "commit"}]}