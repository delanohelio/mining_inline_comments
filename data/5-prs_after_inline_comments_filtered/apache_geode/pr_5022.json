{"pr_number": 5022, "pr_title": "GEODE:8042- Create Integrated Distributed/HA test for Redis Module/Sp\u2026", "pr_createdAt": "2020-04-29T18:12:16Z", "pr_url": "https://github.com/apache/geode/pull/5022", "timeline": [{"oid": "28a524ade36d44df0428ea605654e6763a95aa4f", "url": "https://github.com/apache/geode/commit/28a524ade36d44df0428ea605654e6763a95aa4f", "message": "GEODE:8042- Create Integrated Distributed/HA test for Redis Module/Spring Session\n\nAuthored-by: Jens Deppe <jdeppe@vmware.com>", "committedDate": "2020-04-29T18:03:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYyNDAyOQ==", "url": "https://github.com/apache/geode/pull/5022#discussion_r417624029", "bodyText": "Could we use the jedis we created in set up here instead of creating a new one?", "author": "sabbey37", "createdAt": "2020-04-29T21:30:05Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];\n+    client2Port = availablePorts[3];\n+\n+    int localServer1Port = server1Port;\n+    int localServer2Port = server2Port;\n+    int localClient1Port = client1Port;\n+    int localClient2Port = client2Port;\n+\n+    locator = cluster.startLocatorVM(indexOfLocator);\n+\n+    redisPropsForServer1 = new Properties();\n+    redisPropsForServer1.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer1.setProperty(\"redis-port\", Integer.toString(server1Port));\n+    redisPropsForServer1.setProperty(\"log-level\", \"warn\");\n+\n+    redisPropsForServer2 = new Properties();\n+    redisPropsForServer2.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer2.setProperty(\"redis-port\", Integer.toString(server2Port));\n+    redisPropsForServer2.setProperty(\"log-level\", \"warn\");\n+\n+    cluster.startServerVM(indexOfServer1, redisPropsForServer1, locator.getPort());\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+\n+    client1 = cluster.getVM(indexOfClient1);\n+    client2 = cluster.getVM(indexOfClient2);\n+\n+    client1.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient1Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer1Port));\n+      SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    client2.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient2Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer2Port));\n+      springApplicationContext = SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    restTemplate = new RestTemplate();\n+    jedis = new Jedis(\"localHost\", server1Port, JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void cleanupAfterTest() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void cleanupAfterClass() {\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_beAbleToCreateASession() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    cluster.getMember(0);\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    assertThat(resultHeaders).isNotNull();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(cookieString);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    assertThat(jedis.hgetAll(\"spring:session:sessions:\" + new String(decodedCookie))).isNotEmpty();\n+  }\n+\n+  @Test\n+  public void should_storeSessionDataInRedis() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);\n+\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"note1\");\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(sessionAsCookie);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    // Hook up to redis server, confirm session is there...\n+    Jedis jedis =\n+        new Jedis(\"localHost\", server1Port, JEDIS_TIMEOUT);", "originalCommit": "28a524ade36d44df0428ea605654e6763a95aa4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "df5210e8a2e294dcd3034a2d2d338843bff46a7b", "url": "https://github.com/apache/geode/commit/df5210e8a2e294dcd3034a2d2d338843bff46a7b", "message": "changes made following internal review", "committedDate": "2020-04-29T22:18:04Z", "type": "commit"}, {"oid": "15a4a3e7bf6128bbac387655fe2a1e54e462b71a", "url": "https://github.com/apache/geode/commit/15a4a3e7bf6128bbac387655fe2a1e54e462b71a", "message": "fixes unchecked conversions and removes unnecessary thymeleaf templates", "committedDate": "2020-04-30T17:46:24Z", "type": "commit"}, {"oid": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "url": "https://github.com/apache/geode/commit/b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "message": "updates expected pom files", "committedDate": "2020-04-30T18:43:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyMzM1MA==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418223350", "bodyText": "Should these be final, and all-caps?", "author": "ringles", "createdAt": "2020-04-30T18:58:17Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNDg5OA==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418224898", "bodyText": "Since these have the same values and almost the same names, do they really buy any clarity? It seems to make things more confusing down below when they are used.", "author": "ringles", "createdAt": "2020-04-30T19:00:59Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNjM2Ng==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418226366", "bodyText": "Could these blocks be pulled into methods, like \"startGeodeServer([args])\", \"startRedisServer([args])\"?", "author": "ringles", "createdAt": "2020-04-30T19:03:48Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];\n+    client2Port = availablePorts[3];\n+\n+    int localServer1Port = server1Port;\n+    int localServer2Port = server2Port;\n+    int localClient1Port = client1Port;\n+    int localClient2Port = client2Port;\n+\n+    locator = cluster.startLocatorVM(indexOfLocator);\n+\n+    redisPropsForServer1 = new Properties();\n+    redisPropsForServer1.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer1.setProperty(\"redis-port\", Integer.toString(server1Port));\n+    redisPropsForServer1.setProperty(\"log-level\", \"warn\");\n+", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNzM2OQ==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418227369", "bodyText": "requestHeaders is not used in this test.", "author": "ringles", "createdAt": "2020-04-30T19:05:46Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];\n+    client2Port = availablePorts[3];\n+\n+    int localServer1Port = server1Port;\n+    int localServer2Port = server2Port;\n+    int localClient1Port = client1Port;\n+    int localClient2Port = client2Port;\n+\n+    locator = cluster.startLocatorVM(indexOfLocator);\n+\n+    redisPropsForServer1 = new Properties();\n+    redisPropsForServer1.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer1.setProperty(\"redis-port\", Integer.toString(server1Port));\n+    redisPropsForServer1.setProperty(\"log-level\", \"warn\");\n+\n+    redisPropsForServer2 = new Properties();\n+    redisPropsForServer2.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer2.setProperty(\"redis-port\", Integer.toString(server2Port));\n+    redisPropsForServer2.setProperty(\"log-level\", \"warn\");\n+\n+    cluster.startServerVM(indexOfServer1, redisPropsForServer1, locator.getPort());\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+\n+    client1 = cluster.getVM(indexOfClient1);\n+    client2 = cluster.getVM(indexOfClient2);\n+\n+    client1.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient1Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer1Port));\n+      SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    client2.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient2Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer2Port));\n+      springApplicationContext = SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    restTemplate = new RestTemplate();\n+    jedis = new Jedis(\"localHost\", server1Port, JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void cleanupAfterTest() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void cleanupAfterClass() {\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_beAbleToCreateASession() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    cluster.getMember(0);\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    assertThat(resultHeaders).isNotNull();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzMDE5OQ==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418230199", "bodyText": "It might flow better if this section were at line 188. Then the flow is \"set some data, confirm the data is in Redis, then pull the data out and confirm its what we set.\"\nPerhaps even better, split into two tests, one that sets the data and finds it in Redis, and another tests that pulls the data back out and checks it against what was sent.", "author": "ringles", "createdAt": "2020-04-30T19:11:06Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];\n+    client2Port = availablePorts[3];\n+\n+    int localServer1Port = server1Port;\n+    int localServer2Port = server2Port;\n+    int localClient1Port = client1Port;\n+    int localClient2Port = client2Port;\n+\n+    locator = cluster.startLocatorVM(indexOfLocator);\n+\n+    redisPropsForServer1 = new Properties();\n+    redisPropsForServer1.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer1.setProperty(\"redis-port\", Integer.toString(server1Port));\n+    redisPropsForServer1.setProperty(\"log-level\", \"warn\");\n+\n+    redisPropsForServer2 = new Properties();\n+    redisPropsForServer2.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer2.setProperty(\"redis-port\", Integer.toString(server2Port));\n+    redisPropsForServer2.setProperty(\"log-level\", \"warn\");\n+\n+    cluster.startServerVM(indexOfServer1, redisPropsForServer1, locator.getPort());\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+\n+    client1 = cluster.getVM(indexOfClient1);\n+    client2 = cluster.getVM(indexOfClient2);\n+\n+    client1.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient1Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer1Port));\n+      SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    client2.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient2Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer2Port));\n+      springApplicationContext = SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    restTemplate = new RestTemplate();\n+    jedis = new Jedis(\"localHost\", server1Port, JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void cleanupAfterTest() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void cleanupAfterClass() {\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_beAbleToCreateASession() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    cluster.getMember(0);\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    assertThat(resultHeaders).isNotNull();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(cookieString);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    assertThat(jedis.hgetAll(\"spring:session:sessions:\" + new String(decodedCookie))).isNotEmpty();\n+  }\n+\n+  @Test\n+  public void should_storeSessionDataInRedis() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);\n+\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"note1\");\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(sessionAsCookie);", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzMDc5Ng==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418230796", "bodyText": "These blocks processing HttpHeaders and HttpCookies could be put into methods; they are just tools to access the data, not material to what we're testing themselves.", "author": "ringles", "createdAt": "2020-04-30T19:12:07Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];\n+    client2Port = availablePorts[3];\n+\n+    int localServer1Port = server1Port;\n+    int localServer2Port = server2Port;\n+    int localClient1Port = client1Port;\n+    int localClient2Port = client2Port;\n+\n+    locator = cluster.startLocatorVM(indexOfLocator);\n+\n+    redisPropsForServer1 = new Properties();\n+    redisPropsForServer1.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer1.setProperty(\"redis-port\", Integer.toString(server1Port));\n+    redisPropsForServer1.setProperty(\"log-level\", \"warn\");\n+\n+    redisPropsForServer2 = new Properties();\n+    redisPropsForServer2.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer2.setProperty(\"redis-port\", Integer.toString(server2Port));\n+    redisPropsForServer2.setProperty(\"log-level\", \"warn\");\n+\n+    cluster.startServerVM(indexOfServer1, redisPropsForServer1, locator.getPort());\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+\n+    client1 = cluster.getVM(indexOfClient1);\n+    client2 = cluster.getVM(indexOfClient2);\n+\n+    client1.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient1Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer1Port));\n+      SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    client2.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient2Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer2Port));\n+      springApplicationContext = SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    restTemplate = new RestTemplate();\n+    jedis = new Jedis(\"localHost\", server1Port, JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void cleanupAfterTest() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void cleanupAfterClass() {\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_beAbleToCreateASession() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    cluster.getMember(0);\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    assertThat(resultHeaders).isNotNull();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(cookieString);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    assertThat(jedis.hgetAll(\"spring:session:sessions:\" + new String(decodedCookie))).isNotEmpty();\n+  }\n+\n+  @Test\n+  public void should_storeSessionDataInRedis() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);\n+\n+    HttpHeaders requestHeaders = new HttpHeaders();", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzMzQyOA==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418233428", "bodyText": "Without seeing the DunitSocketResolver below, it's hard to understand how the Spring app knows to switch ports when a server goes down. If starting a Spring app was in a method, the \"localport1\", \"localport2\" arguments might stand out better.", "author": "ringles", "createdAt": "2020-04-30T19:16:59Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];\n+    client2Port = availablePorts[3];\n+\n+    int localServer1Port = server1Port;\n+    int localServer2Port = server2Port;\n+    int localClient1Port = client1Port;\n+    int localClient2Port = client2Port;\n+\n+    locator = cluster.startLocatorVM(indexOfLocator);\n+\n+    redisPropsForServer1 = new Properties();\n+    redisPropsForServer1.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer1.setProperty(\"redis-port\", Integer.toString(server1Port));\n+    redisPropsForServer1.setProperty(\"log-level\", \"warn\");\n+\n+    redisPropsForServer2 = new Properties();\n+    redisPropsForServer2.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer2.setProperty(\"redis-port\", Integer.toString(server2Port));\n+    redisPropsForServer2.setProperty(\"log-level\", \"warn\");\n+\n+    cluster.startServerVM(indexOfServer1, redisPropsForServer1, locator.getPort());\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+\n+    client1 = cluster.getVM(indexOfClient1);\n+    client2 = cluster.getVM(indexOfClient2);\n+\n+    client1.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient1Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer1Port));\n+      SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    client2.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient2Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer2Port));\n+      springApplicationContext = SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    restTemplate = new RestTemplate();\n+    jedis = new Jedis(\"localHost\", server1Port, JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void cleanupAfterTest() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void cleanupAfterClass() {\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_beAbleToCreateASession() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    cluster.getMember(0);\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    assertThat(resultHeaders).isNotNull();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(cookieString);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    assertThat(jedis.hgetAll(\"spring:session:sessions:\" + new String(decodedCookie))).isNotEmpty();\n+  }\n+\n+  @Test\n+  public void should_storeSessionDataInRedis() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);\n+\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"note1\");\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(sessionAsCookie);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    Map<String, String> sessionInfo =\n+        jedis.hgetAll(\"spring:session:sessions:\" + new String(decodedCookie));\n+\n+    assertThat(sessionInfo).isNotNull();\n+    assertThat(sessionInfo.get(\"sessionAttr:NOTES\")).isNotNull();\n+\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_propagateSessionData_toOtherServers() {\n+\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient1\");\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"noteFromClient1\");\n+  }\n+\n+  @Test\n+  public void should_getSessionDataFromOtherGeodeRedisServer_whenOriginalServerGoesDown() {\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient2\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client2Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    cluster.crashVM(indexOfServer2);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client1Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"noteFromClient2\");\n+\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+  }\n+\n+  @Test\n+  public void should_getSessionDataFromServer_whenServerGoesDownAndIsRestarted() {\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient2\");\n+\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client2Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"noteFromClient1\", requestHeaders);\n+\n+    cluster.crashVM(indexOfServer2);\n+\n+    restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request2,\n+            String.class);\n+\n+    cluster.startServerVM(indexOfServer2,\n+        redisPropsForServer2,\n+        locator.getPort());\n+\n+    HttpEntity<String> request3 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request3,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes).containsExactly(\"noteFromClient2\", \"noteFromClient1\");\n+  }\n+\n+  @Test\n+  public void should_getCorrectSessionData_whenGeodeRedisServerGoesDown_andClientConnectsToDifferentServer() {", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNDY4MQ==", "url": "https://github.com/apache/geode/pull/5022#discussion_r418234681", "bodyText": "This block (http-level stuff) should be moved closer to where it's used, immediately above the try/finally block. (If http operations were all bundled into a method, then it wouldn't be possible to interleave logic like this.)", "author": "ringles", "createdAt": "2020-04-30T19:19:25Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.net.HttpCookie;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.web.client.RestTemplate;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})\n+public class RedisSessionDistDUnitTest implements Serializable {\n+\n+  @ClassRule\n+  public static ClusterStartupRule cluster =\n+      new ClusterStartupRule(5);\n+\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreSystemProperties =\n+      new DistributedRestoreSystemProperties();\n+\n+  public static ConfigurableApplicationContext springApplicationContext;\n+\n+  private String LOCALHOST = \"http://127.0.0.1\";\n+\n+  private static int indexOfLocator = 0;\n+  private static int indexOfServer1 = 1;\n+  private static int indexOfServer2 = 2;\n+  private static int indexOfClient1 = 3;\n+  private static int indexOfClient2 = 4;\n+\n+  private static VM client1;\n+  private static VM client2;\n+\n+  private static int server1Port;\n+  private static int server2Port;\n+  private static int client1Port;\n+  private static int client2Port;\n+\n+  private static Properties redisPropsForServer1;\n+  private static Properties redisPropsForServer2;\n+  private static MemberVM locator;\n+\n+  private static RestTemplate restTemplate;\n+\n+  private static Jedis jedis;\n+\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+\n+  @BeforeClass\n+  public static void setup() {\n+\n+    int[] availablePorts =\n+        AvailablePortHelper.getRandomAvailableTCPPorts(4);\n+\n+    server1Port = availablePorts[0];\n+    server2Port = availablePorts[1];\n+    client1Port = availablePorts[2];\n+    client2Port = availablePorts[3];\n+\n+    int localServer1Port = server1Port;\n+    int localServer2Port = server2Port;\n+    int localClient1Port = client1Port;\n+    int localClient2Port = client2Port;\n+\n+    locator = cluster.startLocatorVM(indexOfLocator);\n+\n+    redisPropsForServer1 = new Properties();\n+    redisPropsForServer1.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer1.setProperty(\"redis-port\", Integer.toString(server1Port));\n+    redisPropsForServer1.setProperty(\"log-level\", \"warn\");\n+\n+    redisPropsForServer2 = new Properties();\n+    redisPropsForServer2.setProperty(\"redis-bind-address\", \"localHost\");\n+    redisPropsForServer2.setProperty(\"redis-port\", Integer.toString(server2Port));\n+    redisPropsForServer2.setProperty(\"log-level\", \"warn\");\n+\n+    cluster.startServerVM(indexOfServer1, redisPropsForServer1, locator.getPort());\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+\n+    client1 = cluster.getVM(indexOfClient1);\n+    client2 = cluster.getVM(indexOfClient2);\n+\n+    client1.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient1Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer1Port));\n+      SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    client2.invoke(\"start a spring app\", () -> {\n+      System.setProperty(\"server.port\", Integer.toString(localClient2Port));\n+      System.setProperty(\"spring.redis.port\", Integer.toString(localServer2Port));\n+      springApplicationContext = SpringApplication.run(\n+          RedisSpringTestApplication.class,\n+          \"\" + localServer1Port, \"\" + localServer2Port);\n+    });\n+\n+    restTemplate = new RestTemplate();\n+    jedis = new Jedis(\"localHost\", server1Port, JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void cleanupAfterTest() {\n+    jedis.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void cleanupAfterClass() {\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_beAbleToCreateASession() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    cluster.getMember(0);\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    assertThat(resultHeaders).isNotNull();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(cookieString);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    assertThat(jedis.hgetAll(\"spring:session:sessions:\" + new String(decodedCookie))).isNotEmpty();\n+  }\n+\n+  @Test\n+  public void should_storeSessionDataInRedis() {\n+    HttpEntity<String> request = new HttpEntity<>(\"note1\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);\n+\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"note1\");\n+\n+    List<HttpCookie> cookies = HttpCookie.parse(sessionAsCookie);\n+    byte[] decodedCookie = Base64.getDecoder().decode(cookies.get(0).getValue());\n+\n+    Map<String, String> sessionInfo =\n+        jedis.hgetAll(\"spring:session:sessions:\" + new String(decodedCookie));\n+\n+    assertThat(sessionInfo).isNotNull();\n+    assertThat(sessionInfo.get(\"sessionAttr:NOTES\")).isNotNull();\n+\n+    jedis.disconnect();\n+  }\n+\n+  @Test\n+  public void should_propagateSessionData_toOtherServers() {\n+\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient1\");\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"noteFromClient1\");\n+  }\n+\n+  @Test\n+  public void should_getSessionDataFromOtherGeodeRedisServer_whenOriginalServerGoesDown() {\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient2\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client2Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionAsCookie);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    cluster.crashVM(indexOfServer2);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client1Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"noteFromClient2\");\n+\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+  }\n+\n+  @Test\n+  public void should_getSessionDataFromServer_whenServerGoesDownAndIsRestarted() {\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient2\");\n+\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client2Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"noteFromClient1\", requestHeaders);\n+\n+    cluster.crashVM(indexOfServer2);\n+\n+    restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client1Port + \"/addSessionNote\",\n+            request2,\n+            String.class);\n+\n+    cluster.startServerVM(indexOfServer2,\n+        redisPropsForServer2,\n+        locator.getPort());\n+\n+    HttpEntity<String> request3 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request3,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes).containsExactly(\"noteFromClient2\", \"noteFromClient1\");\n+  }\n+\n+  @Test\n+  public void should_getCorrectSessionData_whenGeodeRedisServerGoesDown_andClientConnectsToDifferentServer() {\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient2\");\n+\n+    HttpHeaders resultHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client2Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String cookieString = resultHeaders.get(\"Set-Cookie\").get(0);\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", cookieString);\n+    HttpEntity<String> request2 = new HttpEntity<>(\"\", requestHeaders);\n+\n+    cluster.crashVM(indexOfServer2);\n+\n+    String[] sessionNotes = restTemplate\n+        .exchange(\n+            LOCALHOST + \":\" + client2Port + \"/getSessionNotes\",\n+            HttpMethod.GET,\n+            request2,\n+            String[].class)\n+        .getBody();\n+\n+    assertThat(sessionNotes[0]).isEqualTo(\"noteFromClient2\");\n+\n+    cluster.startServerVM(indexOfServer2, redisPropsForServer2, locator.getPort());\n+  }\n+\n+\n+  @Test\n+  public void should_getCorrectSessionData_whenAppInstanceGoesDown_andClientConnectsToDifferentAppInstance() {\n+\n+    HttpEntity<String> request = new HttpEntity<>(\"noteFromClient2\");\n+    HttpHeaders responseHeaders = restTemplate\n+        .postForEntity(\n+            LOCALHOST + \":\" + client2Port + \"/addSessionNote\",\n+            request,\n+            String.class)\n+        .getHeaders();\n+\n+    String sessionAsCookie = responseHeaders.get(\"Set-Cookie\").get(0);", "originalCommit": "b71b6bc3ce110e1e7e9bd167615790e556ec27e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "78e64107c6c62a4b15bc1c756d11b560531b04da", "url": "https://github.com/apache/geode/commit/78e64107c6c62a4b15bc1c756d11b560531b04da", "message": "refactor", "committedDate": "2020-04-30T23:03:12Z", "type": "forcePushed"}, {"oid": "ff814048520cd9ab476fd4d44977d1ae196b4695", "url": "https://github.com/apache/geode/commit/ff814048520cd9ab476fd4d44977d1ae196b4695", "message": "refactor", "committedDate": "2020-04-30T23:08:40Z", "type": "forcePushed"}, {"oid": "fc4f2963de588a9c5c0a40060ae879bef7d5520b", "url": "https://github.com/apache/geode/commit/fc4f2963de588a9c5c0a40060ae879bef7d5520b", "message": "refactor", "committedDate": "2020-04-30T23:09:34Z", "type": "forcePushed"}, {"oid": "2872863f0ddb2fab97935a1824689251b4b2069f", "url": "https://github.com/apache/geode/commit/2872863f0ddb2fab97935a1824689251b4b2069f", "message": "refactor", "committedDate": "2020-04-30T23:14:28Z", "type": "forcePushed"}, {"oid": "9f4bbd805af041f0a61498f518ff7792ec6ae99c", "url": "https://github.com/apache/geode/commit/9f4bbd805af041f0a61498f518ff7792ec6ae99c", "message": "refactor", "committedDate": "2020-04-30T23:17:09Z", "type": "forcePushed"}, {"oid": "1a62b772f97172a83332a0038ca4ac3bac70f11a", "url": "https://github.com/apache/geode/commit/1a62b772f97172a83332a0038ca4ac3bac70f11a", "message": "refactor", "committedDate": "2020-04-30T23:18:52Z", "type": "forcePushed"}, {"oid": "10faab604902dbbfafca6022c210f1ed6e0ab144", "url": "https://github.com/apache/geode/commit/10faab604902dbbfafca6022c210f1ed6e0ab144", "message": "refactor", "committedDate": "2020-04-30T23:38:54Z", "type": "forcePushed"}, {"oid": "d9d7eeb632385e189a123665ea6ad3bc18e47312", "url": "https://github.com/apache/geode/commit/d9d7eeb632385e189a123665ea6ad3bc18e47312", "message": "refactor", "committedDate": "2020-04-30T23:48:34Z", "type": "commit"}, {"oid": "d9d7eeb632385e189a123665ea6ad3bc18e47312", "url": "https://github.com/apache/geode/commit/d9d7eeb632385e189a123665ea6ad3bc18e47312", "message": "refactor", "committedDate": "2020-04-30T23:48:34Z", "type": "forcePushed"}]}