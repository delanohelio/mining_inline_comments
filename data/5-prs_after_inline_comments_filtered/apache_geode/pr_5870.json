{"pr_number": 5870, "pr_title": "GEODE-5922: concurrency problems in SerialGatewaySenderQueue", "pr_createdAt": "2020-12-21T21:34:57Z", "pr_url": "https://github.com/apache/geode/pull/5870", "timeline": [{"oid": "f8b04f090553f7e790a6a6964f1a95db7ad0bbe5", "url": "https://github.com/apache/geode/commit/f8b04f090553f7e790a6a6964f1a95db7ad0bbe5", "message": "GEODE-5922: concurrency problems in SerialGatewaySenderQueue\n\nreverting 3ed37a754d789bb52cf190db23088e819955fd58 for performance testing", "committedDate": "2020-12-21T21:32:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0NzcwMQ==", "url": "https://github.com/apache/geode/pull/5870#discussion_r551647701", "bodyText": "Do we having testing around this now synchronized method?", "author": "echobravopapa", "createdAt": "2021-01-05T00:26:23Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -255,23 +247,18 @@ public void destroy() {\n   }\n \n   @Override\n-  public boolean put(Object event) throws CacheException {\n-    lock.writeLock().lock();\n-    try {\n-      GatewaySenderEventImpl eventImpl = (GatewaySenderEventImpl) event;\n-      final Region r = eventImpl.getRegion();\n-      final boolean isPDXRegion =\n-          (r instanceof DistributedRegion && r.getName().equals(PeerTypeRegistration.REGION_NAME));\n-      final boolean isWbcl =\n-          this.regionName.startsWith(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX);\n-      if (!(isPDXRegion && isWbcl)) {\n-        putAndGetKey(event);\n-        return true;\n-      }\n-      return false;\n-    } finally {\n-      lock.writeLock().unlock();\n+  public synchronized boolean put(Object event) throws CacheException {", "originalCommit": "f8b04f090553f7e790a6a6964f1a95db7ad0bbe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY1MDEyOQ==", "url": "https://github.com/apache/geode/pull/5870#discussion_r551650129", "bodyText": "I didn't see any code changes for usage of this method...", "author": "echobravopapa", "createdAt": "2021-01-05T00:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0NzcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0OTc4NQ==", "url": "https://github.com/apache/geode/pull/5870#discussion_r551649785", "bodyText": "I was going to ask why this was re-ordered, but its just the diff making it look that way...", "author": "echobravopapa", "createdAt": "2021-01-05T00:33:39Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -316,71 +304,66 @@ public AsyncEvent take() throws CacheException {\n    * have peeked. If the entry was not peeked, this method will silently return.\n    */\n   @Override\n-  public void remove() throws CacheException {\n-    lock.writeLock().lock();\n+  public synchronized void remove() throws CacheException {\n+    if (peekedIds.isEmpty()) {\n+      return;\n+    }\n+    Long key = peekedIds.remove();\n+    boolean isExtraPeeked = extraPeekedIds.remove(key);\n     try {\n-      if (peekedIds.isEmpty()) {\n-        return;\n+      // Increment the head key\n+      if (!isExtraPeeked) {\n+        updateHeadKey(key.longValue());\n       }\n-      Long key = peekedIds.remove();\n-      boolean isExtraPeeked = extraPeekedIds.remove(key);\n-      try {\n-        // Increment the head key\n-        if (!isExtraPeeked) {\n-          updateHeadKey(key.longValue());\n-        }\n-        removeIndex(key);\n-        // Remove the entry at that key with a callback arg signifying it is\n-        // a WAN queue so that AbstractRegionEntry.destroy can get the value\n-        // even if it has been evicted to disk. In the normal case, the\n-        // AbstractRegionEntry.destroy only gets the value in the VM.\n-        this.region.localDestroy(key, WAN_QUEUE_TOKEN);\n-        this.stats.decQueueSize();\n-\n-      } catch (EntryNotFoundException ok) {\n-        // this is acceptable because the conflation can remove entries\n-        // out from underneath us.\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\n-              \"{}: Did not destroy entry at {} it was not there. It should have been removed by conflation.\",\n-              this, key);\n-        }\n+      removeIndex(key);\n+      // Remove the entry at that key with a callback arg signifying it is\n+      // a WAN queue so that AbstractRegionEntry.destroy can get the value\n+      // even if it has been evicted to disk. In the normal case, the\n+      // AbstractRegionEntry.destroy only gets the value in the VM.\n+      this.region.localDestroy(key, WAN_QUEUE_TOKEN);\n+      this.stats.decQueueSize();\n+\n+    } catch (EntryNotFoundException ok) {\n+      // this is acceptable because the conflation can remove entries\n+      // out from underneath us.\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\n+            \"{}: Did not destroy entry at {} it was not there. It should have been removed by conflation.\",\n+            this, key);\n       }\n+    }\n \n-      boolean wasEmpty = this.lastDispatchedKey == this.lastDestroyedKey;\n-      if (!isExtraPeeked) {\n+    boolean wasEmpty = this.lastDispatchedKey == this.lastDestroyedKey;\n+    if (!isExtraPeeked) {\n+      this.lastDispatchedKey = key;", "originalCommit": "f8b04f090553f7e790a6a6964f1a95db7ad0bbe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}