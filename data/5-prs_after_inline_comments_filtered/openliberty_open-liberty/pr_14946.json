{"pr_number": 14946, "pr_title": "Mp jwt12 encrypt fat 2", "pr_createdAt": "2020-11-12T16:57:07Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/14946", "timeline": [{"oid": "19317f2360a8acc9f8dd37a8f6945dc8996e5ee8", "url": "https://github.com/OpenLiberty/open-liberty/commit/19317f2360a8acc9f8dd37a8f6945dc8996e5ee8", "message": "Issue 13575: Add support for mp.jwt.decrypt.key.location in MP JWT 1.2 - test code", "committedDate": "2020-11-02T15:08:08Z", "type": "commit"}, {"oid": "04e8fc56632a35e2a0d564e85929a922ee5cf9d7", "url": "https://github.com/OpenLiberty/open-liberty/commit/04e8fc56632a35e2a0d564e85929a922ee5cf9d7", "message": "Issue 13575: Add support for mp.jwt.decrypt.key.location in MP JWT 1.2 - product code", "committedDate": "2020-11-02T15:08:09Z", "type": "commit"}, {"oid": "664e0fa07df24b1011e2ca9acd38f2ac28106cf0", "url": "https://github.com/OpenLiberty/open-liberty/commit/664e0fa07df24b1011e2ca9acd38f2ac28106cf0", "message": "Merge remote-tracking branch 'ayoho/13577-consumeJwe-2' into mpJwt12_Encrypt_FAT_2", "committedDate": "2020-11-02T15:17:27Z", "type": "commit"}, {"oid": "8ddc70bdbf80f59e3c88c43d8aa5d27a077cceba", "url": "https://github.com/OpenLiberty/open-liberty/commit/8ddc70bdbf80f59e3c88c43d8aa5d27a077cceba", "message": "Issue 13577: Expanding support for JWE consumption", "committedDate": "2020-11-03T23:04:27Z", "type": "commit"}, {"oid": "46150fedd39c6671fc5f8e6b31974cd720a82638", "url": "https://github.com/OpenLiberty/open-liberty/commit/46150fedd39c6671fc5f8e6b31974cd720a82638", "message": "Issue 13577: FAT updates for JWE changes", "committedDate": "2020-11-04T16:16:58Z", "type": "commit"}, {"oid": "e82daf0ff5417948a387b5e9f5782e9c43b9a658", "url": "https://github.com/OpenLiberty/open-liberty/commit/e82daf0ff5417948a387b5e9f5782e9c43b9a658", "message": "First set of mpJwt JWE FATs", "committedDate": "2020-11-04T22:48:12Z", "type": "commit"}, {"oid": "b15b93c4e79d511e0e1fb9e86cde9add3b1b672d", "url": "https://github.com/OpenLiberty/open-liberty/commit/b15b93c4e79d511e0e1fb9e86cde9add3b1b672d", "message": "Merge remote-tracking branch 'ayoho/13577-consumeJwe-3' into mpJwt12_Encrypt_FAT_2", "committedDate": "2020-11-04T22:50:30Z", "type": "commit"}, {"oid": "21443e531c3a90ff5907197a57531bd708dbebf3", "url": "https://github.com/OpenLiberty/open-liberty/commit/21443e531c3a90ff5907197a57531bd708dbebf3", "message": "mpJwt JWE FAT additions", "committedDate": "2020-11-12T16:18:14Z", "type": "commit"}, {"oid": "8610da97b120dc731486e4dc71cfe5db3cd1f954", "url": "https://github.com/OpenLiberty/open-liberty/commit/8610da97b120dc731486e4dc71cfe5db3cd1f954", "message": "Merge remote-tracking branch 'origin/integration' into mpJwt12_Encrypt_FAT_2", "committedDate": "2020-11-12T16:38:50Z", "type": "commit"}, {"oid": "68ec96aac7e570220eb0c1edc6b359f9a4da4ec9", "url": "https://github.com/OpenLiberty/open-liberty/commit/68ec96aac7e570220eb0c1edc6b359f9a4da4ec9", "message": "Merge remote-tracking branch 'origin/integration' into mpJwt12_Encrypt_FAT_2", "committedDate": "2020-11-16T16:34:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2ODM4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r523068381", "bodyText": "I'd recommend using some kind of data structure for these cases where you're using a single string to pass multiple pieces of information.", "author": "ayoho", "createdAt": "2020-11-13T16:38:30Z", "path": "dev/com.ibm.ws.security.mp.jwt.1.2_fat/fat/src/com/ibm/ws/security/mp/jwt12/fat/sharedTests/GenericEnvVarsAndSystemPropertiesTests.java", "diffHunk": "@@ -50,9 +57,13 @@ public static void commonMpJwt12Setup(LibertyServer requestedServer, String conf\n         cookieName = name;\n         sigAlgorithm = algorithm;\n \n-        setUpAndStartBuilderServer(jwtBuilderServer, \"server_using_buildApp.xml\");\n+        setUpAndStartBuilderServer(jwtBuilderServer, \"server_using_buildApp.xml\", false);\n \n-        MP12ConfigSettings mpConfigSettings = new MP12ConfigSettings(MP12ConfigSettings.PublicKeyLocationNotSet, MP12ConfigSettings.PublicKeyNotSet, MP12ConfigSettings.IssuerNotSet, MpJwt12FatConstants.X509_CERT, header, name, audience, algorithm);\n+        if (decryptKeyLoc != null && decryptKeyLoc.startsWith(\"builderId\")) {\n+            String builderId = decryptKeyLoc.split(\":\")[1];", "originalCommit": "8610da97b120dc731486e4dc71cfe5db3cd1f954", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2OTYzNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r523069636", "bodyText": "Would a Map<String, String> make more sense here?", "author": "ayoho", "createdAt": "2020-11-13T16:40:22Z", "path": "dev/com.ibm.ws.security.mp.jwt.1.2_fat/fat/src/com/ibm/ws/security/mp/jwt12/fat/sharedTests/GenericEnvVarsAndSystemPropertiesTests.java", "diffHunk": "@@ -68,23 +79,59 @@ public static void commonMpJwt12Setup(LibertyServer requestedServer, String conf\n      * @throws Exception\n      */\n     public void genericGoodTest() throws Exception {\n+        genericGoodTest(sigAlgorithm);\n+    }\n+\n+    public void genericGoodTest(String builderId) throws Exception {\n \n         resourceServer.restoreServerConfigurationAndWaitForApps();\n         // the builder we'll use has the same name as the signature algorithm\n-        standard12TestFlow(sigAlgorithm, resourceServer, MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_ROOT_CONTEXT,\n-                         MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_NO_MP_CONFIG_IN_APP, headerValue,\n-                         cookieName);\n+        standard12TestFlow(builderId, resourceServer, MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_NO_MP_CONFIG_IN_APP, headerValue,\n+                           cookieName);\n \n     }\n \n     public void genericBadTest(String config, Expectations expectations) throws Exception {\n+        genericBadTest(sigAlgorithm, config, expectations);\n+    }\n+\n+    public void genericBadTest(String builderId, String config, Expectations expectations) throws Exception {\n \n         resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, config);\n         // the builder we'll use has the same name as the signature algorithm\n-        standard12TestFlow(sigAlgorithm, resourceServer, MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_ROOT_CONTEXT,\n-                         MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_NO_MP_CONFIG_IN_APP, headerValue,\n-                         cookieName, expectations);\n+        standard12TestFlow(builderId, resourceServer, MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.NO_MP_CONFIG_IN_APP_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_NO_MP_CONFIG_IN_APP, headerValue,\n+                           cookieName, expectations);\n \n     }\n \n+    /**\n+     * generic test that builds token with rs256 for both signature and algorithm, but, caller specifies the value for the\n+     * key management key alg and/or content encryption alg.\n+     * Caller will set up mp config properties expecting rs256 encryption and signing in either env vars or system properties\n+     * We can't specify values other than the defaults for these 2 attributes in the builder config, so, we need to build our own token\n+     *\n+     * @param keyMgmtAlg - requested key management key alg to use when building the token\n+     * @param contentEncryptAlg - requested content encryption algorithm to use when building the token\n+     * @throws Exception\n+     */\n+    public void genericDecryptOtherKeyMgmtAlgOrOtherContentEncryptAlg(String keyMgmtAlg, String contentEncryptAlg) throws Exception {\n+\n+        List<NameValuePair> extraClaims = new ArrayList<NameValuePair>();", "originalCommit": "8610da97b120dc731486e4dc71cfe5db3cd1f954", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ4MzEwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r525483101", "bodyText": "Using what called method expects passed - if I use a map, I'd probably have to re-write called method and other callers of that method.", "author": "c00crane", "createdAt": "2020-11-17T20:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2OTYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyNDk2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r524524965", "bodyText": "I'm a little confused here. All of the references to algorithms that I'm seeing in this test say RS256, including the call to build the token, so where's the HS256 coming from? If the payload of the JWE isn't a JWS, you should end up with the CWWKS6065E error message saying the payload isn't a JWS.", "author": "ayoho", "createdAt": "2020-11-16T19:39:08Z", "path": "dev/com.ibm.ws.security.mp.jwt.1.2_fat/fat/src/com/ibm/ws/security/mp/jwt12/fat/MPJwt12ConfigUsingBuilderTests.java", "diffHunk": "@@ -293,71 +304,293 @@ public void MPJwt12ConfigUsingBuilderTests_Header_Cookie_passTokenInAuthHeaderAn\n      */\n     /********************************* End publickey.algorithm ****************************************/\n \n-    /******************************** Start xxx (Encrypted token) ***************************************/\n+    /******************************** Start Encryption ***************************************/\n+\n+    /**\n+     * Encrypt token with RS256 (also sign with RS256) - mpJwt config specifies the appropriate RS256 keys for decypt and signing\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS256_tokenRS256() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_RS256.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS256_enc_RS256\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER, null);\n+\n+    }\n+\n+    /**\n+     * Encrypt token with RS384 (also sign with RS384) - mpJwt config specifies the appropriate RS384 keys for decypt and signing\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS384_tokenRS384() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS384_encrypt_RS384.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS384_enc_RS384\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER, null);\n+    }\n+\n+    /**\n+     * Encrypt token with RS512 (also sign with RS512) - mpJwt config specifies the appropriate RS512 keys for decypt and signing\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS512_tokenRS512() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS512_encrypt_RS512.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS512_enc_RS512\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER, null);\n+    }\n+\n+    /**\n+     * Encrypt the token with a RS512 key, try to decrypt with an RS384 key\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS384_tokenRS512() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS384_encrypt_RS384.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS512_enc_RS512\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER,\n+                          setEncryptMismatchExpectations(resourceServer, ExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * This is another mis-match, but the configured alias uses a type that we don't support (ES can't be used for encryption)\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtES384_tokenRS256() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_ES384.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS256_enc_RS256\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER,\n+                          setEncryptMismatchKeyTypeExpectations(resourceServer, ExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * show that encryption and signing are separate - show that we can use different algorithms (keys/certs) for\n+     * encrypting and signing\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJWtRS256_signUsingRS384() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS384_encrypt_RS256.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS384_enc_RS256\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER, null);\n+\n+    }\n+\n+    /**\n+     * Test that we not accept a JWS when the config specifies a keyManagementAlias (basically, the config accepts/expects JWE)\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS256_tokenNotEncrypted() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_RS256.xml\");\n+        genericConfigTest(resourceServer, MpJwt12FatConstants.SIGALG_RS256, MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER,\n+                          setEncryptNotJWETokenExpectations(resourceServer, ExpectExtraMsgs));\n+\n+    }\n+\n+    /**\n+     * Test that we do not accept a JWE token when the config does not specify a keyManagementKeyAlias (basically, the config accepts/expects JWS)\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtNoEncryption_tokenEncrypted() throws Exception {\n+\n+        // use the original server config which has no encryption\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_orig_1_2.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS256_enc_RS256\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER,\n+                          setNoEncryptNotJWSTokenExpectations(resourceServer, ExpectExtraMsgs));\n+\n+    }\n+\n+    /**\n+     * Test that we can accept/process a token built specifying RSA_OAEP_256 for the key management algorithm.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS256_token_RSA_OAEP_256_RS256_publicKey_A256GCM() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_RS256.xml\");\n+\n+        List<NameValuePair> extraClaims = new ArrayList<NameValuePair>();\n+        extraClaims.add(new NameValuePair(JwtConstants.PARAM_UPN, defaultUser));\n+        // add more args to create a JWE with a different key management algorithm\n+        String encryptKey = JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256);\n+\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_KEY_MGMT_ALG, MpJwt12FatConstants.KEY_MGMT_KEY_ALG_256));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_ENCRYPT_KEY, encryptKey));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_CONTENT_ENCRYPT_ALG, MpJwt12FatConstants.DEFAULT_CONTENT_ENCRYPT_ALG));\n+        String token = actions.getJwtTokenUsingBuilder(_testName, jwtBuilderServer, \"sign_RS256_enc_RS256\", extraClaims);\n+\n+        for (TestApps app : setTestAppArray(resourceServer)) {\n+            WebClient webClient = actions.createWebClient();\n+\n+            Page response = actions.invokeUrlWithBearerToken(_testName, webClient, app.getUrl(), token);\n+\n+            validationUtils.validateResult(response, setGoodAppExpectations(app.getUrl(), app.getClassName()));\n+\n+        }\n+    }\n \n-    // encrypt the token, omit key from config\n-    // don't encrypt the token, but do include a key in the config\n-    // encrypt with each supported and use both matching and non-matching keys (may only use rs256)\n-    // have tests that use both the sslRef in the mpJwt config and the server wide config\n-    // sign with one - encrypt with another\n-    /******************************** End xxx (Encrypted token) ***************************************/\n     /**\n-     * Code to loop through encryption keys of all types and\n-     * validate behavior (success if they match, failure if they do not)\n+     * Test that we can accept/process a token built specifying A192GCM for the content encryption algorithm.\n      *\n-     * @param privateKey - the private key that'll match the config\n      * @throws Exception\n      */\n-    public void genericEncryption(String privateKeyAlg) throws Exception {\n-\n-        // TODO\n-        // may need unique expectations for conflicts between types vs conflicts between \"size\"\n-        // ie HS256 and RS256 vs RS256 and RS512\n-        Expectations badExpectations = setBadEncryptExpectations(resourceServer);\n-\n-        for (String encKeyAlg : rsAlgList) { // RS256, RS384, RS512\n-            // note the build name must match the name in the list\n-            // thought about creating the tokens once, but:\n-            // 1) that makes it harder to reference\n-            // 2) this puts more stress on our builder...\n-            Log.info(thisClass, \"genericEncryption\", \"********************************************\");\n-            Log.info(thisClass, \"genericEncryption\", \"* Config: \" + privateKeyAlg + \"      Token: \" + encKeyAlg + \"          *\");\n-            Log.info(thisClass, \"genericEncryption\", \"********************************************\");\n-\n-//            String builtToken = actions.getJwtTokenUsingBuilder(_testName, jwtBuilderServer, \"enc_\" + encKeyAlg);\n-\n-            if (encKeyAlg.equals(privateKeyAlg)) {\n-                genericConfigTest(resourceServer, MpJwt12FatConstants.SIGALG_RS256, MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER, null);\n-            } else {\n-                genericConfigTest(resourceServer, MpJwt12FatConstants.SIGALG_RS256, MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER, badExpectations);\n-            }\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS256_token_RSA_OAEP_RS256_publicKey_A192GCM() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_RS256.xml\");\n+\n+        List<NameValuePair> extraClaims = new ArrayList<NameValuePair>();\n+        extraClaims.add(new NameValuePair(JwtConstants.PARAM_UPN, defaultUser));\n+        // add more args to create a JWE with a different content encryption alg\n+        String encryptKey = JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256);\n+\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_KEY_MGMT_ALG, MpJwt12FatConstants.DEFAULT_KEY_MGMT_KEY_ALG));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_ENCRYPT_KEY, encryptKey));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_CONTENT_ENCRYPT_ALG, MpJwt12FatConstants.CONTENT_ENCRYPT_ALG_192));\n+        String token = actions.getJwtTokenUsingBuilder(_testName, jwtBuilderServer, \"sign_RS256_enc_RS256\", extraClaims);\n+\n+        for (TestApps app : setTestAppArray(resourceServer)) {\n+            WebClient webClient = actions.createWebClient();\n+\n+            Page response = actions.invokeUrlWithBearerToken(_testName, webClient, app.getUrl(), token);\n+\n+            validationUtils.validateResult(response, setGoodAppExpectations(app.getUrl(), app.getClassName()));\n+\n         }\n     }\n \n-    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJWTusingRS256() throws Exception {\n+    /**\n+     * Config specifies a keyManagementKeyAlias that does not exist - make sure we don't try to use a \"default\" key instead.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtinvalid_signUsingRS256() throws Exception {\n \n-        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_encrypt_RS256.xml\");\n-        genericEncryption(MpJwt12FatConstants.ENCRYPT_RS256);\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_invalid.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS256_enc_RS256\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER,\n+                          setEncryptInvalidKeyTypeExpectations(resourceServer, \"badAlias\", ExpectExtraMsgs));\n \n     }\n \n-    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJWTusingRS384_tokenRS384() throws Exception {\n+    /**\n+     * Try to use the public key instead of the private key to decrypt\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtpublicKey_signUsingRS256() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_publicKey.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS256_enc_RS256\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER,\n+                          setEncryptInvalidKeyTypeExpectations(resourceServer, \"rs256\", ExpectExtraMsgs));\n \n     }\n \n-    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJWTusingRS512_tokenRS512() throws Exception {\n+    /**\n+     * Test that we do not allow use of a key that is too short - the minimum we allow is 2048. Try to use a key that is only 1024 in length\n+     * ( the check on the key length occurs before we try to use the key to decrypt (which would in this case fail too)\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtShortPrivateKey_signUsingRS256() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_shortPrivateKey.xml\");\n+        genericConfigTest(resourceServer, \"sign_RS256_enc_RS256\", MpJwt12FatConstants.AUTHORIZATION, MpJwt12FatConstants.TOKEN_TYPE_BEARER,\n+                          setEncryptShortKeyTypeExpectations(resourceServer, ExpectExtraMsgs));\n \n     }\n \n-    public void MPJwt12ConfigUsingBuilderTests_encrypt_keyRS256_signUsingRS384() throws Exception {\n+    /**\n+     * Test that we do not allow a JWE that only contains Json in the payload\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS256_simpleJsonPayload() throws Exception {\n+\n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_RS256.xml\");\n \n+        // build a jwt token whose payload only contains json data - make sure that we do not allow this format (it's not supported at this time)\n+        String jwtToken = builderHelpers\n+                        .buildAlternatePayloadJWEToken(JwtKeyTools.getPublicKeyFromPem(JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256)));\n+        Log.info(thisClass, _testName, \"Funky token: \" + jwtToken);\n+        for (TestApps app : setTestAppArray(resourceServer)) {\n+            WebClient webClient = actions.createWebClient();\n+\n+            Page response = actions.invokeUrlWithBearerToken(_testName, webClient, app.getUrl(), jwtToken);\n+\n+            validationUtils.validateResult(response, setEncryptInvalidPayloadExpectations(resourceServer, ExpectExtraMsgs));\n+\n+        }\n     }\n \n-    public void MPJwt12ConfigUsingBuilderTests_encrypt_keyNotEncrypted_signUsingRS256() throws Exception {\n+    /**\n+     * Test that we do not allow a JWE that only contains Json in the payload\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12ConfigUsingBuilderTests_encrypt_mpJwtRS256_JWETypeNotJose() throws Exception {\n \n+        resourceServer.reconfigureServerUsingExpandedConfiguration(_testName, \"rs_server_sigAlg_RS256_encrypt_RS256.xml\");\n+\n+        // build a jwt token whose payload only contains json data - make sure that we do not allow this format (it's not supported at this time)\n+        String jwtToken = builderHelpers\n+                        .buildJWETokenWithAltHeader(JwtKeyTools.getPublicKeyFromPem(JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256)),\n+                                                    \"notJOSE\", \"jwt\");\n+// for debug       new JwtTokenForTest(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256));\n+        Log.info(thisClass, _testName, \"Funky token: \" + jwtToken);\n+        for (TestApps app : setTestAppArray(resourceServer)) {\n+            WebClient webClient = actions.createWebClient();\n+\n+            Page response = actions.invokeUrlWithBearerToken(_testName, webClient, app.getUrl(), jwtToken);\n+\n+            // The test code generates a token that uses HS256 - if we get far enough to fail on that, we haven't failed checking the JWE Type :)\n+            validationUtils.validateResult(response, setBadCertExpectations(resourceServer, KeyMismatch));", "originalCommit": "68ec96aac7e570220eb0c1edc6b359f9a4da4ec9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMzU2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r526203563", "bodyText": "The test \"builder\" is building a token that is encrypted with RS256, but signed with HS256.  The mpJwt config is expecting RS256 - hence the key mismatch failure on the signature.  It should never get a message saying that the payload isn't JWS - we're expecting JWE and we're sending JWE - the header of the JWE just has a different \"typ\" value - which we're trying to show that we don't care/check.\nI fixed the comment before the call to build the token as well as the comment on the check.", "author": "c00crane", "createdAt": "2020-11-18T15:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyNDk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUzNjQ3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r524536474", "bodyText": "Similar comment as before with not quite following where HS256 is coming into play here and which error message we're actually encountering.", "author": "ayoho", "createdAt": "2020-11-16T19:59:30Z", "path": "dev/com.ibm.ws.security.mp.jwt.1.2_fat/fat/src/com/ibm/ws/security/mp/jwt12/fat/configInAppTests/MPJwt12MPConfigInApp_Tests.java", "diffHunk": "@@ -594,8 +607,481 @@ public void MPJwt12MPConfigInApp_GoodNonDefaultKeyAndAlgorithmInMPConfig_UnderWe\n \n     /******************************* End Signature Algorithm tests *******************************/\n \n-// TODO - add encryption tests\n     /******************************** Start Encryption tests **********************************/\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS256 private key in META-INF.\n+     * The token was created using the paired public key - decrypt should be good and we should have access to the app\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocRelativeForRS256InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF,\n+                           MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER);\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS256 private key in META-INF.\n+     * The token passed in used an RS384 key to encrypt - decrypt should fail\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_EncryptRS384DecryptRS256InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS384_enc_RS384\", resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMismatchExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS256 private key in META-INF.\n+     * The token passed in used an RS512 key to encrypt - decrypt should fail\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_EncryptRS5124DecryptRS256InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS512_enc_RS512\", resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMismatchExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the fully qualified file location for the RS256 private key under WEB-INF.\n+     * The token was created using the paired public key - decrypt should be good and we should have access to the app\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocFileForRS256InMPConfig_UnderWebInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.GOOD_FILE_DECRYPT_KEY_RS256_IN_CONFIG_UNDER_WEB_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_UNDER_WEB_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_UNDER_WEB_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER);\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the URL file location for the RS384 private key in META-INF.\n+     * The token was created using the paired public key - decrypt should be good and we should have access to the app\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocUrlForRS384InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS384_enc_RS384\", resourceServer, MpJwt12FatConstants.GOOD_URL_DECRYPT_KEY_RS384_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER);\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS384 private key under WEB-INF.\n+     * The token was created using the paired public key - decrypt should be good and we should have access to the app\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocRelativeForRS384InMPConfig_UnderWebInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS384_enc_RS384\", resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS384_IN_CONFIG_UNDER_WEB_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_UNDER_WEB_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_UNDER_WEB_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER);\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS384 private key in META-INF.\n+     * The token passed in used an RS256 key to encrypt - decrypt should fail\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_EncryptRS2564DecryptRS384InMPConfig_UnderWebInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS384_IN_CONFIG_UNDER_WEB_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_UNDER_WEB_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_UNDER_WEB_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMismatchExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS384 private key in META-INF.\n+     * The token passed in used an RS512 key to encrypt - decrypt should fail\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_EncryptRS5124DecryptRS384InMPConfig_UnderWebInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS512_enc_RS512\", resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS384_IN_CONFIG_UNDER_WEB_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_UNDER_WEB_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_UNDER_WEB_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMismatchExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the fully qualified file location for the RS512 private key in META-INF.\n+     * The token was created using the paired public key - decrypt should be good and we should have access to the app\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocFileForRS512InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS512_enc_RS512\", resourceServer, MpJwt12FatConstants.GOOD_FILE_DECRYPT_KEY_RS512_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER);\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the fully qualified file location for the RS512 private key in META-INF.\n+     * The token passed in used an RS256 key to encrypt - decrypt should fail\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_EncryptRS2564DecryptRS512InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.GOOD_FILE_DECRYPT_KEY_RS512_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMismatchExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the fully qualified file location for the RS512 private key in META-INF.\n+     * The token passed in used an RS384 key to encrypt - decrypt should fail\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_EncryptRS3844DecryptRS512InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS384_enc_RS384\", resourceServer, MpJwt12FatConstants.GOOD_FILE_DECRYPT_KEY_RS512_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMismatchExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the url file location for the RS512 private key under WEB-INF.\n+     * The token was created using the paired public key - decrypt should be good and we should have access to the app\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocUrlForRS512InMPConfig_UnderWebInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS512_enc_RS512\", resourceServer, MpJwt12FatConstants.GOOD_URL_DECRYPT_KEY_RS512_IN_CONFIG_UNDER_WEB_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_UNDER_WEB_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_UNDER_WEB_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER);\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the ES256 private key in META-INF.\n+     * We expect a failure as ES256 is not supported for encryption.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocES256InMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.BAD_DECRYPT_KEY_ES256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMissingKeyExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the ES256 private key under WEB-INF.\n+     * We expect a failure as ES256 is not supported for encryption.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocES256InMPConfig_UnderWebInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.BAD_DECRYPT_KEY_ES256_IN_CONFIG_UNDER_WEB_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_UNDER_WEB_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_UNDER_WEB_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMissingKeyExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to plain text version of the RS256 private key in META-INF.\n+     * We expect a failure as we do not allow a plain text key.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocPlainTextInMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.BAD_PLAINTEXT_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptPlainTextKeyExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to jwks uri under WEB-INF.\n+     * We expect a failure as the jwks uri will not return the private key.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptKeyLocJwksUriInMPConfig_UnderWebInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.BAD_JWKSURI_DECRYPT_KEY_RS256_IN_CONFIG_UNDER_WEB_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_UNDER_WEB_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_UNDER_WEB_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMissingKeyExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative key location for the RS256 private key in META-INF.\n+     * The token was created using the paired public key, but the keyManagementKeyAlgorithm in the token is set to RSA_OAEP-256\n+     * instead of RSA_OAEP - decrypt should be good and we should have access to the app.\n+     * The builder doesn't allow that value for keyManagementKeyAlgorithm, but we should accept it.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_encrypt_mpJwtRS256_token_RSA_OAEP_256_RS256_publicKey_A256GCM() throws Exception {\n+\n+        List<NameValuePair> extraClaims = new ArrayList<NameValuePair>();\n+        extraClaims.add(new NameValuePair(JwtConstants.PARAM_UPN, defaultUser));\n+        // add more args\n+        String encryptKey = JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256);\n+\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_KEY_MGMT_ALG, MpJwt12FatConstants.KEY_MGMT_KEY_ALG_256));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_ENCRYPT_KEY, encryptKey));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_CONTENT_ENCRYPT_ALG, MpJwt12FatConstants.DEFAULT_CONTENT_ENCRYPT_ALG));\n+        String token = actions.getJwtTokenUsingBuilder(_testName, jwtBuilderServer, \"sign_RS256_enc_RS256\", extraClaims);\n+\n+        useToken(token,\n+                 buildAppUrl(resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                             MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP),\n+                 MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.AUTHORIZATION,\n+                 MpJwt12FatConstants.TOKEN_TYPE_BEARER, null);\n+\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative key location for the RS256 private key in META-INF.\n+     * The token was created using the paired public key, but the contentEncryptionAlgorith in the token is set to A192AGM\n+     * instead of A256AGM - decrypt should be good and we should have access to the app.\n+     * The builder doesn't allow that value for contentEncryptionAlgorithm, but we should accept it.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_encrypt_mpJwtRS256_token_RSA_OAEP_RS256_publicKey_A192GCM() throws Exception {\n+\n+        List<NameValuePair> extraClaims = new ArrayList<NameValuePair>();\n+        extraClaims.add(new NameValuePair(JwtConstants.PARAM_UPN, defaultUser));\n+        // add more args\n+        String encryptKey = JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256);\n+\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_KEY_MGMT_ALG, MpJwt12FatConstants.DEFAULT_KEY_MGMT_KEY_ALG));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_ENCRYPT_KEY, encryptKey));\n+        extraClaims.add(new NameValuePair(MpJwt12FatConstants.PARAM_CONTENT_ENCRYPT_ALG, MpJwt12FatConstants.CONTENT_ENCRYPT_ALG_192));\n+        String token = actions.getJwtTokenUsingBuilder(_testName, jwtBuilderServer, \"sign_RS256_enc_RS256\", extraClaims);\n+\n+        useToken(token,\n+                 buildAppUrl(resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                             MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP),\n+                 MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.AUTHORIZATION,\n+                 MpJwt12FatConstants.TOKEN_TYPE_BEARER, null);\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to a plain text string in META-INF.\n+     * We expect a failure as a simple string is not valid.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptStringKeyInMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.BAD_STRING_DECRYPT_KEY_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMissingKeyExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the same public key that was used to create the token in META-INF.\n+     * We expect a failure as we need to specify the private key.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptPublicKeyInMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.BAD_DECRYPT_PUBLIC_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptMissingKeyExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to a private key that is too short (less than 2048 in length) in META-INF.\n+     * We expect a failure as the consuming code with determine that the key is too short. (It will fail for that before we\n+     * would hit an error where we can't decrypt because the keys don't match (the builder won't allow a short key to be\n+     * used to encrypt))\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptShortKeyInMPConfig_InMetaInf_test() throws Exception {\n+\n+        standard12TestFlow(\"sign_RS256_enc_RS256\", resourceServer, MpJwt12FatConstants.BAD_SHORT_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                           MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.MPJWT_APP_CLASS_MP_CONFIG_IN_META_INF, MpJwt12FatConstants.AUTHORIZATION,\n+                           MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptShortKeyTypeExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS256 key in META-INF.\n+     * The token that is used contains a simple Json Payload and not a full JWS.\n+     * We expect a failure as we do NOT support this payload at this time.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptRS256InMPConfig_InMetaInf_simpleJsonPayload_test() throws Exception {\n+\n+        String jwtToken = builderHelpers\n+                        .buildAlternatePayloadJWEToken(JwtKeyTools.getPublicKeyFromPem(JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256)));\n+\n+        useToken(jwtToken,\n+                 buildAppUrl(resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                             MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP),\n+                 MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.AUTHORIZATION,\n+                 MpJwt12FatConstants.TOKEN_TYPE_BEARER, setEncryptInvalidPayloadExpectations(resourceServer, DoNotExpectExtraMsgs));\n+    }\n+\n+    /**\n+     * Test shows that we'll pick up the private key setting from mp config properties\n+     * The app has mp.jwt.decrypt.key.location set to the relative file location for the RS256 key in META-INF.\n+     * The token that is used has the \"typ\" value in the JWE header set to notJose.\n+     * We expect a failure as we expect the value to be set to \"JOSE\".\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void MPJwt12MPConfigInApp_NoMPJwt12ConfigInServerXml_DecryptRS256InMPConfig_InMetaInf_JweTypeNotJose_test() throws Exception {\n+\n+        // build a jwt token whose payload only contains json data - make sure that we do not allow this format (it's not supported at this time)\n+        String jwtToken = builderHelpers\n+                        .buildJWETokenWithAltHeader(JwtKeyTools.getPublicKeyFromPem(JwtKeyTools.getComplexPublicKeyForSigAlg(jwtBuilderServer, MpJwt12FatConstants.SIGALG_RS256)),\n+                                                    \"notJOSE\", \"jwt\");\n+\n+        // The test code generates a token that uses HS256 - if we get far enough to fail on that, we haven't failed checking the JWE Type :)\n+        useToken(jwtToken,\n+                 buildAppUrl(resourceServer, MpJwt12FatConstants.GOOD_RELATIVE_DECRYPT_KEY_RS256_IN_CONFIG_IN_META_INF_ROOT_CONTEXT,\n+                             MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP),\n+                 MpJwt12FatConstants.MP_CONFIG_IN_META_INF_TREE_APP, MpJwt12FatConstants.AUTHORIZATION,\n+                 MpJwt12FatConstants.TOKEN_TYPE_BEARER, setBadCertExpectations(resourceServer, KeyMismatch));", "originalCommit": "68ec96aac7e570220eb0c1edc6b359f9a4da4ec9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3NzQxMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r525477411", "bodyText": "same comment... updated the comments", "author": "c00crane", "createdAt": "2020-11-17T20:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUzNjQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDU0NTM2NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14946#discussion_r524545364", "bodyText": "I might be interested in double checking this one. Do you know whether the ClassCastException is coming from our code or from jose4j? I wonder if there might be something cleaner we could do, depending on what this actually ends up looking like.", "author": "ayoho", "createdAt": "2020-11-16T20:16:03Z", "path": "dev/com.ibm.ws.security.mp.jwt.1.2_fat/fat/src/com/ibm/ws/security/mp/jwt12/fat/sharedTests/MPJwt12MPConfigTests.java", "diffHunk": "@@ -519,58 +650,191 @@ public Expectations setBadAudiencesExpectations(LibertyServer server) throws Exc\n \n     }\n \n-//    /**\n-//     * Set expectations for tests that have bad Audiences values\n-//     *\n-//     * @return Expectations\n-//     * @throws Exception\n-//     */\n-//    public Expectations setBadAlgorithmExpectations(LibertyServer server) throws Exception {\n-//\n-//        Expectations expectations = new Expectations();\n-//        expectations.addExpectation(new ResponseStatusExpectation(HttpServletResponse.SC_UNAUTHORIZED));\n-//\n-////        expectations.addExpectation(new ServerMessageExpectation(server, MpJwtMessageConstants.CWWKS5523E_ERROR_CREATING_JWT_USING_TOKEN_IN_REQ, \"Messagelog did not contain an error indicating a problem authenticating the request with the provided token.\"));\n-////        expectations.addExpectation(new ServerMessageExpectation(server, MpJwtMessageConstants.CWWKS6023E_AUDIENCE_NOT_TRUSTED, \"Messagelog did not contain an exception indicating that the audience is NOT valid.\"));\n-//\n-//        return expectations;\n-//\n-//    }\n-\n-//\n-//    /**\n-//     * Set expectations for tests that have bad Decryption key location values\n-//     *\n-//     * @return Expectations\n-//     * @throws Exception\n-//     */\n-//    public Expectations setBadDecryptionKeyLocationExpectations(LibertyServer server) throws Exception {\n-//\n-//        Expectations expectations = new Expectations();\n-//        expectations.addExpectation(new ResponseStatusExpectation(HttpServletResponse.SC_UNAUTHORIZED));\n-//\n-//        // TODO - fix when we have the correct messages\n-//        //expectations.addExpectation(new ServerMessageExpectation(server, MpJwtMessageConstants.CWWKS5523E_ERROR_CREATING_JWT_USING_TOKEN_IN_REQ, \"Messagelog did not contain an error indicating a problem authenticating the request with the provided token.\"));\n-//        //expectations.addExpectation(new ServerMessageExpectation(server, MpJwtMessageConstants.CWWKS6022E_ISSUER_NOT_TRUSTED, \"Messagelog did not contain an exception indicating that the issuer is NOT valid.\"));\n-//\n-//        return expectations;\n-//\n-//    }\n+    /**\n+     * Sets expectations to check when the keyManagementKeyAlias is not set\n+     *\n+     * @param server - server whose logs will be searched\n+     * @param extraMsgs - the tai drives the code down different paths depending on if it finds config info in server.xml - if it finds config settings, we'll get 2 extra messages.\n+     * @return Expectations - built expectations\n+     * @throws Exception\n+     */\n+    public Expectations setEncryptMissingKeyExpectations(LibertyServer server, boolean extraMsgs) throws Exception {\n+        Expectations expectations = setAllBadEncryptExpectations(server, extraMsgs);\n+        expectations.addExpectation(new ServerMessageExpectation(server, \"The key must not be null\", \"Messagelog did not contain an exception indicating that the keyManagementKeyAlias was missing.\"));\n+        return expectations;\n+\n+    }\n+\n+    /**\n+     * Sets expectations to check when the keyManagementKeyAlias is not set\n+     *\n+     * @param server - server whose logs will be searched\n+     * @param extraMsgs - the tai drives the code down different paths depending on if it finds config info in server.xml - if it finds config settings, we'll get 2 extra messages.\n+     * @return Expectations - built expectations\n+     * @throws Exception\n+     */\n+    public Expectations setEncryptPlainTextKeyExpectations(LibertyServer server, boolean extraMsgs) throws Exception {\n+        Expectations expectations = setAllBadEncryptExpectations(server, extraMsgs);\n+        expectations.addExpectation(new ServerMessageExpectation(server, MpJwtMessageConstants.CWWKS6062E_PLAINTEXT_KEY, \"Messagelog did not contain an exception indicating that the mp.jwt.decrypt.key.location contained a plaintext key.\"));\n+        return expectations;\n+\n+    }\n+\n+    /**\n+     * Sets expectations to check when the keyManagementKeyAlias is not set\n+     *\n+     * @param server - server whose logs will be searched\n+     * @param extraMsgs - the tai drives the code down different paths depending on if it finds config info in server.xml - if it finds config settings, we'll get 2 extra messages.\n+     * @return Expectations - built expectations\n+     * @throws Exception\n+     */\n+    public Expectations setEncryptMismatchExpectations(LibertyServer server, boolean extraMsgs) throws Exception {\n+        Expectations expectations = setAllBadEncryptExpectations(server, extraMsgs);\n+        expectations.addExpectation(new ServerMessageExpectation(server, \"javax.crypto.AEADBadTagException\", \"Messagelog did not contain an exception indicating a tag mismatch.\"));\n+        return expectations;\n+\n+    }\n+\n+    /**\n+     * Sets expectations to check when the keyManagementKeyAlias is not set\n+     *\n+     * @param server - server whose logs will be searched\n+     * @param extraMsgs - the tai drives the code down different paths depending on if it finds config info in server.xml - if it finds config settings, we'll get 2 extra messages.\n+     * @return Expectations - built expectations\n+     * @throws Exception\n+     */\n+    public Expectations setEncryptMismatchKeyTypeExpectations(LibertyServer server, boolean extraMsgs) throws Exception {\n+        Expectations expectations = setAllBadEncryptExpectations(server, extraMsgs);\n+        expectations.addExpectation(new ServerMessageExpectation(server, \"java.lang.ClassCastException\", \"Messagelog did not contain an exception indicating a classcast exception due to the key type.\"));", "originalCommit": "68ec96aac7e570220eb0c1edc6b359f9a4da4ec9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f9cbf785985dd87880935630d30c16f1d9a1b32e", "url": "https://github.com/OpenLiberty/open-liberty/commit/f9cbf785985dd87880935630d30c16f1d9a1b32e", "message": "Reduce trace, fix filename typo and add missing jar", "committedDate": "2020-11-17T21:00:53Z", "type": "commit"}, {"oid": "584caaed7f10515c30045c89b597a1be0a6dd9ea", "url": "https://github.com/OpenLiberty/open-liberty/commit/584caaed7f10515c30045c89b597a1be0a6dd9ea", "message": "Merge remote-tracking branch 'origin/integration' into mpJwt12_Encrypt_FAT_2", "committedDate": "2020-11-17T21:01:35Z", "type": "commit"}, {"oid": "6e409635fed8a8243aefb0f12a03f1ed182d6af6", "url": "https://github.com/OpenLiberty/open-liberty/commit/6e409635fed8a8243aefb0f12a03f1ed182d6af6", "message": "try #2 to fix missing classes", "committedDate": "2020-11-18T15:58:50Z", "type": "commit"}]}