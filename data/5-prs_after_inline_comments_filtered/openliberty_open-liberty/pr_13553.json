{"pr_number": 13553, "pr_title": "update weld to 3.1.7 and 4.0.1", "pr_createdAt": "2020-08-18T20:56:54Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/13553", "timeline": [{"oid": "f2c31721c82aeca442b037acf170cefe878ee8f0", "url": "https://github.com/OpenLiberty/open-liberty/commit/f2c31721c82aeca442b037acf170cefe878ee8f0", "message": "update weld to 3.1.5", "committedDate": "2020-08-19T09:17:08Z", "type": "forcePushed"}, {"oid": "f50defbdaa4e667b69bb2aeaac1327feb2174c38", "url": "https://github.com/OpenLiberty/open-liberty/commit/f50defbdaa4e667b69bb2aeaac1327feb2174c38", "message": "Update to weld 3.1.5", "committedDate": "2021-04-27T13:46:44Z", "type": "forcePushed"}, {"oid": "6ce91dabfc786b25a586f7a75d5e6fad7b0b2278", "url": "https://github.com/OpenLiberty/open-liberty/commit/6ce91dabfc786b25a586f7a75d5e6fad7b0b2278", "message": "Update to weld 3.1.5", "committedDate": "2021-06-21T15:49:13Z", "type": "commit"}, {"oid": "9f35e1e559e45681d262b21ebac49e82824c6b07", "url": "https://github.com/OpenLiberty/open-liberty/commit/9f35e1e559e45681d262b21ebac49e82824c6b07", "message": "Update weld 4.0.0 to 4.0.1", "committedDate": "2021-06-21T15:51:02Z", "type": "forcePushed"}, {"oid": "472683de1b2a115110461664369d2a9358f55198", "url": "https://github.com/OpenLiberty/open-liberty/commit/472683de1b2a115110461664369d2a9358f55198", "message": "Update weld 4.0.0 to 4.0.1", "committedDate": "2021-06-21T16:12:49Z", "type": "commit"}, {"oid": "472683de1b2a115110461664369d2a9358f55198", "url": "https://github.com/OpenLiberty/open-liberty/commit/472683de1b2a115110461664369d2a9358f55198", "message": "Update weld 4.0.0 to 4.0.1", "committedDate": "2021-06-21T16:12:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NjMxOTA5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r656319096", "bodyText": "don't use this same package name, use a new one", "author": "tevans78", "createdAt": "2021-06-22T15:10:57Z", "path": "dev/com.ibm.ws.cdi.1.2.weld/src/com/ibm/ws/cdi/impl/weld/package-info.java", "diffHunk": "@@ -0,0 +1,13 @@\n+/*******************************************************************************\n+ * Copyright (c) 2015 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ * IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+@org.osgi.annotation.versioning.Version(\"1.0\")\n+package com.ibm.ws.cdi.impl.weld;", "originalCommit": "48acaef123d669cbe28446f8ca52c2e1460a79b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzMzMjYwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r683332609", "bodyText": "This is adding a missing package info file for the weld package.", "author": "benjamin-confino", "createdAt": "2021-08-05T10:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NjMxOTA5Ng=="}], "type": "inlineReview"}, {"oid": "3abb04484337689e6149d74669399bf764d32d21", "url": "https://github.com/OpenLiberty/open-liberty/commit/3abb04484337689e6149d74669399bf764d32d21", "message": "cdi 2.0 compiles", "committedDate": "2021-06-23T08:45:34Z", "type": "forcePushed"}, {"oid": "87e23fcae4226a2222eaf6c6617c0b84da02406f", "url": "https://github.com/OpenLiberty/open-liberty/commit/87e23fcae4226a2222eaf6c6617c0b84da02406f", "message": "update ref", "committedDate": "2021-06-28T14:01:08Z", "type": "forcePushed"}, {"oid": "9059ff19382cd4ab3c4922d9e24002836a1da1d9", "url": "https://github.com/OpenLiberty/open-liberty/commit/9059ff19382cd4ab3c4922d9e24002836a1da1d9", "message": "test passes", "committedDate": "2021-06-29T16:57:34Z", "type": "forcePushed"}, {"oid": "8b861dd5f301ffee0229d96b2fbcaa1e075d3a96", "url": "https://github.com/OpenLiberty/open-liberty/commit/8b861dd5f301ffee0229d96b2fbcaa1e075d3a96", "message": "export proxy", "committedDate": "2021-07-08T16:43:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTQ3NTg3Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r669475873", "bodyText": "don't forget to remove this", "author": "tevans78", "createdAt": "2021-07-14T10:09:14Z", "path": "dev/com.ibm.ws.cdi.1.2.weld/src/com/ibm/ws/cdi/proxy/ProxyServicesImpl.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*******************************************************************************\n+ * Copyright (c) 2015 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.cdi.proxy;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.eclipse.osgi.container.ModuleLoader;\n+import org.eclipse.osgi.container.ModuleWiring;\n+import org.eclipse.osgi.util.ManifestElement;\n+import org.jboss.weld.serialization.spi.ProxyServices;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.wiring.BundleWiring;\n+\n+import com.ibm.ws.cdi.impl.weld.AbstractProxyServices;\n+\n+/**\n+ * This service is used to load proxy classes. We need a special classloader so that\n+ * we can load both weld classes and app classes.\n+ *\n+ *\n+ */\n+public class ProxyServicesImpl extends AbstractProxyServices implements ProxyServices {\n+\n+    public ProxyServicesImpl() {\n+        System.out.println(\"GREP 1.2\");", "originalCommit": "f3ad11b01a0458f7478ebb3a6527e617501559c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTQ4MDg3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r669480871", "bodyText": "put some comments here... and actually I don't see a reason why this code wouldn't be kept the same for the older version too?", "author": "tevans78", "createdAt": "2021-07-14T10:16:29Z", "path": "dev/com.ibm.ws.cdi.2.0.weld/src/com/ibm/ws/cdi/impl/weld/AbstractProxyServices.java", "diffHunk": "@@ -117,6 +120,8 @@ public ClassLoader run() {\n                 if (cl instanceof BundleReference) {\n                     Bundle b = ((BundleReference) cl).getBundle();\n                     addWeldDynamicImports(b, WELD_PACKAGES);\n+                } else if (cl == null) {\n+                    return CLASS_LOADER_FOR_SYSTEM_CLASSES;", "originalCommit": "f3ad11b01a0458f7478ebb3a6527e617501559c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTQ4MTM1OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r669481358", "bodyText": "definitely put comments here ... I don't like a Thread.sleep really", "author": "tevans78", "createdAt": "2021-07-14T10:17:12Z", "path": "dev/com.ibm.ws.cdi.2.0.weld/src/com/ibm/ws/cdi/impl/weld/AbstractProxyServices.java", "diffHunk": "@@ -155,6 +160,19 @@ public ClassLoader run() {\n                 }\n                 Class<?> clazz = (Class) method.invoke(loader, args);\n                 return clazz;\n+\n+             } catch (LinkageError e) {\n+                int tries = 10;\n+                while (tries > 0) {\n+                    Class<?> clazz = loadClass\u200b(className, loader);\n+                    if (clazz != null) {\n+                        return clazz;\n+                    }\n+                    Thread.sleep(1000);", "originalCommit": "f3ad11b01a0458f7478ebb3a6527e617501559c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzMyNjE3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r683326171", "bodyText": "Why does it need the sleep anyway?", "author": "Emily-Jiang", "createdAt": "2021-08-05T10:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTQ4MTM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzMyMzY5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r683323698", "bodyText": "indentation!", "author": "tevans78", "createdAt": "2021-08-05T10:17:53Z", "path": "dev/com.ibm.ws.cdi.2.0.weld/src/com/ibm/ws/cdi/impl/weld/AbstractProxyServices.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*******************************************************************************\n+ * Copyright (c) 2015, 2021 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.cdi.impl.weld;\n+\n+import java.lang.reflect.Method;\n+import java.net.URLClassLoader;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.security.ProtectionDomain;\n+import java.util.WeakHashMap;\n+\n+import org.eclipse.osgi.util.ManifestElement;\n+import org.jboss.weld.serialization.spi.ProxyServices;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleException;\n+import org.osgi.framework.BundleReference;\n+import org.osgi.framework.Constants;\n+\n+import com.ibm.ws.cdi.CDIRuntimeException;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+\n+/**\n+ * This service is used to load proxy classes. We need a special classloader so that\n+ * we can load both weld classes and app classes.\n+ *\n+ *\n+ */\n+public abstract class AbstractProxyServices implements ProxyServices {\n+\n+    private static final ManifestElement[] WELD_PACKAGES;\n+    private static final ClassLoader CLASS_LOADER_FOR_SYSTEM_CLASSES = org.jboss.weld.proxy.WeldConstruct.class.getClassLoader(); //I'm using this classloader because we'll need the weld classes to proxy anything.\n+\n+    private static enum ClassLoaderMethods {\n+        ;//No enum instances\n+\n+        private static final Method defineClass1, defineClass2, getClassLoadingLock;\n+\n+        static {\n+            try {\n+                Method[] methods = AccessController.doPrivileged(new PrivilegedExceptionAction<Method[]>() {\n+                    public Method[] run() throws Exception {\n+                        Class<?> cl = Class.forName(\"java.lang.ClassLoader\");\n+                        final String name = \"defineClass\";\n+                        final String getClassLoadingLockName = \"getClassLoadingLock\";\n+\n+                        Method[] methods = new Method[3];\n+\n+                        methods[0] = cl.getDeclaredMethod(name, String.class, byte[].class, int.class, int.class);\n+                        methods[1] = cl.getDeclaredMethod(name, String.class, byte[].class, int.class, int.class, ProtectionDomain.class);\n+                        methods[2] = cl.getDeclaredMethod(getClassLoadingLockName, String.class);\n+                        methods[0].setAccessible(true);\n+                        methods[1].setAccessible(true);\n+                        methods[2].setAccessible(true);\n+                        return methods;\n+                    }\n+                });\n+                defineClass1 = methods[0];\n+                defineClass2 = methods[1];\n+                getClassLoadingLock = methods[2];\n+            } catch (PrivilegedActionException pae) {\n+                throw new RuntimeException(\"cannot initialize ClassPool\", pae.getException());\n+            }\n+        }\n+    }\n+\n+    static {\n+        try {\n+            WELD_PACKAGES = ManifestElement.parseHeader(Constants.DYNAMICIMPORT_PACKAGE, \"org.jboss.weld.*\");\n+        } catch (BundleException e) {\n+            throw new CDIRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void cleanup() {\n+        // This implementation requires no cleanup\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader(final Class<?> proxiedBeanType) {\n+        return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n+            @Override\n+            public ClassLoader run() {\n+                // Must always use the bean type's classloader;\n+                // Otherwise package private access does not work.\n+                // Unfortunately this causes us issues for types from OSGi bundles.\n+\n+                // It would be nice if we could have a marking header that allowed for\n+                // bundles to declare they provide CDI bean types, but this becomes\n+                // problematic for interface types that beans may be using for\n+                // injection types because the exporter may have no idea their types\n+                // are going to be used for CDI.  Therefore we have no way of knowing\n+                // ahead of time what bundles are providing CDI bean types.\n+\n+                // This makes it impossible to use weaving hooks to add new dynamic\n+                // import packages.  The weaving hook approach requires\n+                // a weaving hook registration that knows ahead of time what\n+                // bundles provide CDI bean types and then on first class define using\n+                // that bundle's class loader the weaving hook would add the necessary\n+                // weld packages as dynamic imports.  We cannot and will\n+                // not be able to know exactly which bundles are providing bean\n+                // types until this getClassLoader method is called.  But by the time\n+                // this method is called it is too late for a weaving hook to do\n+                // anything because weld is going to use the returned class loader\n+                // immediately to reflectively define a proxy class.  The class loader\n+                // MUST have visibility to the weld packages before this reflective\n+                // call to defineClass.\n+                ClassLoader cl = proxiedBeanType.getClassLoader();\n+                if (cl instanceof BundleReference) {\n+                    Bundle b = ((BundleReference) cl).getBundle();\n+                    addWeldDynamicImports(b, WELD_PACKAGES);\n+                } else if (cl == null) {\n+                    return CLASS_LOADER_FOR_SYSTEM_CLASSES;\n+                }\n+                return cl;\n+            }\n+        });\n+    }\n+\n+    @Override\n+    @FFDCIgnore(ClassNotFoundException.class)\n+    public Class<?> defineClass\u200b(Class<?> originalClass, String className, byte[] classBytes, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError {\n+\n+        ClassLoader loader = loaderMap.get(originalClass);\n+        Object classLoaderLock = null;\n+        try {\n+            classLoaderLock = ClassLoaderMethods.getClassLoadingLock.invoke(loader, className);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        synchronized (classLoaderLock) {\n+            try {\n+                //First check we haven't defined this in another thread.\n+                return loadClass\u200b(className, loader);\n+            } catch (ClassNotFoundException e) {\n+                //Do nothing, move on to defining the class. \n+            }\n+try {", "originalCommit": "fa337b07cda6103e23971d42ea778991917cd42f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c9c80b1fbde990fa043d713c4158b2506e9815d", "url": "https://github.com/OpenLiberty/open-liberty/commit/5c9c80b1fbde990fa043d713c4158b2506e9815d", "message": "Implement SPI method for weld to define proxy classes", "committedDate": "2021-08-05T10:40:36Z", "type": "commit"}, {"oid": "5cd40181a5a1cd1a61cd09b21cc0296799268126", "url": "https://github.com/OpenLiberty/open-liberty/commit/5cd40181a5a1cd1a61cd09b21cc0296799268126", "message": "add transform rules", "committedDate": "2021-08-05T10:40:53Z", "type": "commit"}, {"oid": "5cd40181a5a1cd1a61cd09b21cc0296799268126", "url": "https://github.com/OpenLiberty/open-liberty/commit/5cd40181a5a1cd1a61cd09b21cc0296799268126", "message": "add transform rules", "committedDate": "2021-08-05T10:40:53Z", "type": "forcePushed"}, {"oid": "cea6e06d0c7afa3a4004e8ad77850817671cc9ed", "url": "https://github.com/OpenLiberty/open-liberty/commit/cea6e06d0c7afa3a4004e8ad77850817671cc9ed", "message": "test without linkage catch", "committedDate": "2021-08-05T16:44:53Z", "type": "commit"}, {"oid": "04c4b41055f823354ad126e42f7216eb01ac835a", "url": "https://github.com/OpenLiberty/open-liberty/commit/04c4b41055f823354ad126e42f7216eb01ac835a", "message": "test without exporting weld", "committedDate": "2021-08-09T09:53:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NTA3NjgyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13553#discussion_r685076824", "bodyText": "remove commented out code.", "author": "Azquelt", "createdAt": "2021-08-09T10:25:13Z", "path": "dev/com.ibm.ws.cdi.2.0.weld/src/com/ibm/ws/cdi/impl/weld/AbstractProxyServices.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*******************************************************************************\n+ * Copyright (c) 2015, 2021 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.cdi.impl.weld;\n+\n+import java.lang.reflect.Method;\n+import java.net.URLClassLoader;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.security.ProtectionDomain;\n+import java.util.WeakHashMap;\n+\n+import org.eclipse.osgi.util.ManifestElement;\n+import org.jboss.weld.serialization.spi.ProxyServices;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleException;\n+import org.osgi.framework.BundleReference;\n+import org.osgi.framework.Constants;\n+\n+import com.ibm.ws.cdi.CDIRuntimeException;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+\n+/**\n+ * This service is used to load proxy classes. We need a special classloader so that\n+ * we can load both weld classes and app classes.\n+ *\n+ *\n+ */\n+public abstract class AbstractProxyServices implements ProxyServices {\n+\n+\tprivate static final ManifestElement[] WELD_PACKAGES;\n+\tprivate static final ClassLoader CLASS_LOADER_FOR_SYSTEM_CLASSES = org.jboss.weld.proxy.WeldConstruct.class.getClassLoader(); //I'm using this classloader because we'll need the weld classes to proxy anything.\n+\n+\tprivate static enum ClassLoaderMethods {\n+\t\t;//No enum instances\n+\n+\t\tprivate static final Method defineClass1, defineClass2, getClassLoadingLock;\n+\n+\t\tstatic {\n+\t\t\ttry {\n+\t\t\t\tMethod[] methods = AccessController.doPrivileged(new PrivilegedExceptionAction<Method[]>() {\n+\t\t\t\t\tpublic Method[] run() throws Exception {\n+\t\t\t\t\t\tClass<?> cl = Class.forName(\"java.lang.ClassLoader\");\n+\t\t\t\t\t\tfinal String name = \"defineClass\";\n+\t\t\t\t\t\tfinal String getClassLoadingLockName = \"getClassLoadingLock\";\n+\n+\t\t\t\t\t\tMethod[] methods = new Method[3];\n+\n+\t\t\t\t\t\tmethods[0] = cl.getDeclaredMethod(name, String.class, byte[].class, int.class, int.class);\n+\t\t\t\t\t\tmethods[1] = cl.getDeclaredMethod(name, String.class, byte[].class, int.class, int.class, ProtectionDomain.class);\n+\t\t\t\t\t\tmethods[2] = cl.getDeclaredMethod(getClassLoadingLockName, String.class);\n+\t\t\t\t\t\tmethods[0].setAccessible(true);\n+\t\t\t\t\t\tmethods[1].setAccessible(true);\n+\t\t\t\t\t\tmethods[2].setAccessible(true);\n+\t\t\t\t\t\treturn methods;\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t\tdefineClass1 = methods[0];\n+\t\t\t\tdefineClass2 = methods[1];\n+\t\t\t\tgetClassLoadingLock = methods[2];\n+\t\t\t} catch (PrivilegedActionException pae) {\n+\t\t\t\tthrow new RuntimeException(\"cannot initialize ClassPool\", pae.getException());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tstatic {\n+\t\ttry {\n+\t\t\tWELD_PACKAGES = ManifestElement.parseHeader(Constants.DYNAMICIMPORT_PACKAGE, \"org.jboss.weld.*\");\n+\t\t} catch (BundleException e) {\n+\t\t\tthrow new CDIRuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void cleanup() {\n+\t\t// This implementation requires no cleanup\n+\t}\n+\n+\t@Override\n+\tpublic ClassLoader getClassLoader(final Class<?> proxiedBeanType) {\n+\t\treturn AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n+\t\t\t@Override\n+\t\t\tpublic ClassLoader run() {\n+\t\t\t\t// Must always use the bean type's classloader;\n+\t\t\t\t// Otherwise package private access does not work.\n+\t\t\t\t// Unfortunately this causes us issues for types from OSGi bundles.\n+\n+\t\t\t\t// It would be nice if we could have a marking header that allowed for\n+\t\t\t\t// bundles to declare they provide CDI bean types, but this becomes\n+\t\t\t\t// problematic for interface types that beans may be using for\n+\t\t\t\t// injection types because the exporter may have no idea their types\n+\t\t\t\t// are going to be used for CDI.  Therefore we have no way of knowing\n+\t\t\t\t// ahead of time what bundles are providing CDI bean types.\n+\n+\t\t\t\t// This makes it impossible to use weaving hooks to add new dynamic\n+\t\t\t\t// import packages.  The weaving hook approach requires\n+\t\t\t\t// a weaving hook registration that knows ahead of time what\n+\t\t\t\t// bundles provide CDI bean types and then on first class define using\n+\t\t\t\t// that bundle's class loader the weaving hook would add the necessary\n+\t\t\t\t// weld packages as dynamic imports.  We cannot and will\n+\t\t\t\t// not be able to know exactly which bundles are providing bean\n+\t\t\t\t// types until this getClassLoader method is called.  But by the time\n+\t\t\t\t// this method is called it is too late for a weaving hook to do\n+\t\t\t\t// anything because weld is going to use the returned class loader\n+\t\t\t\t// immediately to reflectively define a proxy class.  The class loader\n+\t\t\t\t// MUST have visibility to the weld packages before this reflective\n+\t\t\t\t// call to defineClass.\n+\t\t\t\tClassLoader cl = proxiedBeanType.getClassLoader();\n+\t\t\t\tif (cl instanceof BundleReference) {\n+\t\t\t\t\tBundle b = ((BundleReference) cl).getBundle();\n+\t\t\t\t\taddWeldDynamicImports(b, WELD_PACKAGES);\n+\t\t\t\t} else if (cl == null) {\n+\t\t\t\t\treturn CLASS_LOADER_FOR_SYSTEM_CLASSES;\n+\t\t\t\t}\n+\t\t\t\treturn cl;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t@Override\n+\t@FFDCIgnore(ClassNotFoundException.class)\n+\tpublic Class<?> defineClass\u200b(Class<?> originalClass, String className, byte[] classBytes, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError {\n+\n+\t\tClassLoader loader = loaderMap.get(originalClass);\n+\t\tObject classLoaderLock = null;\n+\t\ttry {\n+\t\t\tclassLoaderLock = ClassLoaderMethods.getClassLoadingLock.invoke(loader, className);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\tsynchronized (classLoaderLock) {\n+\t\t\ttry {\n+\t\t\t\t//First check we haven't defined this in another thread.\n+\t\t\t\treturn loadClass\u200b(className, loader);\n+\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t//Do nothing, move on to defining the class. \n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tjava.lang.reflect.Method method;\n+\t\t\t\tObject[] args;\n+\t\t\t\tif (protectionDomain == null) {\n+\t\t\t\t\tmethod = ClassLoaderMethods.defineClass1;\n+\t\t\t\t\targs = new Object[]{className, classBytes, off, len};\n+\t\t\t\t} else {\n+\t\t\t\t\tmethod = ClassLoaderMethods.defineClass2;\n+\t\t\t\t\targs = new Object[]{className, classBytes, off, len, protectionDomain};\n+\t\t\t\t}\n+\t\t\t\tClass<?> clazz = (Class) method.invoke(loader, args); //This is the line that actually puts a new class into a ClassLoader.\n+\t\t\t\treturn clazz;\n+\t\t\t} catch (RuntimeException e) {\n+\t\t\t\tthrow e;\n+\t\t\t} catch (java.lang.reflect.InvocationTargetException e) {\n+\t\t\t\tthrow new RuntimeException(e.getTargetException());\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Class<?> loadClass\u200b(Class<?> originalClass, String classBinaryName) throws ClassNotFoundException {\n+\t\tClassLoader cl = loaderMap.get(originalClass);\n+\t\treturn loadClass\u200b(classBinaryName, cl);\n+\t}\n+\n+\tprivate Class<?> loadClass\u200b(String classBinaryName, ClassLoader cl) throws ClassNotFoundException {\n+\t\treturn Class.forName(classBinaryName, true, cl);\n+\t}\n+\n+\t/*    @FFDCIgnore(ClassNotFoundException.class)\n+    public Class<?> loadClass\u200b(Class<?> originalClass, String classBinaryName) throws ClassNotFoundException {\n+         if (originalClassToProxyClass.containsKey(originalClass)) {\n+             return originalClassToProxyClass.get(originalClass);\n+         } else {\n+             throw new ClassNotFoundException(\"We failed to find a proxy class \" + classBinaryName);\n+         }\n+    }*/", "originalCommit": "04c4b41055f823354ad126e42f7216eb01ac835a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9c4c553f1e257639f211f4dfed767d297a412fbf", "url": "https://github.com/OpenLiberty/open-liberty/commit/9c4c553f1e257639f211f4dfed767d297a412fbf", "message": "tweaks to APS", "committedDate": "2021-08-09T10:59:22Z", "type": "forcePushed"}, {"oid": "921f98ae10ee4eed4b665857ffc87e234ae4fe10", "url": "https://github.com/OpenLiberty/open-liberty/commit/921f98ae10ee4eed4b665857ffc87e234ae4fe10", "message": "tweaks to APS", "committedDate": "2021-08-09T10:59:41Z", "type": "forcePushed"}, {"oid": "c935219de72d50e39e1ce7ed82bc8fee9cd6ce3a", "url": "https://github.com/OpenLiberty/open-liberty/commit/c935219de72d50e39e1ce7ed82bc8fee9cd6ce3a", "message": "tweaks to APS", "committedDate": "2021-08-09T11:00:20Z", "type": "commit"}, {"oid": "c935219de72d50e39e1ce7ed82bc8fee9cd6ce3a", "url": "https://github.com/OpenLiberty/open-liberty/commit/c935219de72d50e39e1ce7ed82bc8fee9cd6ce3a", "message": "tweaks to APS", "committedDate": "2021-08-09T11:00:20Z", "type": "forcePushed"}, {"oid": "411d37b8d3eacc064a135da480ed7864002e0002", "url": "https://github.com/OpenLiberty/open-liberty/commit/411d37b8d3eacc064a135da480ed7864002e0002", "message": "remove package info files", "committedDate": "2021-08-09T11:00:59Z", "type": "commit"}, {"oid": "83393844e0eaeecf81fd3f57546ee8d521139d6b", "url": "https://github.com/OpenLiberty/open-liberty/commit/83393844e0eaeecf81fd3f57546ee8d521139d6b", "message": "Move packages", "committedDate": "2021-08-09T13:35:12Z", "type": "commit"}]}