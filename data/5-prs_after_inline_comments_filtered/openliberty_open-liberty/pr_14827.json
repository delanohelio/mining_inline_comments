{"pr_number": 14827, "pr_title": "Add arhive validation which allows prepended scripts", "pr_createdAt": "2020-11-04T18:19:30Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/14827", "timeline": [{"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "url": "https://github.com/OpenLiberty/open-liberty/commit/557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "message": "Add arhive validation which allows prepended scripts", "committedDate": "2020-11-04T18:12:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NDM2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517584368", "bodyText": "Is this cast to (int) safe?  How is it know that the offset is less than MAX_INT?", "author": "tbitonti", "createdAt": "2020-11-04T19:35:11Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODA4OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517738089", "bodyText": "Removed cast.   Decided archiveOffset can be a long, at least when the zip is not in Zip64 format.   In Zip64 format, if the prepended script is bigger than 200MB, an exception will throw us out.", "author": "jimblye", "createdAt": "2020-11-05T02:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NDM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NDY4Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517584683", "bodyText": "Do we want to display some information here in case of an exception?", "author": "tbitonti", "createdAt": "2020-11-04T19:35:52Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzQ1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517737457", "bodyText": "Added // ffdc.   I think the ffdc is enough", "author": "jimblye", "createdAt": "2020-11-05T01:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NTIxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517585219", "bodyText": "Either add documentation on the @param and @throws lines, or omit them.", "author": "tbitonti", "createdAt": "2020-11-04T19:36:58Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzMxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517737312", "bodyText": "done", "author": "jimblye", "createdAt": "2020-11-05T01:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NTIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NjE0Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517586147", "bodyText": "As above; @param, @return, and @throws can be omitted if they provide no actual documentation.", "author": "tbitonti", "createdAt": "2020-11-04T19:38:45Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzI2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517737265", "bodyText": "done", "author": "jimblye", "createdAt": "2020-11-05T01:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NjE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NjU2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517586568", "bodyText": "Stale 'this' reference.", "author": "tbitonti", "createdAt": "2020-11-04T19:39:30Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzE4OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517737188", "bodyText": "done", "author": "jimblye", "createdAt": "2020-11-05T01:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NjU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4Nzc5Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517587797", "bodyText": "This should probably be made into a unit test, with the test JARs constructed by the test, or stored remotely.", "author": "tbitonti", "createdAt": "2020-11-04T19:41:53Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t\n+\t\t// Have offset from end.  Get offset from beginning.\n+\t\tlong offset = _fileLength >= offsetFromEnd ? _fileLength - offsetFromEnd : 0;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param file a zip file\n+\t * @param offset Position from beginning of file, where data is to be read\n+\t * @param size number of bytes to read\n+\t * @return Returns an array of size 'size' read from file beginning at 'offset'\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromBeginningOfFile(RandomAccessFile file, long offset, int size) throws IOException {\n+\t\t\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\t\n+\t}\n+\t\n+\t/** \n+\t * Test for valid signature and size.\n+\t * @return true if the offset points to a valid End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValidEoCDRec(byte[] bytes, int offset, int centralDirEndRecSize) {\n+\t\tif ( !isSignature(bytes, offset, EOCDR_SIGNATURE) \n+\t\t\t || !isValidEoCDRecSize(bytes, offset + EOCDR_COMMENT_LENGTH_OFFSET, centralDirEndRecSize)) {\n+\t\t\treturn false;\n+\t\t}\n+        return true;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @return true if the signature parameter matches the bytes at offset\n+\t */\n+\tprivate boolean isSignature(byte[] bytes, int offset, int signature) {\n+\n+\t\tlong value = getSignature(bytes, offset);\n+\n+\t\treturn (value == signature);\n+\t}\n+\t\n+\tprivate boolean isValidEoCDRecSize(byte[] bytes, int offset, int size) {\n+\t\t// Size of central directory must be the structure size + comment\n+\t\t// First put length in little endian form (reverse the bytes).\n+\t\tlong commentLength = getLittleEndianValue(bytes, offset, 2);\n+\t\treturn size == (EOCDR_MIN_SIZE + commentLength);\n+\t}\n+\t\n+\t/** \n+\t * @param bytes the data\n+\t * @param offsetInByteArray pointer to a possible Zip64-End-Of-Central-Directory-Record\n+\t * @return true if the offset points to a valid Zip64-End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValid_Zip64EoCDRecord(byte[] bytes, int offsetInByteArray, long offsetInFile) {\n+\t\t\n+\t\tif ( !isSignature(bytes, offsetInByteArray, ZIP64_EOCDR_SIGNATURE)) {\n+\t\t\treturn false;\n+\t\t} \n+\t     \n+\t\tif ( !isValid_Zip64EoCDRecordSize(bytes, offsetInByteArray, offsetInFile) ) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+        return true;\n+\t}\n+\t\n+\tprivate boolean isValid_Zip64EoCDRLocator(byte[] bytes, int offset) {\n+\t\t// Calculate length of Ziop64-End-of-Central-Directory-Record\n+\t\t//int zipLocatorOffset = bytes.length - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+\t\tif ( !isSignature(bytes, offset, ZIP64_LOCATOR_SIGNATURE)) {\n+           return false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method assumes you've already found a valid signature for the Zip64-End-Of-Central-Directory-Record.\n+\t * Of course, the signature might just randomly appear anywhere in the data.  So this method\n+\t * tests to see if the length field makes sense.\n+\t * @param bytes the data\n+\t * @param offsetInArray pointer to Zip64-End-Of-Central-Directory-Record in the data\n+\t * @return true if the size makes sense for a \n+\t */\n+\tprivate boolean isValid_Zip64EoCDRecordSize(byte[] bytes, int offsetInArray, long offsetInFile) {\n+\n+\t\tlong specifiedZip64EoCDRecSize = getZip64EoCDRecordSize( bytes, offsetInArray );\n+\n+\t\tif (specifiedZip64EoCDRecSize > (_fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\tlong calculatedZip64EoCDRecSize = _zip64EoCDRLocatorOffset - offsetInFile;\n+\n+\t\treturn (calculatedZip64EoCDRecSize == specifiedZip64EoCDRecSize);\n+\t}\n+\t\n+\t/**\n+\t * @param bytes\n+\t * @param offsetInArray pointer to Zip64-End-Of-Central-Directory-Record in the data\n+\t * @return\n+\t */\n+\tprivate long getZip64EoCDRecordSize(byte[] bytes, int offsetInArray ) {\n+\n+\t\tlong specifiedZip64EoCDRecSize = getLittleEndianValue(bytes, offsetInArray + ZIP64_EOCDR_SIZE_OFFSET, ZIP64_EOCDR_SIZE_FIELD_LENGTH);\n+\t\t\n+\t\t// The recorded size does not include the 12-byte header.   So let's add that\n+\t\treturn specifiedZip64EoCDRecSize + ZIP64_EOCDR_HEADER_SIZE;\n+\t}\n+\t\t\n+\t/**\n+\t * @param bytes   array of byte\n+\t * @param offset  beginning of value in array of bytes\n+\t * @param length  Must be <= 4\n+\t * @return the bytes at the offset in reversed order\n+\t */\n+\tprivate long getLittleEndianValue(byte[] bytes, int offset, int length) {\n+\t\tlong value = 0;\n+\t\tfor (int i = length - 1; i >= 0; i--) {\n+\t\t\tvalue = ((value << 8) | (bytes[offset + i] & 0xFF));\n+\t\t}\n+\t\treturn value;\n+\t}\n+\t\n+\t/**\n+\t * @return 4-byte signature using offset into byte array.\n+\t */\n+\tprivate long getSignature(byte[] bytes, int offset) {\n+\t\tlong value = 0;\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tvalue = ((value << 8) | (bytes[offset + i] & 0xFF));\n+\t\t}\n+\t\treturn value;\n+\t}\n+\t\n+\t/**\n+\t * @return true if the \"total # of entries\" offset in the End-of-Central-Directory-Record contains 0xFFFF\n+\t */\n+\tprivate boolean isZip64() {\n+\t\treturn (int) getLittleEndianValue(_endOfCentralDirectoryRecord, EOCDR_TOTAL_ENTRIES_OFFSET, 2) == ZIP64_INDICATOR;\n+\t}\n+\t\n+\t/**\n+\t * Checks if the beginning of the actual archive, which might not be at the beginning of the\n+\t * file contains the appropriate local-file-header-signature\n+\t * @param file the zip file\n+\t * @param archiveOffset the offset to the beginning of the archive within the file (Usually 0, but data might be attached in front of the archive).\n+\t * @return true if valid\n+\t * @throws IOException\n+\t */\n+\tprivate boolean archiveStartsWithSignature(RandomAccessFile file, int archiveOffset) throws IOException {\n+\t\t\t\n+\t\tSystem.out.println(\"Archive offset is \" + archiveOffset);\n+\t\t\n+\t\tfile.seek(archiveOffset);\n+\t\tbyte[] localFileHeaderSigBytes = new byte[ 4];\n+\t\tfile.read(localFileHeaderSigBytes, 0, 4);\n+\t\t\n+\t\tif (isSignature(localFileHeaderSigBytes, 0, LOCAL_FILE_HEADER_SIGNATURE)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\treturn false;\n+\t}\n+\t\t\n+\t/**\n+\t * @return \t The location in the file where the archive actually starts. That will normally\n+\t * be 0, but often scripts are pre-pended to the archive; for example to make\n+\t * a self-extracting zip.\n+\t * @throws IOException\n+\t */\n+\tpublic long getActualArchiveOffset() throws IOException {\n+\t\t\n+\t\t// At offset 12 into the End-of-Central-Directory-Record is the size of the Central Directory \n+\t\tlong lengthOfCentralDirectory = getLittleEndianValue( _endOfCentralDirectoryRecord, EOCDR_CENTRAL_DIR_SIZE_OFFSET, 4 );\n+\t\t\n+\t\t// Offset 16 contains the relative offset from the beginning of the actual archive to the Central Directory\n+\t\tlong offsetOfCentralDirectory = getLittleEndianValue( _endOfCentralDirectoryRecord, EOCDR_CENTRAL_DIR_OFFSET, 4 );\n+\t\t\n+\t\tlong zip64RecLengths = isZip64() ? ( _zip64EoCDRecSize + ZIP64_LOCATOR_SIZE ) : 0;\n+\t\t\n+\t\treturn _fileLength - _eocdRecordSize - zip64RecLengths - lengthOfCentralDirectory - offsetOfCentralDirectory;\n+\t}\n+\t\n+\tpublic static void main(String[] args) {", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczOTM0Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517739346", "bodyText": "Removed main for now, but yes there should be unit tests", "author": "jimblye", "createdAt": "2020-11-05T02:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4Nzc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4ODQ2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517588468", "bodyText": "Does the JavaArchive need to be closed?", "author": "tbitonti", "createdAt": "2020-11-04T19:43:12Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipFileContainerFactory.java", "diffHunk": "@@ -352,7 +352,10 @@ private static boolean isZip(ArtifactEntry artifactEntry) {\n             try {\n                 ZipEntry entry = zipInputStream.getNextEntry();\n                 if ( entry == null ) {\n-                    Tr.error(tc, \"bad.zip.data\", getPhysicalPath(artifactEntry));\n+                    JavaArchive javaArchive = new JavaArchive(getPhysicalPath(artifactEntry));", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczOTE3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517739177", "bodyText": "Well, not here.   The JavaArchive.isValid() method opens the archive file in a try with resources.   So it should be closed automagically.", "author": "jimblye", "createdAt": "2020-11-05T02:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4ODQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczOTIzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517739238", "bodyText": "Well, not here.   The JavaArchive.isValid() method opens the archive file in a try with resources.   So it should be closed automagically.", "author": "jimblye", "createdAt": "2020-11-05T02:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4ODQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4ODgyNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517588827", "bodyText": "Same as above: Does the JavaArchive need to be closed?", "author": "tbitonti", "createdAt": "2020-11-04T19:43:52Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipFileContainerFactory.java", "diffHunk": "@@ -448,8 +451,11 @@ private static boolean isZip(File file) {\n             try {\n                 ZipEntry entry = zipInputStream.getNextEntry(); // throws IOException\n                 if ( entry == null ) {\n-                    Tr.error(tc, \"bad.zip.data\", file.getAbsolutePath());\n-                    return false;\n+                    JavaArchive javaArchive = new JavaArchive(file.getAbsolutePath());", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4OTQ3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517589470", "bodyText": "Not sure about using the name \"JavaArchive': The target archive is a PK archive, and can be a plain ZIP file, which has nothing to do with java.", "author": "tbitonti", "createdAt": "2020-11-04T19:44:54Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzEyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517737128", "bodyText": "changed to ZipValidator", "author": "jimblye", "createdAt": "2020-11-05T01:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4OTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MTA5NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517591095", "bodyText": "Hmm; run on exception text?", "author": "tbitonti", "createdAt": "2020-11-04T19:47:48Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzA2MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517737061", "bodyText": "yes", "author": "jimblye", "createdAt": "2020-11-05T01:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MjMwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517592306", "bodyText": "For better performance, the block can be allocated outside of the method, and reused when there are several calls.  But, since this code is a very rare case, that level of optimization doesn't seem necessary.", "author": "tbitonti", "createdAt": "2020-11-04T19:50:06Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNjY1Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517736653", "bodyText": "done", "author": "jimblye", "createdAt": "2020-11-05T01:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MjMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MjkzNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517592936", "bodyText": "We are reading a long but comparing that against an int signature value?", "author": "tbitonti", "createdAt": "2020-11-04T19:51:18Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t\n+\t\t// Have offset from end.  Get offset from beginning.\n+\t\tlong offset = _fileLength >= offsetFromEnd ? _fileLength - offsetFromEnd : 0;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param file a zip file\n+\t * @param offset Position from beginning of file, where data is to be read\n+\t * @param size number of bytes to read\n+\t * @return Returns an array of size 'size' read from file beginning at 'offset'\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromBeginningOfFile(RandomAccessFile file, long offset, int size) throws IOException {\n+\t\t\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\t\n+\t}\n+\t\n+\t/** \n+\t * Test for valid signature and size.\n+\t * @return true if the offset points to a valid End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValidEoCDRec(byte[] bytes, int offset, int centralDirEndRecSize) {\n+\t\tif ( !isSignature(bytes, offset, EOCDR_SIGNATURE) \n+\t\t\t || !isValidEoCDRecSize(bytes, offset + EOCDR_COMMENT_LENGTH_OFFSET, centralDirEndRecSize)) {\n+\t\t\treturn false;\n+\t\t}\n+        return true;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @return true if the signature parameter matches the bytes at offset\n+\t */\n+\tprivate boolean isSignature(byte[] bytes, int offset, int signature) {\n+\n+\t\tlong value = getSignature(bytes, offset);\n+", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNjkxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517736916", "bodyText": "Changed getSignature to return an int.", "author": "jimblye", "createdAt": "2020-11-05T01:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MzUzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517593535", "bodyText": "'size' is an int, but comment length is a long ... but the comment is restricted to 64K at most?  Should 'getLittleEndianValue' answer an int instead of a long?", "author": "tbitonti", "createdAt": "2020-11-04T19:52:32Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t\n+\t\t// Have offset from end.  Get offset from beginning.\n+\t\tlong offset = _fileLength >= offsetFromEnd ? _fileLength - offsetFromEnd : 0;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param file a zip file\n+\t * @param offset Position from beginning of file, where data is to be read\n+\t * @param size number of bytes to read\n+\t * @return Returns an array of size 'size' read from file beginning at 'offset'\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromBeginningOfFile(RandomAccessFile file, long offset, int size) throws IOException {\n+\t\t\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\t\n+\t}\n+\t\n+\t/** \n+\t * Test for valid signature and size.\n+\t * @return true if the offset points to a valid End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValidEoCDRec(byte[] bytes, int offset, int centralDirEndRecSize) {\n+\t\tif ( !isSignature(bytes, offset, EOCDR_SIGNATURE) \n+\t\t\t || !isValidEoCDRecSize(bytes, offset + EOCDR_COMMENT_LENGTH_OFFSET, centralDirEndRecSize)) {\n+\t\t\treturn false;\n+\t\t}\n+        return true;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @return true if the signature parameter matches the bytes at offset\n+\t */\n+\tprivate boolean isSignature(byte[] bytes, int offset, int signature) {\n+\n+\t\tlong value = getSignature(bytes, offset);\n+\n+\t\treturn (value == signature);\n+\t}\n+\t\n+\tprivate boolean isValidEoCDRecSize(byte[] bytes, int offset, int size) {\n+\t\t// Size of central directory must be the structure size + comment\n+\t\t// First put length in little endian form (reverse the bytes).\n+\t\tlong commentLength = getLittleEndianValue(bytes, offset, 2);\n+\t\treturn size == (EOCDR_MIN_SIZE + commentLength);", "originalCommit": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDgxMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517730810", "bodyText": "In this particular call to getLittleEndianValue, we are asking it to read 2 bytes.  So the most it can return here is 0xFFFF.  But sometimes we ask getLittleEndianValue to read 4 bytes and in one place we ask it to read 8 bytes.   A cast to int might be appropriate here, but shouldn't be any harm in storing it in a long.", "author": "jimblye", "createdAt": "2020-11-05T01:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MzUzNQ=="}], "type": "inlineReview"}, {"oid": "0cb9754350b295845c6903f1fdbda052ad040542", "url": "https://github.com/OpenLiberty/open-liberty/commit/0cb9754350b295845c6903f1fdbda052ad040542", "message": "Modifications from code review", "committedDate": "2020-11-05T01:44:27Z", "type": "commit"}, {"oid": "7f6420db8d47508ece8affb9ff5bc676e8924ece", "url": "https://github.com/OpenLiberty/open-liberty/commit/7f6420db8d47508ece8affb9ff5bc676e8924ece", "message": "Rename JavaArchive to ZipValidator, remove 'main' method", "committedDate": "2020-11-05T01:48:37Z", "type": "commit"}, {"oid": "f398c12dc9d7da8346fc53972c49d1d606579649", "url": "https://github.com/OpenLiberty/open-liberty/commit/f398c12dc9d7da8346fc53972c49d1d606579649", "message": "getActualArchiveOffset() changed to private", "committedDate": "2020-11-05T02:15:45Z", "type": "commit"}, {"oid": "066d65c10ec5fdd378f1c718cee7c33ae902a7d8", "url": "https://github.com/OpenLiberty/open-liberty/commit/066d65c10ec5fdd378f1c718cee7c33ae902a7d8", "message": "Fix getBlockFrom...() methods when not enough data", "committedDate": "2020-11-05T16:09:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc2MjA5NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517762095", "bodyText": "This test seems unnecessary: The read will fail if there aren't enough bytes in the file.", "author": "tbitonti", "createdAt": "2020-11-05T02:51:00Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipValidator.java", "diffHunk": "@@ -0,0 +1,483 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class ZipValidator {\n+\n+    // EOCDR is End-of-Central-Directory-Record\n+    private static final int EOCDR_MIN_SIZE = 22;\n+    private static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+    private static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+    private static final int EOCDR_SIGNATURE = 0x504b0506; \n+    private static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+    private static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+    private static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+    private static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+    private static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\n+    // ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+    private static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+    private static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+    private static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+    private static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+    private static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+    // ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+    private static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+    private static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+    private static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\n+    private static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+    private static final int BLOCK_SIZE = 256;\n+    private static final int FORWARD_BLOCK_SIZE = 8192;\n+\n+    // Maximum amount of data (usually a script) that is allowed, by this implementation,\n+    // to be prepended to an archive in Zip64 format. This value may be increased, but it\n+    // increases the time it takes to fail when the zip is corrupted.  This limitation does \n+    // not apply to archives not in Zip64 format.\n+    private static final int MAX_PREFIX_ALLOWED_FOR_ZIP64 = 200*1024*1024;       \n+\n+    private byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+    private int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+    private byte[] _zip64EoCDRLocator;           // 20 bytes;\n+    private long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+    private byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+    private long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+    private long   _fileLength;                  // Length of the archive file\n+\n+    ZipValidator(String archiveFileName) {\n+        _archiveFileName = archiveFileName;\n+    }\n+\n+    /** \n+     * @return true if the archive has valid format\n+     */\n+    public boolean isValid() {\n+\n+        try ( RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+            _fileLength = file.length();\n+            _endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+\n+            if ( isZip64() ) {\n+                _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+                _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+                _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+                _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+            }\n+\n+            long archiveOffset = getActualArchiveOffset();\n+\n+            if (archiveStartsWithSignature(file, archiveOffset)) {\n+                return true;\n+            } \n+\n+        } catch (Exception e) {\n+            //ffdc\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file the zip file \n+     */\n+    private byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\n+        byte[] block = getBlockFromEndOfFile(file, null, BLOCK_SIZE, BLOCK_SIZE);\n+        int size = EOCDR_MIN_SIZE ;\n+        int offset = block.length - size;\n+        int offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\n+        if ( block.length < EOCDR_MIN_SIZE ) {\n+            throw new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+        }\n+\n+        // We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+        // ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+        // Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+        // to avoid an exception because of a read past the end of the block.\n+        while ( !isValidEoCDRec( block, offset, size ) ) {\n+            size++;\n+            offsetFromEnd++;\n+\n+            if ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+                throw new IOException(\"Cannot find central directory end record in zip.\");\n+            }\n+\n+            if ( offsetFromEnd > block.length ) {\n+\n+                block = getBlockFromEndOfFile(file, block, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+                offsetFromEnd = EOCDR_MIN_SIZE;\n+            }\n+            offset = block.length - offsetFromEnd;\t\t\t\n+        }\n+\n+        // Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+        // No need to store the comment, which could be up to 64k.\t\t\n+        _eocdRecordSize = size;\n+        return Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+    }\n+\n+    /**\n+     * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+     * @param file the zip file\n+     */\n+    private byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+        if ( !isZip64() ) {\n+            return null;\n+        }\n+\n+        byte[] block = getBlockFromEndOfFile(file, \n+                                             null,\n+                                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+                                             ZIP64_LOCATOR_SIZE);\t\n+\n+        if ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+            throw new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+        }\n+\n+        return Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+    }\n+\n+    /**\n+     * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+     * in the Zip64 Locator.  If not found there, it is assumed that data has\n+     * been prepended to the archive, and a forward search begins until we find the\n+     * correct signature.  Of course, a false signature could appear just about  \n+     * anywhere in the zip.  So the record must pass additional validation.\n+     * @param file a zip file\n+     * @return a copy of the Zip64-End-of-Central-Directory-Record\n+     */\n+    private byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\n+        if ( !isZip64() ) {\n+            return null;\n+        }\n+\n+        // The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+        // That offset will NOT be correct if data (i.e. a script) has been attached in front of the archive,\n+        // but in that case, the offset will be our starting point for the search.\n+        long zip64EoCDOffset = getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\n+        byte [] block = getBlockFromBeginningOfFile(file, null, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+        if (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {", "originalCommit": "f398c12dc9d7da8346fc53972c49d1d606579649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMzQ3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r518213470", "bodyText": "file.read() actually will return less bytes than requested if there aren't enough bytes available before the end of file.\nfile.seek() lets you seek past the eof, but then when you call file.read() it returns -1.\nAnyway, I think it is possible that you will get back less bytes than you asked for.", "author": "jimblye", "createdAt": "2020-11-05T17:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc2MjA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc2MjUwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517762508", "bodyText": "Hmm, what happens if the file has less than BLOCK_SIZE bytes?", "author": "tbitonti", "createdAt": "2020-11-05T02:52:41Z", "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipValidator.java", "diffHunk": "@@ -0,0 +1,483 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class ZipValidator {\n+\n+    // EOCDR is End-of-Central-Directory-Record\n+    private static final int EOCDR_MIN_SIZE = 22;\n+    private static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+    private static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+    private static final int EOCDR_SIGNATURE = 0x504b0506; \n+    private static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+    private static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+    private static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+    private static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+    private static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\n+    // ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+    private static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+    private static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+    private static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+    private static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+    private static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+    // ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+    private static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+    private static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+    private static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\n+    private static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+    private static final int BLOCK_SIZE = 256;\n+    private static final int FORWARD_BLOCK_SIZE = 8192;\n+\n+    // Maximum amount of data (usually a script) that is allowed, by this implementation,\n+    // to be prepended to an archive in Zip64 format. This value may be increased, but it\n+    // increases the time it takes to fail when the zip is corrupted.  This limitation does \n+    // not apply to archives not in Zip64 format.\n+    private static final int MAX_PREFIX_ALLOWED_FOR_ZIP64 = 200*1024*1024;       \n+\n+    private byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+    private int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+    private byte[] _zip64EoCDRLocator;           // 20 bytes;\n+    private long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+    private byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+    private long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+    private long   _fileLength;                  // Length of the archive file\n+\n+    ZipValidator(String archiveFileName) {\n+        _archiveFileName = archiveFileName;\n+    }\n+\n+    /** \n+     * @return true if the archive has valid format\n+     */\n+    public boolean isValid() {\n+\n+        try ( RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+            _fileLength = file.length();\n+            _endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+\n+            if ( isZip64() ) {\n+                _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+                _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+                _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+                _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+            }\n+\n+            long archiveOffset = getActualArchiveOffset();\n+\n+            if (archiveStartsWithSignature(file, archiveOffset)) {\n+                return true;\n+            } \n+\n+        } catch (Exception e) {\n+            //ffdc\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file the zip file \n+     */\n+    private byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\n+        byte[] block = getBlockFromEndOfFile(file, null, BLOCK_SIZE, BLOCK_SIZE);\n+        int size = EOCDR_MIN_SIZE ;\n+        int offset = block.length - size;\n+        int offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\n+        if ( block.length < EOCDR_MIN_SIZE ) {\n+            throw new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+        }\n+", "originalCommit": "f398c12dc9d7da8346fc53972c49d1d606579649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNjY5Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r518216692", "bodyText": "It actually goes into that the \"  if ( block.length < EOCDR_MIN_SIZE ) { \"  and throws the exception.\nI tried with an \"archive\" file of size 1.", "author": "jimblye", "createdAt": "2020-11-05T17:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc2MjUwOA=="}], "type": "inlineReview"}, {"oid": "cd2d5bd778aa31e5d177d552b9469983eb03e545", "url": "https://github.com/OpenLiberty/open-liberty/commit/cd2d5bd778aa31e5d177d552b9469983eb03e545", "message": "White space only", "committedDate": "2020-11-05T16:46:22Z", "type": "commit"}, {"oid": "0562570757348c68c212439e4b2dc7c4e9a1bcb8", "url": "https://github.com/OpenLiberty/open-liberty/commit/0562570757348c68c212439e4b2dc7c4e9a1bcb8", "message": "Change IOException to ZipException.  Move message", "committedDate": "2020-11-05T20:08:33Z", "type": "commit"}, {"oid": "88b8398f553936d92b056424958762a8aa09f91c", "url": "https://github.com/OpenLiberty/open-liberty/commit/88b8398f553936d92b056424958762a8aa09f91c", "message": "Fix getBlockFromEndOfFile when too few bytes left", "committedDate": "2020-11-05T23:18:49Z", "type": "commit"}, {"oid": "ba8ef2ffad188163a0a2b7ef5b3429807b4d8009", "url": "https://github.com/OpenLiberty/open-liberty/commit/ba8ef2ffad188163a0a2b7ef5b3429807b4d8009", "message": "Remove System.out.println", "committedDate": "2020-11-06T15:37:57Z", "type": "commit"}]}