{"pr_number": 12874, "pr_title": "mpHealth-2.0 Readiness check to report DOWN when application fails to start", "pr_createdAt": "2020-07-02T19:13:46Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/12874", "timeline": [{"oid": "8f4b174d494938c5c10622c16681e373392a2f24", "url": "https://github.com/OpenLiberty/open-liberty/commit/8f4b174d494938c5c10622c16681e373392a2f24", "message": "Fixed readiness check reporting UP when app fails to start, and updated FAT tests", "committedDate": "2020-07-02T19:34:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMxNzA0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450317045", "bodyText": "Line 2: Fix copyright year from 2019-2020 to 2019, 2020", "author": "pgunapal", "createdAt": "2020-07-06T15:51:08Z", "path": "dev/com.ibm.ws.microprofile.health.2.0/src/com/ibm/ws/microprofile/health20/internal/HealthCheck20ServiceImpl.java", "diffHunk": "@@ -96,15 +96,16 @@ public void performHealthCheck(HttpServletRequest request, HttpServletResponse h\n     public void performHealthCheck(HttpServletRequest request, HttpServletResponse httpResponse, String healthCheckProcedure) {\n         Set<HealthCheckResponse> hcResponses = null;\n         Set<String> unstartedAppsSet = new HashSet<String>();\n-        Set<String> apps = appTracker.getAppNames();", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MjExOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450472119", "bodyText": "Fixed", "author": "kabicin", "createdAt": "2020-07-06T20:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMxNzA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNzIwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450337208", "bodyText": "Looks like there are duplicate lines of code in this method from 109-124", "author": "pgunapal", "createdAt": "2020-07-06T16:23:29Z", "path": "dev/com.ibm.ws.microprofile.health.2.0/src/com/ibm/ws/microprofile/health20/internal/HealthCheck20ServiceImpl.java", "diffHunk": "@@ -96,15 +96,16 @@ public void performHealthCheck(HttpServletRequest request, HttpServletResponse h\n     public void performHealthCheck(HttpServletRequest request, HttpServletResponse httpResponse, String healthCheckProcedure) {\n         Set<HealthCheckResponse> hcResponses = null;\n         Set<String> unstartedAppsSet = new HashSet<String>();\n-        Set<String> apps = appTracker.getAppNames();\n+        Set<String> apps = appTracker.getAllAppNames();\n         Iterator<String> appsIt = apps.iterator();\n-\n+        boolean anyAppsInstalled = false;\n         HealthCheckHttpResponseBuilder hcHttpResponseBuilder = new HealthCheck20HttpResponseBuilder();\n \n         while (appsIt.hasNext()) {\n             String appName = appsIt.next();\n-\n-            if (!appTracker.isStarted(appName)) {\n+            if(appTracker.isInstalled(appName)) {\n+                anyAppsInstalled = true;\n+            } else if (!appTracker.isUninstalled(appName) && !appTracker.isStarted(appName)) {\n                 if (tc.isDebugEnabled())", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3Mjg0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450472848", "bodyText": "Agree, silly mistake on my part. Intention was to get rid of the continue call and put the code that follows into an else.", "author": "kabicin", "createdAt": "2020-07-06T20:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNzIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0MTE3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450341172", "bodyText": "For the cases, where the applications are just installed (not started), we should print out the readiness.healthcheck.applications.not.started.down message with the appName in the unstartedAppsSet. Maybe, update the Set in line 107, where we distinguish if any apps are installed?", "author": "pgunapal", "createdAt": "2020-07-06T16:29:47Z", "path": "dev/com.ibm.ws.microprofile.health.2.0/src/com/ibm/ws/microprofile/health20/internal/HealthCheck20ServiceImpl.java", "diffHunk": "@@ -168,6 +177,10 @@ public void performHealthCheck(HttpServletRequest request, HttpServletResponse h\n             Tr.warning(tc, \"readiness.healthcheck.applications.not.started.down.CWMH0053W\", new Object[] { unstartedAppsSet });\n         }\n \n+        if (anyAppsInstalled && !(healthCheckProcedure.equals(HealthCheckConstants.HEALTH_CHECK_LIVE))) {\n+            hcHttpResponseBuilder.setOverallState(State.DOWN);", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MzczNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450473736", "bodyText": "On line 108-110, I've added a statement to add the appName to the unstartedAppsSet set, this should trigger line 172 to print.", "author": "kabicin", "createdAt": "2020-07-06T20:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0MTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0ODkwMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450348902", "bodyText": "Verify if the CWMH0053W message is not displayed.", "author": "pgunapal", "createdAt": "2020-07-06T16:42:37Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/FailsToStartHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.util.Set;\n+import java.net.HttpURLConnection;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class FailsToStartHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\" };\n+\n+    public static final String APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    @Server(\"FailsToStartHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @BeforeClass\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public static void setUp() throws Exception {\n+        log(\"setUp\", \"Add Fails To Start Application to the server.\");\n+        log(\"setUp\", \"Start server\");\n+        server1.startServer();\n+\n+        Set<String> appInstalled = server1.getInstalledAppNames(APP_NAME);\n+        if (appInstalled.isEmpty()) {\n+            JavaArchive testServletJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                     \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+            WebArchive app = ShrinkHelper.buildDefaultApp(APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+            app = app.addAsLibraries(testServletJar);\n+            ShrinkHelper.exportAppToServer(server1, app);\n+        }\n+\n+        log(\"setUp\", \"Wait for app startup\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"setUp\", \"Wait for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"setUp\", \"Wait for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() throws Exception {\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    @Test\n+    public void testSuccessLivenessCheckWithFailsToStartApplication() throws Exception {\n+        log(\"testSuccessLivenessCheckWithFailsToStartApplication\", \"Testing the /health/live endpoint, after the application expectedly failed to start\");\n+        HttpURLConnection conLive = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, LIVE_ENDPOINT);\n+        assertEquals(SUCCESS_RESPONSE_CODE, conLive.getResponseCode());\n+\n+        JsonObject jsonResponse = getJSONPayload(conLive);\n+        JsonArray checks = (JsonArray) jsonResponse.get(\"checks\");\n+        assertEquals(0, checks.size());\n+        assertEquals(jsonResponse.getString(\"status\"), \"UP\");", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDY4Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r452390687", "bodyText": "Added assertEquals on line 102.", "author": "kabicin", "createdAt": "2020-07-09T17:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0ODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0OTEwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450349109", "bodyText": "Verify if the CWMH0053W message is displayed with the appropriate appName in the logs.", "author": "pgunapal", "createdAt": "2020-07-06T16:43:01Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/FailsToStartHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.util.Set;\n+import java.net.HttpURLConnection;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class FailsToStartHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\" };\n+\n+    public static final String APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    @Server(\"FailsToStartHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @BeforeClass\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public static void setUp() throws Exception {\n+        log(\"setUp\", \"Add Fails To Start Application to the server.\");\n+        log(\"setUp\", \"Start server\");\n+        server1.startServer();\n+\n+        Set<String> appInstalled = server1.getInstalledAppNames(APP_NAME);\n+        if (appInstalled.isEmpty()) {\n+            JavaArchive testServletJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                     \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+            WebArchive app = ShrinkHelper.buildDefaultApp(APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+            app = app.addAsLibraries(testServletJar);\n+            ShrinkHelper.exportAppToServer(server1, app);\n+        }\n+\n+        log(\"setUp\", \"Wait for app startup\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"setUp\", \"Wait for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"setUp\", \"Wait for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() throws Exception {\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    @Test\n+    public void testSuccessLivenessCheckWithFailsToStartApplication() throws Exception {\n+        log(\"testSuccessLivenessCheckWithFailsToStartApplication\", \"Testing the /health/live endpoint, after the application expectedly failed to start\");\n+        HttpURLConnection conLive = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, LIVE_ENDPOINT);\n+        assertEquals(SUCCESS_RESPONSE_CODE, conLive.getResponseCode());\n+\n+        JsonObject jsonResponse = getJSONPayload(conLive);\n+        JsonArray checks = (JsonArray) jsonResponse.get(\"checks\");\n+        assertEquals(0, checks.size());\n+        assertEquals(jsonResponse.getString(\"status\"), \"UP\");\n+    }\n+\n+    @Test\n+    public void testFailedReadinessCheckWithFailsToStartApplication() throws Exception {\n+        log(\"testFailedReadinessCheckWithFailsToStartApplication\", \"Testing the /health/ready endpoint, after the application expectedly failed to start\");\n+        HttpURLConnection conLive = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+        assertEquals(FAILED_RESPONSE_CODE, conLive.getResponseCode());\n+\n+        JsonObject jsonResponse = getJSONPayload(conLive);\n+        JsonArray checks = (JsonArray) jsonResponse.get(\"checks\");\n+        assertEquals(0, checks.size());\n+        assertEquals(jsonResponse.getString(\"status\"), \"DOWN\");", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDk2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r452390968", "bodyText": "Added assertTrue on line 117.", "author": "kabicin", "createdAt": "2020-07-09T17:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0OTEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0OTE2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450349166", "bodyText": "Verify if the CWMH0053W message is displayed with the appropriate appName in the logs.", "author": "pgunapal", "createdAt": "2020-07-06T16:43:08Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/FailsToStartHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.util.Set;\n+import java.net.HttpURLConnection;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class FailsToStartHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\" };\n+\n+    public static final String APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    @Server(\"FailsToStartHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @BeforeClass\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public static void setUp() throws Exception {\n+        log(\"setUp\", \"Add Fails To Start Application to the server.\");\n+        log(\"setUp\", \"Start server\");\n+        server1.startServer();\n+\n+        Set<String> appInstalled = server1.getInstalledAppNames(APP_NAME);\n+        if (appInstalled.isEmpty()) {\n+            JavaArchive testServletJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                     \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+            WebArchive app = ShrinkHelper.buildDefaultApp(APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+            app = app.addAsLibraries(testServletJar);\n+            ShrinkHelper.exportAppToServer(server1, app);\n+        }\n+\n+        log(\"setUp\", \"Wait for app startup\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"setUp\", \"Wait for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"setUp\", \"Wait for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() throws Exception {\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    @Test\n+    public void testSuccessLivenessCheckWithFailsToStartApplication() throws Exception {\n+        log(\"testSuccessLivenessCheckWithFailsToStartApplication\", \"Testing the /health/live endpoint, after the application expectedly failed to start\");\n+        HttpURLConnection conLive = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, LIVE_ENDPOINT);\n+        assertEquals(SUCCESS_RESPONSE_CODE, conLive.getResponseCode());\n+\n+        JsonObject jsonResponse = getJSONPayload(conLive);\n+        JsonArray checks = (JsonArray) jsonResponse.get(\"checks\");\n+        assertEquals(0, checks.size());\n+        assertEquals(jsonResponse.getString(\"status\"), \"UP\");\n+    }\n+\n+    @Test\n+    public void testFailedReadinessCheckWithFailsToStartApplication() throws Exception {\n+        log(\"testFailedReadinessCheckWithFailsToStartApplication\", \"Testing the /health/ready endpoint, after the application expectedly failed to start\");\n+        HttpURLConnection conLive = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+        assertEquals(FAILED_RESPONSE_CODE, conLive.getResponseCode());\n+\n+        JsonObject jsonResponse = getJSONPayload(conLive);\n+        JsonArray checks = (JsonArray) jsonResponse.get(\"checks\");\n+        assertEquals(0, checks.size());\n+        assertEquals(jsonResponse.getString(\"status\"), \"DOWN\");\n+    }\n+\n+    @Test\n+    public void testFailedCheckWithFailsToStartApplication() throws Exception {\n+        log(\"testFailedCheckWithFailsToStartApplication\", \"Testing the /health endpoint, after the application expectedly failed to start\");\n+        HttpURLConnection conLive = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, HEALTH_ENDPOINT);\n+        assertEquals(FAILED_RESPONSE_CODE, conLive.getResponseCode());\n+\n+        JsonObject jsonResponse = getJSONPayload(conLive);\n+        JsonArray checks = (JsonArray) jsonResponse.get(\"checks\");\n+        assertEquals(0, checks.size());\n+        assertEquals(jsonResponse.getString(\"status\"), \"DOWN\");", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTQ0Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r452395442", "bodyText": "Added assertTrue on line 132.", "author": "kabicin", "createdAt": "2020-07-09T18:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0OTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0OTU4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450349582", "bodyText": "Update the copyright year to 2019, 2020", "author": "pgunapal", "createdAt": "2020-07-06T16:43:41Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/suite/FATSuite.java", "diffHunk": "@@ -17,12 +17,14 @@\n import com.ibm.ws.microprofile.health20.fat.DelayAppStartupHealthCheckTest;\n import com.ibm.ws.microprofile.health20.fat.DifferentApplicationNameHealthCheckTest;\n import com.ibm.ws.microprofile.health20.fat.MultipleHealthCheckTest;\n+import com.ibm.ws.microprofile.health20.fat.FailsToStartHealthCheckTest;", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTU5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r452395594", "bodyText": "Fixed", "author": "kabicin", "createdAt": "2020-07-09T18:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0OTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1MDUzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450350538", "bodyText": "Should be 2017, 2020", "author": "pgunapal", "createdAt": "2020-07-06T16:45:17Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTracker.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2017, 2019 Contributors to the Eclipse Foundation\n+ * Copyright (c) 2017, 2019, 2020 Contributors to the Eclipse Foundation", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NjExOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r452396119", "bodyText": "Fixed", "author": "kabicin", "createdAt": "2020-07-09T18:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1MDUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3MzE5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450373194", "bodyText": "Should be 2017, 2020", "author": "pgunapal", "createdAt": "2020-07-06T17:26:52Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2017, 2019 Contributors to the Eclipse Foundation\n+ * Copyright (c) 2017, 2019, 2020 Contributors to the Eclipse Foundation", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3NjUzOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450476539", "bodyText": "Fixed", "author": "kabicin", "createdAt": "2020-07-06T20:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3MzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NTMxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450375313", "bodyText": "Do we need a lock here? I think there maybe scenarios where the lock is already being held from isInstalled() or its caller, and it will never get into this method, leading to a potential deadlock.", "author": "pgunapal", "createdAt": "2020-07-06T17:30:53Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -238,6 +253,70 @@ public boolean isStarted(String appName) {\n         }\n     }\n \n+    /**\n+     * Returns true if the application with the specified name is installed, otherwise false.\n+     *\n+     * @return true if the application with the specified name is installed, otherwise false.\n+     */\n+    @Override\n+    public boolean isInstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            String state = getApplicationMBean(appName);\n+            if (state.isEmpty()) {\n+                appStateMap.replace(appName, null);\n+            }\n+            else if (state.equals(\"INSTALLED\")) {\n+                if (appStateMap.get(appName) != ApplicationState.INSTALLED) {\n+                    appStateMap.replace(appName, ApplicationState.INSTALLED);\n+                }\n+                return true;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true if the application with the specified name is uninstalled, otherwise false.\n+     *\n+     * @return true if the application with the specified name is uninstalled, otherwise false.\n+     */\n+    @Override\n+    public boolean isUninstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            if (appStateMap.get(appName) == null) {\n+                return true;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     *\n+     * @return the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     */\n+    private String getApplicationMBean(String appName) {\n+        lock.readLock().lock();", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3NzY0OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450477649", "bodyText": "Makes sense, I have removed the lock.", "author": "kabicin", "createdAt": "2020-07-06T21:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NTY4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450375682", "bodyText": "Declare the String state variable outside of the try block, so we get better scoping. e.g String state = \"\";", "author": "pgunapal", "createdAt": "2020-07-06T17:31:35Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -238,6 +253,70 @@ public boolean isStarted(String appName) {\n         }\n     }\n \n+    /**\n+     * Returns true if the application with the specified name is installed, otherwise false.\n+     *\n+     * @return true if the application with the specified name is installed, otherwise false.\n+     */\n+    @Override\n+    public boolean isInstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            String state = getApplicationMBean(appName);\n+            if (state.isEmpty()) {\n+                appStateMap.replace(appName, null);\n+            }\n+            else if (state.equals(\"INSTALLED\")) {\n+                if (appStateMap.get(appName) != ApplicationState.INSTALLED) {\n+                    appStateMap.replace(appName, ApplicationState.INSTALLED);\n+                }\n+                return true;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true if the application with the specified name is uninstalled, otherwise false.\n+     *\n+     * @return true if the application with the specified name is uninstalled, otherwise false.\n+     */\n+    @Override\n+    public boolean isUninstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            if (appStateMap.get(appName) == null) {\n+                return true;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     *\n+     * @return the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     */\n+    private String getApplicationMBean(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            MBeanInfo bean = null;\n+            try {\n+                ObjectName objectName = new ObjectName(\"WebSphere:service=com.ibm.websphere.application.ApplicationMBean,name=\" + appName);\n+                bean = mbeanServer.getMBeanInfo(objectName);\n+                String state = (String) mbeanServer.getAttribute(objectName, \"State\");", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3NzE3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450477174", "bodyText": "I've modified so the state String is initialized outside of the try statement.", "author": "kabicin", "createdAt": "2020-07-06T21:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NjI5Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450376293", "bodyText": "Remove the inner return statement and just add return state; here", "author": "pgunapal", "createdAt": "2020-07-06T17:32:44Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -238,6 +253,70 @@ public boolean isStarted(String appName) {\n         }\n     }\n \n+    /**\n+     * Returns true if the application with the specified name is installed, otherwise false.\n+     *\n+     * @return true if the application with the specified name is installed, otherwise false.\n+     */\n+    @Override\n+    public boolean isInstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            String state = getApplicationMBean(appName);\n+            if (state.isEmpty()) {\n+                appStateMap.replace(appName, null);\n+            }\n+            else if (state.equals(\"INSTALLED\")) {\n+                if (appStateMap.get(appName) != ApplicationState.INSTALLED) {\n+                    appStateMap.replace(appName, ApplicationState.INSTALLED);\n+                }\n+                return true;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true if the application with the specified name is uninstalled, otherwise false.\n+     *\n+     * @return true if the application with the specified name is uninstalled, otherwise false.\n+     */\n+    @Override\n+    public boolean isUninstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            if (appStateMap.get(appName) == null) {\n+                return true;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     *\n+     * @return the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     */\n+    private String getApplicationMBean(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            MBeanInfo bean = null;\n+            try {\n+                ObjectName objectName = new ObjectName(\"WebSphere:service=com.ibm.websphere.application.ApplicationMBean,name=\" + appName);\n+                bean = mbeanServer.getMBeanInfo(objectName);\n+                String state = (String) mbeanServer.getAttribute(objectName, \"State\");\n+                return state;\n+            } catch (Exception e) {}\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return \"\";", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3NzMwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450477304", "bodyText": "Modified to return the state variable now.", "author": "kabicin", "createdAt": "2020-07-06T21:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NjI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MTE4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r450381181", "bodyText": "How do we know if the app is completely removed from the dropins directory or just stopped?\nFrom the code, it looks like if the state is not STARTED, we are assuming that the app is just stopped and not completed removed from the dropins directory? However, the state in the appStateMap never gets modified, when the application is stopping, in other words, the state will always be STARTED and never go into the first if statement logic, and always go into the else statement logic, no matter what.", "author": "pgunapal", "createdAt": "2020-07-06T17:42:23Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -262,7 +341,13 @@ public void applicationStopped(ApplicationInfo appInfo) {\n         // Remove the stopped application from the appState map\n         lock.writeLock().lock();\n         try {\n-            appStateMap.remove(appName);\n+            if (appStateMap.containsKey(appName)) {\n+               if (appStateMap.get(appName) != ApplicationState.STARTED) {\n+                   appStateMap.replace(appName, ApplicationState.INSTALLED);", "originalCommit": "8f4b174d494938c5c10622c16681e373392a2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMDM1Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r452400353", "bodyText": "Reverted the change to original implementation", "author": "kabicin", "createdAt": "2020-07-09T18:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MTE4MQ=="}], "type": "inlineReview"}, {"oid": "a6185a7119393c35d42fafd81835773489658db4", "url": "https://github.com/OpenLiberty/open-liberty/commit/a6185a7119393c35d42fafd81835773489658db4", "message": "Added and compressed tests in ApplicationStateHealthCheckTest", "committedDate": "2020-07-20T14:30:42Z", "type": "forcePushed"}, {"oid": "a2c6d2c0792b4af9974276d071a672b5b01417a9", "url": "https://github.com/OpenLiberty/open-liberty/commit/a2c6d2c0792b4af9974276d071a672b5b01417a9", "message": "Added and compressed tests in ApplicationStateHealthCheckTest", "committedDate": "2020-07-20T21:23:11Z", "type": "forcePushed"}, {"oid": "935959fa5bbefb4031103a1bd5d869d1719c1a30", "url": "https://github.com/OpenLiberty/open-liberty/commit/935959fa5bbefb4031103a1bd5d869d1719c1a30", "message": "Added and compressed tests in ApplicationStateHealthCheckTest", "committedDate": "2020-07-20T21:27:03Z", "type": "forcePushed"}, {"oid": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "url": "https://github.com/OpenLiberty/open-liberty/commit/28754c68f0fc0db2c007654aa3b72555c574a5ca", "message": "Added and compressed tests in ApplicationStateHealthCheckTest", "committedDate": "2020-07-20T21:28:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3MDAyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458170028", "bodyText": "Can you determine if theses Tests cases should be in LITE or FULL mode, following the guidelines from: https://github.com/OpenLiberty/open-liberty/wiki/FAT-Tests#fat-test-modes", "author": "pgunapal", "createdAt": "2020-07-21T15:05:54Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3MDUxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458170516", "bodyText": "All Assert statements in this Test Class should include a message parameter, so if the Assert fails, it will be easy to debug.", "author": "pgunapal", "createdAt": "2020-07-21T15:06:34Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3MzQ2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458173460", "bodyText": "Looks like in each test case, you deploy applications using repetitive same lines of codes, to further clean up the code, it would be beneficial to add the deploy application lines of code in a separate method, which would concise each test method to be more clearer.", "author": "pgunapal", "createdAt": "2020-07-21T15:10:28Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\", \"CWWKZ0060E\" };\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    public static final String MULTIPLE_APP_NAME = \"MultipleHealthCheckApp\";\n+    public static final String DIFFERENT_APP_NAME = \"DifferentApplicationNameHealthCheckApp\";\n+    public static final String FAILS_TO_START_APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final String SUCCESSFUL_APP_NAME = \"SuccessfulHealthCheckApp\";\n+    public static final String FAILING_APP_NAME = \"FailingHealthCheckApp\";\n+\n+    private static enum HealthCheck {\n+        LIVE, READY, HEALTH;\n+    }\n+\n+    private static enum Status {\n+        SUCCESS, FAILURE;\n+    }\n+\n+    @Server(\"ApplicationStateHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @Before\n+    public void setUp() {}\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        server1.removeAllInstalledAppsForValidation();\n+        server1.deleteAllDropinApplications();\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    /**\n+     * This test will first pre-load a dropin that purposely fails to start.\n+     * It will then load a dropin that would like to reports UP on all health checks.\n+     * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testPreLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5OTYyMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r462299622", "bodyText": "Added helper functions to clean up the tests", "author": "kabicin", "createdAt": "2020-07-29T13:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3MzQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NDg0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458194840", "bodyText": "For this test case, i think it should test the following:\n1- Deploy an application after a server starts\n2- Wait until it is started, verify the Health endpoints (it would be good if it return UP)\n3- Deploy an application that takes awhile to start up (Refer to the DelayedApplication app and test case in the Health 2.0 FAT)\n4- While the application is starting up, verify the Health endpoints again and the Readiness and Health endpoints should return DOWN\n5- Once the application is started, verify the Health endpoints again and it should be UP.", "author": "pgunapal", "createdAt": "2020-07-21T15:38:27Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\", \"CWWKZ0060E\" };\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    public static final String MULTIPLE_APP_NAME = \"MultipleHealthCheckApp\";\n+    public static final String DIFFERENT_APP_NAME = \"DifferentApplicationNameHealthCheckApp\";\n+    public static final String FAILS_TO_START_APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final String SUCCESSFUL_APP_NAME = \"SuccessfulHealthCheckApp\";\n+    public static final String FAILING_APP_NAME = \"FailingHealthCheckApp\";\n+\n+    private static enum HealthCheck {\n+        LIVE, READY, HEALTH;\n+    }\n+\n+    private static enum Status {\n+        SUCCESS, FAILURE;\n+    }\n+\n+    @Server(\"ApplicationStateHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @Before\n+    public void setUp() {}\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        server1.removeAllInstalledAppsForValidation();\n+        server1.deleteAllDropinApplications();\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    /**\n+     * This test will first pre-load a dropin that purposely fails to start.\n+     * It will then load a dropin that would like to reports UP on all health checks.\n+     * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testPreLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        // LibertyServer.startServer() throws TopologyException if any pre-loaded apps aren't started.\n+        // We can ignore this exception, as we expect FailsToStartHealthCheckApp to not start.\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        try {\n+            server1.startServer();\n+        } catch (TopologyException e) {\n+        }\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 0);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 0);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 0);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+    }\n+\n+    /**\n+     * This test will first dynamically load a dropin that reports UP on all health checks.\n+     * It will then dynamically load a dropin that purposely fails to start, which causes\n+     * the readiness/overall state to report DOWN, and the liveness state to be unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testDynamicallyLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints before the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded before server start.\n+     */\n+    @Test\n+    public void testPreLoadedDropinsHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to dropins\");\n+        WebArchive app1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app1);\n+        WebArchive app2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app2);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded after server start.\n+     */\n+    @Test\n+    public void testDynamicallyLoadedDropinsHealthCheckTest() throws Exception {", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMwMDkzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r462300935", "bodyText": "Modified this test to simulate 1-5.", "author": "kabicin", "createdAt": "2020-07-29T13:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NDg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5Njg1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458196857", "bodyText": "Rename test case to \"testPreLoadedApplicationsHealthCheckTest\"", "author": "pgunapal", "createdAt": "2020-07-21T15:41:08Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\", \"CWWKZ0060E\" };\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    public static final String MULTIPLE_APP_NAME = \"MultipleHealthCheckApp\";\n+    public static final String DIFFERENT_APP_NAME = \"DifferentApplicationNameHealthCheckApp\";\n+    public static final String FAILS_TO_START_APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final String SUCCESSFUL_APP_NAME = \"SuccessfulHealthCheckApp\";\n+    public static final String FAILING_APP_NAME = \"FailingHealthCheckApp\";\n+\n+    private static enum HealthCheck {\n+        LIVE, READY, HEALTH;\n+    }\n+\n+    private static enum Status {\n+        SUCCESS, FAILURE;\n+    }\n+\n+    @Server(\"ApplicationStateHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @Before\n+    public void setUp() {}\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        server1.removeAllInstalledAppsForValidation();\n+        server1.deleteAllDropinApplications();\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    /**\n+     * This test will first pre-load a dropin that purposely fails to start.\n+     * It will then load a dropin that would like to reports UP on all health checks.\n+     * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testPreLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        // LibertyServer.startServer() throws TopologyException if any pre-loaded apps aren't started.\n+        // We can ignore this exception, as we expect FailsToStartHealthCheckApp to not start.\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        try {\n+            server1.startServer();\n+        } catch (TopologyException e) {\n+        }\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 0);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 0);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 0);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+    }\n+\n+    /**\n+     * This test will first dynamically load a dropin that reports UP on all health checks.\n+     * It will then dynamically load a dropin that purposely fails to start, which causes\n+     * the readiness/overall state to report DOWN, and the liveness state to be unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testDynamicallyLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints before the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded before server start.\n+     */\n+    @Test\n+    public void testPreLoadedDropinsHealthCheckTest() throws Exception {", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMwMTM5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r462301396", "bodyText": "Renamed", "author": "kabicin", "createdAt": "2020-07-29T13:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5Njg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NzMwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458197303", "bodyText": "Rename test case to \"testDynamicallyLoadedApplicationsHealthCheckTest\"", "author": "pgunapal", "createdAt": "2020-07-21T15:41:44Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\", \"CWWKZ0060E\" };\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    public static final String MULTIPLE_APP_NAME = \"MultipleHealthCheckApp\";\n+    public static final String DIFFERENT_APP_NAME = \"DifferentApplicationNameHealthCheckApp\";\n+    public static final String FAILS_TO_START_APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final String SUCCESSFUL_APP_NAME = \"SuccessfulHealthCheckApp\";\n+    public static final String FAILING_APP_NAME = \"FailingHealthCheckApp\";\n+\n+    private static enum HealthCheck {\n+        LIVE, READY, HEALTH;\n+    }\n+\n+    private static enum Status {\n+        SUCCESS, FAILURE;\n+    }\n+\n+    @Server(\"ApplicationStateHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @Before\n+    public void setUp() {}\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        server1.removeAllInstalledAppsForValidation();\n+        server1.deleteAllDropinApplications();\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    /**\n+     * This test will first pre-load a dropin that purposely fails to start.\n+     * It will then load a dropin that would like to reports UP on all health checks.\n+     * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testPreLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        // LibertyServer.startServer() throws TopologyException if any pre-loaded apps aren't started.\n+        // We can ignore this exception, as we expect FailsToStartHealthCheckApp to not start.\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        try {\n+            server1.startServer();\n+        } catch (TopologyException e) {\n+        }\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 0);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 0);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 0);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+    }\n+\n+    /**\n+     * This test will first dynamically load a dropin that reports UP on all health checks.\n+     * It will then dynamically load a dropin that purposely fails to start, which causes\n+     * the readiness/overall state to report DOWN, and the liveness state to be unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testDynamicallyLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints before the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded before server start.\n+     */\n+    @Test\n+    public void testPreLoadedDropinsHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to dropins\");\n+        WebArchive app1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app1);\n+        WebArchive app2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app2);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded after server start.\n+     */\n+    @Test\n+    public void testDynamicallyLoadedDropinsHealthCheckTest() throws Exception {", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMwMTMxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r462301319", "bodyText": "Renamed", "author": "kabicin", "createdAt": "2020-07-29T13:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NzMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTQxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458201419", "bodyText": "I think this test is redundant since the above test cases test for different statuses when multi applications are deployed as well.", "author": "pgunapal", "createdAt": "2020-07-21T15:47:20Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\", \"CWWKZ0060E\" };\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    public static final String MULTIPLE_APP_NAME = \"MultipleHealthCheckApp\";\n+    public static final String DIFFERENT_APP_NAME = \"DifferentApplicationNameHealthCheckApp\";\n+    public static final String FAILS_TO_START_APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final String SUCCESSFUL_APP_NAME = \"SuccessfulHealthCheckApp\";\n+    public static final String FAILING_APP_NAME = \"FailingHealthCheckApp\";\n+\n+    private static enum HealthCheck {\n+        LIVE, READY, HEALTH;\n+    }\n+\n+    private static enum Status {\n+        SUCCESS, FAILURE;\n+    }\n+\n+    @Server(\"ApplicationStateHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @Before\n+    public void setUp() {}\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        server1.removeAllInstalledAppsForValidation();\n+        server1.deleteAllDropinApplications();\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    /**\n+     * This test will first pre-load a dropin that purposely fails to start.\n+     * It will then load a dropin that would like to reports UP on all health checks.\n+     * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testPreLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        // LibertyServer.startServer() throws TopologyException if any pre-loaded apps aren't started.\n+        // We can ignore this exception, as we expect FailsToStartHealthCheckApp to not start.\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        try {\n+            server1.startServer();\n+        } catch (TopologyException e) {\n+        }\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 0);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 0);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 0);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+    }\n+\n+    /**\n+     * This test will first dynamically load a dropin that reports UP on all health checks.\n+     * It will then dynamically load a dropin that purposely fails to start, which causes\n+     * the readiness/overall state to report DOWN, and the liveness state to be unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testDynamicallyLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints before the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded before server start.\n+     */\n+    @Test\n+    public void testPreLoadedDropinsHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to dropins\");\n+        WebArchive app1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app1);\n+        WebArchive app2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app2);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded after server start.\n+     */\n+    @Test\n+    public void testDynamicallyLoadedDropinsHealthCheckTest() throws Exception {\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Adding DifferentAppNameHealthCheckApp to dropins\");\n+        WebArchive dynamicApp1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, dynamicApp1);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Waiting for DifferentAppNameHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after DifferentAppNameHealthCheckApp is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 3);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp to dropins\");\n+        WebArchive dynamicApp2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, dynamicApp2);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n+    }\n+\n+    /**\n+     * This test ensures that health checks can properly go from success to failure states.\n+     */\n+    @Test\n+    public void testSuccessToFailureHealthCheckTest() throws Exception {", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4OTM2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r461889369", "bodyText": "Removed this test case.", "author": "kabicin", "createdAt": "2020-07-28T21:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTU0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458201540", "bodyText": "I think this test is redundant since the above test cases test for different statuses when multi applications are deployed as well.", "author": "pgunapal", "createdAt": "2020-07-21T15:47:30Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.exception.TopologyException;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\", \"CWWKZ0014W\", \"SRVE0265E\", \"SRVE0283E\", \"CWWKZ0060E\" };\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503;\n+\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    public static final String MULTIPLE_APP_NAME = \"MultipleHealthCheckApp\";\n+    public static final String DIFFERENT_APP_NAME = \"DifferentApplicationNameHealthCheckApp\";\n+    public static final String FAILS_TO_START_APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final String SUCCESSFUL_APP_NAME = \"SuccessfulHealthCheckApp\";\n+    public static final String FAILING_APP_NAME = \"FailingHealthCheckApp\";\n+\n+    private static enum HealthCheck {\n+        LIVE, READY, HEALTH;\n+    }\n+\n+    private static enum Status {\n+        SUCCESS, FAILURE;\n+    }\n+\n+    @Server(\"ApplicationStateHealthCheck\")\n+    public static LibertyServer server1;\n+\n+    @Before\n+    public void setUp() {}\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        server1.removeAllInstalledAppsForValidation();\n+        server1.deleteAllDropinApplications();\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    /**\n+     * This test will first pre-load a dropin that purposely fails to start.\n+     * It will then load a dropin that would like to reports UP on all health checks.\n+     * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testPreLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        // LibertyServer.startServer() throws TopologyException if any pre-loaded apps aren't started.\n+        // We can ignore this exception, as we expect FailsToStartHealthCheckApp to not start.\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        try {\n+            server1.startServer();\n+        } catch (TopologyException e) {\n+        }\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 0);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 0);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 0);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+    }\n+\n+    /**\n+     * This test will first dynamically load a dropin that reports UP on all health checks.\n+     * It will then dynamically load a dropin that purposely fails to start, which causes\n+     * the readiness/overall state to report DOWN, and the liveness state to be unaltered.\n+     */\n+    @Test\n+    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n+    public void testDynamicallyLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints before the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n+        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n+                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n+        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n+        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n+        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n+        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n+        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+\n+        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after the FailsToStart app is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n+        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded before server start.\n+     */\n+    @Test\n+    public void testPreLoadedDropinsHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to dropins\");\n+        WebArchive app1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app1);\n+        WebArchive app2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, app2);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testPreLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded after server start.\n+     */\n+    @Test\n+    public void testDynamicallyLoadedDropinsHealthCheckTest() throws Exception {\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Adding DifferentAppNameHealthCheckApp to dropins\");\n+        WebArchive dynamicApp1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, dynamicApp1);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Waiting for DifferentAppNameHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after DifferentAppNameHealthCheckApp is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 3);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp to dropins\");\n+        WebArchive dynamicApp2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, dynamicApp2);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp to start\");\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n+    }\n+\n+    /**\n+     * This test ensures that health checks can properly go from success to failure states.\n+     */\n+    @Test\n+    public void testSuccessToFailureHealthCheckTest() throws Exception {\n+        log(\"testSuccessToFailureHealthCheckTest\", \"Starting the server\");\n+        server1.startServer();\n+\n+        log(\"testSuccessToFailureHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        WebArchive successApp = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, successApp);\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testSuccessToFailureHealthCheckTest\", \"Expecting successful health checks\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n+\n+        log(\"testSuccessToFailureHealthCheckTest\", \"Adding FailingHealthCheckApp to dropins\");\n+        WebArchive failApp = ShrinkHelper.buildDefaultApp(FAILING_APP_NAME, \"com.ibm.ws.microprofile.health20.failing.health.checks.app\");\n+        ShrinkHelper.exportDropinAppToServer(server1, failApp);\n+        server1.waitForStringInLog(\"CWWKZ0001I.* \" + FAILING_APP_NAME, APP_STARTUP_TIMEOUT);\n+\n+        log(\"testSuccessToFailureHealthCheckTest\", \"Expecting failing health checks\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 2);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 2);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 4);\n+    }\n+\n+    /**\n+     * This test ensures that health checks can not go from failure to success states.\n+     */\n+    @Test\n+    public void testNoFailureToSuccessHealthCheckTest() throws Exception {", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4OTM5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r461889391", "bodyText": "Removed this test case.", "author": "kabicin", "createdAt": "2020-07-28T21:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMjMxNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458202314", "bodyText": "Fix the indentation.", "author": "pgunapal", "createdAt": "2020-07-21T15:48:37Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/suite/FATSuite.java", "diffHunk": "@@ -14,12 +14,14 @@\n import org.junit.runners.Suite;\n import org.junit.runners.Suite.SuiteClasses;\n \n+import com.ibm.ws.microprofile.health20.fat.ApplicationStateHealthCheckTest;\n import com.ibm.ws.microprofile.health20.fat.DelayAppStartupHealthCheckTest;\n import com.ibm.ws.microprofile.health20.fat.DifferentApplicationNameHealthCheckTest;\n import com.ibm.ws.microprofile.health20.fat.MultipleHealthCheckTest;\n \n @RunWith(Suite.class)\n @SuiteClasses({\n+\t\t\t\tApplicationStateHealthCheckTest.class,", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4OTIyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r461889225", "bodyText": "Fixed", "author": "kabicin", "createdAt": "2020-07-28T21:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxODY1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r458218651", "bodyText": "I was just thinking while reviewing the code, this method will be called each time, the health endpoint is called, which means that we would make an MBean call each time, might be expensive. Would adding the MBean call when the application is stopping in applicationStopping() method work in our scenarios and update the appStateMap() accordingly in that method? Then we just read the appStateMap in this method?", "author": "pgunapal", "createdAt": "2020-07-21T16:11:32Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -238,6 +253,65 @@ public boolean isStarted(String appName) {\n         }\n     }\n \n+    /**\n+     * Returns true if the application with the specified name is installed, otherwise false.\n+     *\n+     * @return true if the application with the specified name is installed, otherwise false.\n+     */\n+    @Override\n+    public boolean isInstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            String state = getApplicationMBean(appName);", "originalCommit": "28754c68f0fc0db2c007654aa3b72555c574a5ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMwNjUzMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r462306530", "bodyText": "Moved the MBean check into applicationStopping(), however doing so will make us lose test coverage because our FailsToStart app never enters applicationStopping() (i.e. our app enters applicationStarted() and nothing else beyond that). The appStateMap doesn't get updated the same way it does for an app that fails to start production. For our testing, the indication that our FailsToStart app \"failed to start\", comes from the MBean state change - which we cannot check because FailsToStart app does not automatically trigger applicationStopping(). I've commented out the FailsToStart test cases for now.", "author": "kabicin", "createdAt": "2020-07-29T13:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxODY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM2ODUzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r472368538", "bodyText": "Repeatedly hitting the endpoint that is not ready yet, might throw some ConnectException/SocketTimeoutException/SocketException, so we have to catch that and continue to keep trying it. Refer to the test case (https://github.com/OpenLiberty/open-liberty/blob/integration/dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java#L150)", "author": "pgunapal", "createdAt": "2020-08-18T17:36:48Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -70,235 +85,216 @@\n         SUCCESS, FAILURE;\n     }\n \n-    @Server(\"ApplicationStateHealthCheck\")\n+    public static KafkaContainer kafkaContainer = new KafkaContainer();\n+\n+    final static String SERVER_NAME = \"ApplicationStateHealthCheck\";\n+\n+    @ClassRule\n+    public static RepeatTests r = RepeatTests.withoutModification()\n+                    .andWith(new FeatureReplacementAction()\n+                                    .withID(\"mpHealth-3.0\")\n+                                    .addFeature(\"mpHealth-3.0\")\n+                                    .removeFeature(\"mpHealth-2.0\")\n+                                    .forServers(SERVER_NAME));\n+\n+    @Server(SERVER_NAME)\n     public static LibertyServer server1;\n \n     @Before\n-    public void setUp() {}\n+    public void setUp() throws Exception {\n+        server1.setServerConfigurationFile(\"applicationstate-original-server.xml\");\n+        server1.deleteAllDropinApplications();\n+    }\n \n     @After\n     public void cleanUp() throws Exception {\n         server1.removeAllInstalledAppsForValidation();\n-        server1.deleteAllDropinApplications();\n         server1.stopServer(EXPECTED_FAILURES);\n     }\n \n     /**\n-     * This test will first pre-load a dropin that purposely fails to start.\n+     * This test will first load an application that purposely fails to start.\n      * It will then load a dropin that would like to reports UP on all health checks.\n      * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n      */\n     @Test\n-    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n-    public void testPreLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n-        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n-                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n-        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n-        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n-        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n-\n-        // LibertyServer.startServer() throws TopologyException if any pre-loaded apps aren't started.\n-        // We can ignore this exception, as we expect FailsToStartHealthCheckApp to not start.\n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n-        try {\n-            server1.startServer();\n-        } catch (TopologyException e) {\n-        }\n-\n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n-        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n+    @Mode(TestMode.FULL)\n+    @ExpectedFFDC({ \"com.ibm.ws.container.service.state.StateChangeException\", \n+        \"com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.KafkaAdapterException\", \n+        \"org.jboss.weld.exceptions.DeploymentException\" })\n+    public void testFailsToStartApplicationHealthCheckTest() throws Exception {\n+        server1.setServerConfigurationFile(\"applicationstate-fails-server.xml\");\n \n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n-        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Pre-loading FailsToStartHealthCheckApp and starting the server\");\n+        loadServerAndApplication(FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\", false);\n \n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n         expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 0);\n-        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n+        expectFailsToStartApplicationNotStartedMessage(false);\n \n         expectHealthCheck(HealthCheck.READY, Status.FAILURE, 0);\n-        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n-        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n-\n+        expectFailsToStartApplicationNotStartedMessage(true);\n+        \n         expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 0);\n-        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n-        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n-\n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n-        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n-        ShrinkHelper.exportDropinAppToServer(server1, app);\n+        expectFailsToStartApplicationNotStartedMessage(true);\n \n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n-        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        exportApplication(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        waitForApplication(SUCCESSFUL_APP_NAME);\n \n-        log(\"testPreLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n         expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n         expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n         expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n     }\n \n-    /**\n-     * This test will first dynamically load a dropin that reports UP on all health checks.\n-     * It will then dynamically load a dropin that purposely fails to start, which causes\n-     * the readiness/overall state to report DOWN, and the liveness state to be unaltered.\n-     */\n-    @Test\n-    @ExpectedFFDC({ \"java.lang.Exception\", \"java.lang.RuntimeException\" })\n-    public void testDynamicallyLoadedFailsToStartDropinHealthCheckTest() throws Exception {\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n-        WebArchive app = ShrinkHelper.buildDefaultApp(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n-        ShrinkHelper.exportDropinAppToServer(server1, app);\n-\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Starting the server\");\n-        server1.startServer();\n-\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for SuccessfulHealthCheckApp to start\");\n-        server1.waitForStringInLog(\"CWWKZ0001I.* \" + SUCCESSFUL_APP_NAME, APP_STARTUP_TIMEOUT);\n-\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints before the FailsToStart app is dynamically deployed\");\n-        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n-        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n-        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n-\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Adding FailsToStartHealthCheckApp to dropins\");\n-        JavaArchive failsToStartListenerJar = ShrinkHelper.buildJavaArchive(\"FailsToStartListener\",\n-                                                                            \"com.ibm.ws.microprofile.health20.fails.to.start.listener\");\n-        WebArchive failsToStartApp = ShrinkHelper.defaultApp(server1, FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\");\n-        failsToStartApp = failsToStartApp.addAsLibraries(failsToStartListenerJar);\n-        ShrinkHelper.exportDropinAppToServer(server1, failsToStartApp);\n-\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected app failure\");\n-        server1.waitForStringInLog(\"CWWKZ0012I.* \" + FAILS_TO_START_APP_NAME, APP_STARTUP_TIMEOUT);\n-\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Waiting for expected FFDC failure\");\n-        server1.waitForMultipleStringsInLog(3, \"FFDC1015I\");\n-\n-        log(\"testDynamicallyLoadedFailsToStartDropinHealthCheckTest\", \"Testing health check endpoints after the FailsToStart app is dynamically deployed\");\n-        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n-        assertEquals(0, server1.findStringsInLogs(\"CWMH0053W\").size());\n-\n-        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n-        List<String> notStartedMessages = server1.findStringsInLogs(\"CWMH0053W\");\n-        assertTrue(notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n-\n-        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n-        List<String> notStartedMessages2 = server1.findStringsInLogs(\"CWMH0053W\");\n-        assertTrue(notStartedMessages2.size() == 1 && notStartedMessages2.get(0).contains(FAILS_TO_START_APP_NAME));\n-    }\n-\n     /**\n      * This test ensures that health checks adjust when dropins are loaded before server start.\n      */\n     @Test\n-    public void testPreLoadedDropinsHealthCheckTest() throws Exception {\n-        log(\"testPreLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to dropins\");\n-        WebArchive app1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n-        ShrinkHelper.exportDropinAppToServer(server1, app1);\n-        WebArchive app2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n-        ShrinkHelper.exportDropinAppToServer(server1, app2);\n-\n-        log(\"testPreLoadedDropinsHealthCheckTest\", \"Starting the server\");\n-        server1.startServer();\n+    public void testPreLoadedApplicationsHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedApplicationsHealthCheckTest\", \"Pre-loading \" + DIFFERENT_APP_NAME + \" and \" + MULTIPLE_APP_NAME +\" and starting the server\");\n+        loadServerAndApplications(Arrays.asList(DIFFERENT_APP_NAME, MULTIPLE_APP_NAME), \n+            Arrays.asList(\"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\", \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\"), false);\n \n-        log(\"testPreLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp and DifferentAppNameHealthCheckApp to start\");\n-        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n-        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n-\n-        log(\"testPreLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        log(\"testPreLoadedApplicationsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n         expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n         expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n         expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n     }\n \n     /**\n      * This test ensures that health checks adjust when dropins are loaded after server start.\n+     * It also tests that readiness reports DOWN when an app is in the middle of starting up.\n+     * Implementation borrowed from DelayAppStartupHealthCheckTest.\n      */\n     @Test\n-    public void testDynamicallyLoadedDropinsHealthCheckTest() throws Exception {\n-        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Starting the server\");\n-        server1.startServer();\n-\n-        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Adding DifferentAppNameHealthCheckApp to dropins\");\n-        WebArchive dynamicApp1 = ShrinkHelper.buildDefaultApp(DIFFERENT_APP_NAME, \"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\");\n-        ShrinkHelper.exportDropinAppToServer(server1, dynamicApp1);\n-\n-        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Waiting for DifferentAppNameHealthCheckApp to start\");\n-        server1.waitForStringInLog(\"CWWKZ0001I.* \" + DIFFERENT_APP_NAME, APP_STARTUP_TIMEOUT);\n+    public void testDynamicallyLoadedApplicationsHealthCheckTest() throws Exception {\n+        server1.setServerConfigurationFile(\"delayed-server.xml\");\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Starting the server and dynamically adding \" + SUCCESSFUL_APP_NAME);\n+        loadServerAndApplication(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\", true);\n \n-        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Testing health check endpoints after DifferentAppNameHealthCheckApp is dynamically deployed\");\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Testing health check endpoints after \" + SUCCESSFUL_APP_NAME + \" is dynamically deployed\");\n         expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n-        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n-        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n \n-        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Adding MultipleHealthCheckApp to dropins\");\n-        WebArchive dynamicApp2 = ShrinkHelper.buildDefaultApp(MULTIPLE_APP_NAME, \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\");\n-        ShrinkHelper.exportDropinAppToServer(server1, dynamicApp2);\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Adding \" + DELAYED_APP_NAME + \" to dropins\");\n+        exportApplication(DELAYED_APP_NAME, \"com.ibm.ws.microprofile.health20.delayed.health.check.app\");\n \n-        log(\"testDynamicallyLoadedDropinsHealthCheckTest\", \"Waiting for MultipleHealthCheckApp to start\");\n-        server1.waitForStringInLog(\"CWWKZ0001I.* \" + MULTIPLE_APP_NAME, APP_STARTUP_TIMEOUT);\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Testing for readiness DOWN while \" + DELAYED_APP_NAME + \" is starting.\");\n+        try {\n+            HttpURLConnection conReady = null;\n+            int responseCode = -1;\n+            boolean first_time = true;\n+            boolean app_ready = false;\n+            long start_time = System.currentTimeMillis();\n+            long time_out = 180000; // 180000ms = 3min\n+\n+            // Repeatedly hit the readiness endpoint until an UP response is received\n+            while (!app_ready) {\n+                conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);", "originalCommit": "f3c4c48dbc5216a9522de54c33a0b07d5f79d79b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MjI4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r474172285", "bodyText": "Resolved. Shouldn't need this since there is an expectHealthCheck call beforehand which would only pass if the server had successfully started.", "author": "kabicin", "createdAt": "2020-08-20T17:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM2ODUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MDY1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r472370659", "bodyText": "should be 2020", "author": "pgunapal", "createdAt": "2020-08-18T17:40:40Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/test-applications/FailsToStartHealthCheckApp/src/com/ibm/ws/microprofile/health20/fails/to/start/health/check/app/BasicMessagingBean.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2020 IBM Corporation and others.\n+ * Copyright (c) 2019 IBM Corporation and others.", "originalCommit": "f3c4c48dbc5216a9522de54c33a0b07d5f79d79b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MTk0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r474171948", "bodyText": "Updated", "author": "kabicin", "createdAt": "2020-08-20T17:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MDY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkyNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r472371926", "bodyText": "The parameter for the getApplicationMBean, should be \"appName\", instead of \"appInfo.getDeploymentName()", "author": "pgunapal", "createdAt": "2020-08-18T17:42:46Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -336,7 +334,12 @@ public void applicationStopped(ApplicationInfo appInfo) {\n         // Remove the stopped application from the appState map\n         lock.writeLock().lock();\n         try {\n-            appStateMap.remove(appName);\n+            String state = getApplicationMBean(appInfo.getDeploymentName());", "originalCommit": "f3c4c48dbc5216a9522de54c33a0b07d5f79d79b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MTkwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r474171907", "bodyText": "Updated.", "author": "kabicin", "createdAt": "2020-08-20T17:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3Nzc2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r472377760", "bodyText": "Add a Tr.debug() in the catch block and print out the Exception message, so we can debug it, if something goes wrong.", "author": "pgunapal", "createdAt": "2020-08-18T17:52:48Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -238,6 +253,63 @@ public boolean isStarted(String appName) {\n         }\n     }\n \n+    /**\n+     * Returns true if the application with the specified name is installed, otherwise false.\n+     *\n+     * @return true if the application with the specified name is installed, otherwise false.\n+     */\n+    @Override\n+    public boolean isInstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            if (appStateMap.get(appName) == ApplicationState.INSTALLED) {\n+                String state = getApplicationMBean(appName);\n+                if (state.isEmpty()) {\n+                    appStateMap.replace(appName, null);\n+                } else {\n+                    return true;\n+                }\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true if the application with the specified name is uninstalled, otherwise false.\n+     *\n+     * @return true if the application with the specified name is uninstalled, otherwise false.\n+     */\n+    @Override\n+    public boolean isUninstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            if (appStateMap.get(appName) == null) {\n+                return true;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     *\n+     * @return the MBeanInfo of appName if the ApplicationMBean exists, otherwise null.\n+     */\n+    private String getApplicationMBean(String appName) {\n+        MBeanInfo bean = null;\n+        String state = \"\";\n+        try {\n+            ObjectName objectName = new ObjectName(\"WebSphere:service=com.ibm.websphere.application.ApplicationMBean,name=\" + appName);\n+            bean = mbeanServer.getMBeanInfo(objectName);\n+            state = (String) mbeanServer.getAttribute(objectName, \"State\");\n+        } catch (Exception e) {}", "originalCommit": "f3c4c48dbc5216a9522de54c33a0b07d5f79d79b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MTczMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r474171731", "bodyText": "Added a Tr.debug message.", "author": "kabicin", "createdAt": "2020-08-20T17:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3Nzc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NTAwMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r472395002", "bodyText": "Do we need to call the MBean here, since we are calling it in the applicationStopped() method? I remember discussing about it, can you refresh my memory, why we need it here, instead of just reading the appStateMap similar to the isStarted() method. We call this method in the HealthCheckServiceImpl, so if the endpoint is hit every 5 seconds, the MBean would get called every 5 seconds, which might cause a performance impact.", "author": "pgunapal", "createdAt": "2020-08-18T18:23:11Z", "path": "dev/com.ibm.ws.microprofile.health/src/com/ibm/ws/microprofile/health/internal/AppTrackerImpl.java", "diffHunk": "@@ -238,6 +253,63 @@ public boolean isStarted(String appName) {\n         }\n     }\n \n+    /**\n+     * Returns true if the application with the specified name is installed, otherwise false.\n+     *\n+     * @return true if the application with the specified name is installed, otherwise false.\n+     */\n+    @Override\n+    public boolean isInstalled(String appName) {\n+        lock.readLock().lock();\n+        try {\n+            if (appStateMap.get(appName) == ApplicationState.INSTALLED) {\n+                String state = getApplicationMBean(appName);", "originalCommit": "f3c4c48dbc5216a9522de54c33a0b07d5f79d79b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQyOTgxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r472429816", "bodyText": "This should only have a performance impact for INSTALLED apps. Since INSTALLED apps are essentially apps that failed to start, they have already called applicationStopped() but are not stopped yet. (In general, I am assuming most apps should be STARTING (delayed) or STARTED (running), and for those cases, the MBean would not get checked, so no performance impact) The apps checked by the if statement are in a \"leaked\" state where we won't know if/when they shutdown, so we need to check the MBean to see if they are removed.\nBringing back to previous discussion, this part of the code is supposed to tackle the issue where we are not sure when the failed to start app was removed from the dropins/apps folder because we lost reference to it via the ApplicationStateListener.", "author": "kabicin", "createdAt": "2020-08-18T19:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0MTE2MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r472441161", "bodyText": "That makes sense, thanks!", "author": "pgunapal", "createdAt": "2020-08-18T19:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NTAwMg=="}], "type": "inlineReview"}, {"oid": "6e3498dcec141360fae49bb2018a6a95c3155112", "url": "https://github.com/OpenLiberty/open-liberty/commit/6e3498dcec141360fae49bb2018a6a95c3155112", "message": "Fixed readiness health check by reporting DOWN for failed to start apps and added automated tests", "committedDate": "2020-08-21T15:35:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NzAwMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12874#discussion_r474887000", "bodyText": "This message needs to be updated to \"was found\".", "author": "pgunapal", "createdAt": "2020-08-21T19:21:35Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/ApplicationStateHealthCheckTest.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.health20.fat;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.net.HttpURLConnection;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.annotation.ExpectedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.custom.junit.runner.Mode;\n+import componenttest.custom.junit.runner.Mode.TestMode;\n+import componenttest.exception.TopologyException;\n+import componenttest.rules.repeater.FeatureReplacementAction;\n+import componenttest.rules.repeater.RepeatTests;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class ApplicationStateHealthCheckTest {\n+    private static final String[] EXPECTED_FAILURES = { \"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWM*H0053W\", \"CWMMH0052W\", \"CWMMH0053W\", \"CWWKZ0060E\", \"CWWKZ0002E\" };\n+\n+    public static final String MULTIPLE_APP_NAME = \"MultipleHealthCheckApp\";\n+    public static final String DIFFERENT_APP_NAME = \"DifferentApplicationNameHealthCheckApp\";\n+    public static final String DELAYED_APP_NAME = \"DelayedHealthCheckApp\";\n+    public static final String FAILS_TO_START_APP_NAME = \"FailsToStartHealthCheckApp\";\n+    public static final String SUCCESSFUL_APP_NAME = \"SuccessfulHealthCheckApp\";\n+\n+    private final String HEALTH_ENDPOINT = \"/health\";\n+    private final String READY_ENDPOINT = \"/health/ready\";\n+    private final String LIVE_ENDPOINT = \"/health/live\";\n+\n+    private final int SUCCESS_RESPONSE_CODE = 200;\n+    private final int FAILED_RESPONSE_CODE = 503; // Response when port is open but Application is not ready\n+\n+    public static final int APP_STARTUP_TIMEOUT = 120 * 1000;\n+\n+    private static enum HealthCheck {\n+        LIVE, READY, HEALTH;\n+    }\n+\n+    private static enum Status {\n+        SUCCESS, FAILURE;\n+    }\n+\n+    public static KafkaContainer kafkaContainer = new KafkaContainer();\n+\n+    final static String SERVER_NAME = \"ApplicationStateHealthCheck\";\n+\n+    @ClassRule\n+    public static RepeatTests r = RepeatTests.withoutModification()\n+                    .andWith(new FeatureReplacementAction()\n+                                    .withID(\"mpHealth-3.0\")\n+                                    .addFeature(\"mpHealth-3.0\")\n+                                    .removeFeature(\"mpHealth-2.0\")\n+                                    .forServers(SERVER_NAME));\n+\n+    @Server(SERVER_NAME)\n+    public static LibertyServer server1;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        server1.setServerConfigurationFile(\"applicationstate-original-server.xml\");\n+        server1.deleteAllDropinApplications();\n+    }\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        server1.removeAllInstalledAppsForValidation();\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    /**\n+     * This test will first load an application that purposely fails to start.\n+     * It will then load a dropin that would like to reports UP on all health checks.\n+     * But since the pre-loaded app failed to start, readiness/overall reports DOWN and liveness remains unaltered.\n+     */\n+    @Test\n+    @Mode(TestMode.FULL)\n+    @ExpectedFFDC({ \"com.ibm.ws.container.service.state.StateChangeException\",\n+                    \"com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.KafkaAdapterException\",\n+                    \"org.jboss.weld.exceptions.DeploymentException\" })\n+    public void testFailsToStartApplicationHealthCheckTest() throws Exception {\n+        server1.setServerConfigurationFile(\"applicationstate-fails-server.xml\");\n+\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Pre-loading FailsToStartHealthCheckApp and starting the server\");\n+        loadServerAndApplication(FAILS_TO_START_APP_NAME, \"com.ibm.ws.microprofile.health20.fails.to.start.health.check.app\", false);\n+\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Testing health check endpoints after FailsToStartHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 0);\n+        expectFailsToStartApplicationNotStartedMessage(false);\n+\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 0);\n+        expectFailsToStartApplicationNotStartedMessage(true);\n+\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 0);\n+        expectFailsToStartApplicationNotStartedMessage(true);\n+\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Adding SuccessfulHealthCheckApp to dropins\");\n+        addApplication(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\");\n+        waitForApplication(SUCCESSFUL_APP_NAME);\n+\n+        log(\"testFailsToStartApplicationHealthCheckTest\", \"Testing health check endpoints after SuccessfulHealthCheckApp has been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 2);\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded before server start.\n+     */\n+    @Test\n+    public void testPreLoadedApplicationsHealthCheckTest() throws Exception {\n+        log(\"testPreLoadedApplicationsHealthCheckTest\", \"Pre-loading \" + DIFFERENT_APP_NAME + \" and \" + MULTIPLE_APP_NAME + \" and starting the server\");\n+        loadServerAndApplications(Arrays.asList(DIFFERENT_APP_NAME, MULTIPLE_APP_NAME),\n+                                  Arrays.asList(\"com.ibm.ws.microprofile.health20.different.app.name.health.checks.app\",\n+                                                \"com.ibm.ws.microprofile.health20.multiple.health.checks.app\"),\n+                                  false);\n+\n+        log(\"testPreLoadedApplicationsHealthCheckTest\", \"Testing health check endpoints after MultipleHealthCheckApp and DifferentAppNameHealthCheckApp have been loaded\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.READY, Status.FAILURE, 3);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.FAILURE, 7);\n+    }\n+\n+    /**\n+     * This test ensures that health checks adjust when dropins are loaded after server start.\n+     * It also tests that readiness reports DOWN when an app is in the middle of starting up.\n+     * Implementation borrowed from DelayAppStartupHealthCheckTest.\n+     */\n+    @Test\n+    public void testDynamicallyLoadedApplicationsHealthCheckTest() throws Exception {\n+        server1.setServerConfigurationFile(\"delayed-server.xml\");\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Starting the server and dynamically adding \" + SUCCESSFUL_APP_NAME);\n+        loadServerAndApplication(SUCCESSFUL_APP_NAME, \"com.ibm.ws.microprofile.health20.successful.health.checks.app\", true);\n+\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Testing health check endpoints after \" + SUCCESSFUL_APP_NAME + \" is dynamically deployed\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 1);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 2);\n+\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Adding \" + DELAYED_APP_NAME + \" to dropins\");\n+        addApplication(DELAYED_APP_NAME, \"com.ibm.ws.microprofile.health20.delayed.health.check.app\");\n+\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Testing for readiness DOWN while \" + DELAYED_APP_NAME + \" is starting.\");\n+        try {\n+            HttpURLConnection conReady = null;\n+            int responseCode = -1;\n+            boolean first_time = true;\n+            boolean app_ready = false;\n+            long start_time = System.currentTimeMillis();\n+            long time_out = 180000; // 180000ms = 3min\n+\n+            // Repeatedly hit the readiness endpoint until an UP response is received\n+            while (!app_ready) {\n+                conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+                responseCode = conReady.getResponseCode();\n+\n+                // We need to ensure we get a connection refused in the case of the server not finished starting up\n+                // We expect a connection refused as the ports are not open until server is fully started\n+                if (first_time) {\n+                    log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Testing the /health/ready endpoint as DelayedHealthCheckApp is still starting up.\");\n+                    String message = \"The connection did not dip with a response code \" + FAILED_RESPONSE_CODE + \" as required, instead it received code \" + responseCode +\n+                                     \". This is likely due to a rare timing issue where the server starts faster than we can hit the readiness endpoint.\";\n+                    assertTrue(message, conReady != null && responseCode == FAILED_RESPONSE_CODE);\n+                    first_time = false;\n+                } else {\n+                    if (responseCode == SUCCESS_RESPONSE_CODE) {\n+                        app_ready = true;\n+                    } else if (System.currentTimeMillis() - start_time > time_out) {\n+                        throw new TimeoutException(\"Timed out waiting for server and app to be ready. Timeout set to \" + time_out + \"ms.\");\n+                    }\n+                }\n+\n+            }\n+        } catch (Exception e) {\n+            fail(\"Encountered an issue while Testing the /health/ready endpoint as the server and/or application(s) are starting up ---> \" + e);\n+        }\n+\n+        log(\"testDynamicallyLoadedApplicationsHealthCheckTest\", \"Testing health check endpoints after \" + SUCCESSFUL_APP_NAME + \" and \" + DELAYED_APP_NAME + \" have started\");\n+        expectHealthCheck(HealthCheck.LIVE, Status.SUCCESS, 2);\n+        expectHealthCheck(HealthCheck.READY, Status.SUCCESS, 2);\n+        expectHealthCheck(HealthCheck.HEALTH, Status.SUCCESS, 4);\n+    }\n+\n+    private void expectFailsToStartApplicationNotStartedMessage(boolean expectMessage) throws Exception {\n+        if (expectMessage) {\n+            List<String> notStartedMessages = server1.findStringsInLogs(\"CWM*H0053W\");\n+            assertTrue(\"The CWM*H0053W message for \" + FAILS_TO_START_APP_NAME + \" was not found in the logs.\",\n+                       notStartedMessages.size() == 1 && notStartedMessages.get(0).contains(FAILS_TO_START_APP_NAME));\n+        } else {\n+            assertEquals(\"The CWM*H0053W message for \" + FAILS_TO_START_APP_NAME + \" was not found in the logs.\",", "originalCommit": "6e3498dcec141360fae49bb2018a6a95c3155112", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34dc8bc59c362bc7008899e6fddd05cd6ec900a5", "url": "https://github.com/OpenLiberty/open-liberty/commit/34dc8bc59c362bc7008899e6fddd05cd6ec900a5", "message": "Fixed readiness health check by reporting DOWN for failed to start apps and added automated tests", "committedDate": "2020-08-21T19:31:29Z", "type": "commit"}, {"oid": "34dc8bc59c362bc7008899e6fddd05cd6ec900a5", "url": "https://github.com/OpenLiberty/open-liberty/commit/34dc8bc59c362bc7008899e6fddd05cd6ec900a5", "message": "Fixed readiness health check by reporting DOWN for failed to start apps and added automated tests", "committedDate": "2020-08-21T19:31:29Z", "type": "forcePushed"}]}