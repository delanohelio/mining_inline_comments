{"pr_number": 12299, "pr_title": "mpMetrics-3.0 NO SHIP code drop (JAX-RS relevant changes in two other separate PRs  )", "pr_createdAt": "2020-05-21T03:12:28Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/12299", "timeline": [{"oid": "cc7a5d05e0477c2e46f458993714fa0860d82770", "url": "https://github.com/OpenLiberty/open-liberty/commit/cc7a5d05e0477c2e46f458993714fa0860d82770", "message": "mpMetrics-3.0 noShip code drop (JAX-RS relevant changes in two separate PRs  )\n\nMicroProfile Metrics features:\nauto - com.ibm.websphere.appserver.mpMetrics-3.0-monitor-1.0\npublic - com.ibm.websphere.appserver.mpMetrics-3.0\nprivate - com.ibm.websphere.appserver.org.eclipse.microprofile.metrics-3.0\n\n- Using a snapshot of the MicroProfile Metric API has it has not been released yet or RCed. Cannot retrieve from maven.\n\n- Introduced Stereotype support (MetricResolver#hasMetricAnnotation, MetricResolver#getAnnotation)\n\n- New MetricRegistry API. It is now an interface and new methods are added.\n\n- Concept of Re-usability removed (MetricResolver class modified - remove use of getReusable method)\n\n- SimpleTimer now tracks high and lows from the \"previous\" full/complete minute. \"Previous\" is defined as the last time the simple timer was queried which could be a few minutes ago. This is similar to the behaviour of the \"previous\" minute tracking of the ConcurrentGauge metric.", "committedDate": "2020-05-21T03:22:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyNDQ2Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428424467", "bodyText": "Removal of reusability only checks if metadata is different.\nThere also use to exist code that retrieved the reusable value from the annotation. But that has been removed as is not apparant in this diff.", "author": "Channyboy", "createdAt": "2020-05-21T03:24:12Z", "path": "dev/com.ibm.ws.microprofile.metrics.cdi.3.0/src/io/astefanutti/metrics/cdi30/MetricResolver.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/*******************************************************************************\n+ * Copyright (c) 2017, 2020 IBM Corporation and others.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ *******************************************************************************\n+ * Copyright \u00a9 2013 Antonin Stefanutti (antonin.stefanutti@gmail.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *******************************************************************************/\n+package io.astefanutti.metrics.cdi30;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Vetoed;\n+import javax.enterprise.inject.spi.BeanManager;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.annotation.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+import org.eclipse.microprofile.metrics.annotation.Gauge;\n+import org.eclipse.microprofile.metrics.annotation.Metered;\n+import org.eclipse.microprofile.metrics.annotation.SimplyTimed;\n+import org.eclipse.microprofile.metrics.annotation.Timed;\n+\n+import com.ibm.ws.microprofile.metrics.cdi30.helper.Utils;\n+\n+@ApplicationScoped\n+public class MetricResolver {\n+\n+    @Inject\n+    private MetricRegistry registry;\n+\n+    @Inject\n+    protected MetricsExtension extension;\n+\n+    @Inject\n+    protected MetricName metricName;\n+\n+    @Inject\n+    protected BeanManager beanManager;\n+\n+    public <E extends Member & AnnotatedElement> Of<Counted> counted(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Counted.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<ConcurrentGauge> concurentGauged(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, ConcurrentGauge.class);\n+    }\n+\n+    public Of<Gauge> gauge(Class<?> topClass, Method method) {\n+        return resolverOf(topClass, method, Gauge.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Metered> metered(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Metered.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Timed> timed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, Timed.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<SimplyTimed> simplyTimed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, SimplyTimed.class);\n+    }\n+\n+    private <E extends Member & AnnotatedElement, T extends Annotation> Of<T> resolverOf(Class<?> bean, E element, Class<T> metric) {\n+        if (element.isAnnotationPresent(metric))\n+            return elementResolverOf(element, metric);\n+        else\n+            return beanResolverOf(element, metric, bean);\n+    }\n+\n+    protected <E extends Member & AnnotatedElement, T extends Annotation> Of<T> elementResolverOf(E element, Class<T> metric) {\n+        T annotation = element.getAnnotation(metric);\n+\n+        // See if we have the name cached\n+        String name = extension.getMetricNameForMember(element, annotation);\n+\n+        boolean initialDiscovery = false;\n+        if (name == null) {\n+            name = metricName(element, metric, metricName(annotation), isMetricAbsolute(annotation));\n+            initialDiscovery = true;\n+        }\n+\n+        MetadataBuilder mdb = Metadata.builder().withName(name).withType(this.getType(annotation)).withUnit(this.getUnit(annotation)).withDescription(this.getDescription(annotation)).withDisplayName(this.getDisplayname(annotation));\n+\n+        String[] tags = this.getTags(annotation);\n+\n+        Of<T> of = new DoesHaveMetric<>(annotation, name, mdb.build(), initialDiscovery, tags);\n+        checkReusable(of);\n+        return of;\n+    }\n+\n+    protected <T extends Annotation> boolean hasMetricAnnotationBean(Class<T> metric, Class<?> bean) {\n+        if (bean.isAnnotationPresent(metric))\n+            return true;\n+\n+        /*\n+         * Go through the annotations available in this class to see if a sterotype is present\n+         * that contains the metric annotation we are testing for\n+         */\n+        Annotation[] beanAnotations = bean.getAnnotations();\n+        for (Annotation annotation : beanAnotations) {\n+\n+            Class<? extends Annotation> annotationType = annotation.annotationType();\n+            if (beanManager.isStereotype(annotationType) && annotationType.isAnnotationPresent(metric)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    protected <T extends Annotation> T getAnnotationBean(Class<T> metric, Class<?> bean) {\n+        T annotationObj = bean.getAnnotation(metric);\n+        if (annotationObj != null)\n+            return annotationObj;\n+\n+        /*\n+         * Go through the annotations available in this class to see if a sterotype is present\n+         * that contains the metric annotation we are testing for and retrieves the Annotation\n+         */\n+\n+        Annotation[] beanAnotations = bean.getAnnotations();\n+        for (Annotation annotation : beanAnotations) {\n+\n+            Class<? extends Annotation> annotationType = annotation.annotationType();\n+            if (beanManager.isStereotype(annotationType) && annotationType.isAnnotationPresent(metric)) {\n+                annotationObj = annotationType.getAnnotation(metric);\n+                if (annotationObj != null) {\n+                    return annotationObj;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    protected <E extends Member & AnnotatedElement, T extends Annotation> Of<T> beanResolverOf(E element, Class<T> metric, Class<?> bean) {\n+\n+        if (hasMetricAnnotationBean(metric, bean)) {\n+            T annotation = getAnnotationBean(metric, bean);\n+\n+            // See if we have the name cached\n+            String name = extension.getMetricNameForMember(element, annotation);\n+\n+            boolean initialDiscovery = false;\n+            if (name == null) {\n+                name = metricName(bean, element, metric, metricName(annotation), isMetricAbsolute(annotation));\n+                initialDiscovery = true;\n+            }\n+\n+            MetadataBuilder mdb = Metadata.builder().withName(name).withType(this.getType(annotation)).withUnit(this.getUnit(annotation)).withDescription(this.getDescription(annotation)).withDisplayName(this.getDisplayname(annotation));\n+            String[] tags = this.getTags(annotation);\n+\n+            Of<T> of = new DoesHaveMetric<>(annotation, name, mdb.build(), initialDiscovery, tags);\n+            checkReusable(of);\n+\n+            return of;\n+        } else if (bean.getSuperclass() != null) {\n+            return beanResolverOf(element, metric, bean.getSuperclass());\n+        }\n+        return new DoesNotHaveMetric<>();\n+\n+    }\n+\n+    // TODO: should be grouped with the metric name strategy\n+    private <E extends Member & AnnotatedElement> String metricName(E element, Class<? extends Annotation> type, String name, boolean absolute) {\n+        String metric = name.isEmpty() ? defaultName(element, type) : metricName.of(name);\n+        return absolute ? metric : MetricRegistry.name(element.getDeclaringClass(), metric);\n+    }\n+\n+    private <E extends Member & AnnotatedElement> String metricName(Class<?> bean, E element, Class<? extends Annotation> type, String name, boolean absolute) {\n+        String metric = name.isEmpty() ? bean.getSimpleName() : metricName.of(name);\n+        return absolute ? MetricRegistry.name(metric, defaultName(element, type)) : MetricRegistry.name(bean.getPackage().getName(), metric, defaultName(element, type));\n+    }\n+\n+    private <E extends Member & AnnotatedElement> String defaultName(E element, Class<? extends Annotation> type) {\n+        return memberName(element);\n+    }\n+\n+    // While the Member Javadoc states that the getName method should returns\n+    // the simple name of the underlying member or constructor, the FQN is returned\n+    // for constructors. See JDK-6294399:\n+    // http://bugs.java.com/view_bug.do?bug_id=6294399\n+    private String memberName(Member member) {\n+        if (member instanceof Constructor)\n+            return member.getDeclaringClass().getSimpleName();\n+        else\n+            return member.getName();\n+    }\n+\n+    private String metricName(Annotation annotation) {\n+        if (Counted.class.isInstance(annotation))\n+            return ((Counted) annotation).name();\n+        else if (ConcurrentGauge.class.isInstance(annotation))\n+            return ((ConcurrentGauge) annotation).name();\n+        else if (Gauge.class.isInstance(annotation))\n+            return ((Gauge) annotation).name();\n+        else if (Metered.class.isInstance(annotation))\n+            return ((Metered) annotation).name();\n+        else if (Timed.class.isInstance(annotation))\n+            return ((Timed) annotation).name();\n+        else if (SimplyTimed.class.isInstance(annotation))\n+            return ((SimplyTimed) annotation).name();\n+        else\n+            throw new IllegalArgumentException(\"Unsupported Metrics forMethod [\" + annotation.getClass().getName() + \"]\");\n+    }\n+\n+    private boolean isMetricAbsolute(Annotation annotation) {\n+\n+        if (Counted.class.isInstance(annotation))\n+            return ((Counted) annotation).absolute();\n+        else if (ConcurrentGauge.class.isInstance(annotation))\n+            return ((ConcurrentGauge) annotation).absolute();\n+        else if (Gauge.class.isInstance(annotation))\n+            return ((Gauge) annotation).absolute();\n+        else if (Metered.class.isInstance(annotation))\n+            return ((Metered) annotation).absolute();\n+        else if (Timed.class.isInstance(annotation))\n+            return ((Timed) annotation).absolute();\n+        else if (SimplyTimed.class.isInstance(annotation))\n+            return ((SimplyTimed) annotation).absolute();\n+        else\n+            throw new IllegalArgumentException(\"Unsupported Metrics forMethod [\" + annotation.getClass().getName() + \"]\");\n+    }\n+\n+    private String[] getTags(Annotation annotation) {\n+        if (Counted.class.isInstance(annotation))\n+            return ((Counted) annotation).tags();\n+        else if (ConcurrentGauge.class.isInstance(annotation))\n+            return ((ConcurrentGauge) annotation).tags();\n+        else if (Gauge.class.isInstance(annotation))\n+            return ((Gauge) annotation).tags();\n+        else if (Metered.class.isInstance(annotation))\n+            return ((Metered) annotation).tags();\n+        else if (Timed.class.isInstance(annotation))\n+            return ((Timed) annotation).tags();\n+        else if (SimplyTimed.class.isInstance(annotation))\n+            return ((SimplyTimed) annotation).tags();\n+        else\n+            throw new IllegalArgumentException(\"Unsupported Metrics forMethod [\" + annotation.getClass().getName() + \"]\");\n+\n+    }\n+\n+    private String getDisplayname(Annotation annotation) {\n+        if (Counted.class.isInstance(annotation))\n+            return ((Counted) annotation).displayName();\n+        else if (ConcurrentGauge.class.isInstance(annotation))\n+            return ((ConcurrentGauge) annotation).displayName();\n+        else if (Gauge.class.isInstance(annotation))\n+            return ((Gauge) annotation).displayName();\n+        else if (Metered.class.isInstance(annotation))\n+            return ((Metered) annotation).displayName();\n+        else if (Timed.class.isInstance(annotation))\n+            return ((Timed) annotation).displayName();\n+        else if (SimplyTimed.class.isInstance(annotation))\n+            return ((SimplyTimed) annotation).displayName();\n+        else\n+            throw new IllegalArgumentException(\"Unsupported Metrics forMethod [\" + annotation.getClass().getName() + \"]\");\n+\n+    }\n+\n+    private String getDescription(Annotation annotation) {\n+        if (Counted.class.isInstance(annotation))\n+            return ((Counted) annotation).description();\n+        else if (ConcurrentGauge.class.isInstance(annotation))\n+            return ((ConcurrentGauge) annotation).description();\n+        else if (Gauge.class.isInstance(annotation))\n+            return ((Gauge) annotation).description();\n+        else if (Metered.class.isInstance(annotation))\n+            return ((Metered) annotation).description();\n+        else if (Timed.class.isInstance(annotation))\n+            return ((Timed) annotation).description();\n+        else if (SimplyTimed.class.isInstance(annotation))\n+            return ((SimplyTimed) annotation).description();\n+        else\n+            throw new IllegalArgumentException(\"Unsupported Metrics forMethod [\" + annotation.getClass().getName() + \"]\");\n+    }\n+\n+    private MetricType getType(Annotation annotation) {\n+        if (Counted.class.isInstance(annotation))\n+            return MetricType.COUNTER;\n+        else if (ConcurrentGauge.class.isInstance(annotation))\n+            return MetricType.CONCURRENT_GAUGE;\n+        else if (Gauge.class.isInstance(annotation))\n+            return MetricType.GAUGE;\n+        else if (Metered.class.isInstance(annotation))\n+            return MetricType.METERED;\n+        else if (Timed.class.isInstance(annotation))\n+            return MetricType.TIMER;\n+        else if (SimplyTimed.class.isInstance(annotation))\n+            return MetricType.SIMPLE_TIMER;\n+        else\n+            throw new IllegalArgumentException(\"Unsupported Metrics forMethod [\" + annotation.getClass().getName() + \"]\");\n+    }\n+\n+    private String getUnit(Annotation annotation) {\n+        if (Counted.class.isInstance(annotation))\n+            return ((Counted) annotation).unit();\n+        else if (ConcurrentGauge.class.isInstance(annotation))\n+            return MetricUnits.NONE;\n+        else if (Gauge.class.isInstance(annotation))\n+            return ((Gauge) annotation).unit();\n+        else if (Metered.class.isInstance(annotation))\n+            return ((Metered) annotation).unit();\n+        else if (Timed.class.isInstance(annotation))\n+            return ((Timed) annotation).unit();\n+        else if (SimplyTimed.class.isInstance(annotation))\n+            return ((SimplyTimed) annotation).unit();\n+        else\n+            throw new IllegalArgumentException(\"Unsupported Metrics forMethod [\" + annotation.getClass().getName() + \"]\");\n+    }\n+\n+    /**\n+     * Checks whether the metric should be re-usable\n+     */\n+    private <T extends Annotation> boolean checkReusable(MetricResolver.Of<T> of) {\n+\n+        // If the metric has been registered before (eg. metrics found in RequestScoped beans),\n+        // we don't need to worry about re-usable\n+        if (!of.isInitialDiscovery()) {\n+            return true;\n+        }\n+\n+        String name = of.metadata().getName();\n+        String[] tags = of.tags();\n+        MetricID metricID = new MetricID(name, Utils.tagsToTags(tags));\n+\n+        Metadata existingMetadata = registry.getMetadata(name);\n+\n+        /*\n+         * If the current metadata does not equal an existing metadata (of matching name).. - Then we can NOT re-use.\n+         * Type check is conducted when registering/retrieving metric.\n+         */\n+        if ((existingMetadata != null && !existingMetadata.equals(of.metadata()))) {", "originalCommit": "cc7a5d05e0477c2e46f458993714fa0860d82770", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyNDcxOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428424718", "bodyText": "this method added to support CDI stereotypes", "author": "Channyboy", "createdAt": "2020-05-21T03:25:21Z", "path": "dev/com.ibm.ws.microprofile.metrics.cdi.3.0/src/io/astefanutti/metrics/cdi30/MetricResolver.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/*******************************************************************************\n+ * Copyright (c) 2017, 2020 IBM Corporation and others.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ *******************************************************************************\n+ * Copyright \u00a9 2013 Antonin Stefanutti (antonin.stefanutti@gmail.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *******************************************************************************/\n+package io.astefanutti.metrics.cdi30;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Vetoed;\n+import javax.enterprise.inject.spi.BeanManager;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.annotation.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+import org.eclipse.microprofile.metrics.annotation.Gauge;\n+import org.eclipse.microprofile.metrics.annotation.Metered;\n+import org.eclipse.microprofile.metrics.annotation.SimplyTimed;\n+import org.eclipse.microprofile.metrics.annotation.Timed;\n+\n+import com.ibm.ws.microprofile.metrics.cdi30.helper.Utils;\n+\n+@ApplicationScoped\n+public class MetricResolver {\n+\n+    @Inject\n+    private MetricRegistry registry;\n+\n+    @Inject\n+    protected MetricsExtension extension;\n+\n+    @Inject\n+    protected MetricName metricName;\n+\n+    @Inject\n+    protected BeanManager beanManager;\n+\n+    public <E extends Member & AnnotatedElement> Of<Counted> counted(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Counted.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<ConcurrentGauge> concurentGauged(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, ConcurrentGauge.class);\n+    }\n+\n+    public Of<Gauge> gauge(Class<?> topClass, Method method) {\n+        return resolverOf(topClass, method, Gauge.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Metered> metered(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Metered.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Timed> timed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, Timed.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<SimplyTimed> simplyTimed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, SimplyTimed.class);\n+    }\n+\n+    private <E extends Member & AnnotatedElement, T extends Annotation> Of<T> resolverOf(Class<?> bean, E element, Class<T> metric) {\n+        if (element.isAnnotationPresent(metric))\n+            return elementResolverOf(element, metric);\n+        else\n+            return beanResolverOf(element, metric, bean);\n+    }\n+\n+    protected <E extends Member & AnnotatedElement, T extends Annotation> Of<T> elementResolverOf(E element, Class<T> metric) {\n+        T annotation = element.getAnnotation(metric);\n+\n+        // See if we have the name cached\n+        String name = extension.getMetricNameForMember(element, annotation);\n+\n+        boolean initialDiscovery = false;\n+        if (name == null) {\n+            name = metricName(element, metric, metricName(annotation), isMetricAbsolute(annotation));\n+            initialDiscovery = true;\n+        }\n+\n+        MetadataBuilder mdb = Metadata.builder().withName(name).withType(this.getType(annotation)).withUnit(this.getUnit(annotation)).withDescription(this.getDescription(annotation)).withDisplayName(this.getDisplayname(annotation));\n+\n+        String[] tags = this.getTags(annotation);\n+\n+        Of<T> of = new DoesHaveMetric<>(annotation, name, mdb.build(), initialDiscovery, tags);\n+        checkReusable(of);\n+        return of;\n+    }\n+\n+    protected <T extends Annotation> boolean hasMetricAnnotationBean(Class<T> metric, Class<?> bean) {", "originalCommit": "cc7a5d05e0477c2e46f458993714fa0860d82770", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyNDc5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428424799", "bodyText": "this method added to support CDI stereotypes", "author": "Channyboy", "createdAt": "2020-05-21T03:25:43Z", "path": "dev/com.ibm.ws.microprofile.metrics.cdi.3.0/src/io/astefanutti/metrics/cdi30/MetricResolver.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/*******************************************************************************\n+ * Copyright (c) 2017, 2020 IBM Corporation and others.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ *******************************************************************************\n+ * Copyright \u00a9 2013 Antonin Stefanutti (antonin.stefanutti@gmail.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *******************************************************************************/\n+package io.astefanutti.metrics.cdi30;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Vetoed;\n+import javax.enterprise.inject.spi.BeanManager;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.annotation.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+import org.eclipse.microprofile.metrics.annotation.Gauge;\n+import org.eclipse.microprofile.metrics.annotation.Metered;\n+import org.eclipse.microprofile.metrics.annotation.SimplyTimed;\n+import org.eclipse.microprofile.metrics.annotation.Timed;\n+\n+import com.ibm.ws.microprofile.metrics.cdi30.helper.Utils;\n+\n+@ApplicationScoped\n+public class MetricResolver {\n+\n+    @Inject\n+    private MetricRegistry registry;\n+\n+    @Inject\n+    protected MetricsExtension extension;\n+\n+    @Inject\n+    protected MetricName metricName;\n+\n+    @Inject\n+    protected BeanManager beanManager;\n+\n+    public <E extends Member & AnnotatedElement> Of<Counted> counted(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Counted.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<ConcurrentGauge> concurentGauged(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, ConcurrentGauge.class);\n+    }\n+\n+    public Of<Gauge> gauge(Class<?> topClass, Method method) {\n+        return resolverOf(topClass, method, Gauge.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Metered> metered(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Metered.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Timed> timed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, Timed.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<SimplyTimed> simplyTimed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, SimplyTimed.class);\n+    }\n+\n+    private <E extends Member & AnnotatedElement, T extends Annotation> Of<T> resolverOf(Class<?> bean, E element, Class<T> metric) {\n+        if (element.isAnnotationPresent(metric))\n+            return elementResolverOf(element, metric);\n+        else\n+            return beanResolverOf(element, metric, bean);\n+    }\n+\n+    protected <E extends Member & AnnotatedElement, T extends Annotation> Of<T> elementResolverOf(E element, Class<T> metric) {\n+        T annotation = element.getAnnotation(metric);\n+\n+        // See if we have the name cached\n+        String name = extension.getMetricNameForMember(element, annotation);\n+\n+        boolean initialDiscovery = false;\n+        if (name == null) {\n+            name = metricName(element, metric, metricName(annotation), isMetricAbsolute(annotation));\n+            initialDiscovery = true;\n+        }\n+\n+        MetadataBuilder mdb = Metadata.builder().withName(name).withType(this.getType(annotation)).withUnit(this.getUnit(annotation)).withDescription(this.getDescription(annotation)).withDisplayName(this.getDisplayname(annotation));\n+\n+        String[] tags = this.getTags(annotation);\n+\n+        Of<T> of = new DoesHaveMetric<>(annotation, name, mdb.build(), initialDiscovery, tags);\n+        checkReusable(of);\n+        return of;\n+    }\n+\n+    protected <T extends Annotation> boolean hasMetricAnnotationBean(Class<T> metric, Class<?> bean) {\n+        if (bean.isAnnotationPresent(metric))\n+            return true;\n+\n+        /*\n+         * Go through the annotations available in this class to see if a sterotype is present\n+         * that contains the metric annotation we are testing for\n+         */\n+        Annotation[] beanAnotations = bean.getAnnotations();\n+        for (Annotation annotation : beanAnotations) {\n+\n+            Class<? extends Annotation> annotationType = annotation.annotationType();\n+            if (beanManager.isStereotype(annotationType) && annotationType.isAnnotationPresent(metric)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    protected <T extends Annotation> T getAnnotationBean(Class<T> metric, Class<?> bean) {", "originalCommit": "cc7a5d05e0477c2e46f458993714fa0860d82770", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyNzE2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428427168", "bodyText": "166-167 using the above two new methods.\nIt use to directly check the bean if the annotation was present and retrieve it. That of course did not support stereotypes.", "author": "Channyboy", "createdAt": "2020-05-21T03:36:23Z", "path": "dev/com.ibm.ws.microprofile.metrics.cdi.3.0/src/io/astefanutti/metrics/cdi30/MetricResolver.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/*******************************************************************************\n+ * Copyright (c) 2017, 2020 IBM Corporation and others.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ *******************************************************************************\n+ * Copyright \u00a9 2013 Antonin Stefanutti (antonin.stefanutti@gmail.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *******************************************************************************/\n+package io.astefanutti.metrics.cdi30;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Vetoed;\n+import javax.enterprise.inject.spi.BeanManager;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.annotation.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+import org.eclipse.microprofile.metrics.annotation.Gauge;\n+import org.eclipse.microprofile.metrics.annotation.Metered;\n+import org.eclipse.microprofile.metrics.annotation.SimplyTimed;\n+import org.eclipse.microprofile.metrics.annotation.Timed;\n+\n+import com.ibm.ws.microprofile.metrics.cdi30.helper.Utils;\n+\n+@ApplicationScoped\n+public class MetricResolver {\n+\n+    @Inject\n+    private MetricRegistry registry;\n+\n+    @Inject\n+    protected MetricsExtension extension;\n+\n+    @Inject\n+    protected MetricName metricName;\n+\n+    @Inject\n+    protected BeanManager beanManager;\n+\n+    public <E extends Member & AnnotatedElement> Of<Counted> counted(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Counted.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<ConcurrentGauge> concurentGauged(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, ConcurrentGauge.class);\n+    }\n+\n+    public Of<Gauge> gauge(Class<?> topClass, Method method) {\n+        return resolverOf(topClass, method, Gauge.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Metered> metered(Class<?> topClass, E element) {\n+        return resolverOf(topClass, element, Metered.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<Timed> timed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, Timed.class);\n+    }\n+\n+    public <E extends Member & AnnotatedElement> Of<SimplyTimed> simplyTimed(Class<?> bean, E element) {\n+        return resolverOf(bean, element, SimplyTimed.class);\n+    }\n+\n+    private <E extends Member & AnnotatedElement, T extends Annotation> Of<T> resolverOf(Class<?> bean, E element, Class<T> metric) {\n+        if (element.isAnnotationPresent(metric))\n+            return elementResolverOf(element, metric);\n+        else\n+            return beanResolverOf(element, metric, bean);\n+    }\n+\n+    protected <E extends Member & AnnotatedElement, T extends Annotation> Of<T> elementResolverOf(E element, Class<T> metric) {\n+        T annotation = element.getAnnotation(metric);\n+\n+        // See if we have the name cached\n+        String name = extension.getMetricNameForMember(element, annotation);\n+\n+        boolean initialDiscovery = false;\n+        if (name == null) {\n+            name = metricName(element, metric, metricName(annotation), isMetricAbsolute(annotation));\n+            initialDiscovery = true;\n+        }\n+\n+        MetadataBuilder mdb = Metadata.builder().withName(name).withType(this.getType(annotation)).withUnit(this.getUnit(annotation)).withDescription(this.getDescription(annotation)).withDisplayName(this.getDisplayname(annotation));\n+\n+        String[] tags = this.getTags(annotation);\n+\n+        Of<T> of = new DoesHaveMetric<>(annotation, name, mdb.build(), initialDiscovery, tags);\n+        checkReusable(of);\n+        return of;\n+    }\n+\n+    protected <T extends Annotation> boolean hasMetricAnnotationBean(Class<T> metric, Class<?> bean) {\n+        if (bean.isAnnotationPresent(metric))\n+            return true;\n+\n+        /*\n+         * Go through the annotations available in this class to see if a sterotype is present\n+         * that contains the metric annotation we are testing for\n+         */\n+        Annotation[] beanAnotations = bean.getAnnotations();\n+        for (Annotation annotation : beanAnotations) {\n+\n+            Class<? extends Annotation> annotationType = annotation.annotationType();\n+            if (beanManager.isStereotype(annotationType) && annotationType.isAnnotationPresent(metric)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    protected <T extends Annotation> T getAnnotationBean(Class<T> metric, Class<?> bean) {\n+        T annotationObj = bean.getAnnotation(metric);\n+        if (annotationObj != null)\n+            return annotationObj;\n+\n+        /*\n+         * Go through the annotations available in this class to see if a sterotype is present\n+         * that contains the metric annotation we are testing for and retrieves the Annotation\n+         */\n+\n+        Annotation[] beanAnotations = bean.getAnnotations();\n+        for (Annotation annotation : beanAnotations) {\n+\n+            Class<? extends Annotation> annotationType = annotation.annotationType();\n+            if (beanManager.isStereotype(annotationType) && annotationType.isAnnotationPresent(metric)) {\n+                annotationObj = annotationType.getAnnotation(metric);\n+                if (annotationObj != null) {\n+                    return annotationObj;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    protected <E extends Member & AnnotatedElement, T extends Annotation> Of<T> beanResolverOf(E element, Class<T> metric, Class<?> bean) {\n+\n+        if (hasMetricAnnotationBean(metric, bean)) {", "originalCommit": "cc7a5d05e0477c2e46f458993714fa0860d82770", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyNzY3OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428427678", "bodyText": "The implementation for calculating/retrieving the previous max high and low is similar to the implementation from ConcurrentGauge.", "author": "Channyboy", "createdAt": "2020-05-21T03:38:47Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/impl/SimpleTimer30Impl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.impl;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+\n+import com.ibm.ws.microprofile.metrics.impl.Clock;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+\n+/**\n+ * A timer metric which aggregates timing durations and provides duration statistics, plus\n+ * throughput statistics via {@link Meter}.\n+ */\n+public class SimpleTimer30Impl implements SimpleTimer {\n+\n+    // maximum count achieved in previous minute\n+    private final AtomicLong max_previousMinute;\n+    // minimum count achieved in previous minute\n+    private final AtomicLong min_previousMinute;\n+\n+    // maximum count achieved in this minute\n+    private final AtomicLong max_thisMinute;\n+    // minimum count achieved in this minute\n+    private final AtomicLong min_thisMinute;\n+\n+    // current timestamp rounded down to the last whole minute\n+    private final AtomicLong thisMinute;\n+\n+    /**\n+     * A timing context.\n+     *\n+     * @see SimpleTimer30Impl#time()\n+     */\n+    public static class Context implements SimpleTimer.Context {\n+        private final SimpleTimer30Impl simpleTimer;\n+        private final Clock clock;\n+        private final long startTime;\n+\n+        private Context(SimpleTimer30Impl simpleTimer, Clock clock) {\n+            this.simpleTimer = simpleTimer;\n+            this.clock = clock;\n+            this.startTime = clock.getTick();\n+        }\n+\n+        /**\n+         * Updates the timer with the difference between current and start time. Call to this method will\n+         * not reset the start time. Multiple calls result in multiple updates.\n+         *\n+         * @return the elapsed time in nanoseconds\n+         */\n+        @Override\n+        public long stop() {\n+            final long elapsed = clock.getTick() - startTime;\n+            simpleTimer.update(Duration.ofNanos(elapsed));\n+            return elapsed;\n+        }\n+\n+        /** Equivalent to calling {@link #stop()}. */\n+        @Override\n+        public void close() {\n+            stop();\n+        }\n+    }\n+\n+    private final Counter count;\n+    private Duration elapsedTime;\n+    private final Clock clock;\n+\n+    public SimpleTimer30Impl() {\n+        this(Clock.defaultClock());\n+    }\n+\n+    public SimpleTimer30Impl(Clock clock) {\n+        this.clock = clock;\n+        this.count = new CounterImpl();\n+        this.elapsedTime = Duration.ZERO;\n+\n+        max_previousMinute = new AtomicLong(0);\n+        min_previousMinute = new AtomicLong(0);\n+        max_thisMinute = new AtomicLong(0);\n+        min_thisMinute = new AtomicLong(0);\n+        thisMinute = new AtomicLong(getCurrentMinuteFromSystem());\n+    }\n+\n+    /**\n+     * Adds a recorded duration.\n+     *\n+     * @param duration the length of the duration\n+     * @param unit     the scale unit of {@code duration}\n+     */\n+    @Override\n+    public void update(Duration duration) {\n+        maybeStartNewMinute();\n+        Long duration_nanos = duration.toNanos();\n+        if (duration_nanos >= 0) {\n+            synchronized (this) {\n+                count.inc();\n+                elapsedTime = elapsedTime.plus(duration);\n+\n+                if (duration_nanos > max_thisMinute.get())\n+                    max_thisMinute.set(duration_nanos);\n+\n+                if (duration_nanos < min_thisMinute.get() || min_thisMinute.get() == 0L)\n+                    min_thisMinute.set(duration_nanos);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public <T> T time(Callable<T> event) throws Exception {\n+        maybeStartNewMinute();\n+        final long startTime = clock.getTick();\n+        try {\n+            return event.call();\n+        } finally {\n+            update(Duration.ofNanos(clock.getTick() - startTime));\n+        }\n+    }\n+\n+    @Override\n+    public void time(Runnable event) {\n+        maybeStartNewMinute();\n+        final long startTime = clock.getTick();\n+        try {\n+            event.run();\n+        } finally {\n+            update(Duration.ofNanos(clock.getTick() - startTime));\n+\n+        }\n+    }\n+\n+    @Override\n+    public Context time() {\n+        maybeStartNewMinute();\n+        return new Context(this, clock);\n+    }\n+\n+    @Override\n+    public long getCount() {\n+        maybeStartNewMinute();\n+        return count.getCount();\n+    }\n+\n+    @Override\n+    public Duration getElapsedTime() {\n+        maybeStartNewMinute();\n+        return elapsedTime;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Duration getMaxTimeDuration() {", "originalCommit": "cc7a5d05e0477c2e46f458993714fa0860d82770", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyNzgyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428427823", "bodyText": "Changes/Additions to the Timer to use the Duration object. (as per the spec)", "author": "Channyboy", "createdAt": "2020-05-21T03:39:30Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/impl/Timer30Impl.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*******************************************************************************\n+* Copyright (c) 2020 IBM Corporation and others.\n+*\n+* All rights reserved. This program and the accompanying materials\n+* are made available under the terms of the Eclipse Public License v1.0\n+* which accompanies this distribution, and is available at\n+* http://www.eclipse.org/legal/epl-v10.html\n+*\n+*******************************************************************************\n+* Copyright 2010-2013 Coda Hale and Yammer, Inc.\n+*\n+* Licensed under the Apache License, Version 2.0 (the \"License\");\n+* you may not use this file except in compliance with the License.\n+* You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.impl;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Snapshot;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.ws.microprofile.metrics.impl.Clock;\n+import com.ibm.ws.microprofile.metrics.impl.ExponentiallyDecayingReservoir;\n+import com.ibm.ws.microprofile.metrics.impl.HistogramImpl;\n+import com.ibm.ws.microprofile.metrics.impl.MeterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.Reservoir;\n+import com.ibm.ws.microprofile.metrics.impl.TimerImpl;\n+\n+/**\n+ * A timer metric which aggregates timing durations and provides duration statistics, plus\n+ * throughput statistics via {@link Meter}.\n+ */\n+public class Timer30Impl implements Timer {", "originalCommit": "cc7a5d05e0477c2e46f458993714fa0860d82770", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "url": "https://github.com/OpenLiberty/open-liberty/commit/9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "message": "mpMetrics-3.0 noShip code drop (JAX-RS relevant changes in two separate PRs  )\n\nMicroProfile Metrics features:\nauto - com.ibm.websphere.appserver.mpMetrics-3.0-monitor-1.0\npublic - com.ibm.websphere.appserver.mpMetrics-3.0\nprivate - com.ibm.websphere.appserver.org.eclipse.microprofile.metrics-3.0\n\n- Using a snapshot of the MicroProfile Metric API has it has not been released yet or RCed. Cannot retrieve from maven.\n\n- Introduced Stereotype support (MetricResolver#hasMetricAnnotation, MetricResolver#getAnnotation)\n\n- New MetricRegistry API. It is now an interface and new methods are added.\n\n- Concept of Re-usability removed (MetricResolver class modified - remove use of getReusable method)\n\n- SimpleTimer now tracks high and lows from the \"previous\" full/complete minute. \"Previous\" is defined as the last time the simple timer was queried which could be a few minutes ago. This is similar to the behaviour of the \"previous\" minute tracking of the ConcurrentGauge metric.", "committedDate": "2020-05-21T03:44:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyOTI0NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428429244", "bodyText": "new method.", "author": "Channyboy", "createdAt": "2020-05-21T03:45:50Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/impl/MetricRegistry30Impl.java", "diffHunk": "@@ -0,0 +1,1090 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.impl;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NoSuchElementException;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.enterprise.inject.Vetoed;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.eclipse.microprofile.metrics.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricFilter;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.metrics.impl.ConcurrentGaugeImpl;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.ExponentiallyDecayingReservoir;\n+import com.ibm.ws.microprofile.metrics.impl.HistogramImpl;\n+import com.ibm.ws.microprofile.metrics.impl.MeterImpl;\n+\n+/**\n+ * A registry of metric instances.\n+ */\n+@Vetoed\n+public class MetricRegistry30Impl implements MetricRegistry {\n+\n+    protected final ConcurrentMap<MetricID, Metric> metricsMID;\n+    protected final ConcurrentMap<String, Metadata> metadataMID;\n+    protected final ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>> applicationMap;\n+    private final ConfigProviderResolver configResolver;\n+\n+    private final static boolean usingJava2Security = System.getSecurityManager() != null;\n+\n+    /**\n+     * Creates a new {@link MetricRegistry}.\n+     *\n+     * @param configResolver\n+     */\n+    public MetricRegistry30Impl(ConfigProviderResolver configResolver) {\n+        this.metricsMID = new ConcurrentHashMap<MetricID, Metric>();\n+\n+        this.metadataMID = new ConcurrentHashMap<String, Metadata>();\n+\n+        this.applicationMap = new ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>>();\n+\n+        this.configResolver = configResolver;\n+    }\n+\n+    /**\n+     * Convert the metric class type into an enum\n+     * For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+     *\n+     * @param in The metric\n+     * @return the matching Enum\n+     */\n+    public static MetricType from(Metric in) {\n+        if (Gauge.class.isInstance(in))\n+            return MetricType.GAUGE;\n+        if (Counter.class.isInstance(in))\n+            return MetricType.COUNTER;\n+        if (Histogram.class.isInstance(in))\n+            return MetricType.HISTOGRAM;\n+        if (Meter.class.isInstance(in))\n+            return MetricType.METERED;\n+        if (Timer.class.isInstance(in))\n+            return MetricType.TIMER;\n+        if (SimpleTimer.class.isInstance(in))\n+            return MetricType.SIMPLE_TIMER;\n+        return MetricType.INVALID;\n+    }\n+\n+    /**\n+     * Creates a new {@link ConcurrentMap} implementation for use inside the registry. Override this\n+     * to create a {@link MetricRegistry} with space- or time-bounded metric lifecycles, for\n+     * example.\n+     *\n+     * @return a new {@link ConcurrentMap}\n+     */\n+    protected ConcurrentMap<String, Metric> buildMap() {\n+        return new ConcurrentHashMap<String, Metric>();\n+    }\n+\n+    /**\n+     * Given a {@link Metric}, registers it under the given name.\n+     *\n+     * @param name   the name of the metric\n+     * @param metric the metric\n+     * @param <T>    the type of the metric\n+     * @return {@code metric}\n+     * @throws IllegalArgumentException if the name is already registered\n+     */\n+    @Override\n+    public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException {\n+        // For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+\n+        //return register(new Metadata(name, from(metric)), metric);\n+        return register(Metadata.builder().withName(name).withType(from(metric)).build(), metric);\n+    }\n+\n+    @Override\n+    public <T extends Metric> T register(Metadata metadata, T metric) throws IllegalArgumentException {\n+        return register(metadata, metric, null);\n+    }\n+\n+    @Override\n+    @FFDCIgnore({ NoSuchElementException.class })\n+    public <T extends Metric> T register(Metadata metadata, T metric, Tag... tags) throws IllegalArgumentException {\n+\n+        /*\n+         * Checks if MetaData with the given name already exists or not.\n+         * If it does, then check if they match.\n+         * Throw an exception otherwise.\n+         * RF->f(x)\n+         */\n+        if (metadataMID.keySet().contains(metadata.getName())) {\n+            Metadata existingMetadata = metadataMID.get(metadata.getName());\n+\n+            if (!metadata.equals(existingMetadata)) {\n+                throw new IllegalArgumentException(\"Metadata does not match for existing Metadata for \" + metadata.getName());\n+            }\n+        }\n+        //Create Copy of Metadata object so it can't be changed after its registered\n+        //rf-rm\n+        MetadataBuilder metadataBuilder = Metadata.builder(metadata);\n+\n+        ArrayList<Tag> cumulativeTags = (tags == null) ? new ArrayList<Tag>() : new ArrayList<Tag>(Arrays.asList(tags));\n+\n+        //Append global tags to the metric\n+        //rf-rm\n+        Config config = configResolver.getConfig(getThreadContextClassLoader());\n+        try {\n+            String[] globaltags = config.getValue(\"MP_METRICS_TAGS\", String.class).split(\"(?<!\\\\\\\\),\");\n+            for (String tag : globaltags) {\n+                if (!(tag == null || tag.isEmpty() || !tag.contains(\"=\"))) {\n+                    String key = tag.substring(0, tag.indexOf(\"=\"));\n+                    String val = tag.substring(tag.indexOf(\"=\") + 1);\n+                    if (key.length() == 0 || val.length() == 0) {\n+                        throw new IllegalArgumentException(\"Malformed list of Global Tags. Tag names \"\n+                                                           + \"must match the following regex [a-zA-Z_][a-zA-Z0-9_]*.\"\n+                                                           + \" Global Tag values must not be empty.\"\n+                                                           + \" Global Tag values MUST escape equal signs `=` and commas `,`\"\n+                                                           + \"with a backslash `\\\\` \");\n+                    }\n+                    val = val.replace(\"\\\\,\", \",\");\n+                    val = val.replace(\"\\\\=\", \"=\");\n+                    if (!cumulativeTags.contains(key)) {\n+                        cumulativeTags.add(new Tag(key, val));\n+                    }\n+                }\n+            }\n+        } catch (NoSuchElementException e) {\n+            //Continue if there is no global tags\n+        }\n+\n+        MetricID MetricID = new MetricID(metadata.getName(), tags);\n+        Class<T> metricClass = determineMetricClass(metric);\n+\n+        //Ensure all metrics with this name are the same type\n+        validateMetricNameToSingleType(MetricID.getName(), metricClass);\n+\n+        /*\n+         * Rest of the method officialy registers the metric\n+         * Add to MetricID -> Metric Map and Name -> MetaData map\n+         */\n+\n+        final Metric existingMetric = metricsMID.putIfAbsent(MetricID, metric);\n+\n+        if (existingMetric != null) {\n+            throw new IllegalArgumentException(\"A metric named \" + MetricID.getName() + \" with tags \" + MetricID.getTagsAsString() + \" already exists\");\n+        }\n+\n+        this.metadataMID.putIfAbsent(metadata.getName(), metadataBuilder.build());\n+\n+        addNameToApplicationMap(MetricID);\n+        return metric;\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param name\n+     */\n+    protected void addNameToApplicationMap(MetricID metricID) {\n+        String appName = getApplicationName();\n+        addNameToApplicationMap(metricID, appName);\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map given the application name.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param metricID metric ID of metric that was added\n+     * @param appName  applicationName\n+     */\n+    public void addNameToApplicationMap(MetricID metricID, String appName) {\n+        // If it is a base metric, the name will be null\n+        if (appName == null)\n+            return;\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.get(appName);\n+        if (list == null) {\n+            ConcurrentLinkedQueue<MetricID> newList = new ConcurrentLinkedQueue<MetricID>();\n+            list = applicationMap.putIfAbsent(appName, newList);\n+            if (list == null)\n+                list = newList;\n+        }\n+        list.add(metricID);\n+    }\n+\n+    public void unRegisterApplicationMetrics() {\n+        unRegisterApplicationMetrics(getApplicationName());\n+    }\n+\n+    public void unRegisterApplicationMetrics(String appName) {\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.remove(appName);\n+\n+        if (list != null) {\n+            for (MetricID metricID : list) {\n+                remove(metricID);\n+            }\n+        }\n+    }\n+\n+    private String getApplicationName() {\n+        com.ibm.ws.runtime.metadata.ComponentMetaData metaData = com.ibm.ws.threadContext.ComponentMetaDataAccessorImpl.getComponentMetaDataAccessor().getComponentMetaData();\n+        if (metaData != null) {\n+            com.ibm.websphere.csi.J2EEName name = metaData.getJ2EEName();\n+            if (name != null) {\n+                return name.getApplication();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return the {@link Counter} registered under this name; or create and register\n+     * a new {@link Counter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Counter}\n+     */\n+    @Override\n+    public Counter counter(String name) {\n+        return this.counter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.COUNTER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.COUNTER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.counter(metadata, tags);\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.COUNTER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.counter(metadata, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(MetricID metricID) {\n+        return counter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.COUNTERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Histogram} registered under this name; or create and register\n+     * a new {@link Histogram} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Histogram}\n+     */\n+    @Override\n+    public Histogram histogram(String name) {\n+        return this.histogram(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.HISTOGRAM).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.HISTOGRAM)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.histogram(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(MetricID metricID) {\n+        return histogram(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.HISTOGRAM).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.histogram(metadata, null);\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.HISTOGRAMS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Meter} registered under this name; or create and register\n+     * a new {@link Meter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Meter}\n+     */\n+    @Override\n+    public Meter meter(String name) {\n+        // return this.meter(new Metadata(name, MetricType.METERED));\n+        return this.meter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.METERED).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.METERED)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.meter(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(MetricID metricID) {\n+        return meter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.METERED).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.meter(metadata, null);\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.METERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Timer} registered under this name; or create and register\n+     * a new {@link Timer} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Timer}\n+     */\n+    @Override\n+    public Timer timer(String name) {\n+        return this.timer(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.TIMER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.TIMER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.timer(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(MetricID metricID) {\n+        return timer(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.TIMER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.timer(metadata, null);\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.TIMERS, tags);\n+    }\n+\n+    /**\n+     * Removes all metrics with the given name.\n+     *\n+     * @param name the name of the metric\n+     * @return whether or not the metric was removed\n+     */\n+    @Override\n+    public boolean remove(String name) {\n+        Iterator<Entry<MetricID, Metric>> iterator = metricsMID.entrySet().iterator();\n+\n+        while (iterator.hasNext()) {\n+            Entry<MetricID, Metric> entry = iterator.next();\n+            MetricID tempMID = entry.getKey();\n+            if (tempMID.getName().equals(name)) {\n+                iterator.remove();\n+            }\n+        }\n+        metadataMID.remove(name);\n+\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean remove(MetricID metricID) {\n+        final Metric metric = metricsMID.remove(metricID);\n+        String name = metricID.getName();\n+\n+        if (metric != null) {\n+            boolean isLastOne = true;\n+\n+            for (MetricID mid : metricsMID.keySet()) {\n+                if (mid.getName().equals(name)) {\n+                    isLastOne = false;\n+                    break;\n+                }\n+            }\n+            if (isLastOne) {\n+                metadataMID.remove(name);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Removes all metrics which match the given filter.\n+     *\n+     * @param filter a filter\n+     */\n+    @Override\n+    public void removeMatching(MetricFilter filter) {\n+        for (Map.Entry<MetricID, Metric> entry : metricsMID.entrySet()) {\n+            if (filter.matches(entry.getKey(), entry.getValue())) {\n+                remove(entry.getKey());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of the names of all the metrics in the registry.\n+     *\n+     * @return the names of all the metrics\n+     */\n+    @Override\n+    public SortedSet<String> getNames() {\n+        return Collections.unmodifiableSortedSet(new TreeSet<String>(metadataMID.keySet()));\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names.\n+     *\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges() {\n+        return getGauges(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges(MetricFilter filter) {\n+        return getMetrics(Gauge.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names.\n+     *\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters() {\n+        return getCounters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters(MetricFilter filter) {\n+        return getMetrics(Counter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names.\n+     *\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms() {\n+        return getHistograms(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms(MetricFilter filter) {\n+        return getMetrics(Histogram.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names.\n+     *\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters() {\n+        return getMeters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters(MetricFilter filter) {\n+        return getMetrics(Meter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names.\n+     *\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers() {\n+        return getTimers(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers(MetricFilter filter) {\n+        return getMetrics(Timer.class, filter);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends Metric> T getOrAdd(Metadata metadata, MetricBuilder30<T> builder, Tag... tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (builder.isInstance(metric)) {\n+            return (T) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, builder.newMetric(), tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (builder.isInstance(added)) {\n+                    return (T) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Gauge<?> getOrAdd(Metadata metadata, Gauge<?> incomingMetric, Tag[] tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        //validateMetricNameToSingleType(metadata.getName(), builder);\n+        MetricType mt = from(incomingMetric);\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (incomingMetric.getClass().isInstance(metric)) {\n+            return (Gauge<?>) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, incomingMetric, tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                //validateMetricNameToSingleType(metadata.getName(), builder);\n+                for (MetricID mid : metricsMID.keySet()) {\n+                    if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+                    }\n+                }\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (incomingMetric.getClass().isInstance(added)) {\n+                    return (Gauge<?>) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name    metric name\n+     * @param builder MetricBuilder30\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, MetricBuilder30<T> builder) {\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(name) && !builder.isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name        metric name\n+     * @param metricClass Class/Type of the metric\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, Class<T> metricClass) {\n+\n+        for (Entry<MetricID, Metric> entrySet : metricsMID.entrySet()) {\n+            if (entrySet.getKey().getName().equals(name) && !metricClass.isAssignableFrom(entrySet.getValue().getClass())) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Metric> SortedMap<MetricID, T> getMetrics(Class<T> ofType, MetricFilter filter) {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyOTI3NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428429275", "bodyText": "new method.", "author": "Channyboy", "createdAt": "2020-05-21T03:46:01Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/impl/MetricRegistry30Impl.java", "diffHunk": "@@ -0,0 +1,1090 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.impl;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NoSuchElementException;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.enterprise.inject.Vetoed;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.eclipse.microprofile.metrics.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricFilter;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.metrics.impl.ConcurrentGaugeImpl;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.ExponentiallyDecayingReservoir;\n+import com.ibm.ws.microprofile.metrics.impl.HistogramImpl;\n+import com.ibm.ws.microprofile.metrics.impl.MeterImpl;\n+\n+/**\n+ * A registry of metric instances.\n+ */\n+@Vetoed\n+public class MetricRegistry30Impl implements MetricRegistry {\n+\n+    protected final ConcurrentMap<MetricID, Metric> metricsMID;\n+    protected final ConcurrentMap<String, Metadata> metadataMID;\n+    protected final ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>> applicationMap;\n+    private final ConfigProviderResolver configResolver;\n+\n+    private final static boolean usingJava2Security = System.getSecurityManager() != null;\n+\n+    /**\n+     * Creates a new {@link MetricRegistry}.\n+     *\n+     * @param configResolver\n+     */\n+    public MetricRegistry30Impl(ConfigProviderResolver configResolver) {\n+        this.metricsMID = new ConcurrentHashMap<MetricID, Metric>();\n+\n+        this.metadataMID = new ConcurrentHashMap<String, Metadata>();\n+\n+        this.applicationMap = new ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>>();\n+\n+        this.configResolver = configResolver;\n+    }\n+\n+    /**\n+     * Convert the metric class type into an enum\n+     * For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+     *\n+     * @param in The metric\n+     * @return the matching Enum\n+     */\n+    public static MetricType from(Metric in) {\n+        if (Gauge.class.isInstance(in))\n+            return MetricType.GAUGE;\n+        if (Counter.class.isInstance(in))\n+            return MetricType.COUNTER;\n+        if (Histogram.class.isInstance(in))\n+            return MetricType.HISTOGRAM;\n+        if (Meter.class.isInstance(in))\n+            return MetricType.METERED;\n+        if (Timer.class.isInstance(in))\n+            return MetricType.TIMER;\n+        if (SimpleTimer.class.isInstance(in))\n+            return MetricType.SIMPLE_TIMER;\n+        return MetricType.INVALID;\n+    }\n+\n+    /**\n+     * Creates a new {@link ConcurrentMap} implementation for use inside the registry. Override this\n+     * to create a {@link MetricRegistry} with space- or time-bounded metric lifecycles, for\n+     * example.\n+     *\n+     * @return a new {@link ConcurrentMap}\n+     */\n+    protected ConcurrentMap<String, Metric> buildMap() {\n+        return new ConcurrentHashMap<String, Metric>();\n+    }\n+\n+    /**\n+     * Given a {@link Metric}, registers it under the given name.\n+     *\n+     * @param name   the name of the metric\n+     * @param metric the metric\n+     * @param <T>    the type of the metric\n+     * @return {@code metric}\n+     * @throws IllegalArgumentException if the name is already registered\n+     */\n+    @Override\n+    public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException {\n+        // For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+\n+        //return register(new Metadata(name, from(metric)), metric);\n+        return register(Metadata.builder().withName(name).withType(from(metric)).build(), metric);\n+    }\n+\n+    @Override\n+    public <T extends Metric> T register(Metadata metadata, T metric) throws IllegalArgumentException {\n+        return register(metadata, metric, null);\n+    }\n+\n+    @Override\n+    @FFDCIgnore({ NoSuchElementException.class })\n+    public <T extends Metric> T register(Metadata metadata, T metric, Tag... tags) throws IllegalArgumentException {\n+\n+        /*\n+         * Checks if MetaData with the given name already exists or not.\n+         * If it does, then check if they match.\n+         * Throw an exception otherwise.\n+         * RF->f(x)\n+         */\n+        if (metadataMID.keySet().contains(metadata.getName())) {\n+            Metadata existingMetadata = metadataMID.get(metadata.getName());\n+\n+            if (!metadata.equals(existingMetadata)) {\n+                throw new IllegalArgumentException(\"Metadata does not match for existing Metadata for \" + metadata.getName());\n+            }\n+        }\n+        //Create Copy of Metadata object so it can't be changed after its registered\n+        //rf-rm\n+        MetadataBuilder metadataBuilder = Metadata.builder(metadata);\n+\n+        ArrayList<Tag> cumulativeTags = (tags == null) ? new ArrayList<Tag>() : new ArrayList<Tag>(Arrays.asList(tags));\n+\n+        //Append global tags to the metric\n+        //rf-rm\n+        Config config = configResolver.getConfig(getThreadContextClassLoader());\n+        try {\n+            String[] globaltags = config.getValue(\"MP_METRICS_TAGS\", String.class).split(\"(?<!\\\\\\\\),\");\n+            for (String tag : globaltags) {\n+                if (!(tag == null || tag.isEmpty() || !tag.contains(\"=\"))) {\n+                    String key = tag.substring(0, tag.indexOf(\"=\"));\n+                    String val = tag.substring(tag.indexOf(\"=\") + 1);\n+                    if (key.length() == 0 || val.length() == 0) {\n+                        throw new IllegalArgumentException(\"Malformed list of Global Tags. Tag names \"\n+                                                           + \"must match the following regex [a-zA-Z_][a-zA-Z0-9_]*.\"\n+                                                           + \" Global Tag values must not be empty.\"\n+                                                           + \" Global Tag values MUST escape equal signs `=` and commas `,`\"\n+                                                           + \"with a backslash `\\\\` \");\n+                    }\n+                    val = val.replace(\"\\\\,\", \",\");\n+                    val = val.replace(\"\\\\=\", \"=\");\n+                    if (!cumulativeTags.contains(key)) {\n+                        cumulativeTags.add(new Tag(key, val));\n+                    }\n+                }\n+            }\n+        } catch (NoSuchElementException e) {\n+            //Continue if there is no global tags\n+        }\n+\n+        MetricID MetricID = new MetricID(metadata.getName(), tags);\n+        Class<T> metricClass = determineMetricClass(metric);\n+\n+        //Ensure all metrics with this name are the same type\n+        validateMetricNameToSingleType(MetricID.getName(), metricClass);\n+\n+        /*\n+         * Rest of the method officialy registers the metric\n+         * Add to MetricID -> Metric Map and Name -> MetaData map\n+         */\n+\n+        final Metric existingMetric = metricsMID.putIfAbsent(MetricID, metric);\n+\n+        if (existingMetric != null) {\n+            throw new IllegalArgumentException(\"A metric named \" + MetricID.getName() + \" with tags \" + MetricID.getTagsAsString() + \" already exists\");\n+        }\n+\n+        this.metadataMID.putIfAbsent(metadata.getName(), metadataBuilder.build());\n+\n+        addNameToApplicationMap(MetricID);\n+        return metric;\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param name\n+     */\n+    protected void addNameToApplicationMap(MetricID metricID) {\n+        String appName = getApplicationName();\n+        addNameToApplicationMap(metricID, appName);\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map given the application name.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param metricID metric ID of metric that was added\n+     * @param appName  applicationName\n+     */\n+    public void addNameToApplicationMap(MetricID metricID, String appName) {\n+        // If it is a base metric, the name will be null\n+        if (appName == null)\n+            return;\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.get(appName);\n+        if (list == null) {\n+            ConcurrentLinkedQueue<MetricID> newList = new ConcurrentLinkedQueue<MetricID>();\n+            list = applicationMap.putIfAbsent(appName, newList);\n+            if (list == null)\n+                list = newList;\n+        }\n+        list.add(metricID);\n+    }\n+\n+    public void unRegisterApplicationMetrics() {\n+        unRegisterApplicationMetrics(getApplicationName());\n+    }\n+\n+    public void unRegisterApplicationMetrics(String appName) {\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.remove(appName);\n+\n+        if (list != null) {\n+            for (MetricID metricID : list) {\n+                remove(metricID);\n+            }\n+        }\n+    }\n+\n+    private String getApplicationName() {\n+        com.ibm.ws.runtime.metadata.ComponentMetaData metaData = com.ibm.ws.threadContext.ComponentMetaDataAccessorImpl.getComponentMetaDataAccessor().getComponentMetaData();\n+        if (metaData != null) {\n+            com.ibm.websphere.csi.J2EEName name = metaData.getJ2EEName();\n+            if (name != null) {\n+                return name.getApplication();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return the {@link Counter} registered under this name; or create and register\n+     * a new {@link Counter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Counter}\n+     */\n+    @Override\n+    public Counter counter(String name) {\n+        return this.counter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.COUNTER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.COUNTER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.counter(metadata, tags);\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.COUNTER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.counter(metadata, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(MetricID metricID) {\n+        return counter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.COUNTERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Histogram} registered under this name; or create and register\n+     * a new {@link Histogram} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Histogram}\n+     */\n+    @Override\n+    public Histogram histogram(String name) {\n+        return this.histogram(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.HISTOGRAM).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.HISTOGRAM)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.histogram(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(MetricID metricID) {\n+        return histogram(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.HISTOGRAM).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.histogram(metadata, null);\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.HISTOGRAMS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Meter} registered under this name; or create and register\n+     * a new {@link Meter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Meter}\n+     */\n+    @Override\n+    public Meter meter(String name) {\n+        // return this.meter(new Metadata(name, MetricType.METERED));\n+        return this.meter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.METERED).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.METERED)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.meter(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(MetricID metricID) {\n+        return meter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.METERED).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.meter(metadata, null);\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.METERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Timer} registered under this name; or create and register\n+     * a new {@link Timer} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Timer}\n+     */\n+    @Override\n+    public Timer timer(String name) {\n+        return this.timer(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.TIMER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.TIMER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.timer(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(MetricID metricID) {\n+        return timer(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.TIMER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.timer(metadata, null);\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.TIMERS, tags);\n+    }\n+\n+    /**\n+     * Removes all metrics with the given name.\n+     *\n+     * @param name the name of the metric\n+     * @return whether or not the metric was removed\n+     */\n+    @Override\n+    public boolean remove(String name) {\n+        Iterator<Entry<MetricID, Metric>> iterator = metricsMID.entrySet().iterator();\n+\n+        while (iterator.hasNext()) {\n+            Entry<MetricID, Metric> entry = iterator.next();\n+            MetricID tempMID = entry.getKey();\n+            if (tempMID.getName().equals(name)) {\n+                iterator.remove();\n+            }\n+        }\n+        metadataMID.remove(name);\n+\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean remove(MetricID metricID) {\n+        final Metric metric = metricsMID.remove(metricID);\n+        String name = metricID.getName();\n+\n+        if (metric != null) {\n+            boolean isLastOne = true;\n+\n+            for (MetricID mid : metricsMID.keySet()) {\n+                if (mid.getName().equals(name)) {\n+                    isLastOne = false;\n+                    break;\n+                }\n+            }\n+            if (isLastOne) {\n+                metadataMID.remove(name);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Removes all metrics which match the given filter.\n+     *\n+     * @param filter a filter\n+     */\n+    @Override\n+    public void removeMatching(MetricFilter filter) {\n+        for (Map.Entry<MetricID, Metric> entry : metricsMID.entrySet()) {\n+            if (filter.matches(entry.getKey(), entry.getValue())) {\n+                remove(entry.getKey());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of the names of all the metrics in the registry.\n+     *\n+     * @return the names of all the metrics\n+     */\n+    @Override\n+    public SortedSet<String> getNames() {\n+        return Collections.unmodifiableSortedSet(new TreeSet<String>(metadataMID.keySet()));\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names.\n+     *\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges() {\n+        return getGauges(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges(MetricFilter filter) {\n+        return getMetrics(Gauge.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names.\n+     *\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters() {\n+        return getCounters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters(MetricFilter filter) {\n+        return getMetrics(Counter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names.\n+     *\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms() {\n+        return getHistograms(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms(MetricFilter filter) {\n+        return getMetrics(Histogram.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names.\n+     *\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters() {\n+        return getMeters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters(MetricFilter filter) {\n+        return getMetrics(Meter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names.\n+     *\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers() {\n+        return getTimers(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers(MetricFilter filter) {\n+        return getMetrics(Timer.class, filter);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends Metric> T getOrAdd(Metadata metadata, MetricBuilder30<T> builder, Tag... tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (builder.isInstance(metric)) {\n+            return (T) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, builder.newMetric(), tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (builder.isInstance(added)) {\n+                    return (T) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Gauge<?> getOrAdd(Metadata metadata, Gauge<?> incomingMetric, Tag[] tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        //validateMetricNameToSingleType(metadata.getName(), builder);\n+        MetricType mt = from(incomingMetric);\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (incomingMetric.getClass().isInstance(metric)) {\n+            return (Gauge<?>) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, incomingMetric, tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                //validateMetricNameToSingleType(metadata.getName(), builder);\n+                for (MetricID mid : metricsMID.keySet()) {\n+                    if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+                    }\n+                }\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (incomingMetric.getClass().isInstance(added)) {\n+                    return (Gauge<?>) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name    metric name\n+     * @param builder MetricBuilder30\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, MetricBuilder30<T> builder) {\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(name) && !builder.isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name        metric name\n+     * @param metricClass Class/Type of the metric\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, Class<T> metricClass) {\n+\n+        for (Entry<MetricID, Metric> entrySet : metricsMID.entrySet()) {\n+            if (entrySet.getKey().getName().equals(name) && !metricClass.isAssignableFrom(entrySet.getValue().getClass())) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Metric> SortedMap<MetricID, T> getMetrics(Class<T> ofType, MetricFilter filter) {\n+        return (SortedMap<MetricID, T>) getMetrics(\n+                                                   (metricID, metric) -> filter.matches(metricID, metric)\n+                                                                         && ofType.isAssignableFrom(metric.getClass()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public SortedMap<MetricID, Metric> getMetrics(MetricFilter filter) {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyOTQzMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428429430", "bodyText": "new method.", "author": "Channyboy", "createdAt": "2020-05-21T03:46:48Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/impl/MetricRegistry30Impl.java", "diffHunk": "@@ -0,0 +1,1090 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.impl;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NoSuchElementException;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.enterprise.inject.Vetoed;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.eclipse.microprofile.metrics.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricFilter;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.metrics.impl.ConcurrentGaugeImpl;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.ExponentiallyDecayingReservoir;\n+import com.ibm.ws.microprofile.metrics.impl.HistogramImpl;\n+import com.ibm.ws.microprofile.metrics.impl.MeterImpl;\n+\n+/**\n+ * A registry of metric instances.\n+ */\n+@Vetoed\n+public class MetricRegistry30Impl implements MetricRegistry {\n+\n+    protected final ConcurrentMap<MetricID, Metric> metricsMID;\n+    protected final ConcurrentMap<String, Metadata> metadataMID;\n+    protected final ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>> applicationMap;\n+    private final ConfigProviderResolver configResolver;\n+\n+    private final static boolean usingJava2Security = System.getSecurityManager() != null;\n+\n+    /**\n+     * Creates a new {@link MetricRegistry}.\n+     *\n+     * @param configResolver\n+     */\n+    public MetricRegistry30Impl(ConfigProviderResolver configResolver) {\n+        this.metricsMID = new ConcurrentHashMap<MetricID, Metric>();\n+\n+        this.metadataMID = new ConcurrentHashMap<String, Metadata>();\n+\n+        this.applicationMap = new ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>>();\n+\n+        this.configResolver = configResolver;\n+    }\n+\n+    /**\n+     * Convert the metric class type into an enum\n+     * For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+     *\n+     * @param in The metric\n+     * @return the matching Enum\n+     */\n+    public static MetricType from(Metric in) {\n+        if (Gauge.class.isInstance(in))\n+            return MetricType.GAUGE;\n+        if (Counter.class.isInstance(in))\n+            return MetricType.COUNTER;\n+        if (Histogram.class.isInstance(in))\n+            return MetricType.HISTOGRAM;\n+        if (Meter.class.isInstance(in))\n+            return MetricType.METERED;\n+        if (Timer.class.isInstance(in))\n+            return MetricType.TIMER;\n+        if (SimpleTimer.class.isInstance(in))\n+            return MetricType.SIMPLE_TIMER;\n+        return MetricType.INVALID;\n+    }\n+\n+    /**\n+     * Creates a new {@link ConcurrentMap} implementation for use inside the registry. Override this\n+     * to create a {@link MetricRegistry} with space- or time-bounded metric lifecycles, for\n+     * example.\n+     *\n+     * @return a new {@link ConcurrentMap}\n+     */\n+    protected ConcurrentMap<String, Metric> buildMap() {\n+        return new ConcurrentHashMap<String, Metric>();\n+    }\n+\n+    /**\n+     * Given a {@link Metric}, registers it under the given name.\n+     *\n+     * @param name   the name of the metric\n+     * @param metric the metric\n+     * @param <T>    the type of the metric\n+     * @return {@code metric}\n+     * @throws IllegalArgumentException if the name is already registered\n+     */\n+    @Override\n+    public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException {\n+        // For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+\n+        //return register(new Metadata(name, from(metric)), metric);\n+        return register(Metadata.builder().withName(name).withType(from(metric)).build(), metric);\n+    }\n+\n+    @Override\n+    public <T extends Metric> T register(Metadata metadata, T metric) throws IllegalArgumentException {\n+        return register(metadata, metric, null);\n+    }\n+\n+    @Override\n+    @FFDCIgnore({ NoSuchElementException.class })\n+    public <T extends Metric> T register(Metadata metadata, T metric, Tag... tags) throws IllegalArgumentException {\n+\n+        /*\n+         * Checks if MetaData with the given name already exists or not.\n+         * If it does, then check if they match.\n+         * Throw an exception otherwise.\n+         * RF->f(x)\n+         */\n+        if (metadataMID.keySet().contains(metadata.getName())) {\n+            Metadata existingMetadata = metadataMID.get(metadata.getName());\n+\n+            if (!metadata.equals(existingMetadata)) {\n+                throw new IllegalArgumentException(\"Metadata does not match for existing Metadata for \" + metadata.getName());\n+            }\n+        }\n+        //Create Copy of Metadata object so it can't be changed after its registered\n+        //rf-rm\n+        MetadataBuilder metadataBuilder = Metadata.builder(metadata);\n+\n+        ArrayList<Tag> cumulativeTags = (tags == null) ? new ArrayList<Tag>() : new ArrayList<Tag>(Arrays.asList(tags));\n+\n+        //Append global tags to the metric\n+        //rf-rm\n+        Config config = configResolver.getConfig(getThreadContextClassLoader());\n+        try {\n+            String[] globaltags = config.getValue(\"MP_METRICS_TAGS\", String.class).split(\"(?<!\\\\\\\\),\");\n+            for (String tag : globaltags) {\n+                if (!(tag == null || tag.isEmpty() || !tag.contains(\"=\"))) {\n+                    String key = tag.substring(0, tag.indexOf(\"=\"));\n+                    String val = tag.substring(tag.indexOf(\"=\") + 1);\n+                    if (key.length() == 0 || val.length() == 0) {\n+                        throw new IllegalArgumentException(\"Malformed list of Global Tags. Tag names \"\n+                                                           + \"must match the following regex [a-zA-Z_][a-zA-Z0-9_]*.\"\n+                                                           + \" Global Tag values must not be empty.\"\n+                                                           + \" Global Tag values MUST escape equal signs `=` and commas `,`\"\n+                                                           + \"with a backslash `\\\\` \");\n+                    }\n+                    val = val.replace(\"\\\\,\", \",\");\n+                    val = val.replace(\"\\\\=\", \"=\");\n+                    if (!cumulativeTags.contains(key)) {\n+                        cumulativeTags.add(new Tag(key, val));\n+                    }\n+                }\n+            }\n+        } catch (NoSuchElementException e) {\n+            //Continue if there is no global tags\n+        }\n+\n+        MetricID MetricID = new MetricID(metadata.getName(), tags);\n+        Class<T> metricClass = determineMetricClass(metric);\n+\n+        //Ensure all metrics with this name are the same type\n+        validateMetricNameToSingleType(MetricID.getName(), metricClass);\n+\n+        /*\n+         * Rest of the method officialy registers the metric\n+         * Add to MetricID -> Metric Map and Name -> MetaData map\n+         */\n+\n+        final Metric existingMetric = metricsMID.putIfAbsent(MetricID, metric);\n+\n+        if (existingMetric != null) {\n+            throw new IllegalArgumentException(\"A metric named \" + MetricID.getName() + \" with tags \" + MetricID.getTagsAsString() + \" already exists\");\n+        }\n+\n+        this.metadataMID.putIfAbsent(metadata.getName(), metadataBuilder.build());\n+\n+        addNameToApplicationMap(MetricID);\n+        return metric;\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param name\n+     */\n+    protected void addNameToApplicationMap(MetricID metricID) {\n+        String appName = getApplicationName();\n+        addNameToApplicationMap(metricID, appName);\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map given the application name.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param metricID metric ID of metric that was added\n+     * @param appName  applicationName\n+     */\n+    public void addNameToApplicationMap(MetricID metricID, String appName) {\n+        // If it is a base metric, the name will be null\n+        if (appName == null)\n+            return;\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.get(appName);\n+        if (list == null) {\n+            ConcurrentLinkedQueue<MetricID> newList = new ConcurrentLinkedQueue<MetricID>();\n+            list = applicationMap.putIfAbsent(appName, newList);\n+            if (list == null)\n+                list = newList;\n+        }\n+        list.add(metricID);\n+    }\n+\n+    public void unRegisterApplicationMetrics() {\n+        unRegisterApplicationMetrics(getApplicationName());\n+    }\n+\n+    public void unRegisterApplicationMetrics(String appName) {\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.remove(appName);\n+\n+        if (list != null) {\n+            for (MetricID metricID : list) {\n+                remove(metricID);\n+            }\n+        }\n+    }\n+\n+    private String getApplicationName() {\n+        com.ibm.ws.runtime.metadata.ComponentMetaData metaData = com.ibm.ws.threadContext.ComponentMetaDataAccessorImpl.getComponentMetaDataAccessor().getComponentMetaData();\n+        if (metaData != null) {\n+            com.ibm.websphere.csi.J2EEName name = metaData.getJ2EEName();\n+            if (name != null) {\n+                return name.getApplication();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return the {@link Counter} registered under this name; or create and register\n+     * a new {@link Counter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Counter}\n+     */\n+    @Override\n+    public Counter counter(String name) {\n+        return this.counter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.COUNTER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.COUNTER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.counter(metadata, tags);\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.COUNTER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.counter(metadata, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(MetricID metricID) {\n+        return counter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.COUNTERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Histogram} registered under this name; or create and register\n+     * a new {@link Histogram} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Histogram}\n+     */\n+    @Override\n+    public Histogram histogram(String name) {\n+        return this.histogram(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.HISTOGRAM).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.HISTOGRAM)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.histogram(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(MetricID metricID) {\n+        return histogram(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.HISTOGRAM).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.histogram(metadata, null);\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.HISTOGRAMS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Meter} registered under this name; or create and register\n+     * a new {@link Meter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Meter}\n+     */\n+    @Override\n+    public Meter meter(String name) {\n+        // return this.meter(new Metadata(name, MetricType.METERED));\n+        return this.meter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.METERED).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.METERED)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.meter(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(MetricID metricID) {\n+        return meter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.METERED).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.meter(metadata, null);\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.METERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Timer} registered under this name; or create and register\n+     * a new {@link Timer} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Timer}\n+     */\n+    @Override\n+    public Timer timer(String name) {\n+        return this.timer(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.TIMER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.TIMER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.timer(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(MetricID metricID) {\n+        return timer(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.TIMER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.timer(metadata, null);\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.TIMERS, tags);\n+    }\n+\n+    /**\n+     * Removes all metrics with the given name.\n+     *\n+     * @param name the name of the metric\n+     * @return whether or not the metric was removed\n+     */\n+    @Override\n+    public boolean remove(String name) {\n+        Iterator<Entry<MetricID, Metric>> iterator = metricsMID.entrySet().iterator();\n+\n+        while (iterator.hasNext()) {\n+            Entry<MetricID, Metric> entry = iterator.next();\n+            MetricID tempMID = entry.getKey();\n+            if (tempMID.getName().equals(name)) {\n+                iterator.remove();\n+            }\n+        }\n+        metadataMID.remove(name);\n+\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean remove(MetricID metricID) {\n+        final Metric metric = metricsMID.remove(metricID);\n+        String name = metricID.getName();\n+\n+        if (metric != null) {\n+            boolean isLastOne = true;\n+\n+            for (MetricID mid : metricsMID.keySet()) {\n+                if (mid.getName().equals(name)) {\n+                    isLastOne = false;\n+                    break;\n+                }\n+            }\n+            if (isLastOne) {\n+                metadataMID.remove(name);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Removes all metrics which match the given filter.\n+     *\n+     * @param filter a filter\n+     */\n+    @Override\n+    public void removeMatching(MetricFilter filter) {\n+        for (Map.Entry<MetricID, Metric> entry : metricsMID.entrySet()) {\n+            if (filter.matches(entry.getKey(), entry.getValue())) {\n+                remove(entry.getKey());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of the names of all the metrics in the registry.\n+     *\n+     * @return the names of all the metrics\n+     */\n+    @Override\n+    public SortedSet<String> getNames() {\n+        return Collections.unmodifiableSortedSet(new TreeSet<String>(metadataMID.keySet()));\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names.\n+     *\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges() {\n+        return getGauges(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges(MetricFilter filter) {\n+        return getMetrics(Gauge.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names.\n+     *\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters() {\n+        return getCounters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters(MetricFilter filter) {\n+        return getMetrics(Counter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names.\n+     *\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms() {\n+        return getHistograms(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms(MetricFilter filter) {\n+        return getMetrics(Histogram.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names.\n+     *\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters() {\n+        return getMeters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters(MetricFilter filter) {\n+        return getMetrics(Meter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names.\n+     *\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers() {\n+        return getTimers(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers(MetricFilter filter) {\n+        return getMetrics(Timer.class, filter);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends Metric> T getOrAdd(Metadata metadata, MetricBuilder30<T> builder, Tag... tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (builder.isInstance(metric)) {\n+            return (T) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, builder.newMetric(), tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (builder.isInstance(added)) {\n+                    return (T) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Gauge<?> getOrAdd(Metadata metadata, Gauge<?> incomingMetric, Tag[] tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        //validateMetricNameToSingleType(metadata.getName(), builder);\n+        MetricType mt = from(incomingMetric);\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (incomingMetric.getClass().isInstance(metric)) {\n+            return (Gauge<?>) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, incomingMetric, tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                //validateMetricNameToSingleType(metadata.getName(), builder);\n+                for (MetricID mid : metricsMID.keySet()) {\n+                    if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+                    }\n+                }\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (incomingMetric.getClass().isInstance(added)) {\n+                    return (Gauge<?>) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name    metric name\n+     * @param builder MetricBuilder30\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, MetricBuilder30<T> builder) {\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(name) && !builder.isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name        metric name\n+     * @param metricClass Class/Type of the metric\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, Class<T> metricClass) {\n+\n+        for (Entry<MetricID, Metric> entrySet : metricsMID.entrySet()) {\n+            if (entrySet.getKey().getName().equals(name) && !metricClass.isAssignableFrom(entrySet.getValue().getClass())) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Metric> SortedMap<MetricID, T> getMetrics(Class<T> ofType, MetricFilter filter) {\n+        return (SortedMap<MetricID, T>) getMetrics(\n+                                                   (metricID, metric) -> filter.matches(metricID, metric)\n+                                                                         && ofType.isAssignableFrom(metric.getClass()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public SortedMap<MetricID, Metric> getMetrics(MetricFilter filter) {\n+        final TreeMap<MetricID, Metric> sortedMetricsMap = new TreeMap<MetricID, Metric>();\n+        for (Map.Entry<MetricID, Metric> entry : metricsMID.entrySet()) {\n+            if (filter.matches(entry.getKey(), entry.getValue())) {\n+                sortedMetricsMap.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+\n+        return Collections.unmodifiableSortedMap(sortedMetricsMap);\n+    }\n+\n+    @Override\n+    public Map<MetricID, Metric> getMetrics() {\n+        return Collections.unmodifiableMap(metricsMID);\n+    }\n+\n+    @Override\n+    public Map<String, Metadata> getMetadata() {\n+        return Collections.unmodifiableMap(metadataMID);\n+    }\n+\n+    @Override\n+    public Metadata getMetadata(String name) {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyOTg1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428429850", "bodyText": "All new methods below. More overloaded methods to register/retreive metrics. They end up calling the other existing overloaded methods.", "author": "Channyboy", "createdAt": "2020-05-21T03:48:39Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/impl/MetricRegistry30Impl.java", "diffHunk": "@@ -0,0 +1,1090 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.impl;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NoSuchElementException;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.enterprise.inject.Vetoed;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.eclipse.microprofile.metrics.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricFilter;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.metrics.impl.ConcurrentGaugeImpl;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.ExponentiallyDecayingReservoir;\n+import com.ibm.ws.microprofile.metrics.impl.HistogramImpl;\n+import com.ibm.ws.microprofile.metrics.impl.MeterImpl;\n+\n+/**\n+ * A registry of metric instances.\n+ */\n+@Vetoed\n+public class MetricRegistry30Impl implements MetricRegistry {\n+\n+    protected final ConcurrentMap<MetricID, Metric> metricsMID;\n+    protected final ConcurrentMap<String, Metadata> metadataMID;\n+    protected final ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>> applicationMap;\n+    private final ConfigProviderResolver configResolver;\n+\n+    private final static boolean usingJava2Security = System.getSecurityManager() != null;\n+\n+    /**\n+     * Creates a new {@link MetricRegistry}.\n+     *\n+     * @param configResolver\n+     */\n+    public MetricRegistry30Impl(ConfigProviderResolver configResolver) {\n+        this.metricsMID = new ConcurrentHashMap<MetricID, Metric>();\n+\n+        this.metadataMID = new ConcurrentHashMap<String, Metadata>();\n+\n+        this.applicationMap = new ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>>();\n+\n+        this.configResolver = configResolver;\n+    }\n+\n+    /**\n+     * Convert the metric class type into an enum\n+     * For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+     *\n+     * @param in The metric\n+     * @return the matching Enum\n+     */\n+    public static MetricType from(Metric in) {\n+        if (Gauge.class.isInstance(in))\n+            return MetricType.GAUGE;\n+        if (Counter.class.isInstance(in))\n+            return MetricType.COUNTER;\n+        if (Histogram.class.isInstance(in))\n+            return MetricType.HISTOGRAM;\n+        if (Meter.class.isInstance(in))\n+            return MetricType.METERED;\n+        if (Timer.class.isInstance(in))\n+            return MetricType.TIMER;\n+        if (SimpleTimer.class.isInstance(in))\n+            return MetricType.SIMPLE_TIMER;\n+        return MetricType.INVALID;\n+    }\n+\n+    /**\n+     * Creates a new {@link ConcurrentMap} implementation for use inside the registry. Override this\n+     * to create a {@link MetricRegistry} with space- or time-bounded metric lifecycles, for\n+     * example.\n+     *\n+     * @return a new {@link ConcurrentMap}\n+     */\n+    protected ConcurrentMap<String, Metric> buildMap() {\n+        return new ConcurrentHashMap<String, Metric>();\n+    }\n+\n+    /**\n+     * Given a {@link Metric}, registers it under the given name.\n+     *\n+     * @param name   the name of the metric\n+     * @param metric the metric\n+     * @param <T>    the type of the metric\n+     * @return {@code metric}\n+     * @throws IllegalArgumentException if the name is already registered\n+     */\n+    @Override\n+    public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException {\n+        // For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+\n+        //return register(new Metadata(name, from(metric)), metric);\n+        return register(Metadata.builder().withName(name).withType(from(metric)).build(), metric);\n+    }\n+\n+    @Override\n+    public <T extends Metric> T register(Metadata metadata, T metric) throws IllegalArgumentException {\n+        return register(metadata, metric, null);\n+    }\n+\n+    @Override\n+    @FFDCIgnore({ NoSuchElementException.class })\n+    public <T extends Metric> T register(Metadata metadata, T metric, Tag... tags) throws IllegalArgumentException {\n+\n+        /*\n+         * Checks if MetaData with the given name already exists or not.\n+         * If it does, then check if they match.\n+         * Throw an exception otherwise.\n+         * RF->f(x)\n+         */\n+        if (metadataMID.keySet().contains(metadata.getName())) {\n+            Metadata existingMetadata = metadataMID.get(metadata.getName());\n+\n+            if (!metadata.equals(existingMetadata)) {\n+                throw new IllegalArgumentException(\"Metadata does not match for existing Metadata for \" + metadata.getName());\n+            }\n+        }\n+        //Create Copy of Metadata object so it can't be changed after its registered\n+        //rf-rm\n+        MetadataBuilder metadataBuilder = Metadata.builder(metadata);\n+\n+        ArrayList<Tag> cumulativeTags = (tags == null) ? new ArrayList<Tag>() : new ArrayList<Tag>(Arrays.asList(tags));\n+\n+        //Append global tags to the metric\n+        //rf-rm\n+        Config config = configResolver.getConfig(getThreadContextClassLoader());\n+        try {\n+            String[] globaltags = config.getValue(\"MP_METRICS_TAGS\", String.class).split(\"(?<!\\\\\\\\),\");\n+            for (String tag : globaltags) {\n+                if (!(tag == null || tag.isEmpty() || !tag.contains(\"=\"))) {\n+                    String key = tag.substring(0, tag.indexOf(\"=\"));\n+                    String val = tag.substring(tag.indexOf(\"=\") + 1);\n+                    if (key.length() == 0 || val.length() == 0) {\n+                        throw new IllegalArgumentException(\"Malformed list of Global Tags. Tag names \"\n+                                                           + \"must match the following regex [a-zA-Z_][a-zA-Z0-9_]*.\"\n+                                                           + \" Global Tag values must not be empty.\"\n+                                                           + \" Global Tag values MUST escape equal signs `=` and commas `,`\"\n+                                                           + \"with a backslash `\\\\` \");\n+                    }\n+                    val = val.replace(\"\\\\,\", \",\");\n+                    val = val.replace(\"\\\\=\", \"=\");\n+                    if (!cumulativeTags.contains(key)) {\n+                        cumulativeTags.add(new Tag(key, val));\n+                    }\n+                }\n+            }\n+        } catch (NoSuchElementException e) {\n+            //Continue if there is no global tags\n+        }\n+\n+        MetricID MetricID = new MetricID(metadata.getName(), tags);\n+        Class<T> metricClass = determineMetricClass(metric);\n+\n+        //Ensure all metrics with this name are the same type\n+        validateMetricNameToSingleType(MetricID.getName(), metricClass);\n+\n+        /*\n+         * Rest of the method officialy registers the metric\n+         * Add to MetricID -> Metric Map and Name -> MetaData map\n+         */\n+\n+        final Metric existingMetric = metricsMID.putIfAbsent(MetricID, metric);\n+\n+        if (existingMetric != null) {\n+            throw new IllegalArgumentException(\"A metric named \" + MetricID.getName() + \" with tags \" + MetricID.getTagsAsString() + \" already exists\");\n+        }\n+\n+        this.metadataMID.putIfAbsent(metadata.getName(), metadataBuilder.build());\n+\n+        addNameToApplicationMap(MetricID);\n+        return metric;\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param name\n+     */\n+    protected void addNameToApplicationMap(MetricID metricID) {\n+        String appName = getApplicationName();\n+        addNameToApplicationMap(metricID, appName);\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map given the application name.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param metricID metric ID of metric that was added\n+     * @param appName  applicationName\n+     */\n+    public void addNameToApplicationMap(MetricID metricID, String appName) {\n+        // If it is a base metric, the name will be null\n+        if (appName == null)\n+            return;\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.get(appName);\n+        if (list == null) {\n+            ConcurrentLinkedQueue<MetricID> newList = new ConcurrentLinkedQueue<MetricID>();\n+            list = applicationMap.putIfAbsent(appName, newList);\n+            if (list == null)\n+                list = newList;\n+        }\n+        list.add(metricID);\n+    }\n+\n+    public void unRegisterApplicationMetrics() {\n+        unRegisterApplicationMetrics(getApplicationName());\n+    }\n+\n+    public void unRegisterApplicationMetrics(String appName) {\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.remove(appName);\n+\n+        if (list != null) {\n+            for (MetricID metricID : list) {\n+                remove(metricID);\n+            }\n+        }\n+    }\n+\n+    private String getApplicationName() {\n+        com.ibm.ws.runtime.metadata.ComponentMetaData metaData = com.ibm.ws.threadContext.ComponentMetaDataAccessorImpl.getComponentMetaDataAccessor().getComponentMetaData();\n+        if (metaData != null) {\n+            com.ibm.websphere.csi.J2EEName name = metaData.getJ2EEName();\n+            if (name != null) {\n+                return name.getApplication();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return the {@link Counter} registered under this name; or create and register\n+     * a new {@link Counter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Counter}\n+     */\n+    @Override\n+    public Counter counter(String name) {\n+        return this.counter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.COUNTER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.COUNTER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.counter(metadata, tags);\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.COUNTER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.counter(metadata, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Counter counter(MetricID metricID) {\n+        return counter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Counter counter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.COUNTERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Histogram} registered under this name; or create and register\n+     * a new {@link Histogram} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Histogram}\n+     */\n+    @Override\n+    public Histogram histogram(String name) {\n+        return this.histogram(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.HISTOGRAM).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.HISTOGRAM)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.histogram(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Histogram histogram(MetricID metricID) {\n+        return histogram(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.HISTOGRAM).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.histogram(metadata, null);\n+    }\n+\n+    @Override\n+    public Histogram histogram(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.HISTOGRAMS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Meter} registered under this name; or create and register\n+     * a new {@link Meter} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Meter}\n+     */\n+    @Override\n+    public Meter meter(String name) {\n+        // return this.meter(new Metadata(name, MetricType.METERED));\n+        return this.meter(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.METERED).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.METERED)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.meter(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Meter meter(MetricID metricID) {\n+        return meter(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.METERED).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.meter(metadata, null);\n+    }\n+\n+    @Override\n+    public Meter meter(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.METERS, tags);\n+    }\n+\n+    /**\n+     * Return the {@link Timer} registered under this name; or create and register\n+     * a new {@link Timer} if none is registered.\n+     *\n+     * @param name the name of the metric\n+     * @return a new or pre-existing {@link Timer}\n+     */\n+    @Override\n+    public Timer timer(String name) {\n+        return this.timer(name, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.TIMER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.TIMER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.timer(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public Timer timer(MetricID metricID) {\n+        return timer(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.TIMER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.timer(metadata, null);\n+    }\n+\n+    @Override\n+    public Timer timer(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.TIMERS, tags);\n+    }\n+\n+    /**\n+     * Removes all metrics with the given name.\n+     *\n+     * @param name the name of the metric\n+     * @return whether or not the metric was removed\n+     */\n+    @Override\n+    public boolean remove(String name) {\n+        Iterator<Entry<MetricID, Metric>> iterator = metricsMID.entrySet().iterator();\n+\n+        while (iterator.hasNext()) {\n+            Entry<MetricID, Metric> entry = iterator.next();\n+            MetricID tempMID = entry.getKey();\n+            if (tempMID.getName().equals(name)) {\n+                iterator.remove();\n+            }\n+        }\n+        metadataMID.remove(name);\n+\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean remove(MetricID metricID) {\n+        final Metric metric = metricsMID.remove(metricID);\n+        String name = metricID.getName();\n+\n+        if (metric != null) {\n+            boolean isLastOne = true;\n+\n+            for (MetricID mid : metricsMID.keySet()) {\n+                if (mid.getName().equals(name)) {\n+                    isLastOne = false;\n+                    break;\n+                }\n+            }\n+            if (isLastOne) {\n+                metadataMID.remove(name);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Removes all metrics which match the given filter.\n+     *\n+     * @param filter a filter\n+     */\n+    @Override\n+    public void removeMatching(MetricFilter filter) {\n+        for (Map.Entry<MetricID, Metric> entry : metricsMID.entrySet()) {\n+            if (filter.matches(entry.getKey(), entry.getValue())) {\n+                remove(entry.getKey());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of the names of all the metrics in the registry.\n+     *\n+     * @return the names of all the metrics\n+     */\n+    @Override\n+    public SortedSet<String> getNames() {\n+        return Collections.unmodifiableSortedSet(new TreeSet<String>(metadataMID.keySet()));\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names.\n+     *\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges() {\n+        return getGauges(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the gauges in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the gauges in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Gauge> getGauges(MetricFilter filter) {\n+        return getMetrics(Gauge.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names.\n+     *\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters() {\n+        return getCounters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the counters in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the counters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Counter> getCounters(MetricFilter filter) {\n+        return getMetrics(Counter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names.\n+     *\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms() {\n+        return getHistograms(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the histograms in the registry and their names which match the given\n+     * filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the histograms in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Histogram> getHistograms(MetricFilter filter) {\n+        return getMetrics(Histogram.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names.\n+     *\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters() {\n+        return getMeters(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the meters in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the meters in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Meter> getMeters(MetricFilter filter) {\n+        return getMetrics(Meter.class, filter);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names.\n+     *\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers() {\n+        return getTimers(MetricFilter.ALL);\n+    }\n+\n+    /**\n+     * Returns a map of all the timers in the registry and their names which match the given filter.\n+     *\n+     * @param filter the metric filter to match\n+     * @return all the timers in the registry\n+     */\n+    @Override\n+    public SortedMap<MetricID, Timer> getTimers(MetricFilter filter) {\n+        return getMetrics(Timer.class, filter);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends Metric> T getOrAdd(Metadata metadata, MetricBuilder30<T> builder, Tag... tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (builder.isInstance(metric)) {\n+            return (T) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, builder.newMetric(), tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                validateMetricNameToSingleType(metadata.getName(), builder);\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (builder.isInstance(added)) {\n+                    return (T) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Gauge<?> getOrAdd(Metadata metadata, Gauge<?> incomingMetric, Tag[] tags) {\n+        /*\n+         * Check if metric with this name already exists or not.\n+         * If it does exist, checks if is of the same metric type.\n+         * Will throw an exception otherwise\n+         */\n+        //validateMetricNameToSingleType(metadata.getName(), builder);\n+        MetricType mt = from(incomingMetric);\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+            }\n+        }\n+\n+        MetricID metricID = new MetricID(metadata.getName(), tags);\n+        final Metric metric = metricsMID.get(metricID);\n+\n+        //Found an existing metric with matching MetricID\n+        if (incomingMetric.getClass().isInstance(metric)) {\n+            return (Gauge<?>) metric;\n+        } else if (metric == null) { //otherwise register this new metric..\n+            try {\n+                return register(metadata, incomingMetric, tags);\n+            } catch (IllegalArgumentException e) {\n+\n+                //rf-rm\n+                //validateMetricNameToSingleType(metadata.getName(), builder);\n+                for (MetricID mid : metricsMID.keySet()) {\n+                    if (mid.getName().equals(metadata.getName()) && !incomingMetric.getClass().isInstance(metricsMID.get(mid))) {\n+                        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+                    }\n+                }\n+\n+                final Metric added = metricsMID.get(metricID);\n+                if (incomingMetric.getClass().isInstance(added)) {\n+                    return (Gauge<?>) added;\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(metadata.getName() + \" is already used for a different type of metric\");\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name    metric name\n+     * @param builder MetricBuilder30\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, MetricBuilder30<T> builder) {\n+        for (MetricID mid : metricsMID.keySet()) {\n+            if (mid.getName().equals(name) && !builder.isInstance(metricsMID.get(mid))) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Identify if there exists an existing metric with the same metricName, but of different type and throw an exception if so\n+     *\n+     * @param name        metric name\n+     * @param metricClass Class/Type of the metric\n+     */\n+    private <T extends Metric> void validateMetricNameToSingleType(String name, Class<T> metricClass) {\n+\n+        for (Entry<MetricID, Metric> entrySet : metricsMID.entrySet()) {\n+            if (entrySet.getKey().getName().equals(name) && !metricClass.isAssignableFrom(entrySet.getValue().getClass())) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Metric> SortedMap<MetricID, T> getMetrics(Class<T> ofType, MetricFilter filter) {\n+        return (SortedMap<MetricID, T>) getMetrics(\n+                                                   (metricID, metric) -> filter.matches(metricID, metric)\n+                                                                         && ofType.isAssignableFrom(metric.getClass()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public SortedMap<MetricID, Metric> getMetrics(MetricFilter filter) {\n+        final TreeMap<MetricID, Metric> sortedMetricsMap = new TreeMap<MetricID, Metric>();\n+        for (Map.Entry<MetricID, Metric> entry : metricsMID.entrySet()) {\n+            if (filter.matches(entry.getKey(), entry.getValue())) {\n+                sortedMetricsMap.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+\n+        return Collections.unmodifiableSortedMap(sortedMetricsMap);\n+    }\n+\n+    @Override\n+    public Map<MetricID, Metric> getMetrics() {\n+        return Collections.unmodifiableMap(metricsMID);\n+    }\n+\n+    @Override\n+    public Map<String, Metadata> getMetadata() {\n+        return Collections.unmodifiableMap(metadataMID);\n+    }\n+\n+    @Override\n+    public Metadata getMetadata(String name) {\n+        return metadataMID.get(name);\n+    }\n+\n+    protected <T extends Metric> Class<T> determineMetricClass(T metric) {\n+        if (Counter.class.isInstance(metric))\n+            return (Class<T>) Counter.class;\n+        if (ConcurrentGauge.class.isInstance(metric))\n+            return (Class<T>) ConcurrentGauge.class;\n+        if (Histogram.class.isInstance(metric))\n+            return (Class<T>) Histogram.class;\n+        if (Meter.class.isInstance(metric))\n+            return (Class<T>) Meter.class;\n+        if (Timer.class.isInstance(metric))\n+            return (Class<T>) Timer.class;\n+        if (Gauge.class.isInstance(metric))\n+            return (Class<T>) Gauge.class;\n+        if (SimpleTimer.class.isInstance(metric))\n+            return (Class<T>) SimpleTimer.class;\n+        return null;\n+    }\n+\n+    /**\n+     * A quick and easy way of capturing the notion of default metrics.\n+     */\n+    public interface MetricBuilder30<T extends Metric> {\n+        MetricBuilder30<Counter> COUNTERS = new MetricBuilder30<Counter>() {\n+            @Override\n+            public Counter newMetric() {\n+                return new CounterImpl();\n+            }\n+\n+            @Override\n+            public boolean isInstance(Metric metric) {\n+                return Counter.class.isInstance(metric);\n+            }\n+        };\n+\n+        MetricBuilder30<ConcurrentGauge> CONCURRENT_GAUGE = new MetricBuilder30<ConcurrentGauge>() {\n+            @Override\n+            public ConcurrentGauge newMetric() {\n+                return new ConcurrentGaugeImpl();\n+            }\n+\n+            @Override\n+            public boolean isInstance(Metric metric) {\n+                return ConcurrentGauge.class.isInstance(metric);\n+            }\n+        };\n+\n+        MetricBuilder30<Histogram> HISTOGRAMS = new MetricBuilder30<Histogram>() {\n+            @Override\n+            public Histogram newMetric() {\n+                return new HistogramImpl(new ExponentiallyDecayingReservoir());\n+            }\n+\n+            @Override\n+            public boolean isInstance(Metric metric) {\n+                return Histogram.class.isInstance(metric);\n+            }\n+        };\n+\n+        MetricBuilder30<Meter> METERS = new MetricBuilder30<Meter>() {\n+            @Override\n+            public Meter newMetric() {\n+                return new MeterImpl();\n+            }\n+\n+            @Override\n+            public boolean isInstance(Metric metric) {\n+                return Meter.class.isInstance(metric);\n+            }\n+        };\n+\n+        MetricBuilder30<Timer> TIMERS = new MetricBuilder30<Timer>() {\n+            @Override\n+            public Timer newMetric() {\n+                return new Timer30Impl();\n+            }\n+\n+            @Override\n+            public boolean isInstance(Metric metric) {\n+                return Timer.class.isInstance(metric);\n+            }\n+        };\n+\n+        MetricBuilder30<SimpleTimer> SIMPLE_TIMER = new MetricBuilder30<SimpleTimer>() {\n+            @Override\n+            public SimpleTimer newMetric() {\n+                return new SimpleTimer30Impl();\n+            }\n+\n+            @Override\n+            public boolean isInstance(Metric metric) {\n+                return SimpleTimer.class.isInstance(metric);\n+            }\n+        };\n+\n+        T newMetric();\n+\n+        boolean isInstance(Metric metric);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public SortedSet<MetricID> getMetricIDs() {\n+        return Collections.unmodifiableSortedSet(new TreeSet<MetricID>(metricsMID.keySet()));\n+    }\n+\n+    @Override\n+    public ConcurrentGauge concurrentGauge(String name) {\n+        return this.concurrentGauge(name, null);\n+    }\n+\n+    @Override\n+    public ConcurrentGauge concurrentGauge(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.CONCURRENT_GAUGE).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.CONCURRENT_GAUGE)) {\n+                throw new IllegalArgumentException(name + \" is CONCURRENT_GAUGE used for a different type of metric\");\n+            }\n+        }\n+\n+        return this.concurrentGauge(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public ConcurrentGauge concurrentGauge(MetricID metricID) {\n+        return concurrentGauge(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public ConcurrentGauge concurrentGauge(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.CONCURRENT_GAUGE).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.concurrentGauge(metadata, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public ConcurrentGauge concurrentGauge(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.CONCURRENT_GAUGE, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public SortedMap<MetricID, ConcurrentGauge> getConcurrentGauges() {\n+        return getConcurrentGauges(MetricFilter.ALL);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public SortedMap<MetricID, ConcurrentGauge> getConcurrentGauges(MetricFilter filter) {\n+        return getMetrics(ConcurrentGauge.class, filter);\n+    }\n+\n+    private ClassLoader getThreadContextClassLoader() {\n+        if (usingJava2Security) {\n+            return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> {\n+                return Thread.currentThread().getContextClassLoader();\n+            });\n+        }\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    @Override\n+    public SimpleTimer simpleTimer(String name) {\n+        return this.simpleTimer(name, null);\n+    }\n+\n+    @Override\n+    public SimpleTimer simpleTimer(String name, Tag... tags) {\n+        Metadata metadata = Metadata.builder().withName(name).withType(MetricType.SIMPLE_TIMER).build();\n+\n+        if (metadataMID.keySet().contains(name)) {\n+            metadata = metadataMID.get(name);\n+\n+            if (!metadata.getTypeRaw().equals(MetricType.SIMPLE_TIMER)) {\n+                throw new IllegalArgumentException(name + \" is already used for a different type of metric\");\n+            }\n+        }\n+        return this.simpleTimer(metadata, tags);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public SimpleTimer simpleTimer(MetricID metricID) {\n+        return simpleTimer(metricID.getName(), metricID.getTagsAsArray());\n+    }\n+\n+    @Override\n+    public SimpleTimer simpleTimer(Metadata inputMetadata) {\n+        Metadata metadata = null;\n+        if (inputMetadata.getTypeRaw() == MetricType.INVALID) {\n+            metadata = Metadata.builder(inputMetadata).withType(MetricType.SIMPLE_TIMER).build();\n+        } else {\n+            metadata = inputMetadata;\n+        }\n+        return this.simpleTimer(metadata, null);\n+    }\n+\n+    @Override\n+    public SimpleTimer simpleTimer(Metadata metadata, Tag... tags) {\n+        return getOrAdd(metadata, MetricBuilder30.SIMPLE_TIMER, tags);\n+    }\n+\n+    @Override\n+    public SortedMap<MetricID, SimpleTimer> getSimpleTimers() {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzMTA5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428431096", "bodyText": "Needed a new method that returns a map with Object values. This is due to the possibility of a null value being returned.", "author": "Channyboy", "createdAt": "2020-05-21T03:54:16Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/helper/Util30.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.helper;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.microprofile.metrics.Constants;\n+import com.ibm.ws.microprofile.metrics.exceptions.EmptyRegistryException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchMetricException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchRegistryException;\n+import com.ibm.ws.microprofile.metrics23.helper.Util23;\n+\n+/**\n+ *\n+ */\n+public class Util30 extends Util23 {\n+    private static final TraceComponent tc = Tr.register(Util30.class);\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName, String metricName) throws NoSuchRegistryException, NoSuchMetricException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+\n+        SortedSet<MetricID> metricIDSet = registry.getMetricIDs();\n+\n+        Map<MetricID, Metric> returnMap = new HashMap<MetricID, Metric>();\n+\n+        Set<MetricID> potentialMatches = new HashSet<MetricID>();\n+\n+        //for each metricID... want to check if name equals..\n+        for (MetricID tempmid : metricIDSet) {\n+            if (tempmid.getName().equals(metricName)) {\n+                potentialMatches.add(tempmid);\n+            }\n+        }\n+\n+        if (metricIDSet.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        } else if (potentialMatches.size() == 0) {\n+            throw new NoSuchMetricException();\n+        } else {\n+            for (MetricID tmid : potentialMatches) {\n+                returnMap.put(tmid, registry.getMetric(tmid));\n+            }\n+        }\n+        return returnMap;\n+    }\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName) throws NoSuchRegistryException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+        Map<MetricID, Metric> metricMap = registry.getMetrics();\n+        if (metricMap.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        }\n+        return metricMap;\n+    }\n+\n+    public static Map<String, Metadata> getMetricsMetadataAsMap(String registryName) throws NoSuchRegistryException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+        Map<String, Metadata> metricMetadataMap = new HashMap<String, Metadata>();//registry.getMetadata();\n+        for (String name : registry.getNames()) {\n+            metricMetadataMap.put(name, registry.getMetadata(name));\n+        }\n+        if (metricMetadataMap.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        }\n+        return metricMetadataMap;\n+    }\n+\n+    public static Map<String, Metadata> getMetricsMetadataAsMap(String registryName,\n+                                                                String metricName) throws NoSuchRegistryException, EmptyRegistryException, NoSuchMetricException {\n+        MetricRegistry registry = getRegistry(registryName);\n+        Map<String, Metadata> metricMetadataMap = new HashMap<String, Metadata>();\n+        for (String name : registry.getNames()) {\n+            metricMetadataMap.put(name, registry.getMetadata(name));\n+        }\n+\n+        Map<String, Metadata> returnMap = new HashMap<String, Metadata>();\n+\n+        if (metricMetadataMap.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        } else if (!(metricMetadataMap.containsKey(metricName))) {\n+            throw new NoSuchMetricException();\n+        } else {\n+            returnMap.put(metricName, metricMetadataMap.get(metricName));\n+        }\n+        return returnMap;\n+    }\n+\n+    public static Map<String, Number> getTimerNumbers(Timer timer, String tags, double conversionFactor) {\n+        Map<String, Number> results = new HashMap<String, Number>();\n+        results.put(Constants.COUNT + tags, timer.getCount());\n+        results.put(\"elapsedTime\" + tags, timer.getElapsedTime().toNanos());\n+        results.put(Constants.MEAN_RATE + tags, timer.getMeanRate());\n+        results.put(Constants.ONE_MINUTE_RATE + tags, timer.getOneMinuteRate());\n+        results.put(Constants.FIVE_MINUTE_RATE + tags, timer.getFiveMinuteRate());\n+        results.put(Constants.FIFTEEN_MINUTE_RATE + tags, timer.getFifteenMinuteRate());\n+\n+        results.put(Constants.MAX + tags, timer.getSnapshot().getMax() / conversionFactor);\n+        results.put(Constants.MEAN + tags, timer.getSnapshot().getMean() / conversionFactor);\n+        results.put(Constants.MIN + tags, timer.getSnapshot().getMin() / conversionFactor);\n+\n+        results.put(Constants.STD_DEV + tags, timer.getSnapshot().getStdDev() / conversionFactor);\n+\n+        results.put(Constants.MEDIAN + tags, timer.getSnapshot().getMedian() / conversionFactor);\n+        results.put(Constants.PERCENTILE_75TH + tags, timer.getSnapshot().get75thPercentile() / conversionFactor);\n+        results.put(Constants.PERCENTILE_95TH + tags, timer.getSnapshot().get95thPercentile() / conversionFactor);\n+        results.put(Constants.PERCENTILE_98TH + tags, timer.getSnapshot().get98thPercentile() / conversionFactor);\n+        results.put(Constants.PERCENTILE_99TH + tags, timer.getSnapshot().get99thPercentile() / conversionFactor);\n+        results.put(Constants.PERCENTILE_999TH + tags, timer.getSnapshot().get999thPercentile() / conversionFactor);\n+\n+        return results;\n+    }\n+\n+    /*\n+     * To facilitate changes into the MicroProfile Specification in 3.0 we need to return a value that is an\n+     * Object because the maxTimeDuration or minTimeDuration could be a NaN object.\n+     */\n+    public static Map<String, Object> getSimpleTimerNumbersAsObjects(SimpleTimer simpleTimer, String tags, double conversionFactor) {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzMTI1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428431257", "bodyText": "Needed a new method that returns a map with Object values. This is due to the possibility of a null value being returned.", "author": "Channyboy", "createdAt": "2020-05-21T03:54:56Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/writer/JSONMetricWriter30.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.writer;\n+\n+import java.io.Writer;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.microprofile.metrics.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.json.java.JSONObject;\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.metrics.exceptions.EmptyRegistryException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchMetricException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchRegistryException;\n+import com.ibm.ws.microprofile.metrics23.writer.JSONMetricWriter23;\n+import com.ibm.ws.microprofile.metrics30.helper.Util30;\n+\n+/**\n+ *\n+ */\n+public class JSONMetricWriter30 extends JSONMetricWriter23 {\n+\n+    /**\n+     * @param writer\n+     */\n+    public JSONMetricWriter30(Writer writer) {\n+        super(writer);\n+    }\n+\n+    @Override\n+    protected JSONObject getMetricsAsJson(String registryName) throws NoSuchRegistryException, EmptyRegistryException {\n+        return getJsonFromMetricMap(Util30.getMetricsAsMap(registryName), Util30.getMetricsMetadataAsMap(registryName));\n+    }\n+\n+    @Override\n+    protected JSONObject getMetricsAsJson(String registryName, String metricName) throws NoSuchRegistryException, NoSuchMetricException, EmptyRegistryException {\n+        return getJsonFromMetricMap(Util30.getMetricsAsMap(registryName, metricName), Util30.getMetricsMetadataAsMap(registryName, metricName));\n+    }\n+\n+    private static final TraceComponent tc = Tr.register(JSONMetricWriter30.class);\n+\n+    @Override\n+    @FFDCIgnore({ IllegalStateException.class })\n+    protected JSONObject getJsonFromMetricMap(Map<MetricID, Metric> metricMap, Map<String, Metadata> metricMetadataMap) {\n+        JSONObject jsonObject = new JSONObject();\n+\n+        //For each Metric that was returned\n+        for (Entry<MetricID, Metric> entry : metricMap.entrySet()) {\n+            MetricID metricID = entry.getKey();\n+            Map<String, String> tagsMap = metricID.getTags();\n+            String metricName = metricID.getName();\n+            String metricNameWithTags = metricName;\n+            String tags = \"\";\n+\n+            Metadata metricMetaData = metricMetadataMap.get(metricName);\n+            String unit = metricMetaData.getUnit();\n+\n+            // If an invalid unit is entered, default to nanoseconds\n+            double conversionFactor = 1;\n+\n+            switch (unit) {\n+                case MetricUnits.NANOSECONDS:\n+                    conversionFactor = 1;\n+                    break;\n+                case MetricUnits.MICROSECONDS:\n+                    conversionFactor = 1000;\n+                    break;\n+                case MetricUnits.MILLISECONDS:\n+                    conversionFactor = 1000000;\n+                    break;\n+                case MetricUnits.SECONDS:\n+                    conversionFactor = 1000000000L;\n+                    break;\n+                case MetricUnits.MINUTES:\n+                    conversionFactor = 60 * 1000000000L;\n+                    break;\n+                case MetricUnits.HOURS:\n+                    conversionFactor = 60 * 60 * 1000000000L;\n+                    break;\n+                case MetricUnits.DAYS:\n+                    conversionFactor = 24 * 60 * 60 * 1000000000L;\n+                    break;\n+            }\n+\n+            if (tagsMap.size() != 0) {\n+                for (Entry<String, String> tagsMapEntrySet : tagsMap.entrySet()) {\n+                    String tagValue = tagsMapEntrySet.getValue();\n+\n+                    /*\n+                     * As per MicroProfile metrics spec\n+                     * Need to convert semicolons found in the value of tags\n+                     * to underscores\n+                     */\n+                    if (tagValue.contains(\";\")) {\n+                        tagValue = tagValue.replaceAll(\";\", \"_\");\n+                    }\n+\n+                    tags += \";\" + tagsMapEntrySet.getKey() + \"=\" + tagValue;\n+                }\n+                metricNameWithTags = metricName + tags;\n+            }\n+            Metric metric = entry.getValue();\n+\n+            if (Counter.class.isInstance(metric)) {\n+                jsonObject.put(metricNameWithTags, ((Counter) metric).getCount());\n+            } else if (ConcurrentGauge.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMap(Util30.getConcurrentGaugeNumbers((ConcurrentGauge) metric, tags), metricName, jsonObject));\n+            } else if (Gauge.class.isInstance(metric)) {\n+                try {\n+                    jsonObject.put(metricNameWithTags, ((Gauge) metric).getValue());\n+                } catch (IllegalStateException e) {\n+                    // The forwarding gauge is likely unloaded. A warning has already been emitted\n+                }\n+            } else if (Timer.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMap(Util30.getTimerNumbers((Timer) metric, tags, conversionFactor), metricName, jsonObject));\n+            } else if (SimpleTimer.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMapAsObject(Util30.getSimpleTimerNumbersAsObjects((SimpleTimer) metric, tags, conversionFactor), metricName, jsonObject));\n+            } else if (Histogram.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMap(Util30.getHistogramNumbers((Histogram) metric, tags), metricName, jsonObject));\n+            } else if (Meter.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMap(Util30.getMeterNumbers((Meter) metric, tags), metricName, jsonObject));\n+            } else {\n+                Tr.event(tc, \"Metric type '\" + metric.getClass() + \" for \" + metricName + \" is invalid.\");\n+            }\n+        }\n+        return jsonObject;\n+    }\n+\n+    /*\n+     * This method compared to getJsonFromMap returns a map with a value as an Object.. This is because\n+     * the value can be a NaN object.\n+     */\n+    protected JSONObject getJsonFromMapAsObject(Map<String, Object> metricMap, String metricName, JSONObject parentJSONObject) {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzMTM2Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428431362", "bodyText": "Use of new methods where Object values are returned over Number values.", "author": "Channyboy", "createdAt": "2020-05-21T03:55:21Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/writer/JSONMetricWriter30.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.writer;\n+\n+import java.io.Writer;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.microprofile.metrics.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.json.java.JSONObject;\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.metrics.exceptions.EmptyRegistryException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchMetricException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchRegistryException;\n+import com.ibm.ws.microprofile.metrics23.writer.JSONMetricWriter23;\n+import com.ibm.ws.microprofile.metrics30.helper.Util30;\n+\n+/**\n+ *\n+ */\n+public class JSONMetricWriter30 extends JSONMetricWriter23 {\n+\n+    /**\n+     * @param writer\n+     */\n+    public JSONMetricWriter30(Writer writer) {\n+        super(writer);\n+    }\n+\n+    @Override\n+    protected JSONObject getMetricsAsJson(String registryName) throws NoSuchRegistryException, EmptyRegistryException {\n+        return getJsonFromMetricMap(Util30.getMetricsAsMap(registryName), Util30.getMetricsMetadataAsMap(registryName));\n+    }\n+\n+    @Override\n+    protected JSONObject getMetricsAsJson(String registryName, String metricName) throws NoSuchRegistryException, NoSuchMetricException, EmptyRegistryException {\n+        return getJsonFromMetricMap(Util30.getMetricsAsMap(registryName, metricName), Util30.getMetricsMetadataAsMap(registryName, metricName));\n+    }\n+\n+    private static final TraceComponent tc = Tr.register(JSONMetricWriter30.class);\n+\n+    @Override\n+    @FFDCIgnore({ IllegalStateException.class })\n+    protected JSONObject getJsonFromMetricMap(Map<MetricID, Metric> metricMap, Map<String, Metadata> metricMetadataMap) {\n+        JSONObject jsonObject = new JSONObject();\n+\n+        //For each Metric that was returned\n+        for (Entry<MetricID, Metric> entry : metricMap.entrySet()) {\n+            MetricID metricID = entry.getKey();\n+            Map<String, String> tagsMap = metricID.getTags();\n+            String metricName = metricID.getName();\n+            String metricNameWithTags = metricName;\n+            String tags = \"\";\n+\n+            Metadata metricMetaData = metricMetadataMap.get(metricName);\n+            String unit = metricMetaData.getUnit();\n+\n+            // If an invalid unit is entered, default to nanoseconds\n+            double conversionFactor = 1;\n+\n+            switch (unit) {\n+                case MetricUnits.NANOSECONDS:\n+                    conversionFactor = 1;\n+                    break;\n+                case MetricUnits.MICROSECONDS:\n+                    conversionFactor = 1000;\n+                    break;\n+                case MetricUnits.MILLISECONDS:\n+                    conversionFactor = 1000000;\n+                    break;\n+                case MetricUnits.SECONDS:\n+                    conversionFactor = 1000000000L;\n+                    break;\n+                case MetricUnits.MINUTES:\n+                    conversionFactor = 60 * 1000000000L;\n+                    break;\n+                case MetricUnits.HOURS:\n+                    conversionFactor = 60 * 60 * 1000000000L;\n+                    break;\n+                case MetricUnits.DAYS:\n+                    conversionFactor = 24 * 60 * 60 * 1000000000L;\n+                    break;\n+            }\n+\n+            if (tagsMap.size() != 0) {\n+                for (Entry<String, String> tagsMapEntrySet : tagsMap.entrySet()) {\n+                    String tagValue = tagsMapEntrySet.getValue();\n+\n+                    /*\n+                     * As per MicroProfile metrics spec\n+                     * Need to convert semicolons found in the value of tags\n+                     * to underscores\n+                     */\n+                    if (tagValue.contains(\";\")) {\n+                        tagValue = tagValue.replaceAll(\";\", \"_\");\n+                    }\n+\n+                    tags += \";\" + tagsMapEntrySet.getKey() + \"=\" + tagValue;\n+                }\n+                metricNameWithTags = metricName + tags;\n+            }\n+            Metric metric = entry.getValue();\n+\n+            if (Counter.class.isInstance(metric)) {\n+                jsonObject.put(metricNameWithTags, ((Counter) metric).getCount());\n+            } else if (ConcurrentGauge.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMap(Util30.getConcurrentGaugeNumbers((ConcurrentGauge) metric, tags), metricName, jsonObject));\n+            } else if (Gauge.class.isInstance(metric)) {\n+                try {\n+                    jsonObject.put(metricNameWithTags, ((Gauge) metric).getValue());\n+                } catch (IllegalStateException e) {\n+                    // The forwarding gauge is likely unloaded. A warning has already been emitted\n+                }\n+            } else if (Timer.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMap(Util30.getTimerNumbers((Timer) metric, tags, conversionFactor), metricName, jsonObject));\n+            } else if (SimpleTimer.class.isInstance(metric)) {\n+                jsonObject.put(metricName, getJsonFromMapAsObject(Util30.getSimpleTimerNumbersAsObjects((SimpleTimer) metric, tags, conversionFactor), metricName, jsonObject));", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjI4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428846282", "bodyText": "Use Tr to log an error", "author": "fmhwong", "createdAt": "2020-05-21T18:50:29Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/BaseMetrics.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30;\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.management.MBeanServer;\n+import javax.management.ObjectInstance;\n+import javax.management.ObjectName;\n+import javax.management.openmbean.CompositeData;\n+\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+\n+import com.ibm.ws.microprofile.metrics.BaseMetricConstants;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.SharedMetricRegistries;\n+\n+@Component(service = { BaseMetrics.class }, configurationPolicy = ConfigurationPolicy.IGNORE, immediate = true)\n+public class BaseMetrics {\n+\n+    protected static BaseMetrics baseMetrics = null;\n+    protected static String BASE = MetricRegistry.Type.BASE.getName();\n+    public MBeanServer mbs;\n+    protected static Set<String> gcObjectNames = new HashSet<String>();\n+\n+    private static SharedMetricRegistries SHARED_METRIC_REGISTRY;\n+\n+    public static synchronized BaseMetrics getInstance(SharedMetricRegistries sharedMetricRegistry) {\n+        //really shouldn't be using this\n+        SHARED_METRIC_REGISTRY = sharedMetricRegistry;\n+        if (baseMetrics == null)\n+            baseMetrics = new BaseMetrics();\n+        return baseMetrics;\n+    }\n+\n+    @Reference\n+    public void setSharedMetricRegistries(SharedMetricRegistries sharedMetricRegistry) {\n+        BaseMetrics.SHARED_METRIC_REGISTRY = sharedMetricRegistry;\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext context, Map<String, Object> properties) {\n+        mbs = ManagementFactory.getPlatformMBeanServer();\n+        Set<ObjectInstance> mBeanObjectInstanceSet = mbs.queryMBeans(null, null);\n+        populateGcNames(mBeanObjectInstanceSet);\n+        createBaseMetrics();\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext context, int reason) {\n+    }\n+\n+    private void populateGcNames(Set<ObjectInstance> mBeanObjectInstanceSet) {\n+        for (ObjectInstance objInstance : mBeanObjectInstanceSet) {\n+            String objectName = objInstance.getObjectName().toString();\n+            if (objectName.matches(BaseMetricConstants.GC_OBJECT_TYPE)) {\n+                for (String subString : objectName.split(\",\")) {\n+                    subString = subString.trim();\n+                    if (subString.contains(\"name=\")) {\n+                        String name = subString.split(\"=\")[1];\n+                        gcObjectNames.add(name);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void createBaseMetrics() {\n+        MetricRegistry registry = SHARED_METRIC_REGISTRY.getOrCreate(BASE);\n+        //MEMORY METRICS\n+        registry.register(Metadata.builder().withName(\"memory.usedHeap\").withDisplayName(\"Used Heap Memory\").withDescription(\"memory.usedHeap.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.BYTES).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.MEMORY_OBJECT_TYPE, \"HeapMemoryUsage\", \"used\"));\n+\n+        registry.register(Metadata.builder().withName(\"memory.committedHeap\").withDisplayName(\"Committed Heap Memory\").withDescription(\"memory.committedHeap.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.BYTES).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.MEMORY_OBJECT_TYPE, \"HeapMemoryUsage\", \"committed\"));\n+\n+        registry.register(Metadata.builder().withName(\"memory.maxHeap\").withDisplayName(\"Max Heap Memory\").withDescription(\"memory.maxHeap.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.BYTES).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.MEMORY_OBJECT_TYPE, \"HeapMemoryUsage\", \"max\"));\n+\n+        //JVM METRICS\n+        registry.register(Metadata.builder().withName(\"jvm.uptime\").withDisplayName(\"JVM Uptime\").withDescription(\"jvm.uptime.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.MILLISECONDS).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.RUNTIME_OBJECT_TYPE, \"Uptime\"));\n+\n+        //THREAD JVM\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"thread.count\").withDisplayName(\"Thread Count\").withDescription(\"thread.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.THREAD_OBJECT_TYPE, \"ThreadCount\"));\n+\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"thread.daemon.count\").withDisplayName(\"Daemon Thread Count\").withDescription(\"thread.daemon.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.THREAD_OBJECT_TYPE, \"DaemonThreadCount\"));\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"thread.max.count\").withDisplayName(\"Peak Thread Count\").withDescription(\"thread.max.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.THREAD_OBJECT_TYPE, \"PeakThreadCount\"));\n+\n+        //CLASSLOADING METRICS\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"classloader.loadedClasses.count\").withDisplayName(\"Current Loaded Class Count\").withDescription(\"classloader.currentLoadedClass.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.CLASSLOADING_OBJECT_TYPE, \"LoadedClassCount\"));\n+\n+        registry.register(Metadata.builder().withName(\"classloader.loadedClasses.total\").withDisplayName(\"Total Loaded Class Count\").withDescription(\"classloader.totalLoadedClass.count.description\").withType(MetricType.COUNTER).withUnit(MetricUnits.NONE).build(),\n+                          new BMCounter(BaseMetricConstants.CLASSLOADING_OBJECT_TYPE, \"TotalLoadedClassCount\"));\n+\n+        registry.register(Metadata.builder().withName(\"classloader.unloadedClasses.total\").withDisplayName(\"Total Unloaded Class Count\").withDescription(\"classloader.totalUnloadedClass.count.description\").withType(MetricType.COUNTER).withUnit(MetricUnits.NONE).build(),\n+                          new BMCounter(BaseMetricConstants.CLASSLOADING_OBJECT_TYPE, \"UnloadedClassCount\"));\n+\n+        //OPERATING SYSTEM\n+        registry.register(Metadata.builder().withName(\"cpu.availableProcessors\").withDisplayName(\"Available Processors\").withDescription(\"cpu.availableProcessors.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"AvailableProcessors\"));\n+\n+        registry.register(Metadata.builder().withName(\"cpu.systemLoadAverage\").withDisplayName(\"System Load Average\").withDescription(\"cpu.systemLoadAverage.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"SystemLoadAverage\"));\n+\n+        registry.register(Metadata.builder().withName(\"cpu.processCpuLoad\").withDisplayName(\"Process CPU Load\").withDescription(\"cpu.processCpuLoad.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.PERCENT).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"ProcessCpuLoad\"));\n+\n+        registry.register(Metadata.builder().withName(\"cpu.processCpuTime\").withDisplayName(\"Process CPU Time\").withDescription(\"cpu.processCpuTime.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NANOSECONDS).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"ProcessCpuTime\"));\n+\n+        //GARBAGE COLLECTOR METRICS\n+        for (String gcName : gcObjectNames) {\n+\n+            String gcNameNoSpace = removeSpaces(gcName);\n+            Tag gcNameNoSpaceTag = new Tag(\"name\", gcNameNoSpace);\n+            String nameToRegister = \"gc.total\";\n+            registry.register(Metadata.builder().withName(nameToRegister).withDisplayName(\"Garbage Collection Count\").withDescription(\"garbageCollectionCount.description\").withType(MetricType.COUNTER).withUnit(MetricUnits.NONE).build(),\n+                              new BMCounter(BaseMetricConstants.GC_OBJECT_TYPE_NAME + gcName, \"CollectionCount\"), gcNameNoSpaceTag);\n+\n+            nameToRegister = \"gc.time\";\n+            registry.register(Metadata.builder().withName(nameToRegister).withDisplayName(\"Garbage Collection Time\").withDescription(\"garbageCollectionTime.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.MILLISECONDS).build(),\n+                              new BMGauge<Number>(BaseMetricConstants.GC_OBJECT_TYPE_NAME + gcName, \"CollectionTime\"), gcNameNoSpaceTag);\n+        }\n+\n+    }\n+\n+    private String removeSpaces(String aString) {\n+        return aString.replaceAll(\"\\\\s+\", \"\");\n+    }\n+\n+    private class BMGauge<T> implements Gauge<T> {\n+        String objectName, attribute, subAttribute;\n+        boolean isComposite = false;\n+\n+        public BMGauge(String objectName, String attribute) {\n+            this.objectName = objectName;\n+            this.attribute = attribute;\n+        }\n+\n+        public BMGauge(String objectName, String attribute, String subAttribute) {\n+            this.objectName = objectName;\n+            this.attribute = attribute;\n+            this.subAttribute = subAttribute;\n+            isComposite = true;\n+        }\n+\n+        @Override\n+        public T getValue() {\n+            try {\n+                if (isComposite) {\n+                    CompositeData value = (CompositeData) mbs.getAttribute(new ObjectName(objectName), attribute);\n+                    return (T) value.get(subAttribute);\n+                } else {\n+                    T value = (T) mbs.getAttribute(new ObjectName(objectName), attribute);\n+                    return value;\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjM3Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428846376", "bodyText": "Use Tr to log an error", "author": "fmhwong", "createdAt": "2020-05-21T18:50:39Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/BaseMetrics.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30;\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.management.MBeanServer;\n+import javax.management.ObjectInstance;\n+import javax.management.ObjectName;\n+import javax.management.openmbean.CompositeData;\n+\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.MetricUnits;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+\n+import com.ibm.ws.microprofile.metrics.BaseMetricConstants;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.SharedMetricRegistries;\n+\n+@Component(service = { BaseMetrics.class }, configurationPolicy = ConfigurationPolicy.IGNORE, immediate = true)\n+public class BaseMetrics {\n+\n+    protected static BaseMetrics baseMetrics = null;\n+    protected static String BASE = MetricRegistry.Type.BASE.getName();\n+    public MBeanServer mbs;\n+    protected static Set<String> gcObjectNames = new HashSet<String>();\n+\n+    private static SharedMetricRegistries SHARED_METRIC_REGISTRY;\n+\n+    public static synchronized BaseMetrics getInstance(SharedMetricRegistries sharedMetricRegistry) {\n+        //really shouldn't be using this\n+        SHARED_METRIC_REGISTRY = sharedMetricRegistry;\n+        if (baseMetrics == null)\n+            baseMetrics = new BaseMetrics();\n+        return baseMetrics;\n+    }\n+\n+    @Reference\n+    public void setSharedMetricRegistries(SharedMetricRegistries sharedMetricRegistry) {\n+        BaseMetrics.SHARED_METRIC_REGISTRY = sharedMetricRegistry;\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext context, Map<String, Object> properties) {\n+        mbs = ManagementFactory.getPlatformMBeanServer();\n+        Set<ObjectInstance> mBeanObjectInstanceSet = mbs.queryMBeans(null, null);\n+        populateGcNames(mBeanObjectInstanceSet);\n+        createBaseMetrics();\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext context, int reason) {\n+    }\n+\n+    private void populateGcNames(Set<ObjectInstance> mBeanObjectInstanceSet) {\n+        for (ObjectInstance objInstance : mBeanObjectInstanceSet) {\n+            String objectName = objInstance.getObjectName().toString();\n+            if (objectName.matches(BaseMetricConstants.GC_OBJECT_TYPE)) {\n+                for (String subString : objectName.split(\",\")) {\n+                    subString = subString.trim();\n+                    if (subString.contains(\"name=\")) {\n+                        String name = subString.split(\"=\")[1];\n+                        gcObjectNames.add(name);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void createBaseMetrics() {\n+        MetricRegistry registry = SHARED_METRIC_REGISTRY.getOrCreate(BASE);\n+        //MEMORY METRICS\n+        registry.register(Metadata.builder().withName(\"memory.usedHeap\").withDisplayName(\"Used Heap Memory\").withDescription(\"memory.usedHeap.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.BYTES).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.MEMORY_OBJECT_TYPE, \"HeapMemoryUsage\", \"used\"));\n+\n+        registry.register(Metadata.builder().withName(\"memory.committedHeap\").withDisplayName(\"Committed Heap Memory\").withDescription(\"memory.committedHeap.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.BYTES).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.MEMORY_OBJECT_TYPE, \"HeapMemoryUsage\", \"committed\"));\n+\n+        registry.register(Metadata.builder().withName(\"memory.maxHeap\").withDisplayName(\"Max Heap Memory\").withDescription(\"memory.maxHeap.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.BYTES).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.MEMORY_OBJECT_TYPE, \"HeapMemoryUsage\", \"max\"));\n+\n+        //JVM METRICS\n+        registry.register(Metadata.builder().withName(\"jvm.uptime\").withDisplayName(\"JVM Uptime\").withDescription(\"jvm.uptime.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.MILLISECONDS).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.RUNTIME_OBJECT_TYPE, \"Uptime\"));\n+\n+        //THREAD JVM\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"thread.count\").withDisplayName(\"Thread Count\").withDescription(\"thread.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.THREAD_OBJECT_TYPE, \"ThreadCount\"));\n+\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"thread.daemon.count\").withDisplayName(\"Daemon Thread Count\").withDescription(\"thread.daemon.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.THREAD_OBJECT_TYPE, \"DaemonThreadCount\"));\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"thread.max.count\").withDisplayName(\"Peak Thread Count\").withDescription(\"thread.max.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.THREAD_OBJECT_TYPE, \"PeakThreadCount\"));\n+\n+        //CLASSLOADING METRICS\n+        //turnGauge\n+        registry.register(Metadata.builder().withName(\"classloader.loadedClasses.count\").withDisplayName(\"Current Loaded Class Count\").withDescription(\"classloader.currentLoadedClass.count.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.CLASSLOADING_OBJECT_TYPE, \"LoadedClassCount\"));\n+\n+        registry.register(Metadata.builder().withName(\"classloader.loadedClasses.total\").withDisplayName(\"Total Loaded Class Count\").withDescription(\"classloader.totalLoadedClass.count.description\").withType(MetricType.COUNTER).withUnit(MetricUnits.NONE).build(),\n+                          new BMCounter(BaseMetricConstants.CLASSLOADING_OBJECT_TYPE, \"TotalLoadedClassCount\"));\n+\n+        registry.register(Metadata.builder().withName(\"classloader.unloadedClasses.total\").withDisplayName(\"Total Unloaded Class Count\").withDescription(\"classloader.totalUnloadedClass.count.description\").withType(MetricType.COUNTER).withUnit(MetricUnits.NONE).build(),\n+                          new BMCounter(BaseMetricConstants.CLASSLOADING_OBJECT_TYPE, \"UnloadedClassCount\"));\n+\n+        //OPERATING SYSTEM\n+        registry.register(Metadata.builder().withName(\"cpu.availableProcessors\").withDisplayName(\"Available Processors\").withDescription(\"cpu.availableProcessors.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"AvailableProcessors\"));\n+\n+        registry.register(Metadata.builder().withName(\"cpu.systemLoadAverage\").withDisplayName(\"System Load Average\").withDescription(\"cpu.systemLoadAverage.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NONE).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"SystemLoadAverage\"));\n+\n+        registry.register(Metadata.builder().withName(\"cpu.processCpuLoad\").withDisplayName(\"Process CPU Load\").withDescription(\"cpu.processCpuLoad.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.PERCENT).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"ProcessCpuLoad\"));\n+\n+        registry.register(Metadata.builder().withName(\"cpu.processCpuTime\").withDisplayName(\"Process CPU Time\").withDescription(\"cpu.processCpuTime.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.NANOSECONDS).build(),\n+                          new BMGauge<Number>(BaseMetricConstants.OS_OBJECT_TYPE, \"ProcessCpuTime\"));\n+\n+        //GARBAGE COLLECTOR METRICS\n+        for (String gcName : gcObjectNames) {\n+\n+            String gcNameNoSpace = removeSpaces(gcName);\n+            Tag gcNameNoSpaceTag = new Tag(\"name\", gcNameNoSpace);\n+            String nameToRegister = \"gc.total\";\n+            registry.register(Metadata.builder().withName(nameToRegister).withDisplayName(\"Garbage Collection Count\").withDescription(\"garbageCollectionCount.description\").withType(MetricType.COUNTER).withUnit(MetricUnits.NONE).build(),\n+                              new BMCounter(BaseMetricConstants.GC_OBJECT_TYPE_NAME + gcName, \"CollectionCount\"), gcNameNoSpaceTag);\n+\n+            nameToRegister = \"gc.time\";\n+            registry.register(Metadata.builder().withName(nameToRegister).withDisplayName(\"Garbage Collection Time\").withDescription(\"garbageCollectionTime.description\").withType(MetricType.GAUGE).withUnit(MetricUnits.MILLISECONDS).build(),\n+                              new BMGauge<Number>(BaseMetricConstants.GC_OBJECT_TYPE_NAME + gcName, \"CollectionTime\"), gcNameNoSpaceTag);\n+        }\n+\n+    }\n+\n+    private String removeSpaces(String aString) {\n+        return aString.replaceAll(\"\\\\s+\", \"\");\n+    }\n+\n+    private class BMGauge<T> implements Gauge<T> {\n+        String objectName, attribute, subAttribute;\n+        boolean isComposite = false;\n+\n+        public BMGauge(String objectName, String attribute) {\n+            this.objectName = objectName;\n+            this.attribute = attribute;\n+        }\n+\n+        public BMGauge(String objectName, String attribute, String subAttribute) {\n+            this.objectName = objectName;\n+            this.attribute = attribute;\n+            this.subAttribute = subAttribute;\n+            isComposite = true;\n+        }\n+\n+        @Override\n+        public T getValue() {\n+            try {\n+                if (isComposite) {\n+                    CompositeData value = (CompositeData) mbs.getAttribute(new ObjectName(objectName), attribute);\n+                    return (T) value.get(subAttribute);\n+                } else {\n+                    T value = (T) mbs.getAttribute(new ObjectName(objectName), attribute);\n+                    return value;\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private class BMCounter extends CounterImpl {\n+        String objectName, attribute;\n+\n+        public BMCounter(String objectName, String attribute) {\n+            this.objectName = objectName;\n+            this.attribute = attribute;\n+        }\n+\n+        @Override\n+        public long getCount() {\n+            try {\n+                Number value = (Number) mbs.getAttribute(new ObjectName(objectName), attribute);\n+                return value.longValue();\n+            } catch (Exception e) {\n+                e.printStackTrace();", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MzI0NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428943244", "bodyText": "fixed", "author": "Channyboy", "createdAt": "2020-05-21T22:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzQ3NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428847475", "bodyText": "Do you expect FFDCs for the thrown exceptions?", "author": "fmhwong", "createdAt": "2020-05-21T18:52:41Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/helper/Util30.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.helper;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.microprofile.metrics.Constants;\n+import com.ibm.ws.microprofile.metrics.exceptions.EmptyRegistryException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchMetricException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchRegistryException;\n+import com.ibm.ws.microprofile.metrics23.helper.Util23;\n+\n+/**\n+ *\n+ */\n+public class Util30 extends Util23 {\n+    private static final TraceComponent tc = Tr.register(Util30.class);\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName, String metricName) throws NoSuchRegistryException, NoSuchMetricException, EmptyRegistryException {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MzE2NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428943164", "bodyText": "Exception is caught later and an FFDC ignore is applied there.", "author": "Channyboy", "createdAt": "2020-05-21T22:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzYyNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428847627", "bodyText": "Do you expect FFDCs for the thrown exceptions?", "author": "fmhwong", "createdAt": "2020-05-21T18:52:56Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/helper/Util30.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.helper;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.microprofile.metrics.Constants;\n+import com.ibm.ws.microprofile.metrics.exceptions.EmptyRegistryException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchMetricException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchRegistryException;\n+import com.ibm.ws.microprofile.metrics23.helper.Util23;\n+\n+/**\n+ *\n+ */\n+public class Util30 extends Util23 {\n+    private static final TraceComponent tc = Tr.register(Util30.class);\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName, String metricName) throws NoSuchRegistryException, NoSuchMetricException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+\n+        SortedSet<MetricID> metricIDSet = registry.getMetricIDs();\n+\n+        Map<MetricID, Metric> returnMap = new HashMap<MetricID, Metric>();\n+\n+        Set<MetricID> potentialMatches = new HashSet<MetricID>();\n+\n+        //for each metricID... want to check if name equals..\n+        for (MetricID tempmid : metricIDSet) {\n+            if (tempmid.getName().equals(metricName)) {\n+                potentialMatches.add(tempmid);\n+            }\n+        }\n+\n+        if (metricIDSet.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        } else if (potentialMatches.size() == 0) {\n+            throw new NoSuchMetricException();\n+        } else {\n+            for (MetricID tmid : potentialMatches) {\n+                returnMap.put(tmid, registry.getMetric(tmid));\n+            }\n+        }\n+        return returnMap;\n+    }\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName) throws NoSuchRegistryException, EmptyRegistryException {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MzEwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428943103", "bodyText": "Exception is caught later and an FFDC ignore is applied there.", "author": "Channyboy", "createdAt": "2020-05-21T22:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzcxMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428847710", "bodyText": "Do you expect FFDCs for the thrown exceptions?", "author": "fmhwong", "createdAt": "2020-05-21T18:53:04Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/helper/Util30.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.helper;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.microprofile.metrics.Constants;\n+import com.ibm.ws.microprofile.metrics.exceptions.EmptyRegistryException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchMetricException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchRegistryException;\n+import com.ibm.ws.microprofile.metrics23.helper.Util23;\n+\n+/**\n+ *\n+ */\n+public class Util30 extends Util23 {\n+    private static final TraceComponent tc = Tr.register(Util30.class);\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName, String metricName) throws NoSuchRegistryException, NoSuchMetricException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+\n+        SortedSet<MetricID> metricIDSet = registry.getMetricIDs();\n+\n+        Map<MetricID, Metric> returnMap = new HashMap<MetricID, Metric>();\n+\n+        Set<MetricID> potentialMatches = new HashSet<MetricID>();\n+\n+        //for each metricID... want to check if name equals..\n+        for (MetricID tempmid : metricIDSet) {\n+            if (tempmid.getName().equals(metricName)) {\n+                potentialMatches.add(tempmid);\n+            }\n+        }\n+\n+        if (metricIDSet.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        } else if (potentialMatches.size() == 0) {\n+            throw new NoSuchMetricException();\n+        } else {\n+            for (MetricID tmid : potentialMatches) {\n+                returnMap.put(tmid, registry.getMetric(tmid));\n+            }\n+        }\n+        return returnMap;\n+    }\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName) throws NoSuchRegistryException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+        Map<MetricID, Metric> metricMap = registry.getMetrics();\n+        if (metricMap.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        }\n+        return metricMap;\n+    }\n+\n+    public static Map<String, Metadata> getMetricsMetadataAsMap(String registryName) throws NoSuchRegistryException, EmptyRegistryException {", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MzA3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428943074", "bodyText": "Exception is caught later and an FFDC ignore is applied there.", "author": "Channyboy", "createdAt": "2020-05-21T22:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzgwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428847807", "bodyText": "Do you expect FFDCs for the thrown exceptions?", "author": "fmhwong", "createdAt": "2020-05-21T18:53:15Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/helper/Util30.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.helper;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.microprofile.metrics.Constants;\n+import com.ibm.ws.microprofile.metrics.exceptions.EmptyRegistryException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchMetricException;\n+import com.ibm.ws.microprofile.metrics.exceptions.NoSuchRegistryException;\n+import com.ibm.ws.microprofile.metrics23.helper.Util23;\n+\n+/**\n+ *\n+ */\n+public class Util30 extends Util23 {\n+    private static final TraceComponent tc = Tr.register(Util30.class);\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName, String metricName) throws NoSuchRegistryException, NoSuchMetricException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+\n+        SortedSet<MetricID> metricIDSet = registry.getMetricIDs();\n+\n+        Map<MetricID, Metric> returnMap = new HashMap<MetricID, Metric>();\n+\n+        Set<MetricID> potentialMatches = new HashSet<MetricID>();\n+\n+        //for each metricID... want to check if name equals..\n+        for (MetricID tempmid : metricIDSet) {\n+            if (tempmid.getName().equals(metricName)) {\n+                potentialMatches.add(tempmid);\n+            }\n+        }\n+\n+        if (metricIDSet.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        } else if (potentialMatches.size() == 0) {\n+            throw new NoSuchMetricException();\n+        } else {\n+            for (MetricID tmid : potentialMatches) {\n+                returnMap.put(tmid, registry.getMetric(tmid));\n+            }\n+        }\n+        return returnMap;\n+    }\n+\n+    public static Map<MetricID, Metric> getMetricsAsMap(String registryName) throws NoSuchRegistryException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+        Map<MetricID, Metric> metricMap = registry.getMetrics();\n+        if (metricMap.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        }\n+        return metricMap;\n+    }\n+\n+    public static Map<String, Metadata> getMetricsMetadataAsMap(String registryName) throws NoSuchRegistryException, EmptyRegistryException {\n+        MetricRegistry registry = getRegistry(registryName);\n+        Map<String, Metadata> metricMetadataMap = new HashMap<String, Metadata>();//registry.getMetadata();\n+        for (String name : registry.getNames()) {\n+            metricMetadataMap.put(name, registry.getMetadata(name));\n+        }\n+        if (metricMetadataMap.isEmpty()) {\n+            throw new EmptyRegistryException();\n+        }\n+        return metricMetadataMap;\n+    }\n+\n+    public static Map<String, Metadata> getMetricsMetadataAsMap(String registryName,", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0Mjk3OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428942979", "bodyText": "Exception is caught later and an FFDC ignore is applied there.", "author": "Channyboy", "createdAt": "2020-05-21T22:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NzgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDAxMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r428954011", "bodyText": "You might have a NPE here as appName could be null.", "author": "fmhwong", "createdAt": "2020-05-21T22:42:07Z", "path": "dev/com.ibm.ws.microprofile.metrics.3.0/src/com/ibm/ws/microprofile/metrics30/impl/MetricRegistry30Impl.java", "diffHunk": "@@ -0,0 +1,1090 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.metrics30.impl;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NoSuchElementException;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.enterprise.inject.Vetoed;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.eclipse.microprofile.metrics.ConcurrentGauge;\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.Histogram;\n+import org.eclipse.microprofile.metrics.Metadata;\n+import org.eclipse.microprofile.metrics.MetadataBuilder;\n+import org.eclipse.microprofile.metrics.Meter;\n+import org.eclipse.microprofile.metrics.Metric;\n+import org.eclipse.microprofile.metrics.MetricFilter;\n+import org.eclipse.microprofile.metrics.MetricID;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.SimpleTimer;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.metrics.impl.ConcurrentGaugeImpl;\n+import com.ibm.ws.microprofile.metrics.impl.CounterImpl;\n+import com.ibm.ws.microprofile.metrics.impl.ExponentiallyDecayingReservoir;\n+import com.ibm.ws.microprofile.metrics.impl.HistogramImpl;\n+import com.ibm.ws.microprofile.metrics.impl.MeterImpl;\n+\n+/**\n+ * A registry of metric instances.\n+ */\n+@Vetoed\n+public class MetricRegistry30Impl implements MetricRegistry {\n+\n+    protected final ConcurrentMap<MetricID, Metric> metricsMID;\n+    protected final ConcurrentMap<String, Metadata> metadataMID;\n+    protected final ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>> applicationMap;\n+    private final ConfigProviderResolver configResolver;\n+\n+    private final static boolean usingJava2Security = System.getSecurityManager() != null;\n+\n+    /**\n+     * Creates a new {@link MetricRegistry}.\n+     *\n+     * @param configResolver\n+     */\n+    public MetricRegistry30Impl(ConfigProviderResolver configResolver) {\n+        this.metricsMID = new ConcurrentHashMap<MetricID, Metric>();\n+\n+        this.metadataMID = new ConcurrentHashMap<String, Metadata>();\n+\n+        this.applicationMap = new ConcurrentHashMap<String, ConcurrentLinkedQueue<MetricID>>();\n+\n+        this.configResolver = configResolver;\n+    }\n+\n+    /**\n+     * Convert the metric class type into an enum\n+     * For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+     *\n+     * @param in The metric\n+     * @return the matching Enum\n+     */\n+    public static MetricType from(Metric in) {\n+        if (Gauge.class.isInstance(in))\n+            return MetricType.GAUGE;\n+        if (Counter.class.isInstance(in))\n+            return MetricType.COUNTER;\n+        if (Histogram.class.isInstance(in))\n+            return MetricType.HISTOGRAM;\n+        if (Meter.class.isInstance(in))\n+            return MetricType.METERED;\n+        if (Timer.class.isInstance(in))\n+            return MetricType.TIMER;\n+        if (SimpleTimer.class.isInstance(in))\n+            return MetricType.SIMPLE_TIMER;\n+        return MetricType.INVALID;\n+    }\n+\n+    /**\n+     * Creates a new {@link ConcurrentMap} implementation for use inside the registry. Override this\n+     * to create a {@link MetricRegistry} with space- or time-bounded metric lifecycles, for\n+     * example.\n+     *\n+     * @return a new {@link ConcurrentMap}\n+     */\n+    protected ConcurrentMap<String, Metric> buildMap() {\n+        return new ConcurrentHashMap<String, Metric>();\n+    }\n+\n+    /**\n+     * Given a {@link Metric}, registers it under the given name.\n+     *\n+     * @param name   the name of the metric\n+     * @param metric the metric\n+     * @param <T>    the type of the metric\n+     * @return {@code metric}\n+     * @throws IllegalArgumentException if the name is already registered\n+     */\n+    @Override\n+    public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException {\n+        // For MP Metrics 1.0, MetricType.from(Class in) does not support lambdas or proxy classes\n+\n+        //return register(new Metadata(name, from(metric)), metric);\n+        return register(Metadata.builder().withName(name).withType(from(metric)).build(), metric);\n+    }\n+\n+    @Override\n+    public <T extends Metric> T register(Metadata metadata, T metric) throws IllegalArgumentException {\n+        return register(metadata, metric, null);\n+    }\n+\n+    @Override\n+    @FFDCIgnore({ NoSuchElementException.class })\n+    public <T extends Metric> T register(Metadata metadata, T metric, Tag... tags) throws IllegalArgumentException {\n+\n+        /*\n+         * Checks if MetaData with the given name already exists or not.\n+         * If it does, then check if they match.\n+         * Throw an exception otherwise.\n+         * RF->f(x)\n+         */\n+        if (metadataMID.keySet().contains(metadata.getName())) {\n+            Metadata existingMetadata = metadataMID.get(metadata.getName());\n+\n+            if (!metadata.equals(existingMetadata)) {\n+                throw new IllegalArgumentException(\"Metadata does not match for existing Metadata for \" + metadata.getName());\n+            }\n+        }\n+        //Create Copy of Metadata object so it can't be changed after its registered\n+        //rf-rm\n+        MetadataBuilder metadataBuilder = Metadata.builder(metadata);\n+\n+        ArrayList<Tag> cumulativeTags = (tags == null) ? new ArrayList<Tag>() : new ArrayList<Tag>(Arrays.asList(tags));\n+\n+        //Append global tags to the metric\n+        //rf-rm\n+        Config config = configResolver.getConfig(getThreadContextClassLoader());\n+        try {\n+            String[] globaltags = config.getValue(\"MP_METRICS_TAGS\", String.class).split(\"(?<!\\\\\\\\),\");\n+            for (String tag : globaltags) {\n+                if (!(tag == null || tag.isEmpty() || !tag.contains(\"=\"))) {\n+                    String key = tag.substring(0, tag.indexOf(\"=\"));\n+                    String val = tag.substring(tag.indexOf(\"=\") + 1);\n+                    if (key.length() == 0 || val.length() == 0) {\n+                        throw new IllegalArgumentException(\"Malformed list of Global Tags. Tag names \"\n+                                                           + \"must match the following regex [a-zA-Z_][a-zA-Z0-9_]*.\"\n+                                                           + \" Global Tag values must not be empty.\"\n+                                                           + \" Global Tag values MUST escape equal signs `=` and commas `,`\"\n+                                                           + \"with a backslash `\\\\` \");\n+                    }\n+                    val = val.replace(\"\\\\,\", \",\");\n+                    val = val.replace(\"\\\\=\", \"=\");\n+                    if (!cumulativeTags.contains(key)) {\n+                        cumulativeTags.add(new Tag(key, val));\n+                    }\n+                }\n+            }\n+        } catch (NoSuchElementException e) {\n+            //Continue if there is no global tags\n+        }\n+\n+        MetricID MetricID = new MetricID(metadata.getName(), tags);\n+        Class<T> metricClass = determineMetricClass(metric);\n+\n+        //Ensure all metrics with this name are the same type\n+        validateMetricNameToSingleType(MetricID.getName(), metricClass);\n+\n+        /*\n+         * Rest of the method officialy registers the metric\n+         * Add to MetricID -> Metric Map and Name -> MetaData map\n+         */\n+\n+        final Metric existingMetric = metricsMID.putIfAbsent(MetricID, metric);\n+\n+        if (existingMetric != null) {\n+            throw new IllegalArgumentException(\"A metric named \" + MetricID.getName() + \" with tags \" + MetricID.getTagsAsString() + \" already exists\");\n+        }\n+\n+        this.metadataMID.putIfAbsent(metadata.getName(), metadataBuilder.build());\n+\n+        addNameToApplicationMap(MetricID);\n+        return metric;\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param name\n+     */\n+    protected void addNameToApplicationMap(MetricID metricID) {\n+        String appName = getApplicationName();\n+        addNameToApplicationMap(metricID, appName);\n+    }\n+\n+    /**\n+     * Adds the MetricID to an application map given the application name.\n+     * This map is not a complete list of metrics owned by an application,\n+     * produced metrics are managed in the MetricsExtension\n+     *\n+     * @param metricID metric ID of metric that was added\n+     * @param appName  applicationName\n+     */\n+    public void addNameToApplicationMap(MetricID metricID, String appName) {\n+        // If it is a base metric, the name will be null\n+        if (appName == null)\n+            return;\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.get(appName);\n+        if (list == null) {\n+            ConcurrentLinkedQueue<MetricID> newList = new ConcurrentLinkedQueue<MetricID>();\n+            list = applicationMap.putIfAbsent(appName, newList);\n+            if (list == null)\n+                list = newList;\n+        }\n+        list.add(metricID);\n+    }\n+\n+    public void unRegisterApplicationMetrics() {\n+        unRegisterApplicationMetrics(getApplicationName());\n+    }\n+\n+    public void unRegisterApplicationMetrics(String appName) {\n+        ConcurrentLinkedQueue<MetricID> list = applicationMap.remove(appName);", "originalCommit": "9edbbeb2b39fae1a4d57c5f9a9c65443ee9ffbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3MDc0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12299#discussion_r430470740", "bodyText": "Fixed in 9edbbeb", "author": "Channyboy", "createdAt": "2020-05-26T14:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDAxMQ=="}], "type": "inlineReview"}, {"oid": "ea41c6797a4732d48dba73650edd640be7cd3dae", "url": "https://github.com/OpenLiberty/open-liberty/commit/ea41c6797a4732d48dba73650edd640be7cd3dae", "message": "mpMetrics-3.0 noShip code drop (JAX-RS relevant changes in two separate PRs)\n\nMicroProfile Metrics features:\nauto - com.ibm.websphere.appserver.mpMetrics-3.0-monitor-1.0\npublic - com.ibm.websphere.appserver.mpMetrics-3.0\nprivate - com.ibm.websphere.appserver.org.eclipse.microprofile.metrics-3.0\n\n- Using a snapshot of the MicroProfile Metric API has it has not been released yet or RCed. Cannot retrieve from maven.\n\n- Introduced Stereotype support (MetricResolver#hasMetricAnnotation, MetricResolver#getAnnotation)\n\n- New MetricRegistry API. It is now an interface and new methods are added.\n\n- Concept of Re-usability removed (MetricResolver class modified - remove use of getReusable method)\n\n- SimpleTimer now tracks high and lows from the \"previous\" full/complete minute. \"Previous\" is defined as the last time the simple timer was queried which could be a few minutes ago. This is similar to the behaviour of the \"previous\" minute tracking of the ConcurrentGauge metric.\n\nReview fixes:\n- NLS props copyright form 20120 to 2020\n- Null check for appName in MetricRegistry30Impl\n- Bundle build dependancies to use mpConfig-1.4 and CDI 2.0\n- Use of `Tr` log/error/event\n- removed printStackTrace in BaseMetrics", "committedDate": "2020-05-26T15:03:44Z", "type": "commit"}, {"oid": "ea41c6797a4732d48dba73650edd640be7cd3dae", "url": "https://github.com/OpenLiberty/open-liberty/commit/ea41c6797a4732d48dba73650edd640be7cd3dae", "message": "mpMetrics-3.0 noShip code drop (JAX-RS relevant changes in two separate PRs)\n\nMicroProfile Metrics features:\nauto - com.ibm.websphere.appserver.mpMetrics-3.0-monitor-1.0\npublic - com.ibm.websphere.appserver.mpMetrics-3.0\nprivate - com.ibm.websphere.appserver.org.eclipse.microprofile.metrics-3.0\n\n- Using a snapshot of the MicroProfile Metric API has it has not been released yet or RCed. Cannot retrieve from maven.\n\n- Introduced Stereotype support (MetricResolver#hasMetricAnnotation, MetricResolver#getAnnotation)\n\n- New MetricRegistry API. It is now an interface and new methods are added.\n\n- Concept of Re-usability removed (MetricResolver class modified - remove use of getReusable method)\n\n- SimpleTimer now tracks high and lows from the \"previous\" full/complete minute. \"Previous\" is defined as the last time the simple timer was queried which could be a few minutes ago. This is similar to the behaviour of the \"previous\" minute tracking of the ConcurrentGauge metric.\n\nReview fixes:\n- NLS props copyright form 20120 to 2020\n- Null check for appName in MetricRegistry30Impl\n- Bundle build dependancies to use mpConfig-1.4 and CDI 2.0\n- Use of `Tr` log/error/event\n- removed printStackTrace in BaseMetrics", "committedDate": "2020-05-26T15:03:44Z", "type": "forcePushed"}]}