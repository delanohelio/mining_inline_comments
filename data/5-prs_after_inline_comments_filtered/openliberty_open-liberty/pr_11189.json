{"pr_number": 11189, "pr_title": "Add custom access log fields to JSON logs and logstashCollector", "pr_createdAt": "2020-03-04T20:15:26Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/11189", "timeline": [{"oid": "65f3a1753e413c4e3ab7e48fe970343dbc1a8f86", "url": "https://github.com/OpenLiberty/open-liberty/commit/65f3a1753e413c4e3ab7e48fe970343dbc1a8f86", "message": "Clean up and add omit capability", "committedDate": "2020-03-04T20:40:01Z", "type": "forcePushed"}, {"oid": "2126edc08539c179011f0aba1ce326d32ffa01e2", "url": "https://github.com/OpenLiberty/open-liberty/commit/2126edc08539c179011f0aba1ce326d32ffa01e2", "message": "Clean up and add omit capability", "committedDate": "2020-03-04T20:42:27Z", "type": "forcePushed"}, {"oid": "cde81ec8e477afdd090b8b73ea77cb21fbe43572", "url": "https://github.com/OpenLiberty/open-liberty/commit/cde81ec8e477afdd090b8b73ea77cb21fbe43572", "message": "Implement new design and change setting name", "committedDate": "2020-03-10T18:25:22Z", "type": "forcePushed"}, {"oid": "5c504c7a2f024e941d2364bf528d7387715c0885", "url": "https://github.com/OpenLiberty/open-liberty/commit/5c504c7a2f024e941d2364bf528d7387715c0885", "message": "Implement new design and change setting name", "committedDate": "2020-03-10T18:40:09Z", "type": "forcePushed"}, {"oid": "5aaa034c0a981b438ae059d4b759aad89ebde527", "url": "https://github.com/OpenLiberty/open-liberty/commit/5aaa034c0a981b438ae059d4b759aad89ebde527", "message": "Implement new design and change setting name", "committedDate": "2020-03-11T20:41:40Z", "type": "forcePushed"}, {"oid": "e0023e5ef467ba3cb982d26076bd68e6b284fad4", "url": "https://github.com/OpenLiberty/open-liberty/commit/e0023e5ef467ba3cb982d26076bd68e6b284fad4", "message": "Implement new design and change setting name", "committedDate": "2020-03-12T17:36:21Z", "type": "forcePushed"}, {"oid": "de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "url": "https://github.com/OpenLiberty/open-liberty/commit/de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "message": "Add more gets to prevent passing extra params", "committedDate": "2020-03-13T20:57:26Z", "type": "forcePushed"}, {"oid": "fd8ebb593a6acad375d21692f8fc59cb519b720c", "url": "https://github.com/OpenLiberty/open-liberty/commit/fd8ebb593a6acad375d21692f8fc59cb519b720c", "message": "Implement new design and change setting name\n\nAdd more gets to prevent passing extra params", "committedDate": "2020-03-17T17:48:15Z", "type": "forcePushed"}, {"oid": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "url": "https://github.com/OpenLiberty/open-liberty/commit/32c6cffaf51988e90f24a76d864edd4ef0573fc7", "message": "Implement new design and change setting name\n\nAdd more gets to prevent passing extra params", "committedDate": "2020-03-19T14:08:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyNTQ0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r393225448", "bodyText": "Change to getBytesSent()", "author": "Yushan-Lin", "createdAt": "2020-03-16T18:19:17Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,29 +242,104 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {\n+            return getLongValue(9);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getLongValue(9);\n     }\n \n     public int getResponseCode() {\n-        return getIntValue(10);\n+        try {\n+            return getIntValue(10);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getIntValue(10);\n     }\n \n     public long getElapsedTime() {\n-        return getLongValue(11);\n+        try {\n+            return getLongValue(11);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getLongValue(11);\n     }\n \n     public long getDatetime() {\n-        return getLongValue(12);\n+        try {\n+            return getLongValue(12);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getLongValue(12);\n     }\n \n     public String getSequence() {\n         return getStringValue(13);\n     }\n \n-    public String getRequestStartTimeKey() {\n-        return NAMES[0];\n+    // LG-265\n+    public String getRemoteIP() {\n+        return getStringValue(14);\n+    }\n+\n+    public String getBytesReceivedFormatted() {", "originalCommit": "de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyNjMxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r393226319", "bodyText": "change to IBM_BYTESSENT = \"ibm_bytesSent\"\nchange to BYTESSENT = \"bytesSent\"", "author": "Yushan-Lin", "createdAt": "2020-03-16T18:20:52Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java", "diffHunk": "@@ -76,6 +76,25 @@\n     public static final String RESPONSECODE = \"responseCode\";\n     public static final String IBM_ELAPSEDTIME = \"ibm_elapsedTime\";\n     public static final String ELAPSEDTIME = \"elapsedTime\";\n+    // LG-265 new fields\n+    public static final String IBM_REMOTEIP = \"ibm_remoteIP\";\n+    public static final String REMOTEIP = \"remoteIP\";\n+    public static final String IBM_BYTESRECEIVEDFORMATTED = \"ibm_bytesReceivedFormatted\";\n+    public static final String BYTESRECEIVEDFORMATTED = \"bytesReceivedFormatted\";", "originalCommit": "de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NjE5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395196191", "bodyText": "should have a null check if formatSpecifiers != null", "author": "Yushan-Lin", "createdAt": "2020-03-19T17:25:11Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -221,42 +228,185 @@ private static String jsonifyAccess(String wlpUserDir,\n         AccessLogData accessLogData = (AccessLogData) event;\n \n         StringBuilder sb = CollectorJsonHelpers.startAccessLogJson(hostName, wlpUserDir, serverName);\n+        List<String> formatSpecifiers;\n+\n+        if (AccessLogData.isCustomAccessLogToJSONEnabledCollector.equals(\"logFormat\")) {\n+            formatSpecifiers = accessLogData.getFormatSpecifierList();\n+            for (String s : formatSpecifiers) {", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIwMTY5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395201698", "bodyText": "check formatSpecifiers != null", "author": "Yushan-Lin", "createdAt": "2020-03-19T17:33:19Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java", "diffHunk": "@@ -210,56 +211,219 @@ public static String jsonifyAccess(String wlpUserDir, String serverName, String\n         Boolean isFirstField = true;\n         StringBuilder sb = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName);\n \n+        List<String> formatSpecifiers;\n+\n         if (sb.length() > 1)\n             isFirstField = false;\n+        // LG-265\n+        if (AccessLogData.isCustomAccessLogToJSONEnabled.equals(\"logFormat\")) {\n+            formatSpecifiers = accessLogData.getFormatSpecifierList();\n+            for (String s : formatSpecifiers) {", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43ca8f890ee538a9c8644cc70e3b072a5ecb0b07", "url": "https://github.com/OpenLiberty/open-liberty/commit/43ca8f890ee538a9c8644cc70e3b072a5ecb0b07", "message": "Fix bugs + clean up", "committedDate": "2020-03-19T21:24:01Z", "type": "forcePushed"}, {"oid": "ac9491be68a294634dcf67bed6af3fadaade6685", "url": "https://github.com/OpenLiberty/open-liberty/commit/ac9491be68a294634dcf67bed6af3fadaade6685", "message": "Fix bugs + clean up", "committedDate": "2020-03-20T16:43:04Z", "type": "forcePushed"}, {"oid": "610abea3c428614f923d79a4e25dad4c9fbe2439", "url": "https://github.com/OpenLiberty/open-liberty/commit/610abea3c428614f923d79a4e25dad4c9fbe2439", "message": "Fix bugs + clean up", "committedDate": "2020-03-20T21:07:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzUwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395227501", "bodyText": "not sure this is right place to put this.  should be alongside messageFormat / consoleFormat / jsonFieldMappings", "author": "donbourne", "createdAt": "2020-03-19T18:15:27Z", "path": "dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java", "diffHunk": "@@ -63,6 +63,7 @@\n     private static final String TAG_LIST_KEY = \"tag\";\n     private static final String MAX_FIELD_KEY = \"maxFieldLength\";\n     private static final String MAX_EVENTS_KEY = \"maxEvents\";\n+    private static final String ENABLE_CUSTOM_ACCESS_LOG_FIELDS_KEY = \"jsonAccessLogFields\";", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI0Njc2Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395246762", "bodyText": "This seems a bit out of place given the Collector is for general use by all event types.", "author": "donbourne", "createdAt": "2020-03-19T18:48:49Z", "path": "dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java", "diffHunk": "@@ -209,6 +210,7 @@ private void configure(Map<String, Object> configuration) throws IOException {\n      * 3) Status, whether it is enabled or not\n      * 4) Tags associated with the config\n      * 5) maxEvents associated with the config, to throttle events\n+     * 6) Whether custom access log fields will be sent", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI1MjMwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395252304", "bodyText": "jsonAccessLogFields seems out of place here as this is used for formatting any kind of event.", "author": "donbourne", "createdAt": "2020-03-19T18:58:12Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/Formatter.java", "diffHunk": "@@ -18,4 +18,6 @@\n      * by target.\n      */\n     public abstract Object formatEvent(String source, String location, Object event, String[] tags, int maxFieldLength);\n+\n+    public abstract Object formatEvent(String source, String location, Object event, String[] tags, int maxFieldLength, String jsonAccessLogFields);", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MDE3NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395880175", "bodyText": "again, seems incorrect to make TaskImpl (which handles all kinds of events) deal with access log field settings.", "author": "donbourne", "createdAt": "2020-03-20T20:42:07Z", "path": "dev/com.ibm.ws.collector/src/com/ibm/ws/collector/internal/TaskImpl.java", "diffHunk": "@@ -118,7 +118,8 @@ public void start() {\n     private void processEvent(Object event) {\n         long startTime = System.nanoTime();\n \n-        Object formattedEvent = formatter.formatEvent(config.getSourceName(), config.getLocation(), event, config.getTags(), config.getMaxFieldLength());\n+        Object formattedEvent = formatter.formatEvent(config.getSourceName(), config.getLocation(), event, config.getTags(), config.getMaxFieldLength(),\n+                                                      config.getjsonAccessLogFields());", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTY5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395889696", "bodyText": "may be more helpful to call these the non-default access log fields and change the label above to be the default access log fields", "author": "donbourne", "createdAt": "2020-03-20T21:06:18Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java", "diffHunk": "@@ -76,6 +76,25 @@\n     public static final String RESPONSECODE = \"responseCode\";\n     public static final String IBM_ELAPSEDTIME = \"ibm_elapsedTime\";\n     public static final String ELAPSEDTIME = \"elapsedTime\";\n+    // LG-265 new fields", "originalCommit": "ac9491be68a294634dcf67bed6af3fadaade6685", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5MTkwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395891906", "bodyText": "what if user just wants one header?  seems too general to just check for %i", "author": "donbourne", "createdAt": "2020-03-20T21:12:23Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -82,64 +110,233 @@ private void setPair(int index, long l) {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(long l) {\n-        setPair(0, l);\n+    public void setRequestStartTime(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%t\")) {\n+            setRequestStartTime(s);\n+            this.formatSpecifiers[0] = true;\n+        }\n+    }\n+\n+    public void setRequestStartTime(String s) {\n+        setPair(0, s);\n+    }\n+\n+    public void setUriPath(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%U\")) {\n+            setUriPath(s);\n+            this.formatSpecifiers[1] = true;\n+        }\n     }\n \n     public void setUriPath(String s) {\n         setPair(1, s);\n     }\n \n+    public void setRequestMethod(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%m\")) {\n+            setRequestMethod(s);\n+            this.formatSpecifiers[2] = true;\n+        }\n+    }\n+\n     public void setRequestMethod(String s) {\n         setPair(2, s);\n     }\n \n+    public void setQueryString(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%q\")) {\n+            setQueryString(s);\n+            this.formatSpecifiers[3] = true;\n+        }\n+    }\n+\n     public void setQueryString(String s) {\n         setPair(3, s);\n     }\n \n+    public void setRequestHost(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%A\")) {\n+            setRequestHost(s);\n+            this.formatSpecifiers[4] = true;\n+        }\n+    }\n+\n     public void setRequestHost(String s) {\n         setPair(4, s);\n     }\n \n+    public void setRequestPort(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%p\")) {\n+            setRequestPort(s);\n+            this.formatSpecifiers[5] = true;\n+        }\n+    }\n+\n     public void setRequestPort(String s) {\n         setPair(5, s);\n     }\n \n+    public void setRemoteHost(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%h\")) {\n+            setRemoteHost(s);\n+            this.formatSpecifiers[6] = true;\n+        }\n+    }\n+\n     public void setRemoteHost(String s) {\n         setPair(6, s);\n     }\n \n+    public void setUserAgent(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%i\")) {", "originalCommit": "610abea3c428614f923d79a4e25dad4c9fbe2439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNTQ0Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395915443", "bodyText": "possible concern -- if this method, and other like it, follow the exception path often it will cause performance degradation.  eg. if it can happen on multiple fields in every request.", "author": "donbourne", "createdAt": "2020-03-20T22:24:08Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,25 +372,90 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {", "originalCommit": "610abea3c428614f923d79a4e25dad4c9fbe2439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTY0Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219647", "bodyText": "With the new design, we should not be running into any exceptions, so I'm removing the try/catch. (If we do run into an exception, it means we made a mistake elsewhere, likely AccessLogSource.)", "author": "jennifer-c", "createdAt": "2020-04-30T18:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxODg1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r396018859", "bodyText": "not sure you need a whole method for this.  could just use:\nrequestMethod = (request == null) ? null : request.getMethod();\n\n(and similarly for next 3 lines)", "author": "donbourne", "createdAt": "2020-03-21T18:56:29Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java", "diffHunk": "@@ -31,10 +31,10 @@ public boolean set(StringBuilder accessLogEntry,\n         String requestVersion = null;\n \n         if (request != null) {\n-            requestMethod = request.getMethod();\n-            requestURI = request.getRequestURI();\n-            requestQueryString = request.getQueryString();\n-            requestVersion = request.getVersion();\n+            requestMethod = getRequestMethod(response, request, data);", "originalCommit": "610abea3c428614f923d79a4e25dad4c9fbe2439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a15e6c9bc0d03a379798c502ac1d3768f5cefdbe", "url": "https://github.com/OpenLiberty/open-liberty/commit/a15e6c9bc0d03a379798c502ac1d3768f5cefdbe", "message": "Fix bugs + clean up", "committedDate": "2020-04-20T15:16:13Z", "type": "forcePushed"}, {"oid": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "url": "https://github.com/OpenLiberty/open-liberty/commit/c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "message": "Merge branch 'accessLogFormatToJSONSetterFormatters' into accessLogFormatToJSON", "committedDate": "2020-04-20T16:11:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2ODY0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413168640", "bodyText": "add a comment here to indicate what the 4 formatters are for", "author": "donbourne", "createdAt": "2020-04-22T17:18:09Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -53,21 +64,64 @@\n                                             LogFieldConstants.RESPONSECODE,\n                                             LogFieldConstants.ELAPSEDTIME,\n                                             LogFieldConstants.DATETIME,\n-                                            LogFieldConstants.SEQUENCE\n+                                            LogFieldConstants.SEQUENCE,\n+                                            LogFieldConstants.HOSTNAME,\n+                                            LogFieldConstants.WLPUSERDIR,\n+                                            LogFieldConstants.SERVERNAME,\n+                                            LogFieldConstants.TYPE,\n+                                            LogFieldConstants.REMOTEIP,\n+                                            LogFieldConstants.BYTESSENT,\n+                                            LogFieldConstants.COOKIE,\n+                                            LogFieldConstants.REQUESTELAPSEDTIME,\n+                                            LogFieldConstants.REQUESTHEADER,\n+                                            LogFieldConstants.RESPONSEHEADER,\n+                                            LogFieldConstants.REQUESTFIRSTLINE,\n+                                            LogFieldConstants.ACCESSLOGDATETIME,\n+                                            LogFieldConstants.REMOTEUSERID\n     };\n \n+    // For renaming/omitting fields\n+    private static Map<String, String> cookieMap = new HashMap<>();\n+    private static Map<String, String> requestHeaderMap = new HashMap<>();\n+    private static Map<String, String> responseHeaderMap = new HashMap<>();\n+\n     private static NameAliases jsonLoggingNameAliases = new NameAliases(NAMES1_1);\n+    private static NameAliases jsonLoggingNameAliasesLogstash = new NameAliases(NAMES);\n+\n+    private static NameAliases[] nameAliases = { jsonLoggingNameAliases, jsonLoggingNameAliasesLogstash };\n+\n+    public AccessLogDataFormatter[] formatters = new AccessLogDataFormatter[4];", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4MDY1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413180655", "bodyText": "The FormatSpecifier seems overkill and is causing extra method calls.  Suggest we switch to some constants in this file....\nstatic final short KEYS_JSON=0;\nstatic final short KEYS_LOGSTASH=0;", "author": "donbourne", "createdAt": "2020-04-22T17:34:23Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,208 +271,207 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {\n+            return getLongValue(9);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public int getResponseCode() {\n-        return getIntValue(10);\n+        try {\n+            return getIntValue(10);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getElapsedTime() {\n-        return getLongValue(11);\n+        try {\n+            return getLongValue(11);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getDatetime() {\n-        return getLongValue(12);\n+        try {\n+            return getLongValue(12);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public String getSequence() {\n         return getStringValue(13);\n     }\n \n-    public String getRequestStartTimeKey() {\n-        return NAMES[0];\n-    }\n-\n-    public String getUriPathKey() {\n-        return NAMES[1];\n-    }\n-\n-    public String getRequestMethodKey() {\n-        return NAMES[2];\n-    }\n-\n-    public String getQueryStringKey() {\n-        return NAMES[3];\n-    }\n-\n-    public String getRequestHostKey() {\n-        return NAMES[4];\n+    public String getRemoteIP() {\n+        return getStringValue(14);\n     }\n \n-    public String getRequestPortKey() {\n-        return NAMES[5];\n+    public String getBytesSent() {\n+        return getStringValue(15);\n     }\n \n-    public String getRemoteHostKey() {\n-        return NAMES[6];\n+    public KeyValuePairList getCookies() {\n+        return getValues(16);\n     }\n \n-    public String getUserAgentKey() {\n-        return NAMES[7];\n+    public long getRequestElapsedTime() {\n+        try {\n+            return getLongValue(17);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n-    public String getRequestProtocolKey() {\n-        return NAMES[8];\n+    public KeyValuePairList getRequestHeaders() {\n+        return getValues(18);\n     }\n \n-    public String getBytesReceivedKey() {\n-        return NAMES[9];\n+    public KeyValuePairList getResponseHeaders() {\n+        return getValues(19);\n     }\n \n-    public String getResponseCodeKey() {\n-        return NAMES[10];\n+    public String getRequestFirstLine() {\n+        return getStringValue(20);\n     }\n \n-    public String getElapsedTimeKey() {\n-        return NAMES[11];\n+    public String getAccessLogDatetime() {\n+        return getStringValue(21);\n     }\n \n-    public String getDatetimeKey() {\n-        return NAMES[12];\n+    public String getRemoteUser() {\n+        return getStringValue(22);\n     }\n \n-    public String getSequenceKey() {\n-        return NAMES[13];\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n-    public String getRequestStartTimeKey1_1() {\n-        return NAMES1_1[0];\n+    public static String getRequestStartTimeKey(FormatSpecifier format) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5MTM5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413191399", "bodyText": "use cookieName here", "author": "donbourne", "createdAt": "2020-04-22T17:49:35Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,208 +271,207 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {\n+            return getLongValue(9);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public int getResponseCode() {\n-        return getIntValue(10);\n+        try {\n+            return getIntValue(10);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getElapsedTime() {\n-        return getLongValue(11);\n+        try {\n+            return getLongValue(11);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getDatetime() {\n-        return getLongValue(12);\n+        try {\n+            return getLongValue(12);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public String getSequence() {\n         return getStringValue(13);\n     }\n \n-    public String getRequestStartTimeKey() {\n-        return NAMES[0];\n-    }\n-\n-    public String getUriPathKey() {\n-        return NAMES[1];\n-    }\n-\n-    public String getRequestMethodKey() {\n-        return NAMES[2];\n-    }\n-\n-    public String getQueryStringKey() {\n-        return NAMES[3];\n-    }\n-\n-    public String getRequestHostKey() {\n-        return NAMES[4];\n+    public String getRemoteIP() {\n+        return getStringValue(14);\n     }\n \n-    public String getRequestPortKey() {\n-        return NAMES[5];\n+    public String getBytesSent() {\n+        return getStringValue(15);\n     }\n \n-    public String getRemoteHostKey() {\n-        return NAMES[6];\n+    public KeyValuePairList getCookies() {\n+        return getValues(16);\n     }\n \n-    public String getUserAgentKey() {\n-        return NAMES[7];\n+    public long getRequestElapsedTime() {\n+        try {\n+            return getLongValue(17);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n-    public String getRequestProtocolKey() {\n-        return NAMES[8];\n+    public KeyValuePairList getRequestHeaders() {\n+        return getValues(18);\n     }\n \n-    public String getBytesReceivedKey() {\n-        return NAMES[9];\n+    public KeyValuePairList getResponseHeaders() {\n+        return getValues(19);\n     }\n \n-    public String getResponseCodeKey() {\n-        return NAMES[10];\n+    public String getRequestFirstLine() {\n+        return getStringValue(20);\n     }\n \n-    public String getElapsedTimeKey() {\n-        return NAMES[11];\n+    public String getAccessLogDatetime() {\n+        return getStringValue(21);\n     }\n \n-    public String getDatetimeKey() {\n-        return NAMES[12];\n+    public String getRemoteUser() {\n+        return getStringValue(22);\n     }\n \n-    public String getSequenceKey() {\n-        return NAMES[13];\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n-    public String getRequestStartTimeKey1_1() {\n-        return NAMES1_1[0];\n+    public static String getRequestStartTimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[0];\n     }\n \n-    public String getUriPathKey1_1() {\n-        return NAMES1_1[1];\n+    public static String getUriPathKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[1];\n     }\n \n-    public String getRequestMethodKey1_1() {\n-        return NAMES1_1[2];\n+    public static String getRequestMethodKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[2];\n     }\n \n-    public String getQueryStringKey1_1() {\n-        return NAMES1_1[3];\n+    public static String getQueryStringKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[3];\n     }\n \n-    public String getRequestHostKey1_1() {\n-        return NAMES1_1[4];\n+    public static String getRequestHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[4];\n     }\n \n-    public String getRequestPortKey1_1() {\n-        return NAMES1_1[5];\n+    public static String getRequestPortKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[5];\n     }\n \n-    public String getRemoteHostKey1_1() {\n-        return NAMES1_1[6];\n+    public static String getRemoteHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[6];\n     }\n \n-    public String getUserAgentKey1_1() {\n-        return NAMES1_1[7];\n+    public static String getUserAgentKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[7];\n     }\n \n-    public String getRequestProtocolKey1_1() {\n-        return NAMES1_1[8];\n+    public static String getRequestProtocolKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[8];\n     }\n \n-    public String getBytesReceivedKey1_1() {\n-        return NAMES1_1[9];\n+    public static String getBytesReceivedKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[9];\n     }\n \n-    public String getResponseCodeKey1_1() {\n-        return NAMES1_1[10];\n+    public static String getResponseCodeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[10];\n     }\n \n-    public String getElapsedTimeKey1_1() {\n-        return NAMES1_1[11];\n+    public static String getElapsedTimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[11];\n     }\n \n-    public String getDatetimeKey1_1() {\n-        return NAMES1_1[12];\n+    public static String getDatetimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[12];\n     }\n \n-    public String getSequenceKey1_1() {\n-        return NAMES1_1[13];\n+    public static String getSequenceKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[13];\n     }\n \n-    //name aliases\n-    public static String getRequestStartTimeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[0];\n+    public static String getHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[14];\n     }\n \n-    public static String getUriPathKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[1];\n+    public static String getUserDirKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[15];\n     }\n \n-    public static String getRequestMethodKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[2];\n+    public static String getServerNameKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[16];\n     }\n \n-    public static String getQueryStringKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[3];\n+    public static String getTypeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[17];\n     }\n \n-    public static String getRequestHostKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[4];\n+    public static String getRemoteIPKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[18];\n     }\n \n-    public static String getRequestPortKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[5];\n+    public static String getBytesSentKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[19];\n     }\n \n-    public static String getRemoteHostKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[6];\n+    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+        String cookieName = kvp.getKey();\n+        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+            return cookieMap.get(cookieName);\n+        }\n+        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5NTE5NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413195195", "bodyText": "may not be safe to call clear - set to a new empty Map instead", "author": "donbourne", "createdAt": "2020-04-22T17:54:55Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -53,21 +64,64 @@\n                                             LogFieldConstants.RESPONSECODE,\n                                             LogFieldConstants.ELAPSEDTIME,\n                                             LogFieldConstants.DATETIME,\n-                                            LogFieldConstants.SEQUENCE\n+                                            LogFieldConstants.SEQUENCE,\n+                                            LogFieldConstants.HOSTNAME,\n+                                            LogFieldConstants.WLPUSERDIR,\n+                                            LogFieldConstants.SERVERNAME,\n+                                            LogFieldConstants.TYPE,\n+                                            LogFieldConstants.REMOTEIP,\n+                                            LogFieldConstants.BYTESSENT,\n+                                            LogFieldConstants.COOKIE,\n+                                            LogFieldConstants.REQUESTELAPSEDTIME,\n+                                            LogFieldConstants.REQUESTHEADER,\n+                                            LogFieldConstants.RESPONSEHEADER,\n+                                            LogFieldConstants.REQUESTFIRSTLINE,\n+                                            LogFieldConstants.ACCESSLOGDATETIME,\n+                                            LogFieldConstants.REMOTEUSERID\n     };\n \n+    // For renaming/omitting fields\n+    private static Map<String, String> cookieMap = new HashMap<>();\n+    private static Map<String, String> requestHeaderMap = new HashMap<>();\n+    private static Map<String, String> responseHeaderMap = new HashMap<>();\n+\n     private static NameAliases jsonLoggingNameAliases = new NameAliases(NAMES1_1);\n+    private static NameAliases jsonLoggingNameAliasesLogstash = new NameAliases(NAMES);\n+\n+    private static NameAliases[] nameAliases = { jsonLoggingNameAliases, jsonLoggingNameAliasesLogstash };\n+\n+    public AccessLogDataFormatter[] formatters = new AccessLogDataFormatter[4];\n+    KeyValuePairList kvplCookies = new KeyValuePairList(\"cookies\");\n+    KeyValuePairList kvplRequestHeaders = new KeyValuePairList(\"requestHeaders\");\n+    KeyValuePairList kvplResponseHeaders = new KeyValuePairList(\"responseHeaders\");\n+\n+    public static void populateDataMaps(Map<String, String> cookies, Map<String, String> requestHeaders, Map<String, String> responseHeaders) {\n+        cookieMap = cookies;\n+        requestHeaderMap = requestHeaders;\n+        responseHeaderMap = responseHeaders;\n+    }\n+\n+    public void addFormatters(AccessLogDataFormatter[] formatters) {\n+        this.formatters = formatters;\n+    }\n+\n+    public AccessLogDataFormatter[] getFormatters() {\n+        return this.formatters;\n+    }\n \n     public static void newJsonLoggingNameAliases(Map<String, String> newAliases) {\n         jsonLoggingNameAliases.newAliases(newAliases);\n     }\n \n     public static void resetJsonLoggingNameAliases() {\n         jsonLoggingNameAliases.resetAliases();\n+        cookieMap.clear();\n+        requestHeaderMap.clear();\n+        responseHeaderMap.clear();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDU5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413350591", "bodyText": "why change from long to String?", "author": "donbourne", "createdAt": "2020-04-22T21:36:48Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -82,8 +136,8 @@ private void setPair(int index, long l) {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(long l) {\n-        setPair(0, l);\n+    public void setRequestStartTime(String s) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTQ1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219457", "bodyText": "This was an old piece of code that was never called. This has been updated to be a String value (see Slide 21 on the UFO).", "author": "jennifer-c", "createdAt": "2020-04-30T18:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDk5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413350998", "bodyText": "why change from long to String?", "author": "donbourne", "createdAt": "2020-04-22T21:37:37Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -130,16 +184,58 @@ public void setElapsedTime(long l) {\n         setPair(11, l);\n     }\n \n+    // Datetime also not part of logFormat\n     public void setDatetime(long l) {\n         setPair(12, l);\n     }\n \n+    // Sequence also not part of logFormat\n     public void setSequence(String s) {\n         setPair(13, s);\n     }\n \n-    public long getRequestStartTime() {\n-        return getLongValue(0);\n+    // New optional access log fields\n+    public void setRemoteIP(String s) {\n+        setPair(14, s);\n+    }\n+\n+    public void setBytesSent(String s) {\n+        setPair(15, s);\n+    }\n+\n+    public void setCookies(String name, String value) {\n+        kvplCookies.addKeyValuePair(name, value);\n+        setPair(16, kvplCookies);\n+    }\n+\n+    public void setRequestElapsedTime(long l) {\n+        setPair(17, l);\n+    }\n+\n+    public void setRequestHeader(String name, String value) {\n+        kvplRequestHeaders.addKeyValuePair(name, value);\n+        setPair(18, kvplRequestHeaders);\n+    }\n+\n+    public void setResponseHeader(String name, String value) {\n+        kvplResponseHeaders.addKeyValuePair(name, value);\n+        setPair(19, kvplResponseHeaders);\n+    }\n+\n+    public void setRequestFirstLine(String s) {\n+        setPair(20, s);\n+    }\n+\n+    public void setAccessLogDatetime(String s) {\n+        setPair(21, s);\n+    }\n+\n+    public void setRemoteUser(String s) {\n+        setPair(22, s);\n+    }\n+\n+    public String getRequestStartTime() {\n+        return getStringValue(0);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTUwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219504", "bodyText": "see reply above", "author": "jennifer-c", "createdAt": "2020-04-30T18:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3MDA2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413870066", "bodyText": "could you please take all of the one line methods in this class and reformat those to be one line each with no spaces between lines?  would help for readability and to spot patterns (and any inconsistencies).\n    ...\n    public void setRemoteIP(String s)  { setPair(14, s); }\n    public void setBytesSent(String s) { setPair(15, s); }\n    ...", "author": "donbourne", "createdAt": "2020-04-23T14:57:44Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -130,16 +184,58 @@ public void setElapsedTime(long l) {\n         setPair(11, l);\n     }\n \n+    // Datetime also not part of logFormat\n     public void setDatetime(long l) {\n         setPair(12, l);\n     }\n \n+    // Sequence also not part of logFormat\n     public void setSequence(String s) {\n         setPair(13, s);\n     }\n \n-    public long getRequestStartTime() {\n-        return getLongValue(0);\n+    // New optional access log fields\n+    public void setRemoteIP(String s) {\n+        setPair(14, s);\n+    }\n+\n+    public void setBytesSent(String s) {\n+        setPair(15, s);\n+    }", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMjcwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414032708", "bodyText": "this class would be easy to abuse in its current form due to thread safety issues.  suggest you create a Builder class inside this class.  Builder would have the add method, new Builder.build method would return the (immutable) AccessLogDataFormatter.", "author": "donbourne", "createdAt": "2020-04-23T18:36:59Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.data;\n+\n+import java.util.ArrayList;\n+\n+import com.ibm.ws.logging.data.JSONObject.JSONObjectBuilder;\n+\n+/**\n+ *\n+ */\n+public class AccessLogDataFormatter {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMzc2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414033769", "bodyText": "see comment in AccessLogData -- suggest we get rid of this class and just use 2 constants instead.", "author": "donbourne", "createdAt": "2020-04-23T18:38:34Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/FormatSpecifier.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.data;\n+\n+/**\n+ *\n+ */\n+public enum FormatSpecifier {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzNjEyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414036125", "bodyText": "This class name, inside the com.ibm.ws.logging.data package, doesn't indicate it relates to AccessLogData.  suggest you move this class inside AccessLogSource class since that's the only place it has any relevance.", "author": "donbourne", "createdAt": "2020-04-23T18:42:05Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/JsonFieldAdder.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.data;\n+\n+import com.ibm.ws.logging.data.JSONObject.JSONObjectBuilder;\n+\n+/**\n+ *\n+ */\n+public interface JsonFieldAdder {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTIyMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219220", "bodyText": "I don't think it can be moved to AccessLogSource because AccessLogDataFormatter uses the populate method for the field adders. The http transport bundle (where AccessLogSource is located) is not visible to the logging bundle, so we would need to move both", "author": "jennifer-c", "createdAt": "2020-04-30T18:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzNjEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzODU3OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414038579", "bodyText": "a bit unclear...suggest:\nIf value is logFormat, JSON logs will be formatted to include the fields specified in access logging's logFormat field", "author": "donbourne", "createdAt": "2020-04-23T18:46:07Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java", "diffHunk": "@@ -185,6 +186,9 @@\n     /** If true, format the date and time format for log entries in messages.log, trace.log, and FFDC files in ISO-8601 format. */\n     protected volatile boolean isoDateFormat = false;\n \n+    /** If logFormat, format JSON logs to match the logFormat for access logging */", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MTU4Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414151587", "bodyText": "suggest renaming these to make it clear they relate to access logs...\naccessLogCookiesMap, ...", "author": "donbourne", "createdAt": "2020-04-23T21:57:37Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java", "diffHunk": "@@ -493,6 +503,10 @@ public static void applyJsonFields(String value, Boolean omitJsonFields) {\n         Map<String, String> ffdcMap = new HashMap<>();\n         Map<String, String> accessLogMap = new HashMap<>();\n         Map<String, String> auditMap = new HashMap<>();\n+        // For access log data\n+        Map<String, String> cookiesMap = new HashMap<>();\n+        Map<String, String> requestHeaderMap = new HashMap<>();\n+        Map<String, String> responseHeaderMap = new HashMap<>();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MjU4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414152581", "bodyText": "seems like this might have problems if a cookie name has an underscore in it (same goes for request and response headers)", "author": "donbourne", "createdAt": "2020-04-23T21:59:47Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java", "diffHunk": "@@ -536,6 +550,19 @@ public static void applyJsonFields(String value, Boolean omitJsonFields) {\n                     traceMap.put(entry[0], entry[1]);\n                     valueFound = true;\n                 }\n+\n+                // headers and cookies are special because there can be multiple instances\n+                if (entry[0].contains(\"ibm_cookie_\")) {\n+                    cookiesMap.put(entry[0].substring(entry[0].lastIndexOf(\"_\") + 1), entry[1]);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MTg0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414641845", "bodyText": "you're very close to being able to merge this method and the method above... would be good to do that!", "author": "donbourne", "createdAt": "2020-04-24T14:57:28Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -385,24 +386,37 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n \n-        if (tempStartFields != null)\n-            jsonBuilder.addFields(tempStartFields);\n-        else {\n+        if (tempStartFields != null) {\n+            jsonBuilder.addPreformatted(tempStartFields);\n+        } else {\n             //@formatter:off\n-            jsonBuilder.addField(AccessLogData.getTypeKeyJSON(), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n-            .addField(AccessLogData.getHostKeyJSON(), hostName, false, false)\n-            .addField(AccessLogData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-            .addField(AccessLogData.getServerNameKeyJSON(), serverName, false, false);\n+            jsonBuilder.addField(AccessLogData.getTypeKey(fs), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n+            .addField(AccessLogData.getHostKey(fs), hostName, false, false)\n+            .addField(AccessLogData.getUserDirKey(fs), wlpUserDir, false, true)\n+            .addField(AccessLogData.getServerNameKey(fs), serverName, false, false);\n             //@formatter:on\n             startAccessLogJsonFields = jsonBuilder.toString();\n         }\n         return jsonBuilder;\n     }\n \n+    protected static JSONObjectBuilder startAccessLogJsonFieldsLogstash(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MjMyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414652321", "bodyText": "should only ever be running one formatter for one event.  need to pick the right one for each circumstance.", "author": "donbourne", "createdAt": "2020-04-24T15:11:20Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -217,52 +218,29 @@ private static String jsonifyAccess(String wlpUserDir,\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n \n-        StringBuilder sb = CollectorJsonHelpers.startAccessLogJson(hostName, wlpUserDir, serverName);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getUriPathKey(), accessLogData.getUriPath(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestMethodKey(), accessLogData.getRequestMethod(), false, true, false, false, false);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n+        if (formatters[3] != null) {\n+            formatters[3].populate(jsonBuilder, accessLogData);\n         }\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getQueryStringKey(), jsonQueryString, false, true, false, false, false);\n \n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHostKey(), accessLogData.getRequestHost(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestPortKey(), accessLogData.getRequestPort(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteHostKey(), accessLogData.getRemoteHost(), false, true, false, false, false);\n-\n-        String userAgent = accessLogData.getUserAgent();\n-\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[2] != null) {\n+            formatters[2].populate(jsonBuilder, accessLogData);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MDY2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414660668", "bodyText": "should only be using 1 formatter to format an event", "author": "donbourne", "createdAt": "2020-04-24T15:22:57Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java", "diffHunk": "@@ -106,43 +106,26 @@ private static String jsonifyFFDC(int maxFieldLength, String wlpUserDir,\n     public static String jsonifyAccess(String wlpUserDir, String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, FormatSpecifier.JSON);\n+\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n+\n+        if (formatters[1] != null) {\n+            formatters[1].populate(jsonBuilder, accessLogData);\n         }\n \n-        String userAgent = accessLogData.getUserAgent();\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH)\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[0] != null) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MDkzMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414660933", "bodyText": "seems like this should be done by the formatter", "author": "donbourne", "createdAt": "2020-04-24T15:23:17Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java", "diffHunk": "@@ -106,43 +106,26 @@ private static String jsonifyFFDC(int maxFieldLength, String wlpUserDir,\n     public static String jsonifyAccess(String wlpUserDir, String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, FormatSpecifier.JSON);\n+\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n+\n+        if (formatters[1] != null) {\n+            formatters[1].populate(jsonBuilder, accessLogData);\n         }\n \n-        String userAgent = accessLogData.getUserAgent();\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH)\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[0] != null) {\n+            formatters[0].populate(jsonBuilder, accessLogData);\n+        }\n \n         String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-\n         //@formatter:off\n-        jsonBuilder.addField(AccessLogData.getUriPathKeyJSON(), accessLogData.getUriPath(), false, true)\n-        .addField(AccessLogData.getRequestMethodKeyJSON(), accessLogData.getRequestMethod(), false, true)\n-        .addField(AccessLogData.getQueryStringKeyJSON(), jsonQueryString, false, true)\n-        .addField(AccessLogData.getRequestHostKeyJSON(), accessLogData.getRequestHost(), false, true)\n-        .addField(AccessLogData.getRequestPortKeyJSON(), accessLogData.getRequestPort(), false, true)\n-        .addField(AccessLogData.getRemoteHostKeyJSON(), accessLogData.getRemoteHost(), false, true)\n-        .addField(AccessLogData.getUserAgentKeyJSON(), userAgent, false, false)\n-        .addField(AccessLogData.getRequestProtocolKeyJSON(), accessLogData.getRequestProtocol(), false, true)\n-        .addField(AccessLogData.getBytesReceivedKeyJSON(), accessLogData.getBytesReceived(), false)\n-        .addField(AccessLogData.getResponseCodeKeyJSON(), accessLogData.getResponseCode(), false)\n-        .addField(AccessLogData.getElapsedTimeKeyJSON(), accessLogData.getElapsedTime(), false)\n-        .addField(AccessLogData.getDatetimeKeyJSON(), datetime, false, true)\n-        .addField(AccessLogData.getSequenceKeyJSON(), accessLogData.getSequence(), false, true);\n+        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.JSON), datetime, false, true)\n+                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.JSON), accessLogData.getSequence(), false, true);\n         //@formatter:on", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MjAwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414662001", "bodyText": "this seems like it should all be done as part of the formatters", "author": "donbourne", "createdAt": "2020-04-24T15:24:41Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -217,52 +218,29 @@ private static String jsonifyAccess(String wlpUserDir,\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n \n-        StringBuilder sb = CollectorJsonHelpers.startAccessLogJson(hostName, wlpUserDir, serverName);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getUriPathKey(), accessLogData.getUriPath(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestMethodKey(), accessLogData.getRequestMethod(), false, true, false, false, false);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n+        if (formatters[3] != null) {\n+            formatters[3].populate(jsonBuilder, accessLogData);\n         }\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getQueryStringKey(), jsonQueryString, false, true, false, false, false);\n \n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHostKey(), accessLogData.getRequestHost(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestPortKey(), accessLogData.getRequestPort(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteHostKey(), accessLogData.getRemoteHost(), false, true, false, false, false);\n-\n-        String userAgent = accessLogData.getUserAgent();\n-\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[2] != null) {\n+            formatters[2].populate(jsonBuilder, accessLogData);\n         }\n \n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getUserAgentKey(), userAgent, false, false, false, false, false);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestProtocolKey(), accessLogData.getRequestProtocol(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getBytesReceivedKey(), Long.toString(accessLogData.getBytesReceived()), false, true, false, false, true);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getResponseCodeKey(), Integer.toString(accessLogData.getResponseCode()), false, true, false, false, true);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getElapsedTimeKey(), Long.toString(accessLogData.getElapsedTime()), false, true, false, false, true);\n-\n         String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getDatetimeKey(), datetime, false, true, false, false, false);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getSequenceKey(), accessLogData.getSequence(), false, true, false, false, false);\n+        //@formatter:off\n+        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.LOGSTASH), datetime, false, true)\n+                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.LOGSTASH), accessLogData.getSequence(), false, true);\n+        //@formatter:on", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2NjIwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414666206", "bodyText": "missing a constant for logFormat?", "author": "donbourne", "createdAt": "2020-04-24T15:30:17Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/LoggingConstants.java", "diffHunk": "@@ -56,6 +56,9 @@\n     //beta env var for omission of json fields\n     String ENV_WLP_LOGGING_OMIT_JSON_FIELD_MAPPINGS = \"WLP_LOGGING_OMIT_JSON_FIELD_MAPPINGS\";\n \n+    String ENV_WLP_LOGGING_JSON_ACCESS_LOG_FIELDS = \"WLP_LOGGING_JSON_ACCESS_LOG_FIELDS\";\n+    String DEFAULT_JSON_ACCESS_LOG_FIELDS = \"default\";", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU3MjQ0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418572445", "bodyText": "I can add it, but not sure where we'd need to use it", "author": "jennifer-c", "createdAt": "2020-05-01T14:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2NjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4MzM2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414683366", "bodyText": "goal of this token is to have the SAME value for time as is written into the access log file... can't get a new time value.", "author": "donbourne", "createdAt": "2020-04-24T15:54:28Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java", "diffHunk": "@@ -50,4 +49,15 @@ public boolean set(StringBuilder accessLogEntry,\n         return true;\n     }\n \n+    public static String getAccessLogCurrentTimeAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        StringBuilder accessLogCurrentTime = new StringBuilder();\n+        if (data == null) {\n+            accessLogCurrentTime.append(\"[\");\n+            accessLogCurrentTime.append(HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis())));", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MDkyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414740924", "bodyText": "can't store this in a static variable -- requests arrive concurrently on multiple threads.", "author": "donbourne", "createdAt": "2020-04-24T17:25:44Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java", "diffHunk": "@@ -24,10 +24,26 @@ public AccessLogElapsedTime() {\n         // Millisecond accuracy, microsecond precision\n     }\n \n+    // Need some way to \"remember\" the elapsedTime value; the System.nanoTime - startTime\n+    static long currentTime = 0;", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MzEzMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414743131", "bodyText": "line 33 already ensures request != null, so you don't need to check that in each line", "author": "donbourne", "createdAt": "2020-04-24T17:29:16Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java", "diffHunk": "@@ -31,10 +31,10 @@ public boolean set(StringBuilder accessLogEntry,\n         String requestVersion = null;\n \n         if (request != null) {\n-            requestMethod = request.getMethod();\n-            requestURI = request.getRequestURI();\n-            requestQueryString = request.getQueryString();\n-            requestVersion = request.getVersion();\n+            requestMethod = (request == null) ? null : request.getMethod();\n+            requestURI = (request == null) ? null : request.getRequestURI();\n+            requestQueryString = (request == null) ? null : request.getQueryString();\n+            requestVersion = (request == null) ? null : request.getVersion();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MzY3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414743677", "bodyText": "line 66 ensures request != null", "author": "donbourne", "createdAt": "2020-04-24T17:30:08Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java", "diffHunk": "@@ -51,4 +51,26 @@ public boolean set(StringBuilder accessLogEntry,\n \n         return true;\n     }\n+\n+    public static String getFirstLineAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        if (request != null) {\n+            StringBuilder sb = new StringBuilder();\n+            String requestMethod = (request == null) ? null : request.getMethod();\n+            String requestURI = (request == null) ? null : request.getRequestURI();\n+            String requestQueryString = (request == null) ? null : request.getQueryString();\n+            String requestVersion = (request == null) ? null : request.getVersion();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0ODM3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414748371", "bodyText": "for each of these com.ibm.ws.http.channel.internal.values should we should standardize on a set of methods?  it looks like we may have need for\n\nget the value for the access log\nget the value for the JSON log", "author": "donbourne", "createdAt": "2020-04-24T17:38:02Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogRemoteIP.java", "diffHunk": "@@ -27,6 +27,17 @@ public AccessLogRemoteIP() {\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request,\n                        Object data) {\n+        String hostIPAddress = getRemoteIP(response, request, data);\n+\n+        if (hostIPAddress != null) {\n+            accessLogEntry.append(hostIPAddress);\n+        } else {\n+            accessLogEntry.append(\"-\");\n+        }\n+        return true;\n+    }\n+\n+    public static String getRemoteIP(HttpResponseMessage response, HttpRequestMessage request, Object data) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MDUyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414770529", "bodyText": "want time to match between access log and json log", "author": "donbourne", "createdAt": "2020-04-24T18:14:39Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java", "diffHunk": "@@ -57,4 +57,17 @@ public static long getStartTime(HttpResponseMessage response, HttpRequestMessage\n         return startTime;\n     }\n \n+    public static String getStartTimeAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        StringBuilder requestStartTime = new StringBuilder();\n+        long startTime = getStartTime(response, request, data);\n+        if (startTime != 0) {\n+            Date startDate = new Date(startTime);\n+            requestStartTime.append(\"[\");\n+            requestStartTime.append(HttpDispatcher.getDateFormatter().getNCSATime(startDate));", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MjE2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414772166", "bodyText": "This appears to be part of our already published SPI -- can't change it", "author": "donbourne", "createdAt": "2020-04-24T18:17:28Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/wsspi/http/logging/AccessLogForwarder.java", "diffHunk": "@@ -10,9 +10,17 @@\n  *******************************************************************************/\n package com.ibm.wsspi.http.logging;\n \n+import com.ibm.ws.http.logging.internal.AccessLogger.FormatSegment;\n+\n /**\n  * The Access log forwarder is invoked after each http request.\n  */\n public interface AccessLogForwarder {\n-    public void process(AccessLogRecordData logData);\n+    /**\n+     *\n+     * @param logData\n+     * @param parsedFormat A parsed version of logFormat\n+     * @param formatString The original logFormat string\n+     */\n+    public void process(AccessLogRecordData logData, FormatSegment[] parsedFormat, String formatString);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyODMxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414828313", "bodyText": "would help to put \"config\" somewhere in these names to make that more obvious when reading the code", "author": "donbourne", "createdAt": "2020-04-24T19:58:43Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDI4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414834282", "bodyText": "need a comment here to indicate what each of these 4 formatters represents", "author": "donbourne", "createdAt": "2020-04-24T20:10:12Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjA3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414836070", "bodyText": "we probably need a ConcurrentHashMap<logFormat, SetterFormatter>.  that way, when a request comes in we can pick the SetterFormatter appropriate to the HTTP endpoint that is processing it.  that would technically be an very very tiny memory leak (since we have no way to clean it up) -- but it's too small to worry about.", "author": "donbourne", "createdAt": "2020-04-24T20:13:46Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MTI1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414841251", "bodyText": "include comments to show what you expect for the values of these fields", "author": "donbourne", "createdAt": "2020-04-24T20:23:54Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzE2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414843165", "bodyText": "add a comment to indicate that the returned setters should not be modified to avoid concurrency issues with other threads using the same setter list", "author": "donbourne", "createdAt": "2020-04-24T20:27:16Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+\n+        private SetterFormatter() {\n+            this.logFormat = \"\";\n+            this.loggingConfig = \"\";\n+            this.logstashConfig = \"\";\n+        }\n+\n+        void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n+            this.setters = setters;\n+            this.formatters = formatters;\n+        }\n+\n+        List<AccessLogDataFieldSetter> getSetters() {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzI3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414843271", "bodyText": "add a comment to indicate that the returned formatters should not be modified to avoid concurrency issues with other threads using the same formatter list", "author": "donbourne", "createdAt": "2020-04-24T20:27:31Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+\n+        private SetterFormatter() {\n+            this.logFormat = \"\";\n+            this.loggingConfig = \"\";\n+            this.logstashConfig = \"\";\n+        }\n+\n+        void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n+            this.setters = setters;\n+            this.formatters = formatters;\n+        }\n+\n+        List<AccessLogDataFieldSetter> getSetters() {\n+            return this.setters;\n+        }\n+\n+        AccessLogDataFormatter[] getFormatters() {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0Mzg3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414843872", "bodyText": "suggest you delete this method and instead require these strings on the constructor.  avoids having to worry about someone trying to mutate this class after it's created.", "author": "donbourne", "createdAt": "2020-04-24T20:28:42Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+\n+        private SetterFormatter() {\n+            this.logFormat = \"\";\n+            this.loggingConfig = \"\";\n+            this.logstashConfig = \"\";\n+        }\n+\n+        void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n+            this.setters = setters;\n+            this.formatters = formatters;\n+        }\n+\n+        List<AccessLogDataFieldSetter> getSetters() {\n+            return this.setters;\n+        }\n+\n+        AccessLogDataFormatter[] getFormatters() {\n+            return this.formatters;\n+        }\n+\n+        boolean checkConfigChange(String logFormat, String loggingConfig, String logstashConfig) {\n+            if (!logFormat.equals(this.logFormat) || !loggingConfig.equals(this.loggingConfig) || !logstashConfig.equals(this.logstashConfig))\n+                return true;\n+            return false;\n+        }\n+\n+        void setFullConfig(String logFormat, String loggingConfig, String logstashConfig) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwNzM3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414907372", "bodyText": "make private?", "author": "donbourne", "createdAt": "2020-04-24T22:57:26Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwODc0MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414908741", "bodyText": "make private?", "author": "donbourne", "createdAt": "2020-04-24T23:01:17Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxMjEzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414912138", "bodyText": "put a comment above this line to call out why you are taking a copy of the reference (so that we don't forget in future)", "author": "donbourne", "createdAt": "2020-04-24T23:11:58Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {\n+\n+        ArrayList<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        for (String f : fields.keySet()) {\n+            switch (f) {\n+                //@formatter:off\n+                case \"%h\": fieldSetters.add((ald, alrd) -> ald.setRemoteHost(alrd.getRemoteAddress())); break;\n+                case \"%H\": fieldSetters.add((ald, alrd) -> ald.setRequestProtocol(alrd.getVersion())); break;\n+                case \"%A\": fieldSetters.add((ald, alrd) -> ald.setRequestHost(alrd.getLocalIP())); break;\n+                case \"%B\": fieldSetters.add((ald, alrd) -> ald.setBytesReceived(alrd.getBytesWritten())); break;\n+                case \"%m\": fieldSetters.add((ald, alrd) -> ald.setRequestMethod(alrd.getRequest().getMethod())); break;\n+                case \"%p\": fieldSetters.add((ald, alrd) -> ald.setRequestPort(alrd.getLocalPort())); break;\n+                case \"%q\": fieldSetters.add((ald, alrd) -> ald.setQueryString(alrd.getRequest().getQueryString())); break;\n+                case \"%{R}W\": fieldSetters.add((ald, alrd) -> ald.setElapsedTime(alrd.getElapsedTime())); break;\n+                case \"%s\": fieldSetters.add((ald, alrd) -> ald.setResponseCode(alrd.getResponse().getStatusCodeAsInt())); break;\n+                case \"%U\": fieldSetters.add((ald, alrd) -> ald.setUriPath(alrd.getRequest().getRequestURI())); break;\n+                // New - access log only fields\n+                case \"%a\": fieldSetters.add((ald, alrd) -> ald.setRemoteIP(AccessLogRemoteIP.getRemoteIP(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%b\": fieldSetters.add((ald, alrd) -> ald.setBytesSent(AccessLogResponseSize.getResponseSizeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%C\":\n+                    if (fields.get(\"%C\") == null) {\n+                        fieldSetters.add((ald, alrd) -> AccessLogRequestCookie.getAllCookies(alrd.getResponse(), alrd.getRequest(), null)\n+                                                        .forEach(c -> ald.setCookies(c.getName(), c.getValue())));\n+                    } else {\n+                        for (Object data : fields.get(\"%C\")) {\n+                            fieldSetters.add((ald, alrd) -> {\n+                                HttpCookie c = AccessLogRequestCookie.getCookie(alrd.getResponse(), alrd.getRequest(), data);\n+                                if (c != null)\n+                                    ald.setCookies(c.getName(), c.getValue());\n+                            });\n+                        }\n+                    } break;\n+                case \"%D\": fieldSetters.add((ald, alrd) -> ald.setRequestElapsedTime(AccessLogElapsedTime.getElapsedTime(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%i\":\n+                    for (Object data : fields.get(\"%i\")) {\n+                        if (data.equals(USER_AGENT_HEADER))\n+                            fieldSetters.add((ald, alrd) -> ald.setUserAgent(alrd.getRequest().getHeader(USER_AGENT_HEADER).asString()));\n+                        else if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setRequestHeader((String) data, AccessLogRequestHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%o\":\n+                    for (Object data : fields.get(\"%o\")) {\n+                        if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setResponseHeader((String) data, AccessLogResponseHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%r\": fieldSetters.add((ald, alrd) -> ald.setRequestFirstLine(AccessLogFirstLine.getFirstLineAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%t\": fieldSetters.add((ald, alrd) -> ald.setRequestStartTime(AccessLogStartTime.getStartTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%{t}W\": fieldSetters.add((ald, alrd) -> ald.setAccessLogDatetime(AccessLogCurrentTime.getAccessLogCurrentTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%u\": fieldSetters.add((ald, alrd) -> ald.setRemoteUser(AccessLogRemoteUser.getRemoteUser(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                //@formatter:on\n+            }\n+        }\n+        return fieldSetters;\n+    }\n+\n+    AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, FormatSpecifier format) {\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+        boolean isFirstCookie = true;\n+        boolean isFirstRequestHeader = true;\n+        boolean isFirstResponseHeader = true;\n+        for (FormatSegment s : parsedFormat) {\n+            if (s.log != null) {\n+                switch (s.log.getName()) {\n+                    // Original - default fields\n+                    //@formatter:off\n+                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n+                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n+                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    // New - access log only fields\n+                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%C\":\n+                        if (isFirstCookie) {\n+                            formatter.add(addCookiesField(format));\n+                            isFirstCookie = false;\n+                        } break;\n+                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%i\":\n+                        if (s.data.equals(USER_AGENT_HEADER)) {\n+                            formatter.add(addUserAgentField(format));\n+                        } else if (isFirstRequestHeader) {\n+                            formatter.add(addRequestHeaderField(format));\n+                            isFirstRequestHeader = false;\n+                        } break;\n+                    case \"%o\":\n+                        if (isFirstResponseHeader) {\n+                            formatter.add(addResponseHeaderField(format));\n+                            isFirstResponseHeader = false;\n+                        } break;\n+                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    //@formatter:on\n+                }\n+            }\n+        }\n+        return formatter;\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n+\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+\n+        formatter = new AccessLogDataFormatter();\n+        // %h\n+        formatter.add(addRemoteHostField(format));\n+        // %H\n+        formatter.add(addRequestProtocolField(format));\n+        // %A\n+        formatter.add(addRequestHostField(format));\n+        // %B\n+        formatter.add(addBytesReceivedField(format));\n+        // %m\n+        formatter.add(addRequestMethodField(format));\n+        // %p\n+        formatter.add(addRequestPortField(format));\n+        // %q\n+        formatter.add(addQueryStringField(format));\n+        // %{R}W\n+        formatter.add(addElapsedTimeField(format));\n+        // %s\n+        formatter.add(addResponseCodeField(format));\n+        // %U\n+        formatter.add(addUriPathField(format));\n+        // User agent\n+        formatter.add(addUserAgentField(format));\n+        return formatter;\n+    }\n+\n     private class AccessLogHandler implements AccessLogForwarder {\n \n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-        public void process(AccessLogRecordData recordData) {\n-            HttpRequestMessage request = recordData.getRequest();\n-            HttpResponseMessage response = recordData.getResponse();\n-\n-            if (request != null) {\n-\n-                AccessLogData accessLogData = new AccessLogData();\n-\n-                long requestStartTimeVal = recordData.getStartTime();\n-                accessLogData.setRequestStartTime(requestStartTimeVal);\n-                accessLogData.setUriPath(request.getRequestURI());\n-                accessLogData.setRequestMethod(request.getMethod());\n-                accessLogData.setQueryString(request.getQueryString());\n-                accessLogData.setRequestHost(recordData.getLocalIP());\n-                accessLogData.setRequestPort(recordData.getLocalPort());\n-                accessLogData.setRemoteHost(recordData.getRemoteAddress());\n-                accessLogData.setUserAgent(request.getHeader(USER_AGENT_HEADER).asString());\n-                accessLogData.setRequestProtocol(request.getVersion());\n-                accessLogData.setBytesReceived(recordData.getBytesWritten());\n-                accessLogData.setResponseCode(response.getStatusCodeAsInt());\n-                accessLogData.setElapsedTime(recordData.getElapsedTime());\n-                accessLogData.setDatetime(recordData.getTimestamp());\n-\n-                String sequenceVal = requestStartTimeVal + \"_\" + String.format(\"%013X\", seq.incrementAndGet());\n-                accessLogData.setSequence(sequenceVal);\n-\n-                accessLogData.setSourceName(sourceName);\n-\n-                bufferMgr.add(accessLogData);\n-\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n+\n+        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n+            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n+                SetterFormatter newSF = new SetterFormatter();\n+                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+                AccessLogDataFormatter[] formatters = { null, null, null, null };\n+                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+                // Create the mapping of fields to add:{<format key> : <data value/null>}\n+                // Prevents duplicates\n+                initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n+\n+                // Create setter list\n+                fieldSetters = populateSetters(fieldsToAdd);\n+                // These fields are always added\n+                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+                if (jsonAccessLogFields.equals(\"default\")) {\n+                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n+                }\n+                if (jsonAccessLogFields.equals(\"logFormat\")) {\n+                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n                 }\n+                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n+                }\n+                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+                }\n+\n+                newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+                currentSF = newSF;\n+\n+            }\n+            SetterFormatter temp = currentSF;", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxMjgzMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414912830", "bodyText": "put everything inside this if block into another method for initializing the SetterFormatter.  Since most of the time this block is skipped it will make it easier in future to learn/understand the code.", "author": "donbourne", "createdAt": "2020-04-24T23:14:05Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {\n+\n+        ArrayList<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        for (String f : fields.keySet()) {\n+            switch (f) {\n+                //@formatter:off\n+                case \"%h\": fieldSetters.add((ald, alrd) -> ald.setRemoteHost(alrd.getRemoteAddress())); break;\n+                case \"%H\": fieldSetters.add((ald, alrd) -> ald.setRequestProtocol(alrd.getVersion())); break;\n+                case \"%A\": fieldSetters.add((ald, alrd) -> ald.setRequestHost(alrd.getLocalIP())); break;\n+                case \"%B\": fieldSetters.add((ald, alrd) -> ald.setBytesReceived(alrd.getBytesWritten())); break;\n+                case \"%m\": fieldSetters.add((ald, alrd) -> ald.setRequestMethod(alrd.getRequest().getMethod())); break;\n+                case \"%p\": fieldSetters.add((ald, alrd) -> ald.setRequestPort(alrd.getLocalPort())); break;\n+                case \"%q\": fieldSetters.add((ald, alrd) -> ald.setQueryString(alrd.getRequest().getQueryString())); break;\n+                case \"%{R}W\": fieldSetters.add((ald, alrd) -> ald.setElapsedTime(alrd.getElapsedTime())); break;\n+                case \"%s\": fieldSetters.add((ald, alrd) -> ald.setResponseCode(alrd.getResponse().getStatusCodeAsInt())); break;\n+                case \"%U\": fieldSetters.add((ald, alrd) -> ald.setUriPath(alrd.getRequest().getRequestURI())); break;\n+                // New - access log only fields\n+                case \"%a\": fieldSetters.add((ald, alrd) -> ald.setRemoteIP(AccessLogRemoteIP.getRemoteIP(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%b\": fieldSetters.add((ald, alrd) -> ald.setBytesSent(AccessLogResponseSize.getResponseSizeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%C\":\n+                    if (fields.get(\"%C\") == null) {\n+                        fieldSetters.add((ald, alrd) -> AccessLogRequestCookie.getAllCookies(alrd.getResponse(), alrd.getRequest(), null)\n+                                                        .forEach(c -> ald.setCookies(c.getName(), c.getValue())));\n+                    } else {\n+                        for (Object data : fields.get(\"%C\")) {\n+                            fieldSetters.add((ald, alrd) -> {\n+                                HttpCookie c = AccessLogRequestCookie.getCookie(alrd.getResponse(), alrd.getRequest(), data);\n+                                if (c != null)\n+                                    ald.setCookies(c.getName(), c.getValue());\n+                            });\n+                        }\n+                    } break;\n+                case \"%D\": fieldSetters.add((ald, alrd) -> ald.setRequestElapsedTime(AccessLogElapsedTime.getElapsedTime(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%i\":\n+                    for (Object data : fields.get(\"%i\")) {\n+                        if (data.equals(USER_AGENT_HEADER))\n+                            fieldSetters.add((ald, alrd) -> ald.setUserAgent(alrd.getRequest().getHeader(USER_AGENT_HEADER).asString()));\n+                        else if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setRequestHeader((String) data, AccessLogRequestHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%o\":\n+                    for (Object data : fields.get(\"%o\")) {\n+                        if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setResponseHeader((String) data, AccessLogResponseHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%r\": fieldSetters.add((ald, alrd) -> ald.setRequestFirstLine(AccessLogFirstLine.getFirstLineAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%t\": fieldSetters.add((ald, alrd) -> ald.setRequestStartTime(AccessLogStartTime.getStartTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%{t}W\": fieldSetters.add((ald, alrd) -> ald.setAccessLogDatetime(AccessLogCurrentTime.getAccessLogCurrentTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%u\": fieldSetters.add((ald, alrd) -> ald.setRemoteUser(AccessLogRemoteUser.getRemoteUser(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                //@formatter:on\n+            }\n+        }\n+        return fieldSetters;\n+    }\n+\n+    AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, FormatSpecifier format) {\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+        boolean isFirstCookie = true;\n+        boolean isFirstRequestHeader = true;\n+        boolean isFirstResponseHeader = true;\n+        for (FormatSegment s : parsedFormat) {\n+            if (s.log != null) {\n+                switch (s.log.getName()) {\n+                    // Original - default fields\n+                    //@formatter:off\n+                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n+                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n+                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    // New - access log only fields\n+                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%C\":\n+                        if (isFirstCookie) {\n+                            formatter.add(addCookiesField(format));\n+                            isFirstCookie = false;\n+                        } break;\n+                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%i\":\n+                        if (s.data.equals(USER_AGENT_HEADER)) {\n+                            formatter.add(addUserAgentField(format));\n+                        } else if (isFirstRequestHeader) {\n+                            formatter.add(addRequestHeaderField(format));\n+                            isFirstRequestHeader = false;\n+                        } break;\n+                    case \"%o\":\n+                        if (isFirstResponseHeader) {\n+                            formatter.add(addResponseHeaderField(format));\n+                            isFirstResponseHeader = false;\n+                        } break;\n+                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    //@formatter:on\n+                }\n+            }\n+        }\n+        return formatter;\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n+\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+\n+        formatter = new AccessLogDataFormatter();\n+        // %h\n+        formatter.add(addRemoteHostField(format));\n+        // %H\n+        formatter.add(addRequestProtocolField(format));\n+        // %A\n+        formatter.add(addRequestHostField(format));\n+        // %B\n+        formatter.add(addBytesReceivedField(format));\n+        // %m\n+        formatter.add(addRequestMethodField(format));\n+        // %p\n+        formatter.add(addRequestPortField(format));\n+        // %q\n+        formatter.add(addQueryStringField(format));\n+        // %{R}W\n+        formatter.add(addElapsedTimeField(format));\n+        // %s\n+        formatter.add(addResponseCodeField(format));\n+        // %U\n+        formatter.add(addUriPathField(format));\n+        // User agent\n+        formatter.add(addUserAgentField(format));\n+        return formatter;\n+    }\n+\n     private class AccessLogHandler implements AccessLogForwarder {\n \n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-        public void process(AccessLogRecordData recordData) {\n-            HttpRequestMessage request = recordData.getRequest();\n-            HttpResponseMessage response = recordData.getResponse();\n-\n-            if (request != null) {\n-\n-                AccessLogData accessLogData = new AccessLogData();\n-\n-                long requestStartTimeVal = recordData.getStartTime();\n-                accessLogData.setRequestStartTime(requestStartTimeVal);\n-                accessLogData.setUriPath(request.getRequestURI());\n-                accessLogData.setRequestMethod(request.getMethod());\n-                accessLogData.setQueryString(request.getQueryString());\n-                accessLogData.setRequestHost(recordData.getLocalIP());\n-                accessLogData.setRequestPort(recordData.getLocalPort());\n-                accessLogData.setRemoteHost(recordData.getRemoteAddress());\n-                accessLogData.setUserAgent(request.getHeader(USER_AGENT_HEADER).asString());\n-                accessLogData.setRequestProtocol(request.getVersion());\n-                accessLogData.setBytesReceived(recordData.getBytesWritten());\n-                accessLogData.setResponseCode(response.getStatusCodeAsInt());\n-                accessLogData.setElapsedTime(recordData.getElapsedTime());\n-                accessLogData.setDatetime(recordData.getTimestamp());\n-\n-                String sequenceVal = requestStartTimeVal + \"_\" + String.format(\"%013X\", seq.incrementAndGet());\n-                accessLogData.setSequence(sequenceVal);\n-\n-                accessLogData.setSourceName(sourceName);\n-\n-                bufferMgr.add(accessLogData);\n-\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n+\n+        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n+            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n+                SetterFormatter newSF = new SetterFormatter();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxMzQ2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414913469", "bodyText": "put a comment above here to indicate that these are the field formatters", "author": "donbourne", "createdAt": "2020-04-24T23:16:05Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {\n+\n+        ArrayList<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        for (String f : fields.keySet()) {\n+            switch (f) {\n+                //@formatter:off\n+                case \"%h\": fieldSetters.add((ald, alrd) -> ald.setRemoteHost(alrd.getRemoteAddress())); break;\n+                case \"%H\": fieldSetters.add((ald, alrd) -> ald.setRequestProtocol(alrd.getVersion())); break;\n+                case \"%A\": fieldSetters.add((ald, alrd) -> ald.setRequestHost(alrd.getLocalIP())); break;\n+                case \"%B\": fieldSetters.add((ald, alrd) -> ald.setBytesReceived(alrd.getBytesWritten())); break;\n+                case \"%m\": fieldSetters.add((ald, alrd) -> ald.setRequestMethod(alrd.getRequest().getMethod())); break;\n+                case \"%p\": fieldSetters.add((ald, alrd) -> ald.setRequestPort(alrd.getLocalPort())); break;\n+                case \"%q\": fieldSetters.add((ald, alrd) -> ald.setQueryString(alrd.getRequest().getQueryString())); break;\n+                case \"%{R}W\": fieldSetters.add((ald, alrd) -> ald.setElapsedTime(alrd.getElapsedTime())); break;\n+                case \"%s\": fieldSetters.add((ald, alrd) -> ald.setResponseCode(alrd.getResponse().getStatusCodeAsInt())); break;\n+                case \"%U\": fieldSetters.add((ald, alrd) -> ald.setUriPath(alrd.getRequest().getRequestURI())); break;\n+                // New - access log only fields\n+                case \"%a\": fieldSetters.add((ald, alrd) -> ald.setRemoteIP(AccessLogRemoteIP.getRemoteIP(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%b\": fieldSetters.add((ald, alrd) -> ald.setBytesSent(AccessLogResponseSize.getResponseSizeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%C\":\n+                    if (fields.get(\"%C\") == null) {\n+                        fieldSetters.add((ald, alrd) -> AccessLogRequestCookie.getAllCookies(alrd.getResponse(), alrd.getRequest(), null)\n+                                                        .forEach(c -> ald.setCookies(c.getName(), c.getValue())));\n+                    } else {\n+                        for (Object data : fields.get(\"%C\")) {\n+                            fieldSetters.add((ald, alrd) -> {\n+                                HttpCookie c = AccessLogRequestCookie.getCookie(alrd.getResponse(), alrd.getRequest(), data);\n+                                if (c != null)\n+                                    ald.setCookies(c.getName(), c.getValue());\n+                            });\n+                        }\n+                    } break;\n+                case \"%D\": fieldSetters.add((ald, alrd) -> ald.setRequestElapsedTime(AccessLogElapsedTime.getElapsedTime(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%i\":\n+                    for (Object data : fields.get(\"%i\")) {\n+                        if (data.equals(USER_AGENT_HEADER))\n+                            fieldSetters.add((ald, alrd) -> ald.setUserAgent(alrd.getRequest().getHeader(USER_AGENT_HEADER).asString()));\n+                        else if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setRequestHeader((String) data, AccessLogRequestHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%o\":\n+                    for (Object data : fields.get(\"%o\")) {\n+                        if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setResponseHeader((String) data, AccessLogResponseHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%r\": fieldSetters.add((ald, alrd) -> ald.setRequestFirstLine(AccessLogFirstLine.getFirstLineAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%t\": fieldSetters.add((ald, alrd) -> ald.setRequestStartTime(AccessLogStartTime.getStartTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%{t}W\": fieldSetters.add((ald, alrd) -> ald.setAccessLogDatetime(AccessLogCurrentTime.getAccessLogCurrentTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%u\": fieldSetters.add((ald, alrd) -> ald.setRemoteUser(AccessLogRemoteUser.getRemoteUser(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                //@formatter:on\n+            }\n+        }\n+        return fieldSetters;\n+    }\n+\n+    AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, FormatSpecifier format) {\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+        boolean isFirstCookie = true;\n+        boolean isFirstRequestHeader = true;\n+        boolean isFirstResponseHeader = true;\n+        for (FormatSegment s : parsedFormat) {\n+            if (s.log != null) {\n+                switch (s.log.getName()) {\n+                    // Original - default fields\n+                    //@formatter:off\n+                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n+                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n+                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    // New - access log only fields\n+                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%C\":\n+                        if (isFirstCookie) {\n+                            formatter.add(addCookiesField(format));\n+                            isFirstCookie = false;\n+                        } break;\n+                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%i\":\n+                        if (s.data.equals(USER_AGENT_HEADER)) {\n+                            formatter.add(addUserAgentField(format));\n+                        } else if (isFirstRequestHeader) {\n+                            formatter.add(addRequestHeaderField(format));\n+                            isFirstRequestHeader = false;\n+                        } break;\n+                    case \"%o\":\n+                        if (isFirstResponseHeader) {\n+                            formatter.add(addResponseHeaderField(format));\n+                            isFirstResponseHeader = false;\n+                        } break;\n+                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    //@formatter:on\n+                }\n+            }\n+        }\n+        return formatter;\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n+\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+\n+        formatter = new AccessLogDataFormatter();\n+        // %h\n+        formatter.add(addRemoteHostField(format));\n+        // %H\n+        formatter.add(addRequestProtocolField(format));\n+        // %A\n+        formatter.add(addRequestHostField(format));\n+        // %B\n+        formatter.add(addBytesReceivedField(format));\n+        // %m\n+        formatter.add(addRequestMethodField(format));\n+        // %p\n+        formatter.add(addRequestPortField(format));\n+        // %q\n+        formatter.add(addQueryStringField(format));\n+        // %{R}W\n+        formatter.add(addElapsedTimeField(format));\n+        // %s\n+        formatter.add(addResponseCodeField(format));\n+        // %U\n+        formatter.add(addUriPathField(format));\n+        // User agent\n+        formatter.add(addUserAgentField(format));\n+        return formatter;\n+    }\n+\n     private class AccessLogHandler implements AccessLogForwarder {\n \n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-        public void process(AccessLogRecordData recordData) {\n-            HttpRequestMessage request = recordData.getRequest();\n-            HttpResponseMessage response = recordData.getResponse();\n-\n-            if (request != null) {\n-\n-                AccessLogData accessLogData = new AccessLogData();\n-\n-                long requestStartTimeVal = recordData.getStartTime();\n-                accessLogData.setRequestStartTime(requestStartTimeVal);\n-                accessLogData.setUriPath(request.getRequestURI());\n-                accessLogData.setRequestMethod(request.getMethod());\n-                accessLogData.setQueryString(request.getQueryString());\n-                accessLogData.setRequestHost(recordData.getLocalIP());\n-                accessLogData.setRequestPort(recordData.getLocalPort());\n-                accessLogData.setRemoteHost(recordData.getRemoteAddress());\n-                accessLogData.setUserAgent(request.getHeader(USER_AGENT_HEADER).asString());\n-                accessLogData.setRequestProtocol(request.getVersion());\n-                accessLogData.setBytesReceived(recordData.getBytesWritten());\n-                accessLogData.setResponseCode(response.getStatusCodeAsInt());\n-                accessLogData.setElapsedTime(recordData.getElapsedTime());\n-                accessLogData.setDatetime(recordData.getTimestamp());\n-\n-                String sequenceVal = requestStartTimeVal + \"_\" + String.format(\"%013X\", seq.incrementAndGet());\n-                accessLogData.setSequence(sequenceVal);\n-\n-                accessLogData.setSourceName(sourceName);\n-\n-                bufferMgr.add(accessLogData);\n-\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n+\n+        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n+            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n+                SetterFormatter newSF = new SetterFormatter();\n+                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+                AccessLogDataFormatter[] formatters = { null, null, null, null };\n+                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+                // Create the mapping of fields to add:{<format key> : <data value/null>}\n+                // Prevents duplicates\n+                initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n+\n+                // Create setter list\n+                fieldSetters = populateSetters(fieldsToAdd);\n+                // These fields are always added\n+                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+                if (jsonAccessLogFields.equals(\"default\")) {\n+                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n+                }\n+                if (jsonAccessLogFields.equals(\"logFormat\")) {\n+                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n                 }\n+                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n+                }\n+                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+                }\n+\n+                newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+                currentSF = newSF;\n+\n+            }\n+            SetterFormatter temp = currentSF;\n+            AccessLogData accessLogData = new AccessLogData();\n+            for (AccessLogDataFieldSetter s : temp.getSetters()) {\n+                s.add(accessLogData, recordData);\n+            }\n+\n+            accessLogData.addFormatters(temp.getFormatters());\n+            // collectorJSONUtils does the rest of the work from here\n+\n+            accessLogData.setSourceName(sourceName);\n+\n+            bufferMgr.add(accessLogData);\n+\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n             }\n         }\n     }\n+\n+    private static JsonFieldAdder addRemoteHostField(FormatSpecifier format) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxOTUxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414919512", "bodyText": "a few other suggested tests\n\nchanging access log format while server is running\ndisabling access log while server is running\nenabling access log while server is running\n2 http endpoints, each with different access log format settings\na server with tokens in access log format that are invalid\na server with tokens in access log format that are repeated\n\nadd trace to the initialization of SetterFormatters and add a test to make sure that initialization only happens twice with 2 HTTP endpoints, each with different access log format settings", "author": "donbourne", "createdAt": "2020-04-24T23:36:49Z", "path": "dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.fat;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.impl.LibertyServerFactory;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class CustomAccessLogFieldsTest {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMjAwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414922007", "bodyText": "need to also have checks to show that json only includes the expected fields (no unexpected fields)", "author": "donbourne", "createdAt": "2020-04-24T23:45:41Z", "path": "dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.fat;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.impl.LibertyServerFactory;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class CustomAccessLogFieldsTest {\n+    private static final String MESSAGE_LOG = \"logs/messages.log\";\n+\n+    @Server(\"CustomAccessLogFieldsEnv\")\n+    public static LibertyServer envServer;\n+\n+    @Server(\"CustomAccessLogFieldsBootstrap\")\n+    public static LibertyServer bootstrapServer;\n+\n+    @Server(\"CustomAccessLogFieldsXml\")\n+    public static LibertyServer xmlServer;\n+\n+    @Server(\"CustomAccessLogFieldsBadConfig\")\n+    public static LibertyServer badConfigServer;\n+\n+    private static final String SERVER_NAME_ENV = \"CustomAccessLogFieldsEnv\";\n+    private static final String SERVER_NAME_BOOTSTRAP = \"CustomAccessLogFieldsBootstrap\";\n+    private static final String SERVER_NAME_XML = \"CustomAccessLogFieldsXml\";\n+    private static final String SERVER_NAME_BAD_CONFIG = \"CustomAccessLogFieldsBadConfig\";\n+\n+    // variable naming convention?\n+    private final String[] newFields = { \"ibm_remoteIP\", \"ibm_bytesSent\", \"ibm_cookie\", \"ibm_requestElapsedTime\", \"ibm_requestHeader\",\n+                                         \"ibm_responseHeader\", \"ibm_requestFirstLine\", \"ibm_requestStartTime\", \"ibm_accessLogDatetime\", \"ibm_remoteUserID\" };\n+\n+    private static LibertyServer serverInUse; // hold on to the server currently used so cleanUp knows which server to stop\n+\n+    @BeforeClass\n+    public static void initialSetup() throws Exception {\n+        envServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_ENV);\n+        bootstrapServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_BOOTSTRAP);\n+        xmlServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_XML);\n+        badConfigServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_BAD_CONFIG);\n+\n+        // Preserve the original server configuration\n+        envServer.saveServerConfiguration();\n+        bootstrapServer.saveServerConfiguration();\n+        xmlServer.saveServerConfiguration();\n+        badConfigServer.saveServerConfiguration();\n+    }\n+\n+    public void setUp(LibertyServer server) throws Exception {\n+        serverInUse = server;\n+        if (server != null && !server.isStarted()) {\n+            // Restore the original server configuration, before starting the server for each test case.\n+            server.restoreServerConfiguration();\n+            server.startServer();\n+        }\n+    }\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        if (serverInUse != null && serverInUse.isStarted()) {\n+            serverInUse.stopServer(\"com.ibm.ws.logging.fat.ffdc.servlet.FFDCServlet.doGet\", \"ArithmeticException\",\n+                                   \"CWWKG0081E\", \"CWWKG0083W\");\n+        }\n+    }\n+\n+    /*\n+     * This test sets the \"WLP_ENABLE_CUSTOM_ACCESS_LOG_FIELDS\" attribute in the server.env and verifies the property in the messages.log file.\n+     */\n+    @Test\n+    public void testAccessLogFieldNamesEnv() throws Exception {\n+        setUp(envServer);\n+        hitWebPage(\"\", \"\", envServer);\n+        List<String> lines = envServer.findStringsInFileInLibertyServerRoot(\"liberty_accesslog\", MESSAGE_LOG);\n+        System.out.println(lines.get(0));\n+\n+        assertTrue(\"There are fields missing in the output JSON log.\", areAllFieldsPresent(lines));\n+    }\n+\n+    /*\n+     * This test sets the \"WLP_ENABLE_CUSTOM_ACCESS_LOG_FIELDS\" attribute in the server.env and verifies the property in the messages.log file.\n+     */\n+    @Test\n+    public void testAccessLogFieldNamesBootstrap() throws Exception {\n+        setUp(bootstrapServer);\n+        hitWebPage(\"\", \"\", bootstrapServer);\n+        List<String> lines = bootstrapServer.findStringsInFileInLibertyServerRoot(\"liberty_accesslog\", MESSAGE_LOG);\n+        System.out.println(lines.get(0));\n+\n+        assertTrue(\"There are fields missing in the output JSON log.\", areAllFieldsPresent(lines));\n+    }\n+\n+    /*\n+     * This test sets the \"WLP_ENABLE_CUSTOM_ACCESS_LOG_FIELDS\" attribute in the server.env and verifies the property in the messages.log file.\n+     */\n+    @Test\n+    public void testAccessLogFieldNamesXml() throws Exception {\n+        setUp(xmlServer);\n+        hitWebPage(\"\", \"\", xmlServer);\n+        List<String> lines = xmlServer.findStringsInFileInLibertyServerRoot(\"liberty_accesslog\", MESSAGE_LOG);\n+        System.out.println(lines.get(0));\n+\n+        assertTrue(\"There are fields missing in the output JSON log.\", areAllFieldsPresent(lines));\n+    }\n+\n+    @Test\n+    public void testAccessLogFaultyConfig() throws Exception {\n+        // Should we have 3 tests to test each version? Can one test stop and start server 3x?\n+        setUp(badConfigServer);\n+        List<String> lines = badConfigServer.findStringsInFileInLibertyServerRoot(\"TRAS3012W\", MESSAGE_LOG);\n+\n+        assertNotNull(\"The error message was not sent with a bad configuration.\", lines);\n+    }\n+\n+    @Test\n+    public void testRenameAccessLogField() throws Exception {\n+        // rename header, cookie\n+        // rename broadly\n+    }\n+\n+    @Test\n+    public void testOmitAccessLogField() throws Exception {\n+        // omit specific header, cookie\n+        // omit broadly\n+    }\n+\n+    @Test\n+    public void testNullValuesDontPrintInJSON() throws Exception {\n+        // in the access log, it'll print `-` but in the JSON log it shouldn't print at all\n+        // test w/ header, cookie\n+    }\n+\n+    @Test\n+    public void testFieldsInAccessLogAreSameInJSON() throws Exception {\n+        // test that the fields in the access log print the same value in the JSON logs\n+    }\n+\n+    @Test\n+    public void testOnlyUnchangingField() throws Exception {\n+        // test that specifying `= logFormat` doesn't print out the original set of fields unless specified\n+        // %h %H %A %B %m %p %q %R{W} %s %U <- should not be printed out\n+    }\n+\n+    public boolean areAllFieldsPresent(List<String> lines) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMjUzMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418722530", "bodyText": "instead of not having the same optimization for logstashCollector, would be better to have a separate startAccessLogLogstashCollector string that would hold the cached starting fields for LC", "author": "donbourne", "createdAt": "2020-05-01T20:25:31Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -386,37 +385,26 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n \n-        if (tempStartFields != null) {\n+        if (tempStartFields != null && format == AccessLogData.KEYS_JSON) {\n+            // Only applies for JSON fields, or else we'd print the wrong fields for Logstash Collector", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MTE0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418741145", "bodyText": "should probably have a final else condition on this that throws a RuntimeException indicating that there was no formatter for the event.  be sure to test that code path so that you know where this RuntimeException gets caught and doesn't break anything.", "author": "donbourne", "createdAt": "2020-05-01T21:15:19Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -218,24 +217,17 @@ private static String jsonifyAccess(String wlpUserDir,\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, AccessLogData.KEYS_LOGSTASH);\n \n         AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n+        // Only one of these will not be null - there is only one formatter per event. If both are not null, we made a mistake earlier in AccessLogSource\n         if (formatters[3] != null) {\n             formatters[3].populate(jsonBuilder, accessLogData);\n-        }\n-\n-        if (formatters[2] != null) {\n+        } else if (formatters[2] != null) {", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0NDE0MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418744141", "bodyText": "A bit unclear...suggest...\nWe only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field", "author": "donbourne", "createdAt": "2020-05-01T21:23:47Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -136,342 +141,116 @@ private void setPair(int index, long l) {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s) {\n-        setPair(0, s);\n-    }\n-\n-    public void setUriPath(String s) {\n-        setPair(1, s);\n-    }\n-\n-    public void setRequestMethod(String s) {\n-        setPair(2, s);\n-    }\n-\n-    public void setQueryString(String s) {\n-        setPair(3, s);\n-    }\n-\n-    public void setRequestHost(String s) {\n-        setPair(4, s);\n-    }\n-\n-    public void setRequestPort(String s) {\n-        setPair(5, s);\n-    }\n-\n-    public void setRemoteHost(String s) {\n-        setPair(6, s);\n-    }\n-\n-    public void setUserAgent(String s) {\n-        setPair(7, s);\n-    }\n-\n-    public void setRequestProtocol(String s) {\n-        setPair(8, s);\n-    }\n-\n-    public void setBytesReceived(long l) {\n-        setPair(9, l);\n-    }\n-\n-    public void setResponseCode(int i) {\n-        setPair(10, i);\n-    }\n-\n-    public void setElapsedTime(long l) {\n-        setPair(11, l);\n-    }\n-\n-    // Datetime also not part of logFormat\n-    public void setDatetime(long l) {\n-        setPair(12, l);\n-    }\n-\n-    // Sequence also not part of logFormat\n-    public void setSequence(String s) {\n-        setPair(13, s);\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n+    // @formatter:off\n+    public void setRequestStartTime(String s)  { setPair(0, s); }\n+    public void setUriPath(String s)           { setPair(1, s); }\n+    public void setRequestMethod(String s)     { setPair(2, s); }\n+    public void setQueryString(String s)       { setPair(3, s); }\n+    public void setRequestHost(String s)       { setPair(4, s); }\n+    public void setRequestPort(String s)       { setPair(5, s); }\n+    public void setRemoteHost(String s)        { setPair(6, s); }\n+    public void setUserAgent(String s)         { setPair(7, s); }\n+    public void setRequestProtocol(String s)   { setPair(8, s); }\n+    public void setBytesReceived(long l)       { setPair(9, l); }\n+    public void setResponseCode(int i)         { setPair(10, i); }\n+    public void setElapsedTime(long l)         { setPair(11, l); }\n+    public void setDatetime(long l)            { setPair(12, l); }\n+    public void setSequence(String s)          { setPair(13, s); }\n     // New optional access log fields\n-    public void setRemoteIP(String s) {\n-        setPair(14, s);\n-    }\n-\n-    public void setBytesSent(String s) {\n-        setPair(15, s);\n-    }\n-\n+    public void setRemoteIP(String s)          { setPair(14, s); }\n+    public void setBytesSent(String s)         { setPair(15, s); }\n+    public void setRequestElapsedTime(long l)  { setPair(17, l); }\n+    public void setRequestFirstLine(String s)  { setPair(20, s); }\n+    public void setAccessLogDatetime(String s) { setPair(21, s); }\n+    public void setRemoteUser(String s)        { setPair(22, s); }\n     public void setCookies(String name, String value) {\n         kvplCookies.addKeyValuePair(name, value);\n         setPair(16, kvplCookies);\n     }\n-\n-    public void setRequestElapsedTime(long l) {\n-        setPair(17, l);\n-    }\n-\n     public void setRequestHeader(String name, String value) {\n         kvplRequestHeaders.addKeyValuePair(name, value);\n         setPair(18, kvplRequestHeaders);\n     }\n-\n     public void setResponseHeader(String name, String value) {\n         kvplResponseHeaders.addKeyValuePair(name, value);\n         setPair(19, kvplResponseHeaders);\n     }\n \n-    public void setRequestFirstLine(String s) {\n-        setPair(20, s);\n-    }\n-\n-    public void setAccessLogDatetime(String s) {\n-        setPair(21, s);\n-    }\n-\n-    public void setRemoteUser(String s) {\n-        setPair(22, s);\n-    }\n-\n-    public String getRequestStartTime() {\n-        return getStringValue(0);\n-    }\n-\n-    public String getUriPath() {\n-        return getStringValue(1);\n-    }\n-\n-    public String getRequestMethod() {\n-        return getStringValue(2);\n-    }\n-\n-    public String getQueryString() {\n-        return getStringValue(3);\n-    }\n-\n-    public String getRequestHost() {\n-        return getStringValue(4);\n-    }\n-\n-    public String getRequestPort() {\n-        return getStringValue(5);\n-    }\n-\n-    public String getRemoteHost() {\n-        return getStringValue(6);\n-    }\n-\n-    public String getUserAgent() {\n-        return getStringValue(7);\n-    }\n-\n-    public String getRequestProtocol() {\n-        return getStringValue(8);\n-    }\n-\n-    public long getBytesReceived() {\n-        try {\n-            return getLongValue(9);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public int getResponseCode() {\n-        try {\n-            return getIntValue(10);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getElapsedTime() {\n-        try {\n-            return getLongValue(11);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getDatetime() {\n-        try {\n-            return getLongValue(12);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public String getSequence() {\n-        return getStringValue(13);\n-    }\n-\n-    public String getRemoteIP() {\n-        return getStringValue(14);\n-    }\n-\n-    public String getBytesSent() {\n-        return getStringValue(15);\n-    }\n-\n-    public KeyValuePairList getCookies() {\n-        return getValues(16);\n-    }\n-\n-    public long getRequestElapsedTime() {\n-        try {\n-            return getLongValue(17);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public KeyValuePairList getRequestHeaders() {\n-        return getValues(18);\n-    }\n-\n-    public KeyValuePairList getResponseHeaders() {\n-        return getValues(19);\n-    }\n-\n-    public String getRequestFirstLine() {\n-        return getStringValue(20);\n-    }\n-\n-    public String getAccessLogDatetime() {\n-        return getStringValue(21);\n-    }\n-\n-    public String getRemoteUser() {\n-        return getStringValue(22);\n-    }\n-\n-    private KeyValuePairList getValues(int index) {\n-        return (KeyValuePairList) getPairs()[index];\n-    }\n-\n-    public static String getRequestStartTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[0];\n-    }\n-\n-    public static String getUriPathKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[1];\n-    }\n-\n-    public static String getRequestMethodKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[2];\n-    }\n-\n-    public static String getQueryStringKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[3];\n-    }\n-\n-    public static String getRequestHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[4];\n-    }\n-\n-    public static String getRequestPortKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[5];\n-    }\n-\n-    public static String getRemoteHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[6];\n-    }\n-\n-    public static String getUserAgentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[9];\n-    }\n-\n-    public static String getResponseCodeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[11];\n-    }\n-\n-    public static String getDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[12];\n-    }\n-\n-    public static String getSequenceKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[13];\n-    }\n-\n-    public static String getHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[14];\n-    }\n-\n-    public static String getUserDirKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[15];\n-    }\n-\n-    public static String getServerNameKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[16];\n-    }\n-\n-    public static String getTypeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[17];\n-    }\n-\n-    public static String getRemoteIPKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[18];\n-    }\n-\n-    public static String getBytesSentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[19];\n-    }\n-\n-    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public String getRequestStartTime()          { return getStringValue(0); }\n+    public String getUriPath()                   { return getStringValue(1); }\n+    public String getRequestMethod()             { return getStringValue(2); }\n+    public String getQueryString()               { return getStringValue(3); }\n+    public String getRequestHost()               { return getStringValue(4); }\n+    public String getRequestPort()               { return getStringValue(5); }\n+    public String getRemoteHost()                { return getStringValue(6); }\n+    public String getUserAgent()                 { return getStringValue(7); }\n+    public String getRequestProtocol()           { return getStringValue(8); }\n+    public long getBytesReceived()               { return getLongValue(9); }\n+    public int getResponseCode()                 { return getIntValue(10); }\n+    public long getElapsedTime()                 { return getLongValue(11); }\n+    public long getDatetime()                    { return getLongValue(12); }\n+    public String getSequence()                  { return getStringValue(13); }\n+    public String getRemoteIP()                  { return getStringValue(14); }\n+    public String getBytesSent()                 { return getStringValue(15); }\n+    public KeyValuePairList getCookies()         { return getValues(16); }\n+    public long getRequestElapsedTime()          { return getLongValue(17); }\n+    public KeyValuePairList getRequestHeaders()  { return getValues(18); }\n+    public KeyValuePairList getResponseHeaders() { return getValues(19); }\n+    public String getRequestFirstLine()          { return getStringValue(20); }\n+    public String getAccessLogDatetime()         { return getStringValue(21); }\n+    public String getRemoteUser()                { return getStringValue(22); }\n+\n+    public static String getRequestStartTimeKey(int format)   { return nameAliases[format].aliases[0]; }\n+    public static String getUriPathKey(int format)            { return nameAliases[format].aliases[1]; }\n+    public static String getRequestMethodKey(int format)      { return nameAliases[format].aliases[2]; }\n+    public static String getQueryStringKey(int format)        { return nameAliases[format].aliases[3]; }\n+    public static String getRequestHostKey(int format)        { return nameAliases[format].aliases[4]; }\n+    public static String getRequestPortKey(int format)        { return nameAliases[format].aliases[5]; }\n+    public static String getRemoteHostKey(int format)         { return nameAliases[format].aliases[6]; }\n+    public static String getUserAgentKey(int format)          { return nameAliases[format].aliases[7]; }\n+    public static String getRequestProtocolKey(int format)    { return nameAliases[format].aliases[8]; }\n+    public static String getBytesReceivedKey(int format)      { return nameAliases[format].aliases[9]; }\n+    public static String getResponseCodeKey(int format)       { return nameAliases[format].aliases[10]; }\n+    public static String getElapsedTimeKey(int format)        { return nameAliases[format].aliases[11]; }\n+    public static String getDatetimeKey(int format)           { return nameAliases[format].aliases[12]; }\n+    public static String getSequenceKey(int format)           { return nameAliases[format].aliases[13]; }\n+    public static String getHostKey(int format)               { return nameAliases[format].aliases[14]; }\n+    public static String getUserDirKey(int format)            { return nameAliases[format].aliases[15]; }\n+    public static String getServerNameKey(int format)         { return nameAliases[format].aliases[16]; }\n+    public static String getTypeKey(int format)               { return nameAliases[format].aliases[17]; }\n+    public static String getRemoteIPKey(int format)           { return nameAliases[format].aliases[18]; }\n+    public static String getBytesSentKey(int format)          { return nameAliases[format].aliases[19]; }\n+    public static String getRequestElapsedTimeKey(int format) { return nameAliases[format].aliases[21]; }\n+    public static String getRequestFirstLineKey(int format)   { return nameAliases[format].aliases[24]; }\n+    public static String getAccessLogDatetimeKey(int format)  { return nameAliases[format].aliases[25]; }\n+    public static String getRemoteUserKey(int format)         { return nameAliases[format].aliases[26]; }\n+\n+    public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+        // We can only rename for JSON and not logstash collector, so check that it's JSON before renaming field", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzNjg4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419136882", "bodyText": "compute \"[\" + currentTime + \"]\" once and use it in both cases above", "author": "donbourne", "createdAt": "2020-05-03T17:51:54Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java", "diffHunk": "@@ -38,9 +40,12 @@ public Object init(String rawToken) {\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request, Object data) {\n         if (data == null) {\n+            String currentTime = HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis()));\n             accessLogEntry.append(\"[\");\n-            accessLogEntry.append(HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis())));\n+            accessLogEntry.append(currentTime);\n             accessLogEntry.append(\"]\");\n+            accessLogDatetime.set(\"[\" + currentTime + \"]\");\n+", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzNzI4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419137285", "bodyText": "add a comment above this line to state your assumption that the methods below that use this datetime will be called on the same thread", "author": "donbourne", "createdAt": "2020-05-03T17:55:54Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java", "diffHunk": "@@ -18,6 +18,8 @@\n \n public class AccessLogCurrentTime extends AccessLogData {\n \n+    public static ThreadLocal<String> accessLogDatetime = new ThreadLocal<>();", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTEwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151109", "bodyText": "should probably make this private", "author": "donbourne", "createdAt": "2020-05-03T19:51:41Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java", "diffHunk": "@@ -18,25 +18,26 @@\n \n public class AccessLogElapsedTime extends AccessLogData {\n \n+    public static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTMxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151312", "bodyText": "could just put elapsedTime.set here (seems a bit odd to add the class name)", "author": "donbourne", "createdAt": "2020-05-03T19:53:16Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java", "diffHunk": "@@ -18,25 +18,26 @@\n \n public class AccessLogElapsedTime extends AccessLogData {\n \n+    public static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();\n+\n     public AccessLogElapsedTime() {\n         super(\"%D\");\n         // %D - Elapsed time, in milliseconds, of the request/response exchange\n         // Millisecond accuracy, microsecond precision\n     }\n \n-    // Need some way to \"remember\" the elapsedTime value; the System.nanoTime - startTime\n-    static long currentTime = 0;\n-\n     @Override\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request,\n                        Object data) {\n         long startTime = getStartTime(response, request, data);\n         if (startTime != 0) {\n-            currentTime = System.nanoTime();\n-            long elapsedTime = currentTime - startTime;\n-            accessLogEntry.append(TimeUnit.NANOSECONDS.toMicros(elapsedTime));\n+            long elapsedTime = System.nanoTime() - startTime;\n+            long elapsedTimeInMicroseconds = TimeUnit.NANOSECONDS.toMicros(elapsedTime);\n+            AccessLogElapsedTime.elapsedTime.set(elapsedTimeInMicroseconds);", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTQ5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151494", "bodyText": "compute \"[\" + formattedDate + \"]\" once and reuse it.", "author": "donbourne", "createdAt": "2020-05-03T19:54:31Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java", "diffHunk": "@@ -33,9 +34,11 @@ public boolean set(StringBuilder accessLogEntry,\n \n         if (startTime != 0) {\n             Date startDate = new Date(startTime);\n+            String formattedDate = HttpDispatcher.getDateFormatter().getNCSATime(startDate);\n             accessLogEntry.append(\"[\");\n-            accessLogEntry.append(HttpDispatcher.getDateFormatter().getNCSATime(startDate));\n+            accessLogEntry.append(formattedDate);\n             accessLogEntry.append(\"]\");\n+            startTimeFormatted.set(\"[\" + formattedDate + \"]\");", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTgyMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151820", "bodyText": "rename to just delegate -- it's clear from the context what it's a delegate for", "author": "donbourne", "createdAt": "2020-05-03T19:57:11Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/internal/AccessLogRecordDataExt.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ * IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.http.logging.internal;\n+\n+import com.ibm.ws.http.logging.internal.AccessLogger.FormatSegment;\n+import com.ibm.wsspi.http.channel.HttpRequestMessage;\n+import com.ibm.wsspi.http.channel.HttpResponseMessage;\n+import com.ibm.wsspi.http.logging.AccessLogRecordData;\n+\n+/**\n+ *\n+ */\n+public class AccessLogRecordDataExt implements AccessLogRecordData {\n+\n+    AccessLogRecordData delegateRecordData;", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MjA2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419162063", "bodyText": "suggest you take a look at https://stackoverflow.com/questions/16377926/how-to-write-hashcode-method-for-a-particular-class -- that mentions Eclipse IDE has a way to generate your hashcode method for you.", "author": "donbourne", "createdAt": "2020-05-03T21:22:13Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -56,33 +59,82 @@\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");\n+    public String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode\n+        @Override\n+        public int hashCode() {\n+            int hash;\n+            hash = logFormat.hashCode() * loggingConfig.hashCode() * logstashConfig.hashCode();", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MjUxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419162513", "bodyText": "Might make sense to use the Configuration class here instead of having the same 3 fields in SetterFormatter", "author": "donbourne", "createdAt": "2020-05-03T21:25:53Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -56,33 +59,82 @@\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");\n+    public String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode\n+        @Override\n+        public int hashCode() {\n+            int hash;\n+            hash = logFormat.hashCode() * loggingConfig.hashCode() * logstashConfig.hashCode();\n+            return hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration config = (Configuration) obj;\n+            if (!config.getLogFormat().equals(this.logFormat) || !config.getLoggingConfig().equals(this.loggingConfig) || !config.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+    }\n+\n     private static class SetterFormatter {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MzM3OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419163378", "bodyText": "more efficient if, instead of using containsKey(config) followed by get(config) that you just do get(config) followed by checking the response for null.", "author": "donbourne", "createdAt": "2020-05-03T21:33:23Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -263,180 +309,188 @@ AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, Fo\n                 switch (s.log.getName()) {\n                     // Original - default fields\n                     //@formatter:off\n-                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n-                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n-                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n-                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n-                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n-                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n-                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n-                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n-                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n-                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    case \"%h\": builder.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": builder.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": builder.add(addRequestHostField    (format)); break;\n+                    case \"%B\": builder.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": builder.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": builder.add(addRequestPortField    (format)); break;\n+                    case \"%q\": builder.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": builder.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": builder.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": builder.add(addUriPathField        (format)); break;\n                     // New - access log only fields\n-                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n-                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%a\": builder.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": builder.add(addBytesSentField      (format)); break;\n                     case \"%C\":\n                         if (isFirstCookie) {\n-                            formatter.add(addCookiesField(format));\n+                            builder.add(addCookiesField(format));\n                             isFirstCookie = false;\n                         } break;\n-                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n                         if (s.data.equals(USER_AGENT_HEADER)) {\n-                            formatter.add(addUserAgentField(format));\n+                            builder.add(addUserAgentField(format));\n                         } else if (isFirstRequestHeader) {\n-                            formatter.add(addRequestHeaderField(format));\n+                            builder.add(addRequestHeaderField(format));\n                             isFirstRequestHeader = false;\n                         } break;\n                     case \"%o\":\n                         if (isFirstResponseHeader) {\n-                            formatter.add(addResponseHeaderField(format));\n+                            builder.add(addResponseHeaderField(format));\n                             isFirstResponseHeader = false;\n                         } break;\n-                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n-                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n-                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n-                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    case \"%r\": builder.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": builder.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": builder.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": builder.add(addRemoteUserField          (format)); break;\n                     //@formatter:on\n                 }\n             }\n         }\n-        return formatter;\n-\n-    }\n-\n-    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n-\n-        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n-\n-        formatter = new AccessLogDataFormatter();\n-        // %h\n-        formatter.add(addRemoteHostField(format));\n-        // %H\n-        formatter.add(addRequestProtocolField(format));\n-        // %A\n-        formatter.add(addRequestHostField(format));\n-        // %B\n-        formatter.add(addBytesReceivedField(format));\n-        // %m\n-        formatter.add(addRequestMethodField(format));\n-        // %p\n-        formatter.add(addRequestPortField(format));\n-        // %q\n-        formatter.add(addQueryStringField(format));\n-        // %{R}W\n-        formatter.add(addElapsedTimeField(format));\n-        // %s\n-        formatter.add(addResponseCodeField(format));\n-        // %U\n-        formatter.add(addUriPathField(format));\n-        // User agent\n-        formatter.add(addUserAgentField(format));\n-        return formatter;\n+        //@formatter:off\n+        builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n+               .add(addSequenceField(format)); // Datetime, present in all access logs\n+        //@formatter:on\n+        return new AccessLogDataFormatter(builder);\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+\n+        // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n+        //@formatter:off\n+        AccessLogDataFormatterBuilder builder = new AccessLogDataFormatterBuilder();\n+        builder.add(addRemoteHostField(format))  // %h\n+        .add(addRequestProtocolField  (format))  // %H\n+        .add(addRequestHostField      (format))  // %A\n+        .add(addBytesReceivedField    (format))  // %B\n+        .add(addRequestMethodField    (format))  // %m\n+        .add(addRequestPortField      (format))  // %p\n+        .add(addQueryStringField      (format))  // %q\n+        .add(addElapsedTimeField      (format))  // %{R}W\n+        .add(addResponseCodeField     (format))  // %s\n+        .add(addUriPathField          (format))  // %U\n+        .add(addUserAgentField        (format))  // User agent\n+        .add(addDatetimeField         (format))  // Datetime, present in all access logs\n+        .add(addSequenceField         (format)); // Sequence, present in all access logs\n+\n+        return new AccessLogDataFormatter(builder);\n+        //@formatter:on\n+    }\n+\n+    private void initializeSetterFormatter(String formatString, String jsonAccessLogFieldsConfig, String jsonAccessLogFieldsLogstashConfig, FormatSegment[] parsedFormat,\n+                                           AtomicLong seq) {\n+        SetterFormatter newSF = new SetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+        List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+        // Create the mapping of fields to add:{<format key> : <data value/null>}\n+        // Prevents duplicates\n+        initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+        // Create setter list\n+        fieldSetters = populateSetters(fieldsToAdd);\n+        // These fields are always added\n+        fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+        fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+        if (jsonAccessLogFieldsConfig.equals(\"default\")) {\n+            formatters[0] = populateDefaultFormatters(AccessLogData.KEYS_JSON);\n+        } else if (jsonAccessLogFieldsConfig.equals(\"logFormat\")) {\n+            formatters[1] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_JSON);\n+        }\n+\n+        if (jsonAccessLogFieldsLogstashConfig.equals(\"default\")) {\n+            formatters[2] = populateDefaultFormatters(AccessLogData.KEYS_LOGSTASH);\n+        } else if (jsonAccessLogFieldsLogstashConfig.equals(\"logFormat\")) {\n+            formatters[3] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_LOGSTASH);\n+        }\n+        newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+        currentSF = newSF;\n     }\n \n     private class AccessLogHandler implements AccessLogForwarder {\n-\n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-\n-        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n-            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n-            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n-                SetterFormatter newSF = new SetterFormatter();\n-                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n-                AccessLogDataFormatter[] formatters = { null, null, null, null };\n-                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n-\n-                // Create the mapping of fields to add:{<format key> : <data value/null>}\n-                // Prevents duplicates\n-                initializeFieldMap(fieldsToAdd, parsedFormat);\n-\n-                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n-\n-                // Create setter list\n-                fieldSetters = populateSetters(fieldsToAdd);\n-                // These fields are always added\n-                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n-                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n-\n-                if (jsonAccessLogFields.equals(\"default\")) {\n-                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFields.equals(\"logFormat\")) {\n-                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n-                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n-                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+        public void process(AccessLogRecordData recordData) {\n+            // The logFormat, as a string: e.g. \"%a %b %C\"\n+            String formatString = ((AccessLogRecordDataExt) recordData).getFormatString();\n+            // A parsed version of the logFormat\n+            FormatSegment[] parsedFormat = ((AccessLogRecordDataExt) recordData).getParsedFormat();\n+            jsonAccessLogFieldsConfig = AccessLogConfig.jsonAccessLogFieldsConfig;\n+\n+            Configuration config = new Configuration(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig))\n+                if (setterFormatterMap.containsKey(config)) {", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MzUzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419163538", "bodyText": "change this method to be static and just return the SetterFormatter it creates.  rename to createSetterFormatter", "author": "donbourne", "createdAt": "2020-05-03T21:34:30Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -263,180 +309,188 @@ AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, Fo\n                 switch (s.log.getName()) {\n                     // Original - default fields\n                     //@formatter:off\n-                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n-                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n-                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n-                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n-                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n-                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n-                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n-                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n-                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n-                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    case \"%h\": builder.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": builder.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": builder.add(addRequestHostField    (format)); break;\n+                    case \"%B\": builder.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": builder.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": builder.add(addRequestPortField    (format)); break;\n+                    case \"%q\": builder.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": builder.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": builder.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": builder.add(addUriPathField        (format)); break;\n                     // New - access log only fields\n-                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n-                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%a\": builder.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": builder.add(addBytesSentField      (format)); break;\n                     case \"%C\":\n                         if (isFirstCookie) {\n-                            formatter.add(addCookiesField(format));\n+                            builder.add(addCookiesField(format));\n                             isFirstCookie = false;\n                         } break;\n-                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n                         if (s.data.equals(USER_AGENT_HEADER)) {\n-                            formatter.add(addUserAgentField(format));\n+                            builder.add(addUserAgentField(format));\n                         } else if (isFirstRequestHeader) {\n-                            formatter.add(addRequestHeaderField(format));\n+                            builder.add(addRequestHeaderField(format));\n                             isFirstRequestHeader = false;\n                         } break;\n                     case \"%o\":\n                         if (isFirstResponseHeader) {\n-                            formatter.add(addResponseHeaderField(format));\n+                            builder.add(addResponseHeaderField(format));\n                             isFirstResponseHeader = false;\n                         } break;\n-                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n-                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n-                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n-                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    case \"%r\": builder.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": builder.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": builder.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": builder.add(addRemoteUserField          (format)); break;\n                     //@formatter:on\n                 }\n             }\n         }\n-        return formatter;\n-\n-    }\n-\n-    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n-\n-        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n-\n-        formatter = new AccessLogDataFormatter();\n-        // %h\n-        formatter.add(addRemoteHostField(format));\n-        // %H\n-        formatter.add(addRequestProtocolField(format));\n-        // %A\n-        formatter.add(addRequestHostField(format));\n-        // %B\n-        formatter.add(addBytesReceivedField(format));\n-        // %m\n-        formatter.add(addRequestMethodField(format));\n-        // %p\n-        formatter.add(addRequestPortField(format));\n-        // %q\n-        formatter.add(addQueryStringField(format));\n-        // %{R}W\n-        formatter.add(addElapsedTimeField(format));\n-        // %s\n-        formatter.add(addResponseCodeField(format));\n-        // %U\n-        formatter.add(addUriPathField(format));\n-        // User agent\n-        formatter.add(addUserAgentField(format));\n-        return formatter;\n+        //@formatter:off\n+        builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n+               .add(addSequenceField(format)); // Datetime, present in all access logs\n+        //@formatter:on\n+        return new AccessLogDataFormatter(builder);\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+\n+        // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n+        //@formatter:off\n+        AccessLogDataFormatterBuilder builder = new AccessLogDataFormatterBuilder();\n+        builder.add(addRemoteHostField(format))  // %h\n+        .add(addRequestProtocolField  (format))  // %H\n+        .add(addRequestHostField      (format))  // %A\n+        .add(addBytesReceivedField    (format))  // %B\n+        .add(addRequestMethodField    (format))  // %m\n+        .add(addRequestPortField      (format))  // %p\n+        .add(addQueryStringField      (format))  // %q\n+        .add(addElapsedTimeField      (format))  // %{R}W\n+        .add(addResponseCodeField     (format))  // %s\n+        .add(addUriPathField          (format))  // %U\n+        .add(addUserAgentField        (format))  // User agent\n+        .add(addDatetimeField         (format))  // Datetime, present in all access logs\n+        .add(addSequenceField         (format)); // Sequence, present in all access logs\n+\n+        return new AccessLogDataFormatter(builder);\n+        //@formatter:on\n+    }\n+\n+    private void initializeSetterFormatter(String formatString, String jsonAccessLogFieldsConfig, String jsonAccessLogFieldsLogstashConfig, FormatSegment[] parsedFormat,\n+                                           AtomicLong seq) {\n+        SetterFormatter newSF = new SetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+        List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+        // Create the mapping of fields to add:{<format key> : <data value/null>}\n+        // Prevents duplicates\n+        initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+        // Create setter list\n+        fieldSetters = populateSetters(fieldsToAdd);\n+        // These fields are always added\n+        fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+        fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+        if (jsonAccessLogFieldsConfig.equals(\"default\")) {\n+            formatters[0] = populateDefaultFormatters(AccessLogData.KEYS_JSON);\n+        } else if (jsonAccessLogFieldsConfig.equals(\"logFormat\")) {\n+            formatters[1] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_JSON);\n+        }\n+\n+        if (jsonAccessLogFieldsLogstashConfig.equals(\"default\")) {\n+            formatters[2] = populateDefaultFormatters(AccessLogData.KEYS_LOGSTASH);\n+        } else if (jsonAccessLogFieldsLogstashConfig.equals(\"logFormat\")) {\n+            formatters[3] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_LOGSTASH);\n+        }\n+        newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+        currentSF = newSF;\n     }\n \n     private class AccessLogHandler implements AccessLogForwarder {\n-\n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-\n-        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n-            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n-            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n-                SetterFormatter newSF = new SetterFormatter();\n-                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n-                AccessLogDataFormatter[] formatters = { null, null, null, null };\n-                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n-\n-                // Create the mapping of fields to add:{<format key> : <data value/null>}\n-                // Prevents duplicates\n-                initializeFieldMap(fieldsToAdd, parsedFormat);\n-\n-                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n-\n-                // Create setter list\n-                fieldSetters = populateSetters(fieldsToAdd);\n-                // These fields are always added\n-                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n-                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n-\n-                if (jsonAccessLogFields.equals(\"default\")) {\n-                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFields.equals(\"logFormat\")) {\n-                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n-                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n-                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+        public void process(AccessLogRecordData recordData) {\n+            // The logFormat, as a string: e.g. \"%a %b %C\"\n+            String formatString = ((AccessLogRecordDataExt) recordData).getFormatString();\n+            // A parsed version of the logFormat\n+            FormatSegment[] parsedFormat = ((AccessLogRecordDataExt) recordData).getParsedFormat();\n+            jsonAccessLogFieldsConfig = AccessLogConfig.jsonAccessLogFieldsConfig;\n+\n+            Configuration config = new Configuration(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig))\n+                if (setterFormatterMap.containsKey(config)) {\n+                    // If we've created a setterFormatter in the past for this configuration, we'll use it instead of making a new one\n+                    currentSF = setterFormatterMap.get(config);\n+                } else {\n+                    initializeSetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig, parsedFormat, seq);", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NDI5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419164298", "bodyText": "not sure I get why we have a checkConfigChange method -- wouldn't the detection of a new config just be that there's no SetterFormatter in the map when requested with a given key?", "author": "donbourne", "createdAt": "2020-05-03T21:40:19Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -92,12 +144,6 @@ boolean checkConfigChange(String logFormat, String loggingConfig, String logstas\n                 return true;\n             return false;\n         }", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NDc1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419164750", "bodyText": "I think you probably should get rid of currentSF altogether, as well as checkConfigChange.  At this point in the code you could just look up the appropriate SF using the config.", "author": "donbourne", "createdAt": "2020-05-03T21:44:21Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -263,180 +309,188 @@ AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, Fo\n                 switch (s.log.getName()) {\n                     // Original - default fields\n                     //@formatter:off\n-                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n-                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n-                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n-                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n-                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n-                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n-                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n-                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n-                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n-                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    case \"%h\": builder.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": builder.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": builder.add(addRequestHostField    (format)); break;\n+                    case \"%B\": builder.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": builder.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": builder.add(addRequestPortField    (format)); break;\n+                    case \"%q\": builder.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": builder.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": builder.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": builder.add(addUriPathField        (format)); break;\n                     // New - access log only fields\n-                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n-                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%a\": builder.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": builder.add(addBytesSentField      (format)); break;\n                     case \"%C\":\n                         if (isFirstCookie) {\n-                            formatter.add(addCookiesField(format));\n+                            builder.add(addCookiesField(format));\n                             isFirstCookie = false;\n                         } break;\n-                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n                         if (s.data.equals(USER_AGENT_HEADER)) {\n-                            formatter.add(addUserAgentField(format));\n+                            builder.add(addUserAgentField(format));\n                         } else if (isFirstRequestHeader) {\n-                            formatter.add(addRequestHeaderField(format));\n+                            builder.add(addRequestHeaderField(format));\n                             isFirstRequestHeader = false;\n                         } break;\n                     case \"%o\":\n                         if (isFirstResponseHeader) {\n-                            formatter.add(addResponseHeaderField(format));\n+                            builder.add(addResponseHeaderField(format));\n                             isFirstResponseHeader = false;\n                         } break;\n-                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n-                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n-                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n-                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    case \"%r\": builder.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": builder.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": builder.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": builder.add(addRemoteUserField          (format)); break;\n                     //@formatter:on\n                 }\n             }\n         }\n-        return formatter;\n-\n-    }\n-\n-    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n-\n-        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n-\n-        formatter = new AccessLogDataFormatter();\n-        // %h\n-        formatter.add(addRemoteHostField(format));\n-        // %H\n-        formatter.add(addRequestProtocolField(format));\n-        // %A\n-        formatter.add(addRequestHostField(format));\n-        // %B\n-        formatter.add(addBytesReceivedField(format));\n-        // %m\n-        formatter.add(addRequestMethodField(format));\n-        // %p\n-        formatter.add(addRequestPortField(format));\n-        // %q\n-        formatter.add(addQueryStringField(format));\n-        // %{R}W\n-        formatter.add(addElapsedTimeField(format));\n-        // %s\n-        formatter.add(addResponseCodeField(format));\n-        // %U\n-        formatter.add(addUriPathField(format));\n-        // User agent\n-        formatter.add(addUserAgentField(format));\n-        return formatter;\n+        //@formatter:off\n+        builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n+               .add(addSequenceField(format)); // Datetime, present in all access logs\n+        //@formatter:on\n+        return new AccessLogDataFormatter(builder);\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+\n+        // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n+        //@formatter:off\n+        AccessLogDataFormatterBuilder builder = new AccessLogDataFormatterBuilder();\n+        builder.add(addRemoteHostField(format))  // %h\n+        .add(addRequestProtocolField  (format))  // %H\n+        .add(addRequestHostField      (format))  // %A\n+        .add(addBytesReceivedField    (format))  // %B\n+        .add(addRequestMethodField    (format))  // %m\n+        .add(addRequestPortField      (format))  // %p\n+        .add(addQueryStringField      (format))  // %q\n+        .add(addElapsedTimeField      (format))  // %{R}W\n+        .add(addResponseCodeField     (format))  // %s\n+        .add(addUriPathField          (format))  // %U\n+        .add(addUserAgentField        (format))  // User agent\n+        .add(addDatetimeField         (format))  // Datetime, present in all access logs\n+        .add(addSequenceField         (format)); // Sequence, present in all access logs\n+\n+        return new AccessLogDataFormatter(builder);\n+        //@formatter:on\n+    }\n+\n+    private void initializeSetterFormatter(String formatString, String jsonAccessLogFieldsConfig, String jsonAccessLogFieldsLogstashConfig, FormatSegment[] parsedFormat,\n+                                           AtomicLong seq) {\n+        SetterFormatter newSF = new SetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+        List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+        // Create the mapping of fields to add:{<format key> : <data value/null>}\n+        // Prevents duplicates\n+        initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+        // Create setter list\n+        fieldSetters = populateSetters(fieldsToAdd);\n+        // These fields are always added\n+        fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+        fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+        if (jsonAccessLogFieldsConfig.equals(\"default\")) {\n+            formatters[0] = populateDefaultFormatters(AccessLogData.KEYS_JSON);\n+        } else if (jsonAccessLogFieldsConfig.equals(\"logFormat\")) {\n+            formatters[1] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_JSON);\n+        }\n+\n+        if (jsonAccessLogFieldsLogstashConfig.equals(\"default\")) {\n+            formatters[2] = populateDefaultFormatters(AccessLogData.KEYS_LOGSTASH);\n+        } else if (jsonAccessLogFieldsLogstashConfig.equals(\"logFormat\")) {\n+            formatters[3] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_LOGSTASH);\n+        }\n+        newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+        currentSF = newSF;\n     }\n \n     private class AccessLogHandler implements AccessLogForwarder {\n-\n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-\n-        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n-            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n-            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n-                SetterFormatter newSF = new SetterFormatter();\n-                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n-                AccessLogDataFormatter[] formatters = { null, null, null, null };\n-                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n-\n-                // Create the mapping of fields to add:{<format key> : <data value/null>}\n-                // Prevents duplicates\n-                initializeFieldMap(fieldsToAdd, parsedFormat);\n-\n-                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n-\n-                // Create setter list\n-                fieldSetters = populateSetters(fieldsToAdd);\n-                // These fields are always added\n-                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n-                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n-\n-                if (jsonAccessLogFields.equals(\"default\")) {\n-                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFields.equals(\"logFormat\")) {\n-                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n-                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n-                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+        public void process(AccessLogRecordData recordData) {\n+            // The logFormat, as a string: e.g. \"%a %b %C\"\n+            String formatString = ((AccessLogRecordDataExt) recordData).getFormatString();\n+            // A parsed version of the logFormat\n+            FormatSegment[] parsedFormat = ((AccessLogRecordDataExt) recordData).getParsedFormat();\n+            jsonAccessLogFieldsConfig = AccessLogConfig.jsonAccessLogFieldsConfig;\n+\n+            Configuration config = new Configuration(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig))", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419165490", "bodyText": "make private", "author": "donbourne", "createdAt": "2020-05-03T21:50:56Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java", "diffHunk": "@@ -20,25 +20,36 @@\n public class AccessLogDataFormatter {\n \n     // list of actions to populate JSONObjectBuilder\n-    private final ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n+    private ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n \n-    public AccessLogDataFormatter() {\n+    public static class AccessLogDataFormatterBuilder {\n+        private final ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n+\n+        public AccessLogDataFormatterBuilder() {\n+        }\n+\n+        public AccessLogDataFormatterBuilder add(JsonFieldAdder jsonFieldAdder) {\n+            this.jsonFieldAdders.add(jsonFieldAdder);\n+            return this;\n+        }\n+\n+        public AccessLogDataFormatter build() {\n+            AccessLogDataFormatter formatter = new AccessLogDataFormatter(this);\n+            return formatter;\n+        }\n \n     }\n \n-    // adds another JsonFieldAdder to the list\n-    public AccessLogDataFormatter add(JsonFieldAdder jsonFieldAdder) {\n-        this.jsonFieldAdders.add(jsonFieldAdder);\n-        return this;\n+    public AccessLogDataFormatter(AccessLogDataFormatterBuilder builder) {", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxMzkyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419713929", "bodyText": "If it's private then AccessLogSource can't access it since it's in http transport. It needs to be public, or else we'd have to make our list of formatters into a list of formatterBuilders, I think", "author": "jennifer-c", "createdAt": "2020-05-04T20:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MjMxNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420092314", "bodyText": "I think you should be able to call AccessLogDataFormatter aldf = accessLogDataFormatterBuilder.build(); , no?", "author": "donbourne", "createdAt": "2020-05-05T13:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5NjMyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420096328", "bodyText": "yep, you're right, I don't know why I wasn't using that to begin with!", "author": "jennifer-c", "createdAt": "2020-05-05T13:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTYyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419165623", "bodyText": "don't think you need currentSF...see below", "author": "donbourne", "createdAt": "2020-05-03T21:52:00Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -56,33 +59,82 @@\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6275e39afeed15b28845f273de44927dce2c7195", "url": "https://github.com/OpenLiberty/open-liberty/commit/6275e39afeed15b28845f273de44927dce2c7195", "message": "Address comments", "committedDate": "2020-05-05T15:36:42Z", "type": "forcePushed"}, {"oid": "288fe72db71bf525c0222db7bcea4a6f66cfa4b1", "url": "https://github.com/OpenLiberty/open-liberty/commit/288fe72db71bf525c0222db7bcea4a6f66cfa4b1", "message": "Address comments", "committedDate": "2020-05-05T16:25:17Z", "type": "forcePushed"}, {"oid": "5a63baa5199a1e0591a690616b81f4fc4201169d", "url": "https://github.com/OpenLiberty/open-liberty/commit/5a63baa5199a1e0591a690616b81f4fc4201169d", "message": "Address comments", "committedDate": "2020-05-05T18:07:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MTQzMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420381433", "bodyText": "it's possible for tempStartFields to be non-null but to be building an event for logstashCollector.  Suggest you just have one \"tempStartFields\" which gets set to either startAccessLogJsonFields or startAccessLogLogstashCollector depending on the value of format.", "author": "donbourne", "createdAt": "2020-05-05T20:20:09Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -385,20 +386,28 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n+        String tempStartFieldsLogstash = startAccessLogLogstashCollector;\n \n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n+        if (tempStartFields != null) {\n+            if (format == AccessLogData.KEYS_JSON)\n+                jsonBuilder.addPreformatted(tempStartFields);\n+        } else if (tempStartFieldsLogstash != null) {\n+            if (format == AccessLogData.KEYS_LOGSTASH)\n+                jsonBuilder.addPreformatted(tempStartFieldsLogstash);", "originalCommit": "5a63baa5199a1e0591a690616b81f4fc4201169d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTQxMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420385410", "bodyText": "is this used anymore?", "author": "donbourne", "createdAt": "2020-05-05T20:27:43Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -86,7 +87,7 @@ protected static String getEventType(String source, String location) {\n             return \"\";\n     }\n \n-    protected static ThreadLocal<BurstDateFormat> dateFormatTL = new ThreadLocal<BurstDateFormat>() {\n+    public static ThreadLocal<BurstDateFormat> dateFormatTL = new ThreadLocal<BurstDateFormat>() {", "originalCommit": "5a63baa5199a1e0591a690616b81f4fc4201169d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5MTg4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420891885", "bodyText": "Yes, it's used by all the other jsonify methods (jsonifyAudit, jsonifyFFDC, etc) - also, AccessLogSource now also uses it (hence the change from protected->public) since I moved the datetime field into the list of formatters: https://github.com/OpenLiberty/open-liberty/pull/11189/files#diff-83645dd44864a951f486a50cbd6b6e27R375\n(per this review comment #11189 (comment))", "author": "jennifer-c", "createdAt": "2020-05-06T15:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTQxMA=="}], "type": "inlineReview"}, {"oid": "ff624082c4810c563aa7ec8715b3372eec6f5821", "url": "https://github.com/OpenLiberty/open-liberty/commit/ff624082c4810c563aa7ec8715b3372eec6f5821", "message": "Add tests", "committedDate": "2020-05-09T13:09:25Z", "type": "forcePushed"}, {"oid": "581d3b427ff6fa0679b0e36cb91191d37ce1cf65", "url": "https://github.com/OpenLiberty/open-liberty/commit/581d3b427ff6fa0679b0e36cb91191d37ce1cf65", "message": "Fix timing issue in test, add multiple endpoints test", "committedDate": "2020-05-12T16:21:13Z", "type": "forcePushed"}, {"oid": "df43bbbf91302fb9be7fa40b6f75e179b1f479c7", "url": "https://github.com/OpenLiberty/open-liberty/commit/df43bbbf91302fb9be7fa40b6f75e179b1f479c7", "message": "Fix timing issue in test, add multiple endpoints test", "committedDate": "2020-05-13T16:04:07Z", "type": "forcePushed"}, {"oid": "696efda2d9b18781eaab4fcc717edba9464c0e20", "url": "https://github.com/OpenLiberty/open-liberty/commit/696efda2d9b18781eaab4fcc717edba9464c0e20", "message": "Fix timing issue in test, add multiple endpoints test", "committedDate": "2020-05-13T19:27:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzY0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r429473645", "bodyText": "this isn't thread safe.  if one thread updates the config after another thread reaches line 406 you could have problem.  could we set startAccessLogJsonFields (and possibly the other similar fields) in the updateFieldMappings method?", "author": "donbourne", "createdAt": "2020-05-22T22:03:25Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -385,20 +386,27 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAccessLogJsonFields;\n+        String tempStartFields = null;\n+        if (format == AccessLogData.KEYS_JSON)\n+            tempStartFields = startAccessLogJsonFields;\n+        else if (format == AccessLogData.KEYS_LOGSTASH)\n+            tempStartFields = startAccessLogLogstashCollector;\n \n-        if (tempStartFields != null)\n+        if (tempStartFields != null) {\n             jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n+        } else {\n             //@formatter:off\n-            jsonBuilder.addField(AccessLogData.getTypeKeyJSON(), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n-            .addField(AccessLogData.getHostKeyJSON(), hostName, false, false)\n-            .addField(AccessLogData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-            .addField(AccessLogData.getServerNameKeyJSON(), serverName, false, false);\n+            jsonBuilder.addField(AccessLogData.getTypeKey(format), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n+            .addField(AccessLogData.getHostKey(format), hostName, false, false)\n+            .addField(AccessLogData.getUserDirKey(format), wlpUserDir, false, true)\n+            .addField(AccessLogData.getServerNameKey(format), serverName, false, false);\n             //@formatter:on\n-            startAccessLogJsonFields = jsonBuilder.toString();\n+            if (format == AccessLogData.KEYS_JSON)", "originalCommit": "f2bb83b5d0d848cba27f5858a99b664d94511a3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5OTIyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r429999229", "bodyText": "as discussed in slack, can avoid need to have removeDuplicates by changing initializeSetterFormatter to use fieldsToAdd (which already only contains unique values) instead of parsedFormat in calls to populateCustomFormattters", "author": "donbourne", "createdAt": "2020-05-25T15:51:30Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -409,7 +409,21 @@ private void initializeSetterFormatter(String formatString, String jsonAccessLog\n         }\n         newSF.setSettersAndFormatters(fieldSetters, formatters);\n \n-        currentSF = newSF;\n+        return newSF;\n+    }\n+\n+    private void removeDuplicates(FormatSegment[] parsedFormat) {", "originalCommit": "f2bb83b5d0d848cba27f5858a99b664d94511a3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "url": "https://github.com/OpenLiberty/open-liberty/commit/71397c7743fc6bfbe78493b7d7c8102c706c938d", "message": "always call updateFieldMappings after server config update", "committedDate": "2020-05-28T03:04:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0OTM3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431849377", "bodyText": "looks good - maybe just turn formatter off at start of this method and turn it on at end since you need it repeatedly", "author": "donbourne", "createdAt": "2020-05-28T13:49:35Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -195,11 +198,57 @@ protected static void jsonEscape3(StringBuilder sb, String s) {\n     }\n \n     public static void updateFieldMappings() {\n-        startMessageJsonFields = null;\n-        startTraceJsonFields = null;\n-        startAccessLogJsonFields = null;\n-        startAuditJsonFields = null;\n-        startFFDCJsonFields = null;\n+        JSONObjectBuilder jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(LogTraceData.getTypeKeyJSON(true), CollectorConstants.MESSAGES_LOG_EVENT_TYPE, false, false)\n+        .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n+        .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n+        .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n+        //@formatter:on\n+        startMessageJsonFields = jsonBuilder.toString();\n+\n+        jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(AuditData.getTypeKeyJSON(), CollectorConstants.AUDIT_LOG_EVENT_TYPE, false, false)\n+        .addField(AuditData.getHostKeyJSON(), hostName, false, false)\n+        .addField(AuditData.getUserDirKeyJSON(), wlpUserDir, false, true)\n+        .addField(AuditData.getServerNameKeyJSON(), serverName, false, false);\n+\n+        //@formatter:on\n+        startAuditJsonFields = jsonBuilder.toString();\n+\n+        jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(LogTraceData.getTypeKeyJSON(false), CollectorConstants.TRACE_LOG_EVENT_TYPE, false, false)\n+        .addField(LogTraceData.getHostKeyJSON(false), hostName, false, false)\n+        .addField(LogTraceData.getUserDirKeyJSON(false), wlpUserDir, false, true)\n+        .addField(LogTraceData.getServerNameKeyJSON(false), serverName, false, false);\n+        //@formatter:on\n+        startTraceJsonFields = jsonBuilder.toString();\n+\n+        // We should initialize both the regular JSON logging and LogstashCollector variants\n+        for (int i = 0; i < 2; i++) {\n+            jsonBuilder = new JSONObjectBuilder();\n+            //@formatter:off\n+            jsonBuilder.addField(AccessLogData.getTypeKey(i), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n+            .addField(AccessLogData.getHostKey(i), hostName, false, false)\n+            .addField(AccessLogData.getUserDirKey(i), wlpUserDir, false, true)\n+            .addField(AccessLogData.getServerNameKey(i), serverName, false, false);\n+            //@formatter:on\n+            if (i == AccessLogData.KEYS_JSON)\n+                startAccessLogJsonFields = jsonBuilder.toString();\n+            else if (i == AccessLogData.KEYS_LOGSTASH)\n+                startAccessLogLogstashCollector = jsonBuilder.toString();\n+        }\n+\n+        jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(FFDCData.getTypeKeyJSON(), CollectorConstants.FFDC_EVENT_TYPE, false, false)\n+        .addField(FFDCData.getHostKeyJSON(), hostName, false, false)\n+        .addField(FFDCData.getUserDirKeyJSON(), wlpUserDir, false, true)\n+        .addField(FFDCData.getServerNameKeyJSON(), serverName, false, false);\n+        //@formatter:on", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1OTEwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431859103", "bodyText": "can probably just simplify this method assuming startAuditJsonFields is never null.", "author": "donbourne", "createdAt": "2020-05-28T14:02:32Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -321,13 +370,8 @@ protected static JSONObjectBuilder startAuditJsonFields(String hostName, String\n         if (tempStartFields != null) {\n             jsonBuilder.addPreformatted(tempStartFields);\n         } else {\n-            //@formatter:off\n-            jsonBuilder.addField(AuditData.getTypeKeyJSON(), CollectorConstants.AUDIT_LOG_EVENT_TYPE, false, false)\n-            .addField(AuditData.getHostKeyJSON(), hostName, false, false)\n-            .addField(AuditData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-            .addField(AuditData.getServerNameKeyJSON(), serverName, false, false);\n-            //@formatter:on\n-            startAuditJsonFields = jsonBuilder.toString();\n+            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n+            // Should something be returned or have an exception thrown here?", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2MDQ0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431860440", "bodyText": "I think you skipped startMessageJsonFields method?", "author": "donbourne", "createdAt": "2020-05-28T14:04:24Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -357,13 +401,8 @@ protected static JSONObjectBuilder startTraceJsonFields(String hostName, String\n         if (tempStartFields != null)\n             jsonBuilder.addPreformatted(tempStartFields);\n         else {\n-            //@formatter:off\n-            jsonBuilder.addField(LogTraceData.getTypeKeyJSON(false), CollectorConstants.TRACE_LOG_EVENT_TYPE, false, false)\n-            .addField(LogTraceData.getHostKeyJSON(false), hostName, false, false)\n-            .addField(LogTraceData.getUserDirKeyJSON(false), wlpUserDir, false, true)\n-            .addField(LogTraceData.getServerNameKeyJSON(false), serverName, false, false);\n-            //@formatter:on\n-            startTraceJsonFields = jsonBuilder.toString();\n+            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5MDAwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431990008", "bodyText": "add/use setter methods on CollectorJsonHelpers for these", "author": "donbourne", "createdAt": "2020-05-28T17:04:04Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/JsonLogHandler.java", "diffHunk": "@@ -103,6 +104,10 @@ public String run() throws UnknownHostException {\n             serverHostName = containerHost;\n         }\n \n+        CollectorJsonHelpers.hostName = serverHostName;\n+        CollectorJsonHelpers.serverName = wlpServerName;\n+        CollectorJsonHelpers.wlpUserDir = wlpUserDir;", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3OTc5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r432079799", "bodyText": "tempStartFields isn't adding any value here.  could just do...\n        JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n        // We're assuming startMessageJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n        jsonBuilder.addPreformatted(startMessageJsonFields);", "author": "donbourne", "createdAt": "2020-05-28T19:47:39Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -366,57 +369,32 @@ protected static StringBuilder startAuditJson(String hostName, String wlpUserDir\n     protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAuditJsonFields;\n-\n-        if (tempStartFields != null) {\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        } else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(tempStartFields);\n         return jsonBuilder;\n     }\n \n     protected static JSONObjectBuilder startMessageJsonFields(String hostName, String wlpUserDir, String serverName) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startMessageJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            //@formatter:off\n-            jsonBuilder.addField(LogTraceData.getTypeKeyJSON(true), CollectorConstants.MESSAGES_LOG_EVENT_TYPE, false, false)\n-            .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n-            .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n-            .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n-            //@formatter:on\n-            startMessageJsonFields = jsonBuilder.toString();\n-        }\n+        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(tempStartFields);", "originalCommit": "c18473601b73fc97b73624d5ae8e940228ed5983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ5MzAxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r432493016", "bodyText": "just noticed... you don't need hostName / wlpUserDir / serverName in the signature of these methods anymore", "author": "donbourne", "createdAt": "2020-05-29T13:46:21Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -368,46 +368,39 @@ protected static StringBuilder startAuditJson(String hostName, String wlpUserDir\n \n     protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAuditJsonFields;\n-        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n-        jsonBuilder.addPreformatted(tempStartFields);\n+        // We're assuming startAuditJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called", "originalCommit": "073d0cbc671c86655635f6137e6eafb601a1efc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "url": "https://github.com/OpenLiberty/open-liberty/commit/0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "message": "Fix up formatting, simplify the startXXXJsonFields methods, add setters\n\nRemove tempStartFields var\n\nFinal code clean up + fix copyright dates", "committedDate": "2020-05-29T19:16:47Z", "type": "forcePushed"}, {"oid": "5073bf8f330d6fa63e317e750dfdacfaa7dd2fdc", "url": "https://github.com/OpenLiberty/open-liberty/commit/5073bf8f330d6fa63e317e750dfdacfaa7dd2fdc", "message": "Remove case sensitivity for headers, add warning for not providing header name, add null check to prevent NPE to continue after logging warning msg", "committedDate": "2020-06-03T14:38:28Z", "type": "forcePushed"}, {"oid": "87364c2c5fa17af829eb27d0f603b0cc59a7e2bb", "url": "https://github.com/OpenLiberty/open-liberty/commit/87364c2c5fa17af829eb27d0f603b0cc59a7e2bb", "message": "Remove case sensitivity for headers, add warning for not providing header name, add null check to prevent NPE to continue after logging warning msg", "committedDate": "2020-06-03T14:45:40Z", "type": "forcePushed"}, {"oid": "e5102690e0b9f53c46b8e7ac991e95ea2ee3c05b", "url": "https://github.com/OpenLiberty/open-liberty/commit/e5102690e0b9f53c46b8e7ac991e95ea2ee3c05b", "message": "Working basic impl\n\nCondense populateFormatters into two instead of four\n\nMove static var out of AccessLogData, fix configuration checkers\n\nAdd ability to rename/omit specific cookie/header fields\n\nAdd omit cookies/headers functionality and fix field name inconsistency\n\nFix wrong server name and user dir fields being printed in JSON logs\n\nAddress comments\n\nAddress comments\n\nAddress comment\n\ntemporarily disable access log tests to build\n\nFix duplicate fields being printed", "committedDate": "2020-06-04T17:15:38Z", "type": "commit"}, {"oid": "ca22a09aa411d60eda24fb914ad6e96e61c8b48f", "url": "https://github.com/OpenLiberty/open-liberty/commit/ca22a09aa411d60eda24fb914ad6e96e61c8b48f", "message": "Add FAT tests for new jsonAccessLogFields property", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "f129c9daf5c5664835b9d15e20cbde1c7e7aa76f", "url": "https://github.com/OpenLiberty/open-liberty/commit/f129c9daf5c5664835b9d15e20cbde1c7e7aa76f", "message": "Decouple logstashCollector feature from http, fix duplicate headers/cookie bug, address test bugs\n\nFix timing issue in test, add multiple endpoints test\n\nClose BufferedReader and add connection logs\n\nAdd lower timeout threshold for waits in assertNull", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "e5f7c804fbf2f5bc850be045a30132b0e97b3af0", "url": "https://github.com/OpenLiberty/open-liberty/commit/e5f7c804fbf2f5bc850be045a30132b0e97b3af0", "message": "Address thread safety issue with cached start fields, use better method to remove duplicate tokens\n\nRemove removeDuplicates() method, replace with better method that splits tokens into a HashMap while removing duplicates\n\nalways call updateFieldMappings after server config update\n\nFix the startMessageJsonFields method to match the other similar methods", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "ba2bb35585461096406a8a79b2ed07f34cead4a9", "url": "https://github.com/OpenLiberty/open-liberty/commit/ba2bb35585461096406a8a79b2ed07f34cead4a9", "message": "Fix up formatting, simplify the startXXXJsonFields methods, add setters\n\nRemove tempStartFields var\n\nFinal code clean up + fix copyright dates", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "08dbaa2d5a39ffe9ee6fdc66bce56b833b4af254", "url": "https://github.com/OpenLiberty/open-liberty/commit/08dbaa2d5a39ffe9ee6fdc66bce56b833b4af254", "message": "Remove case sensitivity for headers, add warning for not providing header name, add null check to prevent NPE to continue after logging warning msg", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4OTEyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r435589124", "bodyText": "does this check need to ignore case?", "author": "donbourne", "createdAt": "2020-06-04T22:34:29Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -344,13 +349,16 @@ private static AccessLogDataFormatter populateCustomFormatters(Map<String, HashS\n                     case \"%C\": builder.add(addCookiesField           (format)); break;\n                     case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n-                        if (fields.get(\"%i\").contains(\"User-Agent\")) {\n+                        // Error message was printed earlier in populateSetters(), so we just break in this case\n+                        if (fields.get(\"%i\") == null) {\n+                            break;\n+                        }\n+                        if (fields.get(\"%i\").contains(USER_AGENT_HEADER)) {", "originalCommit": "b2087279bd49dc1a876c188d730ef5c98d0ebdb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzNjI2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r435636268", "bodyText": "nope, the method that lowercases the header names is called before this method (and the USER_AGENT_HEADER var is all lowercase)", "author": "jennifer-c", "createdAt": "2020-06-05T01:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4OTEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MjY5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r435592699", "bodyText": "should just be able to add this info to the Tr.register call in AccessLogSource.java", "author": "donbourne", "createdAt": "2020-06-04T22:44:49Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/package-info.java", "diffHunk": "@@ -11,5 +11,8 @@\n /**\n  * @version 1.0.16\n  */\n+@TraceOptions(traceGroup = \"logging\", messageBundle = \"com.ibm.ws.logging.internal.resources.LoggingMessages\")", "originalCommit": "b2087279bd49dc1a876c188d730ef5c98d0ebdb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "url": "https://github.com/OpenLiberty/open-liberty/commit/5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "message": "Change bytesSent field to long instead of String, fix warning messages", "committedDate": "2020-06-05T01:01:50Z", "type": "commit"}, {"oid": "5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "url": "https://github.com/OpenLiberty/open-liberty/commit/5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "message": "Change bytesSent field to long instead of String, fix warning messages", "committedDate": "2020-06-05T01:01:50Z", "type": "forcePushed"}, {"oid": "f723f426ff85d66b8470fcd8defbe355031f7346", "url": "https://github.com/OpenLiberty/open-liberty/commit/f723f426ff85d66b8470fcd8defbe355031f7346", "message": "Edit TRAS3012W warning message", "committedDate": "2020-06-09T14:28:05Z", "type": "forcePushed"}, {"oid": "7d00d9d6065478d5e94a50540e3008f7555900d7", "url": "https://github.com/OpenLiberty/open-liberty/commit/7d00d9d6065478d5e94a50540e3008f7555900d7", "message": "Edit TRAS3012W warning message, move applyJsonFields method call\n\nMove applyJsonFields method call to after creating handlers\n\nFix message", "committedDate": "2020-06-09T22:05:41Z", "type": "forcePushed"}, {"oid": "b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "url": "https://github.com/OpenLiberty/open-liberty/commit/b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "message": "Edit TRAS3012W warning message, move applyJsonFields method call\n\nMove applyJsonFields method call to after creating handlers\n\nFix message", "committedDate": "2020-06-09T22:07:23Z", "type": "commit"}, {"oid": "b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "url": "https://github.com/OpenLiberty/open-liberty/commit/b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "message": "Edit TRAS3012W warning message, move applyJsonFields method call\n\nMove applyJsonFields method call to after creating handlers\n\nFix message", "committedDate": "2020-06-09T22:07:23Z", "type": "forcePushed"}]}