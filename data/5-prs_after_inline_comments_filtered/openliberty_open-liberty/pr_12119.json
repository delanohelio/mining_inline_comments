{"pr_number": 12119, "pr_title": "check for updated directoryURI and refresh certificate", "pr_createdAt": "2020-05-10T18:23:41Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/12119", "timeline": [{"oid": "043d1f413ff09e518d43cdde8590439b366716de", "url": "https://github.com/OpenLiberty/open-liberty/commit/043d1f413ff09e518d43cdde8590439b366716de", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-10T18:30:30Z", "type": "forcePushed"}, {"oid": "15cb6af524c7f675d2afb7cf5ed2f3b5738bf041", "url": "https://github.com/OpenLiberty/open-liberty/commit/15cb6af524c7f675d2afb7cf5ed2f3b5738bf041", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-12T03:30:26Z", "type": "forcePushed"}, {"oid": "1947e8812bf6c743262bd50016573f83f629ed0e", "url": "https://github.com/OpenLiberty/open-liberty/commit/1947e8812bf6c743262bd50016573f83f629ed0e", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-12T03:34:37Z", "type": "forcePushed"}, {"oid": "43685e4282f87248cbb56d95117895c7485f1acb", "url": "https://github.com/OpenLiberty/open-liberty/commit/43685e4282f87248cbb56d95117895c7485f1acb", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-12T03:54:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0ODI2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423448266", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString();\n          \n          \n            \n            \t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString(16);", "author": "jvanhill", "createdAt": "2020-05-12T04:00:54Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -873,5 +911,98 @@ protected void updateAcmeConfigService(AcmeConfigService acmeConfigService, Map<\n \tpublic void setAcmeApplicationStateListener(AcmeApplicationStateListener acmeApplicationStateListener) {\n \t\tapplicationStateListenerRef.set(acmeApplicationStateListener);\n \t}\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprivate boolean directoryURIChanged() throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString fileDirURI = acmeConfig.getDirectoryURI();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t\tString directoryURI = acmeConfig.getDirectoryURI();\n+\t\tif (directoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile() {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t}\n+\n+\tprivate void updateAcmeFile() throws AcmeCaException {\n+\t\tupdateAcmeFile(null);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information.\n+\t * @param acmeCertificate The AcmeCertificate to use to populate\n+\t * the acme file or null to use the default certificate\n+\t * \n+\t * @throws AcmeCaException\n+\t */\n+\tprivate void updateAcmeFile(AcmeCertificate acmeCertificate) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString directoryURI = acmeConfig.getDirectoryURI(); \n+\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\");  \n+\t\tLocalDateTime now = LocalDateTime.now();  \n+\t\tString date = dtf.format(now);\n+\t\tString serial = null;\n+\t\tif (acmeCertificate == null) {\n+\t\t\tX509Certificate certificate = getLeafCertificate(getConfiguredDefaultCertificateChain());\n+\t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString();", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0ODgxNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423448815", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate void updateAcmeFile() throws AcmeCaException {\n          \n          \n            \n                    /**\n          \n          \n            \n                     * Update the historical ACME file.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @throws AcmeCaException TODO\n          \n          \n            \n            \tprivate void updateAcmeFile() throws AcmeCaException {", "author": "jvanhill", "createdAt": "2020-05-12T04:03:33Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -873,5 +911,98 @@ protected void updateAcmeConfigService(AcmeConfigService acmeConfigService, Map<\n \tpublic void setAcmeApplicationStateListener(AcmeApplicationStateListener acmeApplicationStateListener) {\n \t\tapplicationStateListenerRef.set(acmeApplicationStateListener);\n \t}\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprivate boolean directoryURIChanged() throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString fileDirURI = acmeConfig.getDirectoryURI();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t\tString directoryURI = acmeConfig.getDirectoryURI();\n+\t\tif (directoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile() {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t}\n+\n+\tprivate void updateAcmeFile() throws AcmeCaException {", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0OTAxNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423449017", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tserial = acmeCertificate.getCertificate().getSerialNumber().toString();\n          \n          \n            \n            \t\t\tserial = acmeCertificate.getCertificate().getSerialNumber().toString(16);", "author": "jvanhill", "createdAt": "2020-05-12T04:04:32Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -873,5 +911,98 @@ protected void updateAcmeConfigService(AcmeConfigService acmeConfigService, Map<\n \tpublic void setAcmeApplicationStateListener(AcmeApplicationStateListener acmeApplicationStateListener) {\n \t\tapplicationStateListenerRef.set(acmeApplicationStateListener);\n \t}\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprivate boolean directoryURIChanged() throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString fileDirURI = acmeConfig.getDirectoryURI();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t\tString directoryURI = acmeConfig.getDirectoryURI();\n+\t\tif (directoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile() {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t}\n+\n+\tprivate void updateAcmeFile() throws AcmeCaException {\n+\t\tupdateAcmeFile(null);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information.\n+\t * @param acmeCertificate The AcmeCertificate to use to populate\n+\t * the acme file or null to use the default certificate\n+\t * \n+\t * @throws AcmeCaException\n+\t */\n+\tprivate void updateAcmeFile(AcmeCertificate acmeCertificate) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString directoryURI = acmeConfig.getDirectoryURI(); \n+\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\");  \n+\t\tLocalDateTime now = LocalDateTime.now();  \n+\t\tString date = dtf.format(now);\n+\t\tString serial = null;\n+\t\tif (acmeCertificate == null) {\n+\t\t\tX509Certificate certificate = getLeafCertificate(getConfiguredDefaultCertificateChain());\n+\t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString();\n+\t\t} else {\n+\t\t\tserial = acmeCertificate.getCertificate().getSerialNumber().toString();", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0OTU0Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423449546", "bodyText": "Not sure \\t\\t is a good delimiter.", "author": "jvanhill", "createdAt": "2020-05-12T04:06:46Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -873,5 +911,98 @@ protected void updateAcmeConfigService(AcmeConfigService acmeConfigService, Map<\n \tpublic void setAcmeApplicationStateListener(AcmeApplicationStateListener acmeApplicationStateListener) {\n \t\tapplicationStateListenerRef.set(acmeApplicationStateListener);\n \t}\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprivate boolean directoryURIChanged() throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString fileDirURI = acmeConfig.getDirectoryURI();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t\tString directoryURI = acmeConfig.getDirectoryURI();\n+\t\tif (directoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile() {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t}\n+\n+\tprivate void updateAcmeFile() throws AcmeCaException {\n+\t\tupdateAcmeFile(null);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information.\n+\t * @param acmeCertificate The AcmeCertificate to use to populate\n+\t * the acme file or null to use the default certificate\n+\t * \n+\t * @throws AcmeCaException\n+\t */\n+\tprivate void updateAcmeFile(AcmeCertificate acmeCertificate) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString directoryURI = acmeConfig.getDirectoryURI(); \n+\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\");  \n+\t\tLocalDateTime now = LocalDateTime.now();  \n+\t\tString date = dtf.format(now);\n+\t\tString serial = null;\n+\t\tif (acmeCertificate == null) {\n+\t\t\tX509Certificate certificate = getLeafCertificate(getConfiguredDefaultCertificateChain());\n+\t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString();\n+\t\t} else {\n+\t\t\tserial = acmeCertificate.getCertificate().getSerialNumber().toString();\n+\t\t}\n+\t\tString accountURI = acmeClient.getAccount().getLocation().toString();\n \n+       \tFileWriter fr;\n+\t\ttry {\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"\\n\");\n+\t\t   \tfr.write(date + \"\\t\\t\" + serial + \"\\t\\t\" + directoryURI + \"\\t\\t\" + accountURI);", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0OTg4Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423449883", "bodyText": "Maybe this can just be done inside update? If it doesn't exist, try and create it?", "author": "jvanhill", "createdAt": "2020-05-12T04:08:13Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -700,6 +712,14 @@ public File createDefaultSSLCertificate(String filePath, @Sensitive String passw\n \t\t\t */\n \t\t\tFile file = createKeyStore(filePath, acmeCertificate, password, keyStoreType, keyStoreProvider);\n \n+\t\t\t/*\n+\t\t\t * Create the acme file which holds certificate information and a record\n+\t\t\t * of directoryURIs. We use this to determine if the directoryURI has\n+\t\t\t * been updated. If so, we need to refresh the certificate.\n+\t\t\t */\n+\t\t\tcreateAcmeFile();", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MDIwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423450204", "bodyText": "This isn't an AcmeCaException, so not localized.", "author": "jvanhill", "createdAt": "2020-05-12T04:09:40Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -873,5 +911,98 @@ protected void updateAcmeConfigService(AcmeConfigService acmeConfigService, Map<\n \tpublic void setAcmeApplicationStateListener(AcmeApplicationStateListener acmeApplicationStateListener) {\n \t\tapplicationStateListenerRef.set(acmeApplicationStateListener);\n \t}\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprivate boolean directoryURIChanged() throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString fileDirURI = acmeConfig.getDirectoryURI();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t\tString directoryURI = acmeConfig.getDirectoryURI();\n+\t\tif (directoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile() {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t}\n+\n+\tprivate void updateAcmeFile() throws AcmeCaException {\n+\t\tupdateAcmeFile(null);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information.\n+\t * @param acmeCertificate The AcmeCertificate to use to populate\n+\t * the acme file or null to use the default certificate\n+\t * \n+\t * @throws AcmeCaException\n+\t */\n+\tprivate void updateAcmeFile(AcmeCertificate acmeCertificate) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString directoryURI = acmeConfig.getDirectoryURI(); \n+\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\");  \n+\t\tLocalDateTime now = LocalDateTime.now();  \n+\t\tString date = dtf.format(now);\n+\t\tString serial = null;\n+\t\tif (acmeCertificate == null) {\n+\t\t\tX509Certificate certificate = getLeafCertificate(getConfiguredDefaultCertificateChain());\n+\t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString();\n+\t\t} else {\n+\t\t\tserial = acmeCertificate.getCertificate().getSerialNumber().toString();\n+\t\t}\n+\t\tString accountURI = acmeClient.getAccount().getLocation().toString();\n \n+       \tFileWriter fr;\n+\t\ttry {\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"\\n\");\n+\t\t   \tfr.write(date + \"\\t\\t\" + serial + \"\\t\\t\" + directoryURI + \"\\t\\t\" + accountURI);\n+\t\t   \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MDQ4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423450482", "bodyText": "Unnecessary white space.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tAcmeCaRestHandlerTest.class,\n          \n          \n            \n            \tAcmeCaRestHandlerTest.class,", "author": "jvanhill", "createdAt": "2020-05-12T04:10:44Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/FATSuite.java", "diffHunk": "@@ -21,7 +21,8 @@\n \tAcmeSimpleTest.class,\n \tAcmeURISimpleTest.class,\n \tAcmeBoulderSimpleTest.class,  \n-\tAcmeCaRestHandlerTest.class, \n+\t\tAcmeCaRestHandlerTest.class,", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MDUzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423450535", "bodyText": "Unnecessary white space.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tAcmeSwapDirectoriesTest.class,\n          \n          \n            \n            \tAcmeSwapDirectoriesTest.class,", "author": "jvanhill", "createdAt": "2020-05-12T04:10:55Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/FATSuite.java", "diffHunk": "@@ -21,7 +21,8 @@\n \tAcmeSimpleTest.class,\n \tAcmeURISimpleTest.class,\n \tAcmeBoulderSimpleTest.class,  \n-\tAcmeCaRestHandlerTest.class, \n+\t\tAcmeCaRestHandlerTest.class,\n+\t\tAcmeSwapDirectoriesTest.class,", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MDc2MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423450761", "bodyText": "I think I would put all the logic related to historical records into its own class and call it from AcmeProviderImpl.", "author": "jvanhill", "createdAt": "2020-05-12T04:11:55Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -873,5 +911,98 @@ protected void updateAcmeConfigService(AcmeConfigService acmeConfigService, Map<\n \tpublic void setAcmeApplicationStateListener(AcmeApplicationStateListener acmeApplicationStateListener) {\n \t\tapplicationStateListenerRef.set(acmeApplicationStateListener);\n \t}\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprivate boolean directoryURIChanged() throws AcmeCaException {", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MTQ0MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423451441", "bodyText": "Is the kernel component already in our bnd.bnd file?", "author": "jvanhill", "createdAt": "2020-05-12T04:14:55Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -82,6 +91,9 @@\n \n \t/** Configuration for the ACME client. */\n \tprivate static AcmeConfig acmeConfig;\n+\t\n+\t@Reference\n+\tprivate com.ibm.wsspi.kernel.service.location.WsLocationAdmin wslocation;", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgyNjUwMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423826500", "bodyText": "yes", "author": "ryanesch", "createdAt": "2020-05-12T15:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MTczOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423451739", "bodyText": "I don't see any logic in here to limit the number of lines. I think we should probably limit it to 10 or so.", "author": "jvanhill", "createdAt": "2020-05-12T04:16:13Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -873,5 +911,98 @@ protected void updateAcmeConfigService(AcmeConfigService acmeConfigService, Map<\n \tpublic void setAcmeApplicationStateListener(AcmeApplicationStateListener acmeApplicationStateListener) {\n \t\tapplicationStateListenerRef.set(acmeApplicationStateListener);\n \t}\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprivate boolean directoryURIChanged() throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tString fileDirURI = acmeConfig.getDirectoryURI();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t\tString directoryURI = acmeConfig.getDirectoryURI();\n+\t\tif (directoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile() {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, true);\n+\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); // AcmeCaExceptions are localized.\n+\t\t}\n+\t}\n+\n+\tprivate void updateAcmeFile() throws AcmeCaException {\n+\t\tupdateAcmeFile(null);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information.\n+\t * @param acmeCertificate The AcmeCertificate to use to populate\n+\t * the acme file or null to use the default certificate\n+\t * \n+\t * @throws AcmeCaException\n+\t */\n+\tprivate void updateAcmeFile(AcmeCertificate acmeCertificate) throws AcmeCaException {", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MjM4Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423452383", "bodyText": "Assuming copied from AcmeSimpleTest.", "author": "jvanhill", "createdAt": "2020-05-12T04:18:59Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MjYzNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423452634", "bodyText": "are these actually different ports? i think they are the same.", "author": "jvanhill", "createdAt": "2020-05-12T04:19:58Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t\tAcmeFatUtils.checkPortOpen(caContainer2.getHttpPort(), 60000);", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1Mjc5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423452799", "bodyText": "probably don't need this. Just always run HTTPS. We had this in acmesimpletest to run both ways.", "author": "jvanhill", "createdAt": "2020-05-12T04:20:44Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t\tAcmeFatUtils.checkPortOpen(caContainer2.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * Whether to use \"acme://\" style URIs, or \"https://\" style URIs.\n+\t * \n+\t * <p/>\n+\t * Sub-classes can override this method to determine which style URIs should\n+\t * be used.\n+\t * \n+\t * @return Whether to use \"acme://\" style URIs.\n+\t */\n+\tprotected boolean useAcmeURIs() {", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MjkwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423452908", "bodyText": "Need javadoc to explain test.", "author": "jvanhill", "createdAt": "2020-05-12T04:21:01Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t\tAcmeFatUtils.checkPortOpen(caContainer2.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * Whether to use \"acme://\" style URIs, or \"https://\" style URIs.\n+\t * \n+\t * <p/>\n+\t * Sub-classes can override this method to determine which style URIs should\n+\t * be used.\n+\t * \n+\t * @return Whether to use \"acme://\" style URIs.\n+\t */\n+\tprotected boolean useAcmeURIs() {\n+\t\treturn false;\n+\t}\n+\n+\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MzY3Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423453676", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t * Verify that the server is now using a certificate signed by the\n          \n          \n            \n            \t\t\t * Verify that the server is now using a certificate signed by the new", "author": "jvanhill", "createdAt": "2020-05-12T04:23:44Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t\tAcmeFatUtils.checkPortOpen(caContainer2.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * Whether to use \"acme://\" style URIs, or \"https://\" style URIs.\n+\t * \n+\t * <p/>\n+\t * Sub-classes can override this method to determine which style URIs should\n+\t * be used.\n+\t * \n+\t * @return Whether to use \"acme://\" style URIs.\n+\t */\n+\tprotected boolean useAcmeURIs() {\n+\t\treturn false;\n+\t}\n+\n+\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, useAcmeURIs(), DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, useAcmeURIs(), DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1Mzc0Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423453746", "bodyText": "Should check the historical file.", "author": "jvanhill", "createdAt": "2020-05-12T04:24:01Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t\tAcmeFatUtils.checkPortOpen(caContainer2.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * Whether to use \"acme://\" style URIs, or \"https://\" style URIs.\n+\t * \n+\t * <p/>\n+\t * Sub-classes can override this method to determine which style URIs should\n+\t * be used.\n+\t * \n+\t * @return Whether to use \"acme://\" style URIs.\n+\t */\n+\tprotected boolean useAcmeURIs() {\n+\t\treturn false;\n+\t}\n+\n+\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, useAcmeURIs(), DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NTU4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r432585584", "bodyText": "I don't see you checking the historical file.", "author": "jvanhill", "createdAt": "2020-05-29T16:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1Mzc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1Mzg2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423453869", "bodyText": "Check the historical file.", "author": "jvanhill", "createdAt": "2020-05-12T04:24:32Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t\tAcmeFatUtils.checkPortOpen(caContainer2.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * Whether to use \"acme://\" style URIs, or \"https://\" style URIs.\n+\t * \n+\t * <p/>\n+\t * Sub-classes can override this method to determine which style URIs should\n+\t * be used.\n+\t * \n+\t * @return Whether to use \"acme://\" style URIs.\n+\t */\n+\tprotected boolean useAcmeURIs() {\n+\t\treturn false;\n+\t}\n+\n+\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, useAcmeURIs(), DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, useAcmeURIs(), DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NTgwMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r432585802", "bodyText": "Not checking the historical file.", "author": "jvanhill", "createdAt": "2020-05-29T16:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1Mzg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMDAyMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r432600022", "bodyText": "Yes I am, lines 174-182.", "author": "ryanesch", "createdAt": "2020-05-29T16:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1Mzg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxNjIzNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r434816234", "bodyText": "My bad, i misread the test and thought you were doing another operation immediately below.", "author": "jvanhill", "createdAt": "2020-06-03T19:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1Mzg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1NDM3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r423454374", "bodyText": "I think we need a few more tests. Probably do one where we start the server, check the historical file, stop the server, change to the new CA, then restart, verify we regenerated the certificate, then check the historical file.\nWe also should have a test where we check if we could not write to the historical file, and one where we could not read from the historical file (we would need to change the read permissions on the directory, and the file respectively). We may need to skip those tests on windows b/c Java doesn't seem to actually change the permissions. See one of the other FATs for details.", "author": "jvanhill", "createdAt": "2020-05-12T04:26:37Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import java.math.BigInteger;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+\n+/**\n+ * Some simple test for running the acmeCA-2.0 feature.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t\tAcmeFatUtils.checkPortOpen(caContainer2.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * Whether to use \"acme://\" style URIs, or \"https://\" style URIs.\n+\t * \n+\t * <p/>\n+\t * Sub-classes can override this method to determine which style URIs should\n+\t * be used.\n+\t * \n+\t * @return Whether to use \"acme://\" style URIs.\n+\t */\n+\tprotected boolean useAcmeURIs() {\n+\t\treturn false;\n+\t}\n+", "originalCommit": "43685e4282f87248cbb56d95117895c7485f1acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a1849eb0458ae4d8fb0fc94827d33f6a5d97b5c0", "url": "https://github.com/OpenLiberty/open-liberty/commit/a1849eb0458ae4d8fb0fc94827d33f6a5d97b5c0", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-19T15:24:05Z", "type": "forcePushed"}, {"oid": "d3a3b6d1da667f52e8e9164355ce50779b5885b2", "url": "https://github.com/OpenLiberty/open-liberty/commit/d3a3b6d1da667f52e8e9164355ce50779b5885b2", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-19T15:30:19Z", "type": "forcePushed"}, {"oid": "3b6c8065b3fd27c73ad3592d5a059a3bf87c5a96", "url": "https://github.com/OpenLiberty/open-liberty/commit/3b6c8065b3fd27c73ad3592d5a059a3bf87c5a96", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-19T15:47:20Z", "type": "forcePushed"}, {"oid": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "url": "https://github.com/OpenLiberty/open-liberty/commit/0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-19T15:49:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NTgxMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427485810", "bodyText": "Copyright.", "author": "jvanhill", "createdAt": "2020-05-19T17:45:19Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDAwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427504003", "bodyText": "just let this flow out, it will give us the stack trace for the exception if you do.", "author": "jvanhill", "createdAt": "2020-05-19T18:14:04Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);\n+\t\t\tassertEquals(caContainer2.getAcmeDirectoryURI(false), secondDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: FINISH\");\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 4: Stop the server, change the directoryURI, and start the server.\n+\t\t\t * We should renew the certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: START\");\n+\t\t\tserver.stopServer();\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeAppToStart(server);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates3 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial3 = ((X509Certificate) certificates3[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial2.equals(serial3));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 5: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: START\");\n+\t\t\tString thirdDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) thirdDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDEwNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427504105", "bodyText": "just let this flow out, it will give us the stack trace for the exception if you do.", "author": "jvanhill", "createdAt": "2020-05-19T18:14:14Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); ", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDIxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427504213", "bodyText": "just let this flow out, it will give us the stack trace for the exception if you do.", "author": "jvanhill", "createdAt": "2020-05-19T18:14:26Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); ", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDgxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427504819", "bodyText": "Unless you configure domains explicitly, you don't need to clear them.", "author": "jvanhill", "createdAt": "2020-05-19T18:15:23Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMTQ2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427521468", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-05-19T18:43:27Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5Mzg1Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r428893852", "bodyText": "I can't figure out what whitespace you are referring to. Maybe it's confusing because line 141 looks like it's two lines? Or you want me to add white space?", "author": "ryanesch", "createdAt": "2020-05-21T20:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMTQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5NTQ4Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r428895483", "bodyText": "btw certificate and the comment block below. Nit picky.", "author": "jvanhill", "createdAt": "2020-05-21T20:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjE2Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427522162", "bodyText": "Can we have a getHistoryEntries() method or something? I also assume you do this in the product code? Can't you have a helper method there so we only have to update code in one place?", "author": "jvanhill", "createdAt": "2020-05-19T18:44:44Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjMwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427522307", "bodyText": "Can we have a getHistoryEntries() method or something? I also assume you do this in the product code? Can't you have a helper method there so we only have to update code in one place?", "author": "jvanhill", "createdAt": "2020-05-19T18:44:57Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzE4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427523184", "bodyText": "Can we get a helper method and do an assume? Kristi does the same thing elsewhere.", "author": "jvanhill", "createdAt": "2020-05-19T18:46:16Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);\n+\t\t\tassertEquals(caContainer2.getAcmeDirectoryURI(false), secondDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: FINISH\");\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 4: Stop the server, change the directoryURI, and start the server.\n+\t\t\t * We should renew the certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: START\");\n+\t\t\tserver.stopServer();\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeAppToStart(server);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates3 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial3 = ((X509Certificate) certificates3[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial2.equals(serial3));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 5: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: START\");\n+\t\t\tString thirdDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) thirdDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(secondDirURI, thirdDirURI);\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), thirdDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: FINISH\");\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the certificate is refreshed\n+\t * when the ACME file is unreadable or unwritable.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+    @AllowedFFDC(value = { \"java.io.FileNotFoundException\", \"java.io.IOException\" })\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI_filePermissions() throws Exception {\n+\t\tif (System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")) {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzM5Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427523392", "bodyText": "Can we have a getHistoryEntries() method or something? I also assume you do this in the product code? Can't you have a helper method there so we only have to update code in one place?", "author": "jvanhill", "createdAt": "2020-05-19T18:46:39Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);\n+\t\t\tassertEquals(caContainer2.getAcmeDirectoryURI(false), secondDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: FINISH\");\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 4: Stop the server, change the directoryURI, and start the server.\n+\t\t\t * We should renew the certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: START\");\n+\t\t\tserver.stopServer();\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeAppToStart(server);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates3 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial3 = ((X509Certificate) certificates3[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial2.equals(serial3));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 5: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: START\");\n+\t\t\tString thirdDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) thirdDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(secondDirURI, thirdDirURI);\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), thirdDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: FINISH\");\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the certificate is refreshed\n+\t * when the ACME file is unreadable or unwritable.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+    @AllowedFFDC(value = { \"java.io.FileNotFoundException\", \"java.io.IOException\" })\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI_filePermissions() throws Exception {\n+\t\tif (System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")) {\n+\t\t\t// windows not enforcing the setReadable/setWriteable\n+\t\t\tLog.info(AcmeSwapDirectoriesTest.class, testName.getMethodName(),\n+\t\t\t\t\t\"Skipping unreadable/unwriteable file tests on Windows: \"\n+\t\t\t\t\t\t\t+ System.getProperty(\"os.name\", \"unknown\"));\n+\t\t\treturn;\n+\t\t}\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Remove the read permission on the ACME file.\n+\t\t\t * Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate. We are removing a domain in config that is not\n+\t\t\t * the subject CN, so normally this would NOT refresh the cert.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile acmefile = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tacmefile.setReadable(false,false);\n+\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_3);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after being unable to read ACME file.\", serial1.equals(serial2));\n+\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH.\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Remove the write permissions on the ACME file.\n+\t\t\t * Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tif (acmefile.exists()) {\n+\t\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"deleting acme file \" + server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\t\tacmefile.delete();\n+\t\t\t}\n+\n+\t\t\tFile acmeDir = Files.createDirectories(Paths.get(server.getServerRoot() + \"/workarea/acme\")).toFile();\n+\t\t\tif (acmeDir.exists()) {\n+\t\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"acme dir \" + acmeDir.getAbsolutePath() + \" \" + Files.isWritable(Paths.get(acmeDir.getAbsolutePath())));\n+\t\t\t\tacmeDir.setWritable(false);\n+\t\t\t}\n+\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\tif (acmefile.exists()) {\n+\t\t\t\tfail(\"The ACME file should not exist.\");\n+\t\t\t}\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH.\");\n+\t\t\t\t\n+\t\t\t\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the ACME file does not exceed\n+\t * 10 entries. When the 11th entry is added, the oldest one\n+\t * should be removed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI_maxFileSize() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\t\t\n+\t\t//Make sure the ACME directory is writable - in case the previous test fails out.\n+\t\tFile acmeDir = Files.createDirectories(Paths.get(server.getServerRoot() + \"/workarea/acme\")).toFile();\n+\t\tif (acmeDir.exists()) {\n+\t\t\tacmeDir.setWritable(true);\n+\t\t}\n+\t\t\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tAcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Populate the ACME file to max size and update the directoryURI.\n+\t\t\t * We should refresh the certificate and the number of lines in the ACME\n+\t\t\t * file should stay the same.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\n+\t\t\t//Write 10 fake entries to the ACME file\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t       \tFileWriter fr;\n+\t\t\ttry {\n+\t\t\t\tfr = new FileWriter(file, false);\n+\t\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\\n\");\n+\t\t\t\tfor (int i=0; i<10; i++) {\n+\t\t\t\t\tfr.write(\"1234567890        1122334455667788        http://directoryURI\" + i + \"        http://accountURI\");\n+\t\t\t\t\tif (i<9) fr.write(\"\\n\");\n+\t\t\t\t}\n+\t\t\t   \tfr.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\t\n+\t\t\t//Update the config. This normally wouldn't cause a certificate refresh, but\n+\t\t\t//there has been a change in directoryURI.\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_3);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\t\n+\t\t\t//Check the ACME file for the new entry.\n+\t\t\tArrayList<String> lines = new ArrayList<String>();\n+\t\t\tString fileDirURI = null;\n+\t\t\ttry {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyOTA1NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427529054", "bodyText": "Use the product code to write this so we only have to update code in one place?", "author": "jvanhill", "createdAt": "2020-05-19T18:56:15Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);\n+\t\t\tassertEquals(caContainer2.getAcmeDirectoryURI(false), secondDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: FINISH\");\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 4: Stop the server, change the directoryURI, and start the server.\n+\t\t\t * We should renew the certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: START\");\n+\t\t\tserver.stopServer();\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeAppToStart(server);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates3 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial3 = ((X509Certificate) certificates3[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial2.equals(serial3));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 5: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: START\");\n+\t\t\tString thirdDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) thirdDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(secondDirURI, thirdDirURI);\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), thirdDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: FINISH\");\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the certificate is refreshed\n+\t * when the ACME file is unreadable or unwritable.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+    @AllowedFFDC(value = { \"java.io.FileNotFoundException\", \"java.io.IOException\" })\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI_filePermissions() throws Exception {\n+\t\tif (System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")) {\n+\t\t\t// windows not enforcing the setReadable/setWriteable\n+\t\t\tLog.info(AcmeSwapDirectoriesTest.class, testName.getMethodName(),\n+\t\t\t\t\t\"Skipping unreadable/unwriteable file tests on Windows: \"\n+\t\t\t\t\t\t\t+ System.getProperty(\"os.name\", \"unknown\"));\n+\t\t\treturn;\n+\t\t}\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Remove the read permission on the ACME file.\n+\t\t\t * Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate. We are removing a domain in config that is not\n+\t\t\t * the subject CN, so normally this would NOT refresh the cert.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile acmefile = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tacmefile.setReadable(false,false);\n+\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_3);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after being unable to read ACME file.\", serial1.equals(serial2));\n+\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH.\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Remove the write permissions on the ACME file.\n+\t\t\t * Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tif (acmefile.exists()) {\n+\t\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"deleting acme file \" + server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\t\tacmefile.delete();\n+\t\t\t}\n+\n+\t\t\tFile acmeDir = Files.createDirectories(Paths.get(server.getServerRoot() + \"/workarea/acme\")).toFile();\n+\t\t\tif (acmeDir.exists()) {\n+\t\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"acme dir \" + acmeDir.getAbsolutePath() + \" \" + Files.isWritable(Paths.get(acmeDir.getAbsolutePath())));\n+\t\t\t\tacmeDir.setWritable(false);\n+\t\t\t}\n+\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\tif (acmefile.exists()) {\n+\t\t\t\tfail(\"The ACME file should not exist.\");\n+\t\t\t}\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH.\");\n+\t\t\t\t\n+\t\t\t\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the ACME file does not exceed\n+\t * 10 entries. When the 11th entry is added, the oldest one\n+\t * should be removed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI_maxFileSize() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\t\t\n+\t\t//Make sure the ACME directory is writable - in case the previous test fails out.\n+\t\tFile acmeDir = Files.createDirectories(Paths.get(server.getServerRoot() + \"/workarea/acme\")).toFile();\n+\t\tif (acmeDir.exists()) {\n+\t\t\tacmeDir.setWritable(true);\n+\t\t}\n+\t\t\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tAcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Populate the ACME file to max size and update the directoryURI.\n+\t\t\t * We should refresh the certificate and the number of lines in the ACME\n+\t\t\t * file should stay the same.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\n+\t\t\t//Write 10 fake entries to the ACME file\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t       \tFileWriter fr;\n+\t\t\ttry {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMTQ4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427531485", "bodyText": "Check size == 2?", "author": "jvanhill", "createdAt": "2020-05-19T19:00:16Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MDIyMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427540222", "bodyText": "not really a new test. just verifying the last test worked.", "author": "jvanhill", "createdAt": "2020-05-19T19:15:34Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. ", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MDQ4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427540482", "bodyText": "Again, not a new test. You are verifying the previous test.", "author": "jvanhill", "createdAt": "2020-05-19T19:16:02Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);\n+\t\t\tassertEquals(caContainer2.getAcmeDirectoryURI(false), secondDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: FINISH\");\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 4: Stop the server, change the directoryURI, and start the server.\n+\t\t\t * We should renew the certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: START\");\n+\t\t\tserver.stopServer();\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeAppToStart(server);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates3 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial3 = ((X509Certificate) certificates3[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial2.equals(serial3));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 5: Check that the ACME historical file was updated. ", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NzgwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427547804", "bodyText": "I am not really following this test...\nI would have expected:\n\nremove read / write permission\nstart server\ncheck file does NOT exist, new cert written\nstop server\nadd write permission\nstart server\ncheck file exists, new cert (seems we should replace on startup if we can't verify old URL)\nstop server\nadd read permission, swap CAs\nstart server\ncheck that file exists, was updated, new cert (since new CA\nstop server", "author": "jvanhill", "createdAt": "2020-05-19T19:29:03Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);\n+\t\t\tassertEquals(caContainer2.getAcmeDirectoryURI(false), secondDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: FINISH\");\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 4: Stop the server, change the directoryURI, and start the server.\n+\t\t\t * We should renew the certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: START\");\n+\t\t\tserver.stopServer();\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeAppToStart(server);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates3 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial3 = ((X509Certificate) certificates3[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial2.equals(serial3));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 5: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: START\");\n+\t\t\tString thirdDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) thirdDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(secondDirURI, thirdDirURI);\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), thirdDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: FINISH\");\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the certificate is refreshed\n+\t * when the ACME file is unreadable or unwritable.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+    @AllowedFFDC(value = { \"java.io.FileNotFoundException\", \"java.io.IOException\" })", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUxNjQxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r430516416", "bodyText": "I can't change the permissions while the server is down because when a server starts, a new server directory is created, eg. com.ibm.ws.security.acme.fat.simple-21-05-2020-16-03-05. Thus, any acme file i would have created would be down a different path.\nBecause of this, I can't use different directoryURIs to trigger a config update because that would refresh the certificate, and I'm trying to test that an unreadable/unwritable acme file triggers a refresh. So I use domain changes that should not trigger a refresh on their own.\n\nStart the server and wait for initial certificate\nSet the acme file to be unreadable. The next time we try to read it, we should force refresh the certificate.\nUpdate the config with a change that does NOT force refresh and wait for the certificate to refresh.\nDelete the acme file and set the acme directory to be unreadable.\nChange the directoryURI. We won\u2019t be able to write the acme file, but we should refresh the certificate.", "author": "ryanesch", "createdAt": "2020-05-26T15:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjY4Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r432586686", "bodyText": "I thought that the acme.fat.simple directory remained, it just archived the contents at the end of the previous test (this is why we clean up the keystores at the end of each test). Perhaps I am wrong. As long as you are certain this is testing what you believe it is.", "author": "jvanhill", "createdAt": "2020-05-29T16:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0ODQ0Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427548447", "bodyText": "Do we allow a maximum of 12 lines? seems this should be a constant in ACMEConstants.", "author": "jvanhill", "createdAt": "2020-05-19T19:30:12Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_1 = { \"domain1.com\" };\n+\tprivate static final String[] DOMAINS_2 = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };\n+\tprivate static final String[] DOMAINS_3 = { \"domain1.com\", \"domain2.com\" };\n+\n+\tpublic static CAContainer caContainer;\n+\tpublic static CAContainer caContainer2;\n+\n+\t@Rule\n+\tpublic TestName testName = new TestName();\n+\n+\t@BeforeClass\n+\tpublic static void beforeClass() throws Exception {\n+\t\tORIGINAL_CONFIG = server.getServerConfiguration();\n+\t\tcaContainer = new PebbleContainer();\n+\t\tcaContainer2 = new PebbleContainer();\n+\t\tAcmeFatUtils.checkPortOpen(caContainer.getHttpPort(), 60000);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t\tif (caContainer != null) {\n+\t\t\tcaContainer.stop();\n+\t\t}\n+\t\tif (caContainer2 != null) {\n+\t\t\tcaContainer2.stop();\n+\t\t}\n+\t}\n+\n+\t@After\n+\tpublic void afterTest() throws Exception {\n+\t\t/*\n+\t\t * Clear the DNS records for the domain. Required since a few of the\n+\t\t * tests setup invalid A records to test failure scenarios.\n+\t\t */\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer, DOMAINS_ALL);\n+\t\tAcmeFatUtils.clearDnsForDomains(caContainer2, DOMAINS_ALL);\n+\n+\t\t/*\n+\t\t * Cleanup any generated ACME files.\n+\t\t */\n+\t\tAcmeFatUtils.deleteAcmeFiles(server);\n+\t}\n+\n+\t/**\n+\t * This test will verify that the ACME file is created and updated\n+\t * properly. When the directoryURI changes, the certificate should\n+\t * be refreshed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Check that the ACME historical file was created and populated\n+\t\t\t * with the first certificate and original directoryURI. \n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tif (!file.exists()) {\n+\t\t\t\tfail(\"The ACME file should exist at: \" + file.getAbsolutePath());\n+\t\t\t}\n+\t\t\tString firstDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) firstDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), firstDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer2, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer2);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial1.equals(serial2));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 3: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: START\");\n+\t\t\tString secondDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) secondDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(firstDirURI, secondDirURI);\n+\t\t\tassertEquals(caContainer2.getAcmeDirectoryURI(false), secondDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 3: FINISH\");\n+\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 4: Stop the server, change the directoryURI, and start the server.\n+\t\t\t * We should renew the certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: START\");\n+\t\t\tserver.stopServer();\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_1);\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeAppToStart(server);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates3 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial3 = ((X509Certificate) certificates3[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after adding new domain.\", serial2.equals(serial3));\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 4: FINISH\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 5: Check that the ACME historical file was updated. \n+\t\t\t * \n+\t\t\t **********************************************************************/\t\t\t\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: START\");\n+\t\t\tString thirdDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) thirdDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\tassertNotSame(secondDirURI, thirdDirURI);\n+\t\t\tassertEquals(caContainer.getAcmeDirectoryURI(false), thirdDirURI);\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 5: FINISH\");\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the certificate is refreshed\n+\t * when the ACME file is unreadable or unwritable.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+    @AllowedFFDC(value = { \"java.io.FileNotFoundException\", \"java.io.IOException\" })\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI_filePermissions() throws Exception {\n+\t\tif (System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")) {\n+\t\t\t// windows not enforcing the setReadable/setWriteable\n+\t\t\tLog.info(AcmeSwapDirectoriesTest.class, testName.getMethodName(),\n+\t\t\t\t\t\"Skipping unreadable/unwriteable file tests on Windows: \"\n+\t\t\t\t\t\t\t+ System.getProperty(\"os.name\", \"unknown\"));\n+\t\t\treturn;\n+\t\t}\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates1 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Remove the read permission on the ACME file.\n+\t\t\t * Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate. We are removing a domain in config that is not\n+\t\t\t * the subject CN, so normally this would NOT refresh the cert.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: START\");\n+\t\t\tFile acmefile = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\tacmefile.setReadable(false,false);\n+\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_3);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * new CA.\n+\t\t\t */\n+\t\t\tCertificate[] certificates2 = AcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\n+\t\t\tBigInteger serial1 = ((X509Certificate) certificates1[0]).getSerialNumber();\n+\t\t\tBigInteger serial2 = ((X509Certificate) certificates2[0]).getSerialNumber();\n+\t\t\tassertFalse(\"Expected new certificate after being unable to read ACME file.\", serial1.equals(serial2));\n+\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 1: FINISH.\");\n+\t\t\t\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 2: Remove the write permissions on the ACME file.\n+\t\t\t * Update the directoryURI. This should result in a refreshed\n+\t\t\t * certificate.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: START\");\n+\t\t\tif (acmefile.exists()) {\n+\t\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"deleting acme file \" + server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t\t\t\tacmefile.delete();\n+\t\t\t}\n+\n+\t\t\tFile acmeDir = Files.createDirectories(Paths.get(server.getServerRoot() + \"/workarea/acme\")).toFile();\n+\t\t\tif (acmeDir.exists()) {\n+\t\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"acme dir \" + acmeDir.getAbsolutePath() + \" \" + Files.isWritable(Paths.get(acmeDir.getAbsolutePath())));\n+\t\t\t\tacmeDir.setWritable(false);\n+\t\t\t}\n+\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\n+\t\t\tif (acmefile.exists()) {\n+\t\t\t\tfail(\"The ACME file should not exist.\");\n+\t\t\t}\n+\t\t\tLog.info(this.getClass(), testName.getMethodName(), \"TEST 2: FINISH.\");\n+\t\t\t\t\n+\t\t\t\n+\t\t} finally {\n+\t\t\t/*\n+\t\t\t * Stop the server.\n+\t\t\t */\n+\t\t\tserver.stopServer(\"CWPKI2038W\");\n+\t\t}\n+\t}\n+\t/**\n+\t * This test will verify that the ACME file does not exceed\n+\t * 10 entries. When the 11th entry is added, the oldest one\n+\t * should be removed.\n+\t * \n+\t * @throws Exception\n+\t *             If the test failed for some reason.\n+\t */\n+\t@Test\n+\t@CheckForLeakedPasswords(AcmeFatUtils.CACERTS_TRUSTSTORE_PASSWORD)\n+\tpublic void update_directoryURI_maxFileSize() throws Exception {\n+\n+\t\t/*\n+\t\t * Configure the acmeCA-2.0 feature.\n+\t\t */\n+\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_2);\n+\t\t\n+\t\t//Make sure the ACME directory is writable - in case the previous test fails out.\n+\t\tFile acmeDir = Files.createDirectories(Paths.get(server.getServerRoot() + \"/workarea/acme\")).toFile();\n+\t\tif (acmeDir.exists()) {\n+\t\t\tacmeDir.setWritable(true);\n+\t\t}\n+\t\t\n+\t\ttry {\n+\n+\t\t\t/*\n+\t\t\t * Start the server and wait for the certificate to be installed.\n+\t\t\t */\n+\t\t\tserver.startServer();\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\tAcmeFatUtils.waitForSslToCreateKeystore(server);\n+\t\t\tAcmeFatUtils.waitForSslEndpoint(server);\n+\n+\t\t\t/*\n+\t\t\t * Verify that the server is now using a certificate signed by the\n+\t\t\t * CA.\n+\t\t\t */\n+\t\t\tAcmeFatUtils.assertAndGetServerCertificate(server, caContainer);\n+\t\t\t/***********************************************************************\n+\t\t\t * \n+\t\t\t * TEST 1: Populate the ACME file to max size and update the directoryURI.\n+\t\t\t * We should refresh the certificate and the number of lines in the ACME\n+\t\t\t * file should stay the same.\n+\t\t\t * \n+\t\t\t **********************************************************************/\n+\n+\t\t\t//Write 10 fake entries to the ACME file\n+\t\t\tFile file = new File(server.getServerRoot() + \"/workarea/acme/acme.txt\");\n+\t       \tFileWriter fr;\n+\t\t\ttry {\n+\t\t\t\tfr = new FileWriter(file, false);\n+\t\t\t\tfr.write(\"Date\" + \"\\t\\t\\t\" + \"Serial\" + \"\\t\\t\" + \"DirectoryURI\" + \"\\t\\t\" + \"Account URI\" + \"\\n\");\n+\t\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\\n\");\n+\t\t\t\tfor (int i=0; i<10; i++) {\n+\t\t\t\t\tfr.write(\"1234567890        1122334455667788        http://directoryURI\" + i + \"        http://accountURI\");\n+\t\t\t\t\tif (i<9) fr.write(\"\\n\");\n+\t\t\t\t}\n+\t\t\t   \tfr.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\t\n+\t\t\t//Update the config. This normally wouldn't cause a certificate refresh, but\n+\t\t\t//there has been a change in directoryURI.\n+\t\t\tAcmeFatUtils.configureAcmeCA(server, caContainer, ORIGINAL_CONFIG, false, DOMAINS_3);\n+\t\t\tAcmeFatUtils.waitForAcmeToCreateCertificate(server);\n+\t\t\t\n+\t\t\t//Check the ACME file for the new entry.\n+\t\t\tArrayList<String> lines = new ArrayList<String>();\n+\t\t\tString fileDirURI = null;\n+\t\t\ttry {\n+\t\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t\t    String line, lastLine = null; \n+\t\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\t\tlastLine=line;\n+\t\t\t\t\tlines.add(line);\n+\t\t\t\t}\n+\t\t\t\tbr.close();\n+\t\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tfail(e.getMessage()); \n+\t\t\t}\n+\t\t\t\n+\t\t\t//After refreshing the certificate and updating the ACME file,\n+\t\t\t//we should still have 12 lines.\n+\t\t\tassertEquals(12, lines.size());", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1MzAyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427553028", "bodyText": "javadoc", "author": "jvanhill", "createdAt": "2020-05-19T19:38:45Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDg0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427590848", "bodyText": "Not a huge fan of the name either. AcmeHistory perhaps?", "author": "jvanhill", "createdAt": "2020-05-19T20:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1MzAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjE3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427586171", "bodyText": "I would expect us to only have 1 domain. We don't want to switch domains, otherwise the domain changing is what could be leading to the cert renew.", "author": "jvanhill", "createdAt": "2020-05-19T20:40:27Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSwapDirectoriesTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.fat;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.docker.pebble.PebbleContainer;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.CheckForLeakedPasswords;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+/**\n+ * Test for AcmeHistoricalFile. Ensure the file is created, updated, and\n+ * causes refreshing of certificates.\n+ */\n+@RunWith(FATRunner.class)\n+public class AcmeSwapDirectoriesTest {\n+\n+\t@Server(\"com.ibm.ws.security.acme.fat.simple\")\n+\tpublic static LibertyServer server;\n+\n+\tprotected static ServerConfiguration ORIGINAL_CONFIG;\n+\n+\t/*\n+\t * Domains that are configured and cleared before and after the class.\n+\t */\n+\tprivate static final String[] DOMAINS_ALL = { \"domain1.com\", \"domain2.com\", \"domain3.com\" };", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5MDg3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r428890871", "bodyText": "We should not refresh the certificate if we remove a domain that is not the subject cn. I use this domain change to trigger a config update check. Normally, nothing would happen, but since we can't read from the ACME file, we should refresh the certificate.", "author": "ryanesch", "createdAt": "2020-05-21T20:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5Nzk0NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r428897944", "bodyText": "We will refresh the certificate if one of the domains is not in either the CN or the DNSNames in the SANs. I would just be careful changing domains, it may trigger a refresh if done in the wrong oder.\nYou might want to trigger a configuration change with something that can't possibly result in a new cert - like the polling times.", "author": "jvanhill", "createdAt": "2020-05-21T20:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjYwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427586603", "bodyText": "not sure I like this file name. Maybe acmeca-history.txt?", "author": "jvanhill", "createdAt": "2020-05-19T20:41:13Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4Njg2Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427586862", "bodyText": "Localized?", "author": "jvanhill", "createdAt": "2020-05-19T20:41:48Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NzU1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427587557", "bodyText": "The file name should be a constant.", "author": "jvanhill", "createdAt": "2020-05-19T20:43:03Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Updates the historical ACME file.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tupdateAcmeFile(null, certificate, directoryURI, accountURI, wslocation);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information. Max file size is 10 lines.\n+\t * @param acmeCertificate The certificate to use if the default X509 certificate is null.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(AcmeCertificate acmeCertificate, X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4ODEwNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427588105", "bodyText": "Seems to be the opposite. If acmeCertificate is null we look at certificate.", "author": "jvanhill", "createdAt": "2020-05-19T20:44:09Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Updates the historical ACME file.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tupdateAcmeFile(null, certificate, directoryURI, accountURI, wslocation);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information. Max file size is 10 lines.\n+\t * @param acmeCertificate The certificate to use if the default X509 certificate is null.", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4ODUyNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427588526", "bodyText": "Can't we return whether we created the file from createAcmeFile, then we wouldn't need to check if the file exists again?", "author": "jvanhill", "createdAt": "2020-05-19T20:44:55Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Updates the historical ACME file.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tupdateAcmeFile(null, certificate, directoryURI, accountURI, wslocation);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information. Max file size is 10 lines.\n+\t * @param acmeCertificate The certificate to use if the default X509 certificate is null.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(AcmeCertificate acmeCertificate, X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t}\n+\t\t//If the file still doesn't exist, return\n+\t\tif (!file.exists()) {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4ODgwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427588801", "bodyText": "Make static class field.", "author": "jvanhill", "createdAt": "2020-05-19T20:45:22Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Updates the historical ACME file.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tupdateAcmeFile(null, certificate, directoryURI, accountURI, wslocation);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information. Max file size is 10 lines.\n+\t * @param acmeCertificate The certificate to use if the default X509 certificate is null.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(AcmeCertificate acmeCertificate, X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t}\n+\t\t//If the file still doesn't exist, return\n+\t\tif (!file.exists()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\");  ", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4OTA1Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427589056", "bodyText": "Make max file size constant in ACMEConstants.", "author": "jvanhill", "createdAt": "2020-05-19T20:45:46Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Updates the historical ACME file.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tupdateAcmeFile(null, certificate, directoryURI, accountURI, wslocation);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information. Max file size is 10 lines.\n+\t * @param acmeCertificate The certificate to use if the default X509 certificate is null.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(AcmeCertificate acmeCertificate, X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t}\n+\t\t//If the file still doesn't exist, return\n+\t\tif (!file.exists()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\");  \n+\t\tLocalDateTime now = LocalDateTime.now();  \n+\t\tString date = dtf.format(now);\n+\t\tString serial = null;\n+\t\tif (acmeCertificate == null) {\n+\t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString(16);\n+\t\t} else {\n+\t\t\tserial = acmeCertificate.getCertificate().getSerialNumber().toString(16);\n+\t\t}\n+\n+\t\t//Enforce max file size\n+\t\tArrayList<String> lines = new ArrayList<String>();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlines.add(line);\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t\t//remove the oldest entry if we are at max\n+\t\tif (lines.size() >= 12) {", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4OTQ2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427589463", "bodyText": "Localized message.", "author": "jvanhill", "createdAt": "2020-05-19T20:46:24Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Updates the historical ACME file.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tupdateAcmeFile(null, certificate, directoryURI, accountURI, wslocation);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information. Max file size is 10 lines.\n+\t * @param acmeCertificate The certificate to use if the default X509 certificate is null.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(AcmeCertificate acmeCertificate, X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t}\n+\t\t//If the file still doesn't exist, return\n+\t\tif (!file.exists()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\");  \n+\t\tLocalDateTime now = LocalDateTime.now();  \n+\t\tString date = dtf.format(now);\n+\t\tString serial = null;\n+\t\tif (acmeCertificate == null) {\n+\t\t\tif (certificate != null) serial = certificate.getSerialNumber().toString(16);\n+\t\t} else {\n+\t\t\tserial = acmeCertificate.getCertificate().getSerialNumber().toString(16);\n+\t\t}\n+\n+\t\t//Enforce max file size\n+\t\tArrayList<String> lines = new ArrayList<String>();\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlines.add(line);\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t\t//remove the oldest entry if we are at max\n+\t\tif (lines.size() >= 12) {\n+\t\t\tlines.remove(2);\n+\t\t}\n+       \tFileWriter fr;\n+\t\ttry {\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfor (String l: lines) {\n+\t\t\t\tfr.write(l);\n+\t\t\t\tfr.write(\"\\n\");\n+\t\t\t}\n+\t\t\t//write the new entry\n+\t\t   \tfr.write(date + spaceDelim + serial + spaceDelim + directoryURI + spaceDelim + accountURI);\n+\t\t   \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage()); ", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDA5Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427590093", "bodyText": "Does this really throw an AcmeCaException?", "author": "jvanhill", "createdAt": "2020-05-19T20:47:41Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NjA1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r430576059", "bodyText": "nope", "author": "ryanesch", "createdAt": "2020-05-26T17:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDM5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427590399", "bodyText": "Does this really throw an AcmeCaException?", "author": "jvanhill", "createdAt": "2020-05-19T20:48:17Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeHistoricalFileHelper.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.ibm.ws.security.acme.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.StringTokenizer;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.AcmeCertificate;\n+import com.ibm.wsspi.kernel.service.location.WsLocationAdmin;\n+\n+public class AcmeHistoricalFileHelper {\n+\tprivate static final TraceComponent tc = Tr.register(AcmeHistoricalFileHelper.class);\n+\tprivate String spaceDelim = \"                  \";\n+\t\n+\t/**\n+\t * This method determines if the directoryURI has changed by checking\n+\t * the acme file.\n+\t * @return True if the directoryURI has changed\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected boolean directoryURIChanged(String currentDirectoryURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (!file.exists()) {\n+\t\t\tcreateAcmeFile(wslocation);\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileDirURI = currentDirectoryURI;\n+\t\ttry {\n+\t\t    BufferedReader br = new BufferedReader(new FileReader(file));\n+\t\t    String line, lastLine = null; \n+\t\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n+\t\t\t\tlastLine=line;\n+\t\t\t}\n+\t\t\tbr.close();\n+\t\t\tif (lastLine != null && !lastLine.isEmpty()) {\n+\t\t\t\tStringTokenizer tok = new StringTokenizer(lastLine);\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) tok.nextToken();\n+\t\t\t\tif (tok.hasMoreTokens()) fileDirURI = tok.nextToken();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (currentDirectoryURI.equals(fileDirURI)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method will create the initial acme file in the servers/workarea\n+\t * directory. It holds certificate and directoryURI information, eg.\n+\t *  Date                Serial                   DirectoryURI                    Account URI\n+     *  --------------------------------------------------------------------------------------------\n+     *  20200509231118      6542743894787011570      https://localhost:33827/dir     https://localhost:33827/my-account/1\n+\t */\n+\tprivate void createAcmeFile(WsLocationAdmin wslocation) {\n+\t\tFile file = wslocation.getServerWorkareaResource(\"acme/acme.txt\").asFile();\n+\t\tif (file.exists()) return;\n+\t\tfile.getParentFile().mkdirs();\n+\t\ttry {\n+\t\t\tfile.createNewFile();\n+\t\t\tFileWriter fr;\n+\t\t\tfr = new FileWriter(file, false);\n+\t\t\tfr.write(\"Date\" + spaceDelim + \"Serial\" + spaceDelim + \"DirectoryURI\" + spaceDelim + \"Account URI\" + \"\\n\");\n+\t\t\tfr.write(\"-------------------------------------------------------------------------------------------------------------------------\");\n+\t       \tfr.close();\n+\t\t} catch (IOException e) {\n+\t\t\tTr.error(tc, e.getMessage());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Updates the historical ACME file.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException\n+\t */\n+\tprotected void updateAcmeFile(X509Certificate certificate, String directoryURI, String accountURI, WsLocationAdmin wslocation) throws AcmeCaException {\n+\t\tupdateAcmeFile(null, certificate, directoryURI, accountURI, wslocation);\n+\t}\n+\n+\t/**\n+\t * Update the acme file with the original or updated certificate\n+\t * and directoryURI information. Max file size is 10 lines.\n+\t * @param acmeCertificate The certificate to use if the default X509 certificate is null.\n+\t * @param certificate The current X509Certificate.\n+\t * @param directoryURI The current directoryURI from config.\n+\t * @param accountURI The current accountURI from config.\n+\t * @throws AcmeCaException", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MTIzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r427591235", "bodyText": "Can we import the class so we don't have the full qualified name in the source?", "author": "jvanhill", "createdAt": "2020-05-19T20:49:54Z", "path": "dev/com.ibm.ws.security.acme/src/com/ibm/ws/security/acme/internal/AcmeProviderImpl.java", "diffHunk": "@@ -81,7 +81,12 @@\n \n \t/** Configuration for the ACME client. */\n \tprivate static AcmeConfig acmeConfig;\n+\t\n+\tprivate AcmeHistoricalFileHelper acmeHistoricalFileHelper = new AcmeHistoricalFileHelper();\n \n+\t@Reference\n+\tprivate com.ibm.wsspi.kernel.service.location.WsLocationAdmin wslocation;", "originalCommit": "0c6d0822d2ce7d4a56ec78b30c2aa7f2ac91b661", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "df10267b195e9e441cba2204f2f2220571a2c572", "url": "https://github.com/OpenLiberty/open-liberty/commit/df10267b195e9e441cba2204f2f2220571a2c572", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-26T17:01:31Z", "type": "forcePushed"}, {"oid": "110340a2e3e2fbaedc90245321f88bd55482f86c", "url": "https://github.com/OpenLiberty/open-liberty/commit/110340a2e3e2fbaedc90245321f88bd55482f86c", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-26T20:55:44Z", "type": "forcePushed"}, {"oid": "57946db72c50ad84eaaa86b52cba945cd1a22110", "url": "https://github.com/OpenLiberty/open-liberty/commit/57946db72c50ad84eaaa86b52cba945cd1a22110", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-26T21:31:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4Njg4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r432586881", "bodyText": "Javadoc", "author": "jvanhill", "createdAt": "2020-05-29T16:05:58Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/utils/AcmeFatUtils.java", "diffHunk": "@@ -650,4 +650,18 @@ public static void checkPortOpen(int port, long timeoutMs) {\n \n \t\tassertTrue(\"Expected port \" + port + \" to be open.\", open);\n \t}\n+\t\n+\t/**\n+\t * ", "originalCommit": "57946db72c50ad84eaaa86b52cba945cd1a22110", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NzUxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r432587512", "bodyText": "Doesn't appear you use this.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import org.junit.Assume;", "author": "jvanhill", "createdAt": "2020-05-29T16:07:02Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeSimpleTest.java", "diffHunk": "@@ -36,6 +36,7 @@\n import org.apache.http.impl.client.CloseableHttpClient;\n import org.junit.After;\n import org.junit.AfterClass;\n+import org.junit.Assume;", "originalCommit": "57946db72c50ad84eaaa86b52cba945cd1a22110", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5NjU1Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r432596556", "bodyText": "That is used for Assume.assumeTrue in the Windows check.", "author": "ryanesch", "createdAt": "2020-05-29T16:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NzUxMg=="}], "type": "inlineReview"}, {"oid": "0d7bdf581ffed49687e53a00ae1404be1f568676", "url": "https://github.com/OpenLiberty/open-liberty/commit/0d7bdf581ffed49687e53a00ae1404be1f568676", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-29T16:37:43Z", "type": "forcePushed"}, {"oid": "c3588a588a993d4ee17bdd6867d79d11659d8614", "url": "https://github.com/OpenLiberty/open-liberty/commit/c3588a588a993d4ee17bdd6867d79d11659d8614", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-29T16:53:30Z", "type": "forcePushed"}, {"oid": "265446556a35eb84e304b31d39b1764cd195e213", "url": "https://github.com/OpenLiberty/open-liberty/commit/265446556a35eb84e304b31d39b1764cd195e213", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-05-29T16:57:26Z", "type": "forcePushed"}, {"oid": "4749065201a77ffc425d42dbdae0e71cad479734", "url": "https://github.com/OpenLiberty/open-liberty/commit/4749065201a77ffc425d42dbdae0e71cad479734", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-01T14:51:28Z", "type": "forcePushed"}, {"oid": "1e81e7daa06ce12594fbc9a1a4952f66cd4014e8", "url": "https://github.com/OpenLiberty/open-liberty/commit/1e81e7daa06ce12594fbc9a1a4952f66cd4014e8", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-01T16:29:18Z", "type": "forcePushed"}, {"oid": "22176bd642e0697203692df408a443113c51429a", "url": "https://github.com/OpenLiberty/open-liberty/commit/22176bd642e0697203692df408a443113c51429a", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-02T15:37:07Z", "type": "forcePushed"}, {"oid": "4864041abcbaf42dae8d9b1300e475f1c4bbd13a", "url": "https://github.com/OpenLiberty/open-liberty/commit/4864041abcbaf42dae8d9b1300e475f1c4bbd13a", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-02T18:45:41Z", "type": "forcePushed"}, {"oid": "f6566ca8682a8116019ad1beecc7794341ed0a9e", "url": "https://github.com/OpenLiberty/open-liberty/commit/f6566ca8682a8116019ad1beecc7794341ed0a9e", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-03T06:03:42Z", "type": "forcePushed"}, {"oid": "a1be4c658badd92eda8b4fc6a3684272bfd1597b", "url": "https://github.com/OpenLiberty/open-liberty/commit/a1be4c658badd92eda8b4fc6a3684272bfd1597b", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-03T19:06:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxODMzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r434818338", "bodyText": "I'm afraid that by defaulting this to false, everytime we start a server we are going to refresh the certificate. This may result in test passing not for the reason the test was written. I think this should default to \"true\" to disable it by default. And only the tests that are testing history should enable it. I know this is backwards from how we would run, but i think it fits best with our existing tests.", "author": "jvanhill", "createdAt": "2020-06-03T19:56:18Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/utils/AcmeFatUtils.java", "diffHunk": "@@ -276,6 +276,30 @@ public static void configureAcmeCA(LibertyServer server, CAContainer caContainer\n \t */\n \tpublic static void configureAcmeCA(LibertyServer server, CAContainer caContainer,\n \t\t\tServerConfiguration originalConfig, boolean useAcmeURIs, boolean disableRenewWindow, String... domains) throws Exception {\n+\t\tconfigureAcmeCA(server, caContainer, originalConfig, useAcmeURIs, disableRenewWindow, false, domains);", "originalCommit": "a1be4c658badd92eda8b4fc6a3684272bfd1597b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTY4MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/12119#discussion_r435005680", "bodyText": "As discussed, I switched the testing default to True.", "author": "ryanesch", "createdAt": "2020-06-04T05:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxODMzOA=="}], "type": "inlineReview"}, {"oid": "31d41f115b5792b42d307d2278b5e11e508fd8aa", "url": "https://github.com/OpenLiberty/open-liberty/commit/31d41f115b5792b42d307d2278b5e11e508fd8aa", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-03T20:12:28Z", "type": "forcePushed"}, {"oid": "ca68232b434f8dcdffb3617cc6e3285beb5c2566", "url": "https://github.com/OpenLiberty/open-liberty/commit/ca68232b434f8dcdffb3617cc6e3285beb5c2566", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-04T02:02:59Z", "type": "forcePushed"}, {"oid": "459ae486edb08c32ca96f1ee28fd2e74330c57c7", "url": "https://github.com/OpenLiberty/open-liberty/commit/459ae486edb08c32ca96f1ee28fd2e74330c57c7", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-04T05:39:11Z", "type": "forcePushed"}, {"oid": "5bb1a5cb30f4696b70d91f8cae18f72d21237489", "url": "https://github.com/OpenLiberty/open-liberty/commit/5bb1a5cb30f4696b70d91f8cae18f72d21237489", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-04T06:15:38Z", "type": "forcePushed"}, {"oid": "1fa3fa0e58dc34e75d996ae687923fb3ff7da109", "url": "https://github.com/OpenLiberty/open-liberty/commit/1fa3fa0e58dc34e75d996ae687923fb3ff7da109", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-04T18:16:38Z", "type": "commit"}, {"oid": "1fa3fa0e58dc34e75d996ae687923fb3ff7da109", "url": "https://github.com/OpenLiberty/open-liberty/commit/1fa3fa0e58dc34e75d996ae687923fb3ff7da109", "message": "check for updated directoryURI and refresh certificate", "committedDate": "2020-06-04T18:16:38Z", "type": "forcePushed"}]}