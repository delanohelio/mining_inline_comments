{"pr_number": 14590, "pr_title": "Jwe consumer fat 1", "pr_createdAt": "2020-10-20T23:19:40Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/14590", "timeline": [{"oid": "9f83d4b4b6fa2210393e28424568dfb2cb1a6da7", "url": "https://github.com/OpenLiberty/open-liberty/commit/9f83d4b4b6fa2210393e28424568dfb2cb1a6da7", "message": "Issue 13577: JWE consumer support initial drop\n\nFor issue #13577\n\nAdds support for server.xml configuration attributes that allow consuming of JWE tokens.", "committedDate": "2020-10-16T15:15:06Z", "type": "commit"}, {"oid": "89d9c4b9f0d2346f701217b066885c20167730f9", "url": "https://github.com/OpenLiberty/open-liberty/commit/89d9c4b9f0d2346f701217b066885c20167730f9", "message": "Remaining JWE Builder tests", "committedDate": "2020-10-19T18:09:56Z", "type": "commit"}, {"oid": "7413d6773929e731cef2e1952ced9d3672a533f0", "url": "https://github.com/OpenLiberty/open-liberty/commit/7413d6773929e731cef2e1952ced9d3672a533f0", "message": "Merge remote-tracking branch 'origin/integration' into 13577-consumeJwe-1", "committedDate": "2020-10-20T14:29:45Z", "type": "commit"}, {"oid": "654a026c90306a2800abb2297868d351486951f6", "url": "https://github.com/OpenLiberty/open-liberty/commit/654a026c90306a2800abb2297868d351486951f6", "message": "JWT Consumer FAT", "committedDate": "2020-10-20T20:25:02Z", "type": "commit"}, {"oid": "d21ed5517ddb420a0b7ef431b88c925237cbc907", "url": "https://github.com/OpenLiberty/open-liberty/commit/d21ed5517ddb420a0b7ef431b88c925237cbc907", "message": "Merge remote-tracking branch 'origin/integration' into 13577-consumeJwe-1", "committedDate": "2020-10-20T20:33:05Z", "type": "commit"}, {"oid": "d228eb62f63bb91fa33f2aa467fc714e61937bb4", "url": "https://github.com/OpenLiberty/open-liberty/commit/d228eb62f63bb91fa33f2aa467fc714e61937bb4", "message": "Merge remote-tracking branch 'ayoho/13577-consumeJwe-1' into JWE_Consumer_FAT_1", "committedDate": "2020-10-20T23:12:48Z", "type": "commit"}, {"oid": "b1de3dcdaa59e223445a3457af82dbc4f391869a", "url": "https://github.com/OpenLiberty/open-liberty/commit/b1de3dcdaa59e223445a3457af82dbc4f391869a", "message": "Issue 13577: Add doPriv in JWT consumer and Sensitive annotation for JWE decrypt keys", "committedDate": "2020-10-21T14:59:42Z", "type": "commit"}, {"oid": "de457884cedbb41911c1a300192d1cee0c2cf877", "url": "https://github.com/OpenLiberty/open-liberty/commit/de457884cedbb41911c1a300192d1cee0c2cf877", "message": "Update to allow consumer client to handle bad tokens", "committedDate": "2020-10-21T15:08:37Z", "type": "commit"}, {"oid": "b6b105df44248747b52b6e9854ddaff25c6bb3b3", "url": "https://github.com/OpenLiberty/open-liberty/commit/b6b105df44248747b52b6e9854ddaff25c6bb3b3", "message": "Merge remote-tracking branch 'ayoho/13577-consumeJwe-1' into JWE_Consumer_FAT_1", "committedDate": "2020-10-21T15:11:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2MTY0NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14590#discussion_r510261644", "bodyText": "Looks like a redundant if check here.", "author": "ayoho", "createdAt": "2020-10-22T15:37:14Z", "path": "dev/com.ibm.ws.security.fat.common.jwt/test-applications/jwtbuilder/src/com/ibm/ws/security/fat/common/apps/jwtbuilder/JwtBuilderServlet.java", "diffHunk": "@@ -157,12 +194,17 @@ private void addToClaimMap(Map<String, Object> claimMap, Entry<String, String[]>\n         }\n     }\n \n-//    private JwtToken buildJwt(String builderConfigId) throws InvalidBuilderException, InvalidClaimException, JwtException {\n-//        JwtBuilder builder = JwtBuilder.create(builderConfigId);\n-//        //todo - need to figure out how to put upn into the token\n-//        builder.claim(\"upn\", \"testuser\");\n-//        System.out.println(\"builder content: \" + builder.toString());\n-//        return builder.buildJwt();\n-//    }\n+    protected void setEncryptWith(String keyMgmtAlg, String encryptKeyString, String contentEncryptAlg) throws Exception {\n+\n+        if (keyMgmtAlg != null || encryptKeyString != null || contentEncryptAlg != null) {\n+\n+            if (keyMgmtAlg != null || encryptKeyString != null || contentEncryptAlg != null) {", "originalCommit": "b6b105df44248747b52b6e9854ddaff25c6bb3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3MDUyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14590#discussion_r510370529", "bodyText": "argh...  cut/paste - I'll remove it when I make my next delivery...", "author": "c00crane", "createdAt": "2020-10-22T18:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2MTY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM1MzIyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14590#discussion_r510353225", "bodyText": "This is a scenario I'm going to have to think about. At the moment we'll go ahead and try to decrypt a JWE regardless of what the consumer's configuration says (i.e. they may not have keyManagementKeyAlias set). This scenario shows that we'll end up trying to use some default key in the server-wide keystore. As we've been talking about, https://github.com/eclipse/microprofile-jwt-auth/blob/master/spec/src/main/asciidoc/configuration.asciidoc#requirements-for-accepting-signed-and-encrypted-tokens suggests that we shouldn't accept JWEs in the case where the mp.jwt.decrypt.key.location MP Config property (or, in our case, the keyManagementKeyAlias config attribute) isn't set.\nI may very well add a new message for this scenario.", "author": "ayoho", "createdAt": "2020-10-22T17:56:56Z", "path": "dev/com.ibm.ws.security.jwt_fat.consumer/fat/src/com/ibm/ws/security/jwt/fat/consumer/JwtConsumerApiConfigTests.java", "diffHunk": "@@ -1815,4 +1793,336 @@ public void JwtConsumerApiConfigTests_single_valid_amr() throws Exception {\n \n     }\n \n+    // JwtConsumerApiConfigTests_goodKeyManagementKeyAlias_goodSslRef same as JwtConsumerApiConfigTests_encryptRS256_decryptRS256\n+    // JwtConsumerApiConfigTests_nullKeyManagementKeyAlias_goodSslRef same as JwtConsumerApiConfigTests_tokenNotEncrypted_consumerDecrypts\n+    /**\n+     * server.xml has a config that specifies an invalid key management key algorithm - this test ensures that\n+     * after building a jwt that is encrypted with the matching public key, we can not decrypt the token because\n+     * it can't find the certificate to decrypt the token\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void JwtConsumerApiConfigTests_badKeyManagementKeyAlias_goodSslRef() throws Exception {\n+\n+        String jwtToken = actions.getJwtTokenUsingBuilder(_testName, consumerServer, \"key_encrypt_good_RS256\", null);\n+\n+        Expectations expectations = consumerHelpers.buildNegativeAttributeExpectations(JwtConsumerMessageConstants.CWWKS6056E_CAN_NOT_EXTRACT_JWS_FROM_JWE + \".+CertificateException\", currentAction, consumerServer, \"bad_decrypt_RS256\");\n+\n+        Page response = actions.invokeJwtConsumer(_testName, consumerServer, \"bad_decrypt_RS256\", jwtToken);\n+        validationUtils.validateResult(response, currentAction, expectations);\n+\n+    }\n+\n+    /**\n+     * server.xml has a config that specifies a key management key algorithm, but omits the sslRef - the server wide\n+     * SSL config does not use a keystore that contains the alias specifies - this test ensures that\n+     * after building a jwt that is encrypted with the matching public key, we can not decrypt the token because\n+     * it can't find the certificate to decrypt the token\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void JwtConsumerApiConfigTests_goodKeyManagementKeyAlias_missingSslRef_refMissingFromServerwideSSL() throws Exception {\n+\n+        String jwtToken = actions.getJwtTokenUsingBuilder(_testName, consumerServer, \"key_encrypt_good_RS256\", null);\n+\n+        Expectations expectations = consumerHelpers.buildNegativeAttributeExpectations(JwtConsumerMessageConstants.CWWKS6056E_CAN_NOT_EXTRACT_JWS_FROM_JWE + \".+InvalidKeyException\", currentAction, consumerServer, \"missing_sslRef_decrypt_RS256\");\n+\n+        Page response = actions.invokeJwtConsumer(_testName, consumerServer, \"missing_sslRef_decrypt_RS256\", jwtToken);\n+        validationUtils.validateResult(response, currentAction, expectations);\n+\n+    }\n+\n+    /**\n+     * server.xml has a config that specifies a key management key algorithm, but specifies and inavalid sslRef - the server wide\n+     * SSL config does not use a keystore that contains the alias specifies - this test ensures that\n+     * after building a jwt that is encrypted with the matching public key, we can not decrypt the token because\n+     * it can't find the certificate to decrypt the token\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void JwtConsumerApiConfigTests_goodKeyManagementKeyAlias_baddSslRef() throws Exception {\n+\n+        String jwtToken = actions.getJwtTokenUsingBuilder(_testName, consumerServer, \"key_encrypt_good_RS256\", null);\n+\n+        Expectations expectations = consumerHelpers.buildNegativeAttributeExpectations(JwtConsumerMessageConstants.CWWKS6056E_CAN_NOT_EXTRACT_JWS_FROM_JWE + \".+InvalidKeyException\", currentAction, consumerServer, \"bad_sslRef_decrypt_RS256\");\n+\n+        Page response = actions.invokeJwtConsumer(_testName, consumerServer, \"bad_sslRef_decrypt_RS256\", jwtToken);\n+        validationUtils.validateResult(response, currentAction, expectations);\n+\n+    }\n+\n+    /**\n+     * server.xml has a config that specifies a key management key algorithm that is not supported -this test ensures that\n+     * after building a jwt that is encrypted with the matching public key, we can not decrypt the token because\n+     * it can't use an EC alg\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void JwtConsumerApiConfigTests_decryptWithUnsupportedAlg() throws Exception {\n+\n+        String jwtToken = actions.getJwtTokenUsingBuilder(_testName, consumerServer, \"key_encrypt_good_RS256\", null);\n+\n+        Expectations expectations = consumerHelpers.buildNegativeAttributeExpectations(JwtConsumerMessageConstants.CWWKS6056E_CAN_NOT_EXTRACT_JWS_FROM_JWE + \".+InvalidKeyException\", currentAction, consumerServer, \"decrypt_ES384\");\n+\n+        Page response = actions.invokeJwtConsumer(_testName, consumerServer, \"decrypt_ES384\", jwtToken);\n+        validationUtils.validateResult(response, currentAction, expectations);\n+\n+    }\n+\n+    /**\n+     * server.xml has a config that does not specify a keyManagementKeyAlias - this test ensures that after building a jwt\n+     * that is encrypted, we can not decrypt the token because there is not keyManagementKeyAlg\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void JwtConsumerApiConfigTests_encryptedToken_consumerDoesNotDecrypt() throws Exception {\n+\n+        String jwtToken = actions.getJwtTokenUsingBuilder(_testName, consumerServer, \"key_encrypt_good_RS256\", null);\n+\n+        Expectations expectations = consumerHelpers.buildNegativeAttributeExpectations(JwtConsumerMessageConstants.CWWKS6056E_CAN_NOT_EXTRACT_JWS_FROM_JWE + \".+InvalidKeyException\", currentAction, consumerServer, JwtConsumerConstants.SIGALG_RS256);", "originalCommit": "b6b105df44248747b52b6e9854ddaff25c6bb3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3MDQ2NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14590#discussion_r510370464", "bodyText": "I've opened issue #14652 to revisit this test (just in case new failure messages, ... do not make this test fail as it's pretty generic)", "author": "c00crane", "createdAt": "2020-10-22T18:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM1MzIyNQ=="}], "type": "inlineReview"}]}