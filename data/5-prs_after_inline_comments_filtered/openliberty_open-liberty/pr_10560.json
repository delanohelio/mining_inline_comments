{"pr_number": 10560, "pr_title": "Add test to check result of hitting Readiness endpoint as server is starting", "pr_createdAt": "2020-01-23T19:31:04Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/10560", "timeline": [{"oid": "cc124ebe7b4841ec7753b4374c085eb806b5b6ea", "url": "https://github.com/OpenLiberty/open-liberty/commit/cc124ebe7b4841ec7753b4374c085eb806b5b6ea", "message": "Add test to check result of hitting Readiness endpoint as server is starting", "committedDate": "2020-01-23T19:29:06Z", "type": "commit"}, {"oid": "63975dd2b55b064a434f4224936301607865054e", "url": "https://github.com/OpenLiberty/open-liberty/commit/63975dd2b55b064a434f4224936301607865054e", "message": "Fixing copyright years", "committedDate": "2020-01-23T19:32:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNjE4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r370806182", "bodyText": "Why are we setting the responseCode=null again? I don't think this line is needed here, and must be placed in the catch block.", "author": "pgunapal", "createdAt": "2020-01-24T19:33:07Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -73,6 +76,63 @@ public void cleanUp() throws Exception {\n         server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n     }\n \n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n+\n+        class StartServerOnThread extends Thread {\n+            @Override\n+            public void run() {\n+                try {\n+                    server1.startServer();\n+                } catch (Exception e) {\n+                    assertTrue(\"Failure to start server on a seperate thread.\", server1.isStarted());\n+                }\n+            }\n+        }\n+\n+        // Need to ensure the server is not finish starting when readiness endpoint is hit so start the server on a separate thread\n+        // Note: this does not guarantee that we hit the endpoint during server startup, but it is highly likely that it will\n+        StartServerOnThread startServerThread = new StartServerOnThread();\n+        log(\"testReadinessEndpointOnServerStart\", \"Starting DelayedHealthCheck server on separate thread.\");\n+        startServerThread.start();\n+\n+        // Hit the readiness endpoint as the server is still starting up\n+        // We expect a connection refused as the ports are not open until server is fully started\n+        try {\n+            log(\"testReadinessEndpointOnServerStart\", \"Testing the /health/ready endpoint as the server is still starting up.\");\n+            HttpURLConnection conReady;\n+            String responseCode = null;\n+            try {\n+                conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+                responseCode = conReady.getURL().toString();\n+            } catch (ConnectException exception) {\n+                conReady = null;\n+            }\n+            responseCode = null;", "originalCommit": "63975dd2b55b064a434f4224936301607865054e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMwODU2Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r371308567", "bodyText": "Line was removed. It was there originally for testing purposes.", "author": "lamkavan", "createdAt": "2020-01-27T15:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNjE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNjYwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r370806609", "bodyText": "We should check if conReady != null here, before trying to .getURL()....it would lead to a NullPointerException.", "author": "pgunapal", "createdAt": "2020-01-24T19:33:58Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -73,6 +76,63 @@ public void cleanUp() throws Exception {\n         server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n     }\n \n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n+\n+        class StartServerOnThread extends Thread {\n+            @Override\n+            public void run() {\n+                try {\n+                    server1.startServer();\n+                } catch (Exception e) {\n+                    assertTrue(\"Failure to start server on a seperate thread.\", server1.isStarted());\n+                }\n+            }\n+        }\n+\n+        // Need to ensure the server is not finish starting when readiness endpoint is hit so start the server on a separate thread\n+        // Note: this does not guarantee that we hit the endpoint during server startup, but it is highly likely that it will\n+        StartServerOnThread startServerThread = new StartServerOnThread();\n+        log(\"testReadinessEndpointOnServerStart\", \"Starting DelayedHealthCheck server on separate thread.\");\n+        startServerThread.start();\n+\n+        // Hit the readiness endpoint as the server is still starting up\n+        // We expect a connection refused as the ports are not open until server is fully started\n+        try {\n+            log(\"testReadinessEndpointOnServerStart\", \"Testing the /health/ready endpoint as the server is still starting up.\");\n+            HttpURLConnection conReady;\n+            String responseCode = null;\n+            try {\n+                conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+                responseCode = conReady.getURL().toString();", "originalCommit": "63975dd2b55b064a434f4224936301607865054e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ad4ff734de064009c874821e9f1cb186ff3a2a9", "url": "https://github.com/OpenLiberty/open-liberty/commit/5ad4ff734de064009c874821e9f1cb186ff3a2a9", "message": "Making requested chnages", "committedDate": "2020-01-26T22:54:57Z", "type": "commit"}, {"oid": "bd54422bf74d05aa740ef07842a7792ccd3d0d93", "url": "https://github.com/OpenLiberty/open-liberty/commit/bd54422bf74d05aa740ef07842a7792ccd3d0d93", "message": "Temporarily changing test to lite mode so build can run it more than once", "committedDate": "2020-01-28T15:26:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NDU4MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r371964580", "bodyText": "may want to split out the allowed warnings array into a class-level constant for easier reuse", "author": "aguibert", "createdAt": "2020-01-28T17:59:28Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -73,6 +75,69 @@ public void cleanUp() throws Exception {\n         server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n     }\n \n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");", "originalCommit": "bd54422bf74d05aa740ef07842a7792ccd3d0d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NDgyMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r371964820", "bodyText": "I'm not sure about the other tests in this file, but the new test that's being added is important enough that it should run in LITE mode", "author": "aguibert", "createdAt": "2020-01-28T17:59:54Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -39,7 +41,7 @@\n import componenttest.topology.utils.HttpUtils;\n \n @RunWith(FATRunner.class)\n-@Mode(TestMode.FULL)\n+//@Mode(TestMode.FULL)  Comment out temporarily so that build will run this more than once", "originalCommit": "bd54422bf74d05aa740ef07842a7792ccd3d0d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NjY0MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r371966641", "bodyText": "we are only pinging the /health/ready endpoint once here, we should put this inside a loop and repeatedly ping the /health/ready endpoint until it returns HTTP 200", "author": "aguibert", "createdAt": "2020-01-28T18:03:26Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -73,6 +75,69 @@ public void cleanUp() throws Exception {\n         server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n     }\n \n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n+\n+        class StartServerOnThread extends Thread {\n+            @Override\n+            public void run() {\n+                try {\n+                    server1.startServer();\n+                } catch (Exception e) {\n+                    assertTrue(\"Failure to start server on a seperate thread.\", server1.isStarted());\n+                }\n+            }\n+        }\n+\n+        // Need to ensure the server is not finish starting when readiness endpoint is hit so start the server on a separate thread\n+        // Note: this does not guarantee that we hit the endpoint during server startup, but it is highly likely that it will\n+        StartServerOnThread startServerThread = new StartServerOnThread();\n+        log(\"testReadinessEndpointOnServerStart\", \"Starting DelayedHealthCheck server on separate thread.\");\n+        startServerThread.start();\n+\n+        // Hit the readiness endpoint as the server is still starting up\n+        // We expect a connection refused as the ports are not open until server is fully started\n+        try {\n+            log(\"testReadinessEndpointOnServerStart\", \"Testing the /health/ready endpoint as the server is still starting up.\");\n+            HttpURLConnection conReady = null;\n+            String responseCode = null;\n+            boolean connectionExceptionEncountered = false;\n+\n+            try {\n+                conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);", "originalCommit": "bd54422bf74d05aa740ef07842a7792ccd3d0d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2Nzk5Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r371967993", "bodyText": "we should not be doing any log scraping to determine app readiness -- we should be getting that information from the /health/ready endpoint instead. We should poll /health/ready repeatedly until we get the HTTP 200, and once we get the HTTP 200 we should immediately try to access an application endpoint and it should be accessible", "author": "aguibert", "createdAt": "2020-01-28T18:06:08Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -73,6 +75,69 @@ public void cleanUp() throws Exception {\n         server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n     }\n \n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n+\n+        class StartServerOnThread extends Thread {\n+            @Override\n+            public void run() {\n+                try {\n+                    server1.startServer();\n+                } catch (Exception e) {\n+                    assertTrue(\"Failure to start server on a seperate thread.\", server1.isStarted());\n+                }\n+            }\n+        }\n+\n+        // Need to ensure the server is not finish starting when readiness endpoint is hit so start the server on a separate thread\n+        // Note: this does not guarantee that we hit the endpoint during server startup, but it is highly likely that it will\n+        StartServerOnThread startServerThread = new StartServerOnThread();\n+        log(\"testReadinessEndpointOnServerStart\", \"Starting DelayedHealthCheck server on separate thread.\");\n+        startServerThread.start();\n+\n+        // Hit the readiness endpoint as the server is still starting up\n+        // We expect a connection refused as the ports are not open until server is fully started\n+        try {\n+            log(\"testReadinessEndpointOnServerStart\", \"Testing the /health/ready endpoint as the server is still starting up.\");\n+            HttpURLConnection conReady = null;\n+            String responseCode = null;\n+            boolean connectionExceptionEncountered = false;\n+\n+            try {\n+                conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+                responseCode = conReady.getURL().toString();\n+            } catch (ConnectException e) {\n+                log(\"testReadinessEndpointOnServerStart\", e.getMessage()); /// REMOVE THIS AFTER\n+                if (e.getMessage().contains(\"Connection refused\")) {\n+                    connectionExceptionEncountered = true;\n+                }\n+            }\n+\n+            startServerThread.join();\n+\n+            String failure_message = \"The connection was not refused as required, but instead completed with response code: \" + responseCode +\n+                                     \" This is likely due to a rare timing issue where the server starts faster than we can hit the readiness endpoint.\"\n+                                     + \"In that case there are no issues with the feature and this failure may be disregarded.\";\n+            assertTrue(failure_message, conReady == null && connectionExceptionEncountered);\n+        } catch (Exception e) {\n+            startServerThread.join();\n+            fail(\"Encountered an error while Testing the /health/ready endpoint as the server is still starting up. Error: \" + e);\n+        }\n+\n+        // Wait until the application is fully started\n+        String line = server1.waitForStringInLogUsingMark(\"(CWWKZ0001I: Application DelayedHealthCheckApp started)+\", 60000);", "originalCommit": "bd54422bf74d05aa740ef07842a7792ccd3d0d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "94b32f2c8a4e6739e9e28922f7ee77d4f0d27581", "url": "https://github.com/OpenLiberty/open-liberty/commit/94b32f2c8a4e6739e9e28922f7ee77d4f0d27581", "message": "Making requested changes", "committedDate": "2020-01-30T15:54:37Z", "type": "commit"}, {"oid": "f8062a9a3ab26bbcf764b0f5f96c42db5515910b", "url": "https://github.com/OpenLiberty/open-liberty/commit/f8062a9a3ab26bbcf764b0f5f96c42db5515910b", "message": "Updating copyright years", "committedDate": "2020-01-30T15:56:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyMjcwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r373522706", "bodyText": "Doing a thread.join() on the first time through this loop defeats the purpose of the loop and the test. After attempting the connection we should check for:\n\nif we got a connection exception or an HTTP 503, keep looping\nif we get an HTTP 200, then be done with the loop\n\nWe should not have to use a thread.join() unless an unexpected Exception occurs -- let the HTTP response codes from the readiness check dictate the flow of the test", "author": "aguibert", "createdAt": "2020-01-31T14:59:35Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -70,10 +75,96 @@ public void deployApplicationAndStartServer() throws Exception {\n \n     @After\n     public void cleanUp() throws Exception {\n-        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        log(\"testReadinessEndpointOnServerStart\", \"Begin execution of testReadinessEndpointOnServerStart\");\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(EXPECTED_FAILURES);\n+\n+        class StartServerOnThread extends Thread {\n+            @Override\n+            public void run() {\n+                try {\n+                    server1.startServer();\n+                } catch (Exception e) {\n+                    assertTrue(\"Failure to start server on a seperate thread.\", server1.isStarted());\n+                }\n+            }\n+        }\n+\n+        // Need to ensure the server is not finish starting when readiness endpoint is hit so start the server on a separate thread\n+        // Note: this does not guarantee that we hit the endpoint during server startup, but it is highly likely that it will\n+        StartServerOnThread startServerThread = new StartServerOnThread();\n+        log(\"testReadinessEndpointOnServerStart\", \"Starting DelayedHealthCheck server on separate thread.\");\n+        startServerThread.start();\n+\n+        try {\n+            HttpURLConnection conReady = null;\n+            int responseCode = -1;\n+            boolean connectionExceptionEncountered = false;\n+            boolean first_time = true;\n+            boolean app_ready = false;\n+\n+            // Repeatedly hit the readiness endpoint until a response of 200 is received\n+            while (!app_ready) {\n+                try {\n+                    conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+                    responseCode = conReady.getResponseCode();\n+                } catch (ConnectException e) {\n+                    if (e.getMessage().contains(\"Connection refused\")) {\n+                        connectionExceptionEncountered = true;\n+                    }\n+                }\n+\n+                // We need to ensure we get a connection refused in the case of the server not finished starting up\n+                // We expect a connection refused as the ports are not open until server is fully started\n+                if (first_time) {\n+                    log(\"testReadinessEndpointOnServerStart\", \"Testing the /health/ready endpoint as the server is still starting up.\");\n+                    startServerThread.join();\n+                    String failure_message = \"The connection was not refused as required, but instead completed with response code: \" + responseCode +\n+                                             \" This is likely due to a rare timing issue where the server starts faster than we can hit the readiness endpoint.\"\n+                                             + \"In that case there are no issues with the feature and this failure may be disregarded.\";\n+                    assertTrue(failure_message, conReady == null && connectionExceptionEncountered);\n+                    first_time = false;", "originalCommit": "f8062a9a3ab26bbcf764b0f5f96c42db5515910b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyMzM3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r373523370", "bodyText": "we should also add some timeout component to this loop (perhaps 2 minutes max) to prevent from looping forever", "author": "aguibert", "createdAt": "2020-01-31T15:00:45Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -70,10 +75,96 @@ public void deployApplicationAndStartServer() throws Exception {\n \n     @After\n     public void cleanUp() throws Exception {\n-        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        log(\"testReadinessEndpointOnServerStart\", \"Begin execution of testReadinessEndpointOnServerStart\");\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(EXPECTED_FAILURES);\n+\n+        class StartServerOnThread extends Thread {\n+            @Override\n+            public void run() {\n+                try {\n+                    server1.startServer();\n+                } catch (Exception e) {\n+                    assertTrue(\"Failure to start server on a seperate thread.\", server1.isStarted());\n+                }\n+            }\n+        }\n+\n+        // Need to ensure the server is not finish starting when readiness endpoint is hit so start the server on a separate thread\n+        // Note: this does not guarantee that we hit the endpoint during server startup, but it is highly likely that it will\n+        StartServerOnThread startServerThread = new StartServerOnThread();\n+        log(\"testReadinessEndpointOnServerStart\", \"Starting DelayedHealthCheck server on separate thread.\");\n+        startServerThread.start();\n+\n+        try {\n+            HttpURLConnection conReady = null;\n+            int responseCode = -1;\n+            boolean connectionExceptionEncountered = false;\n+            boolean first_time = true;\n+            boolean app_ready = false;\n+\n+            // Repeatedly hit the readiness endpoint until a response of 200 is received\n+            while (!app_ready) {", "originalCommit": "f8062a9a3ab26bbcf764b0f5f96c42db5515910b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyNTY2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10560#discussion_r373525660", "bodyText": "This code could be simplified to the following:\nHttpUtils.findStringInUrl(server, APP_ENDPOINT, \"Testing Delayed Servlet initialization.\");", "author": "aguibert", "createdAt": "2020-01-31T15:05:11Z", "path": "dev/com.ibm.ws.microprofile.health.2.0_fat/fat/src/com/ibm/ws/microprofile/health20/fat/DelayAppStartupHealthCheckTest.java", "diffHunk": "@@ -70,10 +75,96 @@ public void deployApplicationAndStartServer() throws Exception {\n \n     @After\n     public void cleanUp() throws Exception {\n-        server1.stopServer(\"CWWKE1102W\", \"CWWKE1105W\", \"CWMH0052W\", \"CWMH0053W\");\n+        server1.stopServer(EXPECTED_FAILURES);\n+    }\n+\n+    @Test\n+    public void testReadinessEndpointOnServerStart() throws Exception {\n+        log(\"testReadinessEndpointOnServerStart\", \"Begin execution of testReadinessEndpointOnServerStart\");\n+        server1.setMarkToEndOfLog();\n+        server1.stopServer(EXPECTED_FAILURES);\n+\n+        class StartServerOnThread extends Thread {\n+            @Override\n+            public void run() {\n+                try {\n+                    server1.startServer();\n+                } catch (Exception e) {\n+                    assertTrue(\"Failure to start server on a seperate thread.\", server1.isStarted());\n+                }\n+            }\n+        }\n+\n+        // Need to ensure the server is not finish starting when readiness endpoint is hit so start the server on a separate thread\n+        // Note: this does not guarantee that we hit the endpoint during server startup, but it is highly likely that it will\n+        StartServerOnThread startServerThread = new StartServerOnThread();\n+        log(\"testReadinessEndpointOnServerStart\", \"Starting DelayedHealthCheck server on separate thread.\");\n+        startServerThread.start();\n+\n+        try {\n+            HttpURLConnection conReady = null;\n+            int responseCode = -1;\n+            boolean connectionExceptionEncountered = false;\n+            boolean first_time = true;\n+            boolean app_ready = false;\n+\n+            // Repeatedly hit the readiness endpoint until a response of 200 is received\n+            while (!app_ready) {\n+                try {\n+                    conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, READY_ENDPOINT);\n+                    responseCode = conReady.getResponseCode();\n+                } catch (ConnectException e) {\n+                    if (e.getMessage().contains(\"Connection refused\")) {\n+                        connectionExceptionEncountered = true;\n+                    }\n+                }\n+\n+                // We need to ensure we get a connection refused in the case of the server not finished starting up\n+                // We expect a connection refused as the ports are not open until server is fully started\n+                if (first_time) {\n+                    log(\"testReadinessEndpointOnServerStart\", \"Testing the /health/ready endpoint as the server is still starting up.\");\n+                    startServerThread.join();\n+                    String failure_message = \"The connection was not refused as required, but instead completed with response code: \" + responseCode +\n+                                             \" This is likely due to a rare timing issue where the server starts faster than we can hit the readiness endpoint.\"\n+                                             + \"In that case there are no issues with the feature and this failure may be disregarded.\";\n+                    assertTrue(failure_message, conReady == null && connectionExceptionEncountered);\n+                    first_time = false;\n+                } else {\n+                    if (responseCode == 200) {\n+                        app_ready = true;\n+                    }\n+                }\n+\n+            }\n+        } catch (Exception e) {\n+            startServerThread.join();\n+            fail(\"Encountered an error while Testing the /health/ready endpoint as the server and/or application(s) are starting up. Error: \" + e);\n+        }\n+\n+        // Access an application endpoint to verify the application is actually ready\n+        log(\"testReadinessEndpointOnServerStart\", \"Testing an application endpoint, after server and application has started.\");\n+        HttpURLConnection conReady = HttpUtils.getHttpConnectionWithAnyResponseCode(server1, APP_ENDPOINT);\n+        assertEquals(\"The Response Code was not 200 for the following endpoint: \" + conReady.getURL().toString(), SUCCESS_RESPONSE_CODE,\n+                     conReady.getResponseCode());\n+\n+        // Check if the response is correct\n+        String response_text = \"\";\n+        String next_line = \"\";\n+        String expected_response_text = \"Served at: /DelayedHealthCheckAppTesting Delayed Servlet initialization.\";\n+        try {\n+            BufferedReader br = HttpUtils.getResponseBody(conReady, \"UTF-8\");\n+            while ((next_line = br.readLine()) != null) {\n+                response_text += next_line;\n+            }\n+            br.close();\n+        } catch (IOException e) {\n+            fail(\"Encountered an error while reading from BufferedReader br. Error: \" + e);\n+        }\n+        assertEquals(\"Expected \" + expected_response_text + \" but received \" + response_text, expected_response_text, response_text);", "originalCommit": "f8062a9a3ab26bbcf764b0f5f96c42db5515910b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "28057807bec2ace85bea341ffc11901fbaea6b3a", "url": "https://github.com/OpenLiberty/open-liberty/commit/28057807bec2ace85bea341ffc11901fbaea6b3a", "message": "Making requested changes", "committedDate": "2020-01-31T16:15:23Z", "type": "commit"}]}