{"pr_number": 13316, "pr_title": "Metatype changes to add ES256 signature algorithm for JWT", "pr_createdAt": "2020-08-05T16:18:12Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/13316", "timeline": [{"oid": "3b79649c6775e4034a36518bfe73e87b1d68d58d", "url": "https://github.com/OpenLiberty/open-liberty/commit/3b79649c6775e4034a36518bfe73e87b1d68d58d", "message": "Metatype changes to add ES256 signature algorithm for JWT", "committedDate": "2020-08-05T16:22:53Z", "type": "commit"}, {"oid": "3b79649c6775e4034a36518bfe73e87b1d68d58d", "url": "https://github.com/OpenLiberty/open-liberty/commit/3b79649c6775e4034a36518bfe73e87b1d68d58d", "message": "Metatype changes to add ES256 signature algorithm for JWT", "committedDate": "2020-08-05T16:22:53Z", "type": "forcePushed"}, {"oid": "a6de3419d0c0652f16e8fefc8dbb3bccf91531f7", "url": "https://github.com/OpenLiberty/open-liberty/commit/a6de3419d0c0652f16e8fefc8dbb3bccf91531f7", "message": "Correct signing key behavior for RS256 private keys", "committedDate": "2020-08-06T15:58:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4OTQxMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13316#discussion_r467089410", "bodyText": "Can this be enhanced to determine if the key is of the correct type for the algorithm being used.  (using an RS key when the alg specified is ES - and possibly verifying that the cert is RS256 vs RS512...)", "author": "c00crane", "createdAt": "2020-08-07T14:49:54Z", "path": "dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java", "diffHunk": "@@ -435,6 +434,25 @@ public Builder signWith(String algorithm, Key key) throws KeyException {\n         return this;\n     }\n \n+    boolean isValidAlgorithmForJavaSecurityKey(String algorithm) {\n+        if (algorithm == null || algorithm.isEmpty()) {\n+            return false;\n+        }\n+        return algorithm.matches(\"[RE]S[0-9]{3,}\");\n+    }\n+\n+    String getValidAlgorithmListForJavaSecurityKey() {\n+        return Constants.SIGNATURE_ALG_RS256 + \", \" +\n+                Constants.SIGNATURE_ALG_ES256;\n+    }\n+\n+    boolean isValidKeyType(Key key) {\n+        if (key == null || !(key instanceof PrivateKey)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+", "originalCommit": "3b79649c6775e4034a36518bfe73e87b1d68d58d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5Mzk1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13316#discussion_r467093955", "bodyText": "no good place to put this comment, but, can we make sure that the key is the correct for the algorithm specified - either what we get from the truststore, or what we get from the jwk...", "author": "c00crane", "createdAt": "2020-08-07T14:57:20Z", "path": "dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/ConsumerUtil.java", "diffHunk": "@@ -51,641 +51,641 @@\n import com.ibm.wsspi.kernel.service.utils.AtomicServiceReference;\n \n public class ConsumerUtil {\n-\tprivate static final TraceComponent tc = Tr.register(ConsumerUtil.class);\n-\tprivate static final Class<?> thisClass = ConsumerUtil.class;\n-\n-\tprivate AtomicServiceReference<KeyStoreService> keyStoreService = null;\n-\n-\tprivate static TimeUtils timeUtils = new TimeUtils(TimeUtils.YearMonthDateHourMinSecZone);\n-\tprivate final JtiNonceCache jtiCache = new JtiNonceCache();\n-\tpublic final static String ISSUER = \"mp.jwt.verify.issuer\";\n-\tpublic final static String PUBLIC_KEY = \"mp.jwt.verify.publickey\";\n-\tpublic final static String KEY_LOCATION = \"mp.jwt.verify.publickey.location\";\n-\n-\tpublic ConsumerUtil(AtomicServiceReference<KeyStoreService> kss) {\n-\t\tkeyStoreService = kss;\n-\t}\n-\n-\tpublic JwtToken parseJwt(String jwtString, JwtConsumerConfig config) throws Exception {\n-\t\treturn parseJwt(jwtString, config, null);\n-\t}\n-\n-\tpublic JwtToken parseJwt(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n-\t\tJwtContext jwtContext = parseJwtAndGetJwtContext(jwtString, config, properties);\n-\t\tJwtTokenConsumerImpl jwtToken = new JwtTokenConsumerImpl(jwtContext);\n-\t\tcheckForReusedJwt(jwtToken, config);\n-\t\treturn jwtToken;\n-\t}\n-\n-\tJwtContext parseJwtAndGetJwtContext(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n-\t\tJwtContext jwtContext = parseJwtWithoutValidation(jwtString, config);\n-\t\tif (config.isValidationRequired()) {\n-\t\t\tjwtContext = getSigningKeyAndParseJwtWithValidation(jwtString, config, jwtContext, properties);\n-\t\t}\n-\t\treturn jwtContext;\n-\t}\n-\n-\tJwtContext getSigningKeyAndParseJwtWithValidation(String jwtString, JwtConsumerConfig config, JwtContext jwtContext,\n-\t\t\tMap properties) throws Exception {\n-\t\tKey signingKey = getSigningKey(config, jwtContext, properties);\n-\t\treturn parseJwtWithValidation(jwtString, jwtContext, config, signingKey, properties);\n-\t}\n-\n-\t/**\n-\t * Throws an exception if JWTs are not allowed to be reused (as configured by\n-\t * the provided config option) AND a token with a matching \"jti\" and \"issuer\"\n-\t * claim already exists in the cache.\n-\t */\n-\tvoid checkForReusedJwt(JwtTokenConsumerImpl jwt, JwtConsumerConfig config) throws InvalidTokenException {\n-\t\t// Only throw an error if tokens are not allowed to be reused\n-\t\tif (!config.getTokenReuse()) {\n-\t\t\tthrowExceptionIfJwtReused(jwt);\n-\t\t}\n-\t}\n-\n-\tvoid throwExceptionIfJwtReused(JwtTokenConsumerImpl jwt) throws InvalidTokenException {\n-\t\tif (jtiCache.contains(jwt)) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JWT token can only be submitted once. The issuer is \" + jwt.getClaims().getIssuer()\n-\t\t\t\t\t\t+ \", and JTI is \" + jwt.getClaims().getJwtId());\n-\t\t\t}\n-\t\t\tString errorMsg = Tr.formatMessage(tc, \"JWT_DUP_JTI_ERR\",\n-\t\t\t\t\tnew Object[] { jwt.getClaims().getIssuer(), jwt.getClaims().getJwtId() });\n-\t\t\tthrow new InvalidTokenException(errorMsg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get the appropriate signing key based on the signature algorithm specified in\n-\t * the config.\n-\t */\n-\tKey getSigningKey(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\tif (config == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JWT consumer config object is null\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tsigningKey = getSigningKeyBasedOnSignatureAlgorithm(config, jwtContext, properties);\n-\t\tif (signingKey == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"A signing key could not be found\");\n-\t\t\t}\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getSigningKeyBasedOnSignatureAlgorithm(JwtConsumerConfig config, JwtContext jwtContext, Map properties)\n-\t\t\tthrows KeyException {\n-\t\tKey signingKey = null;\n-\t\tString sigAlg = config.getSignatureAlgorithm();\n-\n-\t\tif (Constants.SIGNATURE_ALG_HS256.equals(sigAlg)) {\n-\t\t\tsigningKey = getSigningKeyForHS256(config);\n-\t\t} else if (Constants.SIGNATURE_ALG_RS256.equals(sigAlg)) {\n-\t\t\tsigningKey = getSigningKeyForRS256(config, jwtContext, properties);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getSigningKeyForHS256(JwtConsumerConfig config) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\ttry {\n-\t\t\tsigningKey = getSharedSecretKey(config);\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_SHARED_KEY\", new Object[] { e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\t/**\n-\t * Creates a Key object from the shared key specified in the provided\n-\t * configuration.\n-\t */\n-\tKey getSharedSecretKey(JwtConsumerConfig config) throws KeyException {\n-\t\tif (config == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JWT consumer config object is null\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tString sharedKey = config.getSharedKey();\n-\t\treturn createKeyFromSharedKey(sharedKey);\n-\t}\n-\n-\tKey createKeyFromSharedKey(String sharedKey) throws KeyException {\n-\t\tif (sharedKey == null || sharedKey.isEmpty()) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_MISSING_SHARED_KEY\");\n-\t\t\tthrow new KeyException(msg);\n-\t\t}\n-\t\ttry {\n-\t\t\treturn new HmacKey(sharedKey.getBytes(Constants.UTF_8));\n-\t\t} catch (UnsupportedEncodingException e) {\n-\t\t\t// Should not happen - UTF-8 should be supported\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Caught exception getting shared key bytes: \" + e.getLocalizedMessage());\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tboolean isPublicKeyPropsPresent(Map props) {\n-\t\tif (props == null) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn props.get(PUBLIC_KEY) != null || props.get(KEY_LOCATION) != null;\n-\t}\n-\n-\tKey getSigningKeyForRS256(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\tif (config.getJwkEnabled() || (config.getTrustedAlias() == null && isPublicKeyPropsPresent(properties))) { // need\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// consider\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// MP-Config\n-\t\t\tsigningKey = getKeyForJwkEnabled(config, jwtContext, properties);\n-\t\t} else {\n-\t\t\tsigningKey = getKeyForJwkDisabled(config);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getKeyForJwkEnabled(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\ttry {\n-\t\t\tsigningKey = getJwksKey(config, jwtContext, properties);\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_JWK_KEY\",\n-\t\t\t\t\tnew Object[] { config.getJwkEndpointUrl(), e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tprotected Key getJwksKey(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws Exception {\n-\t\tJsonWebStructure jwtHeader = getJwtHeader(jwtContext);\n-\t\tString kid = jwtHeader.getKeyIdHeaderValue();\n-\t\tJwKRetriever jwkRetriever = null;\n-\t\tif (properties != null) {\n-\t\t\tString publickey = (String) properties.get(PUBLIC_KEY);\n-\t\t\tString keyLocation = (String) properties.get(KEY_LOCATION);\n-\t\t\tif (publickey != null || keyLocation != null) {\n-\t\t\t\tjwkRetriever = new JwKRetriever(config.getId(), config.getSslRef(), config.getJwkEndpointUrl(),\n-\t\t\t\t\t\tconfig.getJwkSet(), JwtUtils.getSSLSupportService(), config.isHostNameVerificationEnabled(),\n-\t\t\t\t\t\tnull, null, publickey, keyLocation);\n-\t\t\t}\n-\t\t}\n-\t\tif (jwkRetriever == null) {\n-\t\t\tjwkRetriever = new JwKRetriever(config.getId(), config.getSslRef(), config.getJwkEndpointUrl(),\n-\t\t\t\t\tconfig.getJwkSet(), JwtUtils.getSSLSupportService(), config.isHostNameVerificationEnabled(), null,\n-\t\t\t\t\tnull);\n-\t\t}\n-\t\tKey signingKey = jwkRetriever.getPublicKeyFromJwk(kid, null,\n-\t\t\t\tconfig.getUseSystemPropertiesForHttpClientConnections()); // only kid or x5t will work but not both\n-\t\treturn signingKey;\n-\t}\n-\n-\tJsonWebStructure getJwtHeader(JwtContext jwtContext) throws Exception {\n-\t\tList<JsonWebStructure> jsonStructures = jwtContext.getJoseObjects();\n-\t\tif (jsonStructures == null || jsonStructures.isEmpty()) {\n-\t\t\t// TODO - NLS message\n-\t\t    throw new Exception(\"Invalid JsonWebStructure\");\n-\t\t}\n-\t\tJsonWebStructure jwtHeader = jsonStructures.get(0);\n-\t\tdebugJwtHeader(jwtHeader);\n-\t\treturn jwtHeader;\n-\t}\n-\n-\tvoid debugJwtHeader(JsonWebStructure jwtHeader) {\n-\t\tif (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"JsonWebStructure class: \" + jwtHeader.getClass().getName() + \" data:\" + jwtHeader);\n-\t\t\tif (jwtHeader instanceof JsonWebSignature) {\n-\t\t\t\tJsonWebSignature signature = (JsonWebSignature) jwtHeader;\n-\t\t\t\tTr.debug(tc, \"JsonWebSignature alg: \" + signature.getAlgorithmHeaderValue() + \" 3rd:'\"\n-\t\t\t\t\t\t+ signature.getEncodedSignature() + \"'\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tKey getKeyForJwkDisabled(JwtConsumerConfig config) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\tString trustedAlias = config.getTrustedAlias();\n-\t\tString trustStoreRef = config.getTrustStoreRef();\n-\t\ttry {\n-\t\t\tsigningKey = getPublicKey(trustedAlias, trustStoreRef, Constants.SIGNATURE_ALG_RS256);\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_PUBLIC_KEY\",\n-\t\t\t\t\tnew Object[] { trustedAlias, trustStoreRef, e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\t/**\n-\t * Creates a Key object from the certificate stored in the trust store and alias\n-\t * provided.\n-\t */\n-\tKey getPublicKey(String trustedAlias, String trustStoreRef, String signatureAlgorithm)\n-\t\t\tthrows KeyStoreServiceException, KeyException {\n-\t\tKey signingKey = getPublicKeyFromKeystore(trustedAlias, trustStoreRef, signatureAlgorithm);\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"Trusted alias: \" + trustedAlias + \", Truststore: \" + trustStoreRef);\n-\t\t\tTr.debug(tc, \"RSAPublicKey: \" + (signingKey instanceof RSAPublicKey));\n-\t\t}\n-\t\tif (signingKey != null && !(signingKey instanceof RSAPublicKey)) {\n-\t\t\tsigningKey = null;\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getPublicKeyFromKeystore(String trustedAlias, String trustStoreRef, String signatureAlgorithm)\n-\t\t\tthrows KeyException {\n-\t\ttry {\n-\t\t\tif (keyStoreService == null) {\n-\t\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TRUSTSTORE_SERVICE_NOT_AVAILABLE\");\n-\t\t\t\tthrow new KeyStoreServiceException(msg);\n-\t\t\t}\n-\t\t\treturn JwtUtils.getPublicKey(trustedAlias, trustStoreRef, keyStoreService.getService());\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_NULL_SIGNING_KEY_WITH_ERROR\",\n-\t\t\t\t\tnew Object[] { signatureAlgorithm, Constants.SIGNING_KEY_X509, e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t}\n-\n-\tprotected JwtContext parseJwtWithoutValidation(String jwtString, JwtConsumerConfig config) throws Exception {\n-\t\tif (jwtString == null || jwtString.isEmpty()) {\n-\t\t\tString errorMsg = Tr.formatMessage(tc, \"JWT_CONSUMER_NULL_OR_EMPTY_STRING\",\n-\t\t\t\t\tnew Object[] { config.getId(), jwtString });\n-\t\t\tthrow new InvalidTokenException(errorMsg);\n-\t\t}\n-\t\tJwtConsumerBuilder builder = initializeJwtConsumerBuilderWithoutValidation(config);\n-\t\tJwtConsumer firstPassJwtConsumer = builder.build();\n-\t\treturn firstPassJwtConsumer.process(jwtString);\n-\t}\n-\n-\tprotected JwtContext parseJwtWithValidation(String jwtString, JwtContext jwtContext, JwtConsumerConfig config,\n-\t\t\tKey key, Map properties) throws Exception {\n-\t\tJwtClaims jwtClaims = jwtContext.getJwtClaims();\n-\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"Key from config: \" + key);\n-\t\t}\n-\n-\t\tvalidateClaims(jwtClaims, jwtContext, config, properties);\n-\t\tvalidateSignatureAlgorithmWithKey(config, key);\n-\n-\t\tJwtConsumerBuilder consumerBuilder = initializeJwtConsumerBuilderWithValidation(config, jwtClaims, key);\n-\t\tJwtConsumer jwtConsumer = consumerBuilder.build();\n-\t\treturn processJwtStringWithConsumer(jwtConsumer, jwtString);\n-\t}\n-\n-\tJwtConsumerBuilder initializeJwtConsumerBuilderWithoutValidation(JwtConsumerConfig config) {\n-\t\tJwtConsumerBuilder builder = new JwtConsumerBuilder();\n-\t\tbuilder.setSkipAllValidators();\n-\t\tbuilder.setDisableRequireSignature();\n-\t\tbuilder.setSkipSignatureVerification();\n-\t\tbuilder.setAllowedClockSkewInSeconds((int) ((config.getClockSkew()) / 1000));\n-\t\treturn builder;\n-\t}\n-\n-\tJwtConsumerBuilder initializeJwtConsumerBuilderWithValidation(JwtConsumerConfig config, JwtClaims jwtClaims,\n-\t\t\tKey key) throws MalformedClaimException {\n-\t\tJwtConsumerBuilder builder = new JwtConsumerBuilder();\n-\t\tbuilder.setExpectedIssuer(jwtClaims.getIssuer());\n-\t\tbuilder.setSkipDefaultAudienceValidation();\n-\t\tbuilder.setRequireExpirationTime();\n-\t\tbuilder.setVerificationKey(key);\n-\t\tbuilder.setRelaxVerificationKeyValidation();\n-\t\tbuilder.setAllowedClockSkewInSeconds((int) (config.getClockSkew() / 1000));\n-\t\treturn builder;\n-\t}\n-\n-\tvoid validateClaims(JwtClaims jwtClaims, JwtContext jwtContext, JwtConsumerConfig config, Map properties)\n-\t\t\tthrows MalformedClaimException, InvalidClaimException, InvalidTokenException {\n-\t\tString issuer = config.getIssuer();\n-\t\tif (issuer == null) {\n-\t\t\tissuer = (properties == null) ? null : (String) properties.get(ISSUER);\n-\t\t}\n-\n-\t\tvalidateIssuer(config.getId(), issuer, jwtClaims.getIssuer());\n-\n-\t\tif (!validateAudience(config.getAudiences(), jwtClaims.getAudience())) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_AUDIENCE_NOT_TRUSTED\",\n-\t\t\t\t\tnew Object[] { jwtClaims.getAudience(), config.getId(), config.getAudiences() });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\n-\t\t// check azp\n-\n-\t\tvalidateIatAndExp(jwtClaims, config.getClockSkew());\n-\n-\t\tvalidateNbf(jwtClaims, config.getClockSkew());\n-\n-\t\tvalidateAlgorithm(jwtContext, config.getSignatureAlgorithm());\n-\t}\n-\n-\t/**\n-\t * Throws an exception if the provided key is null but the config specifies a\n-\t * signature algorithm other than \"none\".\n-\t */\n-\tvoid validateSignatureAlgorithmWithKey(JwtConsumerConfig config, Key key) throws InvalidClaimException {\n-\t\tString signatureAlgorithm = config.getSignatureAlgorithm();\n-\t\tif (key == null && signatureAlgorithm != null && !signatureAlgorithm.equalsIgnoreCase(\"none\")) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_MISSING_KEY\", new Object[] { signatureAlgorithm });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Verifies that tokenIssuer is one of the values specified in the\n-\t * comma-separated issuers string.\n-\t */\n-\tboolean validateIssuer(String consumerConfigId, String issuers, String tokenIssuer) throws InvalidClaimException {\n-\t\tboolean isIssuer = false;\n-\t\tif (issuers == null || issuers.isEmpty()) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TRUSTED_ISSUERS_NULL\",\n-\t\t\t\t\tnew Object[] { tokenIssuer, consumerConfigId });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\n-\t\tStringTokenizer st = new StringTokenizer(issuers, \",\");\n-\t\twhile (st.hasMoreTokens()) {\n-\t\t\tString iss = st.nextToken().trim();\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Trusted issuer: \" + iss);\n-\t\t\t}\n-\t\t\tif (Constants.ALL_ISSUERS.equals(iss) || (tokenIssuer != null && tokenIssuer.equals(iss))) {\n-\t\t\t\tisIssuer = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!isIssuer) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ISSUER_NOT_TRUSTED\",\n-\t\t\t\t\tnew Object[] { tokenIssuer, consumerConfigId, issuers });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t\treturn isIssuer;\n-\t}\n-\n-\t/**\n-\t * Verifies that at least one of the values specified in audiences is contained\n-\t * in the allowedAudiences list.\n-\t */\n-\tboolean validateAudience(List<String> allowedAudiences, List<String> audiences) {\n-\t\tboolean valid = false;\n-\n-\t\tif (allowedAudiences != null && allowedAudiences.contains(Constants.ALL_AUDIENCES)) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tif (allowedAudiences != null && audiences != null) {\n-\t\t\tfor (String audience : audiences) {\n-\t\t\t\tfor (String allowedAud : allowedAudiences) {\n-\t\t\t\t\tif (allowedAud.equals(audience)) {\n-\t\t\t\t\t\tvalid = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (allowedAudiences == null && (audiences == null || audiences.isEmpty())) {\n-\t\t\tvalid = true;\n-\t\t}\n-\n-\t\treturn valid;\n-\t}\n-\n-\t/**\n-\t * Validates the the {@value Claims#ISSUED_AT} and {@value Claims#EXPIRATION}\n-\t * claims are present and properly formed. Also verifies that the\n-\t * {@value Claims#ISSUED_AT} time is after the {@value Claims#EXPIRATION} time.\n-\t */\n-\tvoid validateIatAndExp(JwtClaims jwtClaims, long clockSkewInMilliseconds) throws InvalidClaimException {\n-\t\tif (jwtClaims == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Missing JwtClaims object\");\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tNumericDate issueAtClaim = getIssuedAtClaim(jwtClaims);\n-\t\tNumericDate expirationClaim = getExpirationClaim(jwtClaims);\n-\n-\t\tdebugCurrentTimes(clockSkewInMilliseconds, issueAtClaim, expirationClaim);\n-\n-\t\tvalidateIssuedAtClaim(issueAtClaim, expirationClaim, clockSkewInMilliseconds);\n-\t\tvalidateExpirationClaim(expirationClaim, clockSkewInMilliseconds);\n-\n-\t}\n-\n-\tvoid debugCurrentTimes(long clockSkewInMilliseconds, NumericDate issueAtClaim, NumericDate expirationClaim) {\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tlong now = (new Date()).getTime();\n-\t\t\tNumericDate currentTimeMinusSkew = NumericDate.fromMilliseconds(now - clockSkewInMilliseconds);\n-\t\t\tNumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n-\t\t\tTr.debug(tc, \"Checking iat [\" + createDateString(issueAtClaim) + \"] and exp [\"\n-\t\t\t\t\t+ createDateString(expirationClaim) + \"]\");\n-\t\t\tTr.debug(tc, \"Comparing against current time (minus clock skew of \" + (clockSkewInMilliseconds / 1000)\n-\t\t\t\t\t+ \" seconds) [\" + createDateString(currentTimeMinusSkew) + \"]\");\n-\t\t\tTr.debug(tc, \"Comparing against current time (plus clock skew of \" + (clockSkewInMilliseconds / 1000)\n-\t\t\t\t\t+ \" seconds) [\" + createDateString(currentTimePlusSkew) + \"]\");\n-\t\t}\n-\t}\n-\n-\tvoid validateIssuedAtClaim(NumericDate issueAtClaim, NumericDate expirationClaim, long clockSkewInMilliseconds)\n-\t\t\tthrows InvalidClaimException {\n-\t\tlong now = (new Date()).getTime();\n-\t\tNumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n-\n-\t\tif (issueAtClaim != null && expirationClaim != null) {\n-\t\t\tif (issueAtClaim.isAfter(currentTimePlusSkew)) {\n-\t\t\t\tString msg = Tr.formatMessage(tc, \"JWT_IAT_AFTER_CURRENT_TIME\",\n-\t\t\t\t\t\tnew Object[] { createDateString(issueAtClaim), createDateString(currentTimePlusSkew),\n-\t\t\t\t\t\t\t\t(clockSkewInMilliseconds / 1000) });\n-\t\t\t\tthrow new InvalidClaimException(msg);\n-\t\t\t}\n-\t\t\tif (issueAtClaim.isOnOrAfter(expirationClaim)) {\n-\t\t\t\tString msg = Tr.formatMessage(tc, \"JWT_IAT_AFTER_EXP\",\n-\t\t\t\t\t\tnew Object[] { createDateString(issueAtClaim), createDateString(expirationClaim) });\n-\t\t\t\tthrow new InvalidClaimException(msg);\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// TODO - what if one or the other is missing? is that an error\n-\t\t\t// condition?\n-\t\t}\n-\t}\n-\n-\t\n-\tvoid validateExpirationClaim(NumericDate expirationClaim, long clockSkewInMilliseconds)\n-\t\t\tthrows InvalidClaimException {\n-\t\tlong now = (new Date()).getTime();\n-\t\tNumericDate currentTimeMinusSkew = NumericDate.fromMilliseconds(now - clockSkewInMilliseconds);\n-\n-\t\t// Check that expiration claim is in the future, accounting for the\n-\t\t// clock skew\n-\t\tif (expirationClaim == null || (!expirationClaim.isAfter(currentTimeMinusSkew))) {\n-\t\t\tJwtUtils.setJwtSsoValidationPathExiredToken();\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TOKEN_EXPIRED\", new Object[] { createDateString(expirationClaim),\n-\t\t\t\t\tcreateDateString(currentTimeMinusSkew), (clockSkewInMilliseconds / 1000) });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Validates the the {@value Claims#NOT_BEFORE} claim is present and properly\n-\t * formed. Also\n-\t */\n-\tvoid validateNbf(JwtClaims jwtClaims, long clockSkewInMilliseconds) throws InvalidClaimException {\n-\t\tif (jwtClaims == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Missing JwtClaims object\");\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tNumericDate nbf = getNotBeforeClaim(jwtClaims);\n-\t\tvalidateNotBeforeClaim(nbf, clockSkewInMilliseconds);\n-\t}\n-\n-\tvoid validateNotBeforeClaim(NumericDate nbfClaim, long clockSkewInMilliseconds) throws InvalidClaimException {\n-\t\tlong now = (new Date()).getTime();\n-\t\tNumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n-\n-\t\t// Check that nbf claim is in the past, accounting for the clock skew\n-\t\tif (nbfClaim != null && (nbfClaim.isOnOrAfter(currentTimePlusSkew))) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TOKEN_BEFORE_NBF\", new Object[] { createDateString(nbfClaim),\n-\t\t\t\t\tcreateDateString(currentTimePlusSkew), (clockSkewInMilliseconds / 1000) });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t}\n-\n-\tNumericDate getIssuedAtClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n-\t\tNumericDate iatClaim = null;\n-\t\ttry {\n-\t\t\tiatClaim = jwtClaims.getIssuedAt();\n-\t\t} catch (MalformedClaimException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n-\t\t\t\t\tnew Object[] { Claims.ISSUED_AT, e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidClaimException(msg, e);\n-\t\t}\n-\t\treturn iatClaim;\n-\t}\n-\n-\tNumericDate getExpirationClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n-\t\tNumericDate expClaim = null;\n-\t\ttry {\n-\t\t\texpClaim = jwtClaims.getExpirationTime();\n-\t\t} catch (MalformedClaimException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n-\t\t\t\t\tnew Object[] { Claims.EXPIRATION, e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidClaimException(msg, e);\n-\t\t}\n-\t\treturn expClaim;\n-\t}\n-\n-\tNumericDate getNotBeforeClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n-\t\tNumericDate nbfClaim = null;\n-\t\ttry {\n-\t\t\tnbfClaim = jwtClaims.getNotBefore();\n-\t\t} catch (MalformedClaimException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n-\t\t\t\t\tnew Object[] { Claims.NOT_BEFORE, e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidClaimException(msg, e);\n-\t\t}\n-\t\treturn nbfClaim;\n-\t}\n-\n-\tvoid validateAlgorithm(JwtContext jwtContext, String requiredAlg) throws InvalidTokenException {\n-\t\tif (requiredAlg == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"No required signature algorithm was specified\");\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tString tokenAlg = getAlgorithmFromJwtHeader(jwtContext);\n-\t\tvalidateAlgorithm(requiredAlg, tokenAlg);\n-\t}\n-\n-\tvoid validateAlgorithm(String requiredAlg, String tokenAlg) throws InvalidTokenException {\n-\t\tif (tokenAlg == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Signature algorithm was not found in the JWT\");\n-\t\t\t}\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_MISSING_ALG_HEADER\", new Object[] { requiredAlg });\n-\t\t\tthrow new InvalidTokenException(msg);\n-\t\t}\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"JWT is signed with algorithm: \", tokenAlg);\n-\t\t\tTr.debug(tc, \"JWT is required to be signed with algorithm: \", requiredAlg);\n-\t\t}\n-\t\tif (!requiredAlg.equals(tokenAlg)) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ALGORITHM_MISMATCH\", new Object[] { tokenAlg, requiredAlg });\n-\t\t\tthrow new InvalidTokenException(msg);\n-\t\t}\n-\t}\n-\n-\tJwtContext processJwtStringWithConsumer(JwtConsumer jwtConsumer, String jwtString)\n-\t\t\tthrows InvalidTokenException, InvalidJwtException {\n-\t\tJwtContext validatedJwtContext = null;\n-\t\ttry {\n-\t\t\tvalidatedJwtContext = jwtConsumer.process(jwtString);\n-\t\t} catch (InvalidJwtSignatureException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_INVALID_SIGNATURE\", new Object[] { e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidTokenException(msg, e);\n-\t\t} catch (InvalidJwtException e) {\n-\t\t\tThrowable cause = getRootCause(e);\n-\t\t\tif (cause != null && cause instanceof InvalidKeyException) {\n-\t\t\t\tthrow e;\n-\t\t\t} else {\n-\t\t\t\t// Don't have enough information to output a more useful error\n-\t\t\t\t// message\n-\t\t\t\tthrow e;\n-\t\t\t}\n-\t\t}\n-\t\treturn validatedJwtContext;\n-\t}\n-\n-\tString getAlgorithmFromJwtHeader(JwtContext jwtContext) {\n-\t\tif (jwtContext == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JwtContext is null\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tJsonWebStructure jwtHeader = null;\n-\t\ttry {\n-\t\t\tjwtHeader = getJwtHeader(jwtContext);\n-\t\t} catch (Exception e) {\n-\t\t\t// TODO - NLS message?\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Failed to obtain JWT header\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tString algHeader = jwtHeader.getAlgorithmHeaderValue();\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"JWT is signed with algorithm: \", algHeader);\n-\t\t}\n-\t\treturn algHeader;\n-\t}\n-\n-\tThrowable getRootCause(Exception e) {\n-\t\tThrowable rootCause = null;\n-\t\tThrowable tmpCause = e;\n-\t\twhile (tmpCause != null) {\n-\t\t\trootCause = tmpCause;\n-\t\t\ttmpCause = rootCause.getCause();\n-\t\t}\n-\t\treturn rootCause;\n-\t}\n-\n-\tString createDateString(NumericDate date) {\n-\t\tif (date == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\t// NumericDate.getValue() returns a value in seconds, so convert to\n-\t\t// milliseconds\n-\t\treturn timeUtils.createDateString(1000 * date.getValue());\n-\t}\n+    private static final TraceComponent tc = Tr.register(ConsumerUtil.class);\n+    private static final Class<?> thisClass = ConsumerUtil.class;\n+\n+    private AtomicServiceReference<KeyStoreService> keyStoreService = null;\n+\n+    private static TimeUtils timeUtils = new TimeUtils(TimeUtils.YearMonthDateHourMinSecZone);\n+    private final JtiNonceCache jtiCache = new JtiNonceCache();\n+    public final static String ISSUER = \"mp.jwt.verify.issuer\";\n+    public final static String PUBLIC_KEY = \"mp.jwt.verify.publickey\";\n+    public final static String KEY_LOCATION = \"mp.jwt.verify.publickey.location\";\n+\n+    public ConsumerUtil(AtomicServiceReference<KeyStoreService> kss) {\n+        keyStoreService = kss;\n+    }\n+\n+    public JwtToken parseJwt(String jwtString, JwtConsumerConfig config) throws Exception {\n+        return parseJwt(jwtString, config, null);\n+    }\n+\n+    public JwtToken parseJwt(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n+        JwtContext jwtContext = parseJwtAndGetJwtContext(jwtString, config, properties);\n+        JwtTokenConsumerImpl jwtToken = new JwtTokenConsumerImpl(jwtContext);\n+        checkForReusedJwt(jwtToken, config);\n+        return jwtToken;\n+    }\n+\n+    JwtContext parseJwtAndGetJwtContext(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n+        JwtContext jwtContext = parseJwtWithoutValidation(jwtString, config);\n+        if (config.isValidationRequired()) {\n+            jwtContext = getSigningKeyAndParseJwtWithValidation(jwtString, config, jwtContext, properties);\n+        }\n+        return jwtContext;\n+    }\n+\n+    JwtContext getSigningKeyAndParseJwtWithValidation(String jwtString, JwtConsumerConfig config, JwtContext jwtContext,\n+            Map properties) throws Exception {\n+        Key signingKey = getSigningKey(config, jwtContext, properties);\n+        return parseJwtWithValidation(jwtString, jwtContext, config, signingKey, properties);\n+    }\n+\n+    /**\n+     * Throws an exception if JWTs are not allowed to be reused (as configured by\n+     * the provided config option) AND a token with a matching \"jti\" and \"issuer\"\n+     * claim already exists in the cache.\n+     */\n+    void checkForReusedJwt(JwtTokenConsumerImpl jwt, JwtConsumerConfig config) throws InvalidTokenException {\n+        // Only throw an error if tokens are not allowed to be reused\n+        if (!config.getTokenReuse()) {\n+            throwExceptionIfJwtReused(jwt);\n+        }\n+    }\n+\n+    void throwExceptionIfJwtReused(JwtTokenConsumerImpl jwt) throws InvalidTokenException {\n+        if (jtiCache.contains(jwt)) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"JWT token can only be submitted once. The issuer is \" + jwt.getClaims().getIssuer()\n+                        + \", and JTI is \" + jwt.getClaims().getJwtId());\n+            }\n+            String errorMsg = Tr.formatMessage(tc, \"JWT_DUP_JTI_ERR\",\n+                    new Object[] { jwt.getClaims().getIssuer(), jwt.getClaims().getJwtId() });\n+            throw new InvalidTokenException(errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Get the appropriate signing key based on the signature algorithm specified in\n+     * the config.\n+     */\n+    Key getSigningKey(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        Key signingKey = null;\n+        if (config == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"JWT consumer config object is null\");\n+            }\n+            return null;\n+        }\n+        signingKey = getSigningKeyBasedOnSignatureAlgorithm(config, jwtContext, properties);\n+        if (signingKey == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"A signing key could not be found\");\n+            }\n+        }\n+        return signingKey;\n+    }\n+\n+    Key getSigningKeyBasedOnSignatureAlgorithm(JwtConsumerConfig config, JwtContext jwtContext, Map properties)\n+            throws KeyException {\n+        Key signingKey = null;\n+        String sigAlg = config.getSignatureAlgorithm();\n+\n+        if (Constants.SIGNATURE_ALG_HS256.equals(sigAlg)) {\n+            signingKey = getSigningKeyForHS256(config);\n+        } else if (Constants.SIGNATURE_ALG_RS256.equals(sigAlg)) {\n+            signingKey = getSigningKeyForRS256(config, jwtContext, properties);\n+        } else if (Constants.SIGNATURE_ALG_ES256.equals(sigAlg)) {\n+            signingKey = getSigningKeyForES256(config, jwtContext, properties);\n+        }\n+        return signingKey;\n+    }\n+\n+    Key getSigningKeyForHS256(JwtConsumerConfig config) throws KeyException {\n+        Key signingKey = null;\n+        try {\n+            signingKey = getSharedSecretKey(config);\n+        } catch (Exception e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_SHARED_KEY\", new Object[] { e.getLocalizedMessage() });\n+            throw new KeyException(msg, e);\n+        }\n+        return signingKey;\n+    }\n+\n+    /**\n+     * Creates a Key object from the shared key specified in the provided\n+     * configuration.\n+     */\n+    Key getSharedSecretKey(JwtConsumerConfig config) throws KeyException {\n+        if (config == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"JWT consumer config object is null\");\n+            }\n+            return null;\n+        }\n+        String sharedKey = config.getSharedKey();\n+        return createKeyFromSharedKey(sharedKey);\n+    }\n+\n+    Key createKeyFromSharedKey(String sharedKey) throws KeyException {\n+        if (sharedKey == null || sharedKey.isEmpty()) {\n+            String msg = Tr.formatMessage(tc, \"JWT_MISSING_SHARED_KEY\");\n+            throw new KeyException(msg);\n+        }\n+        try {\n+            return new HmacKey(sharedKey.getBytes(Constants.UTF_8));\n+        } catch (UnsupportedEncodingException e) {\n+            // Should not happen - UTF-8 should be supported\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Caught exception getting shared key bytes: \" + e.getLocalizedMessage());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    boolean isPublicKeyPropsPresent(Map props) {\n+        if (props == null) {\n+            return false;\n+        }\n+        return props.get(PUBLIC_KEY) != null || props.get(KEY_LOCATION) != null;\n+    }\n+\n+    Key getSigningKeyForRS256(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        return getKeyFromJwkOrTrustStore(config, jwtContext, properties);\n+    }\n+\n+    Key getKeyFromJwkOrTrustStore(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        Key signingKey = null;\n+        if (config.getJwkEnabled() || (config.getTrustedAlias() == null && isPublicKeyPropsPresent(properties))) { // need change to consider MP-Config", "originalCommit": "3b79649c6775e4034a36518bfe73e87b1d68d58d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}