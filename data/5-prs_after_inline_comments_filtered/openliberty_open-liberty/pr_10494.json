{"pr_number": 10494, "pr_title": "Expose Producer and ConsumerRecord", "pr_createdAt": "2020-01-20T18:12:45Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/10494", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwNjU2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369006560", "bodyText": "I don't really like putting this logic in what's meant to be a thin wrapper layer.\nI get that if we want to handle Kafka classes directly, then we can only do so so in the adaptor layer, but maybe we could separate the functionality for turning a value into a ProducerRecord from the simple wrapping logic.", "author": "Azquelt", "createdAt": "2020-01-21T13:43:19Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/KafkaProducerImpl.java", "diffHunk": "@@ -21,22 +21,40 @@\n /**\n  *\n  */\n-public class KafkaProducerImpl<K, V> extends AbstractKafkaAdapter<org.apache.kafka.clients.producer.KafkaProducer<K, V>> implements KafkaProducer<K, V> {\n+public class KafkaProducerImpl<K, V, T> extends AbstractKafkaAdapter<org.apache.kafka.clients.producer.KafkaProducer<K, T>> implements KafkaProducer<K, V> {\n \n     private static final String CLAZZ = KafkaProducerImpl.class.getName();\n     private static final Logger LOGGER = Logger.getLogger(CLAZZ);\n \n     public KafkaProducerImpl(Map<String, Object> producerConfig) {\n-        super(new org.apache.kafka.clients.producer.KafkaProducer<K, V>(producerConfig));\n+        super(new org.apache.kafka.clients.producer.KafkaProducer<K, T>(producerConfig));\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public void send(String topic, V value, Callback callback) {\n+    public void send(String configuredTopic, V value, Callback callback, boolean useProducerRecordTopic) {\n         if (LOGGER.isLoggable(Level.FINEST)) {\n-            LOGGER.logp(Level.FINEST, CLAZZ, \"send\", \"Topic: {0}, Value: {1}\", new String[] { topic, value.toString() });\n+            LOGGER.logp(Level.FINEST, CLAZZ, \"send\", \"Configured Topic: {0}, Value: {1}, Use ProducerRecord topic: {2}\",\n+                        new String[] { configuredTopic, value.toString(), Boolean.toString(useProducerRecordTopic) });\n+        }\n+\n+        org.apache.kafka.clients.producer.ProducerRecord<K, T> delegateRecord;\n+\n+        if (value instanceof org.apache.kafka.clients.producer.ProducerRecord) {\n+            org.apache.kafka.clients.producer.ProducerRecord<K, T> userProducerRecord = (org.apache.kafka.clients.producer.ProducerRecord<K, T>) value;\n+            org.apache.kafka.common.header.Headers headers = userProducerRecord.headers();\n+            K key = userProducerRecord.key();\n+            Integer partition = userProducerRecord.partition();\n+            Long timestamp = userProducerRecord.timestamp();\n+            String userTopic = userProducerRecord.topic();\n+            T userValue = userProducerRecord.value();\n+\n+            String topic = useProducerRecordTopic ? userTopic : configuredTopic;\n+\n+            delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(topic, partition, timestamp, key, userValue, headers);\n+        } else {\n+            delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(configuredTopic, (T) value);\n         }\n-        org.apache.kafka.clients.producer.ProducerRecord<K, V> delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(topic, value);\n ", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDQ3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372870477", "bodyText": "A ProducerRecord is now constructed through the factory so the send method now mirrors the original API again.", "author": "tevans78", "createdAt": "2020-01-30T10:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwNjU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwODQyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369008429", "bodyText": "If we go ahead with something using this approach, we should make sure the special value makes sense to the user configuring the application.\nI think something like this would make more sense:\nmp.reactive.messaging.outgoing.foobar.topic=APPLICATION_PROVIDED", "author": "Azquelt", "createdAt": "2020-01-21T13:47:04Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java", "diffHunk": "@@ -26,6 +26,10 @@\n     //The producer or consumer topic\n     public static final String TOPIC = \"topic\";\n \n+    //If the topic is set to this value then when the message payload is a ProducerRecord,\n+    //use the topic set in the ProducerRecord rather than the one set in MP Config\n+    public static final String USE_PRODUCER_RECORD_TOPIC = \"USE_PRODUCER_RECORD_TOPIC\";", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371251860", "bodyText": "Decided that we don't need this special config property value", "author": "tevans78", "createdAt": "2020-01-27T13:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwODQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMDYwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369010607", "bodyText": "It's not valid for ack to be null (Trying to follow it through, I think ack will be passed as the second argument to Message.of(payload, ack) which doesn't permit null)", "author": "Azquelt", "createdAt": "2020-01-21T13:51:06Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaInput.java", "diffHunk": "@@ -140,12 +145,18 @@ public KafkaInput(KafkaAdapterFactory kafkaAdapterFactory, KafkaConsumer<K, V> k\n     }\n \n     private Message<V> wrapInMessage(ConsumerRecord<K, V> record) {\n+        Message<V> message = null;\n         try {\n-            return Message.of(record.value(), this.ackTracker.trackRecord(record));\n+            Supplier<CompletionStage<Void>> ack = null;\n+            if (this.ackTracker != null) {\n+                ack = this.ackTracker.trackRecord(record);\n+            }\n+            message = this.kafkaAdapterFactory.newIncomingKafkaMessage(record, ack);", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5MDE2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371190163", "bodyText": "Reading it through again, it doesn't go to Message.of(), you have your own Message implementation which accepts null as the ack argument.", "author": "Azquelt", "createdAt": "2020-01-27T11:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMTkyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369011928", "bodyText": "I'd prefer either setting the key on the original message, or generating the key completely in the processor method.", "author": "Azquelt", "createdAt": "2020-01-21T13:53:33Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import javax.servlet.annotation.WebServlet;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.junit.Test;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n+\n+@WebServlet(\"/kafkaMessageTest\")\n+public class KafkaMessageServlet extends AbstractKafkaTestServlet {\n+\n+    @Test\n+    public void testKafkaMessage() {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(KafkaMessageBean.CHANNEL_IN);\n+        String value = \"hello\";\n+        writer.sendMessage(value);\n+\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(KafkaMessageBean.CHANNEL_OUT);\n+        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(2));\n+\n+        assertEquals(1, records.size());\n+\n+        ConsumerRecord<String, String> record = records.get(0);\n+        assertEquals(\"OUT_null\", record.key()); //original key defaults to null", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MjI4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371252284", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-27T13:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMjcyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369012724", "bodyText": "Should we also test that nothing is received on CHANNEL_ALT?", "author": "Azquelt", "createdAt": "2020-01-21T13:54:58Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import javax.servlet.annotation.WebServlet;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.junit.Test;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n+\n+@WebServlet(\"/kafkaMessageTest\")\n+public class KafkaMessageServlet extends AbstractKafkaTestServlet {\n+\n+    @Test\n+    public void testKafkaMessage() {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(KafkaMessageBean.CHANNEL_IN);\n+        String value = \"hello\";\n+        writer.sendMessage(value);\n+\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(KafkaMessageBean.CHANNEL_OUT);", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MjAwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371252006", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-27T13:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMjcyNA=="}], "type": "inlineReview"}, {"oid": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "url": "https://github.com/OpenLiberty/open-liberty/commit/ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "message": "Expose Producer and ConsumerRecord", "committedDate": "2020-01-24T16:05:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc2MDc1Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r370760756", "bodyText": "a) true what?\nb) What requires not checking that the correct number of records were fetched?", "author": "Azquelt", "createdAt": "2020-01-24T17:48:39Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java", "diffHunk": "@@ -50,6 +50,10 @@ public ExtendedKafkaReader(KafkaConsumer<K, V> kafkaConsumer, String topic) {\n      * @return the list of records received\n      */\n     public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout) {\n+        return waitForRecords(count, timeout, true);", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwMDYyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371200623", "bodyText": "We discussed this further, see comment below", "author": "Azquelt", "createdAt": "2020-01-27T11:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc2MDc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDY4OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372870688", "bodyText": "Removed the boolean and renamed the methods", "author": "tevans78", "createdAt": "2020-01-30T10:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc2MDc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4Nzg4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371187884", "bodyText": "Instead of passing beta guard booleans around, can we put a static somewhere in the interface bundle?", "author": "Azquelt", "createdAt": "2020-01-27T11:26:42Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaAdapterFactory.java", "diffHunk": "@@ -29,7 +33,7 @@\n     private static final Class<?>[] KAFKA_CONSUMER_ARG_TYPES = { Map.class };\n \n     private static final String KAFKA_PRODUCER_IMPL = \"com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl.KafkaProducerImpl\";\n-    private static final Class<?>[] KAFKA_PRODUCER_ARG_TYPES = { Map.class };\n+    private static final Class<?>[] KAFKA_PRODUCER_ARG_TYPES = { Map.class, boolean.class }; //TODO remove beta guard before GA", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDg3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372870871", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4Nzg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODMyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371188325", "bodyText": "This method in particular needs doc because it's not a simple passthrough.", "author": "Azquelt", "createdAt": "2020-01-27T11:27:40Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaProducer.java", "diffHunk": "@@ -18,10 +18,12 @@\n public interface KafkaProducer<K, V> extends KafkaAdapter {\n \n     /**\n-     * @param record\n+     * @param topic\n+     * @param channelName\n+     * @param value\n      * @param callback\n      */\n-    void send(String topic, V value, Callback callback);\n+    void send(String topic, String channelName, V value, Callback callback);", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTAyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871021", "bodyText": "it is back to being passthrough", "author": "tevans78", "createdAt": "2020-01-30T10:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODUwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371188504", "bodyText": "Remove if this is the only change :)", "author": "Azquelt", "createdAt": "2020-01-27T11:28:03Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTA4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871081", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5Mzk3Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371193976", "bodyText": "Can we have two separate methods instead of a boolean argument.\nMaybe\nreadRecords(int maxCount, Duration timeout);\n\nand\nassertReadRecords(int count, Duration timeout)", "author": "Azquelt", "createdAt": "2020-01-27T11:41:44Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java", "diffHunk": "@@ -50,6 +50,10 @@ public ExtendedKafkaReader(KafkaConsumer<K, V> kafkaConsumer, String topic) {\n      * @return the list of records received\n      */\n     public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout) {\n+        return waitForRecords(count, timeout, true);\n+    }\n+\n+    public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout, boolean assertNumberOfRecords) {", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTE1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871155", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5Mzk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NTgxNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371195815", "bodyText": "Simplify this method.", "author": "Azquelt", "createdAt": "2020-01-27T11:46:28Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n+\n+public class AbstractTopicServlet extends AbstractKafkaTestServlet {\n+\n+    public void testTopic(String topicIn, String expectedTopicOut, String unexpectedTopicOut, String keyOut, String valueOut) {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(topicIn);\n+        String value = \"hello\"; //this value doesn't matter\n+        writer.sendMessage(value);\n+\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(expectedTopicOut);\n+        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+        if (records.size() != 1) {\n+            reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+            records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+            if (records.size() == 1) {\n+                fail(\"Message was sent to wrong topic: \" + unexpectedTopicOut);\n+            } else {\n+                fail(\"Message not found on any topic\");\n+            }\n+        }\n+\n+        ConsumerRecord<String, String> record = records.get(0);\n+        assertEquals(keyOut, record.key());\n+        assertEquals(valueOut, record.value());\n+        assertEquals(expectedTopicOut, record.topic());\n+\n+        reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+        records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+        assertEquals(\"Message may have been sent to more than one topic???\", 0, records.size());\n+    }", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTIzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871235", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NTgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NjExNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371196114", "bodyText": "Should be able to check this now.", "author": "Azquelt", "createdAt": "2020-01-27T11:47:13Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/ConsumerRecordBean.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+@ApplicationScoped\n+public class ConsumerRecordBean {\n+\n+    public static final String CHANNEL_IN = \"consumer-record-in\";\n+    public static final String CHANNEL_OUT = \"consumer-record-out\";\n+    public static final String GROUP_ID = \"consumer-record-app-group\";\n+\n+    public static final String TOPIC = CHANNEL_IN;\n+    public static final String KEY = \"test_key\";\n+    public static final String VALUE = \"hello\";\n+    //public static final int PARTITION = 9;\n+    public static final long TIMESTAMP = 100L;\n+    public static final int NUM_HEADERS = 5;\n+    public static final String HEADER_KEY_PREFIX = \"headerKey\";\n+    public static final String HEADER_VALUE_PREFIX = \"headerKey\";\n+    public static final String PASS = \"PASS\";\n+\n+    @Incoming(CHANNEL_IN)\n+    @Outgoing(CHANNEL_OUT)\n+    public Message<String> checkConsumerRecord(Message<String> in) throws UnsupportedEncodingException {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ConsumerRecord<String, String> consumerRecord = in.unwrap(ConsumerRecord.class);\n+\n+        String incomingKey = consumerRecord.key();\n+        String incomingValue = consumerRecord.value();\n+        String incomingTopic = consumerRecord.topic();\n+        //int incomingPartition = consumerRecord.partition();", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTQ0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871448", "bodyText": "Not done! But it is harder and I want to do it separately.", "author": "tevans78", "createdAt": "2020-01-30T10:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NjExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5ODU1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371198550", "bodyText": "It's hard to read what this is doing. Can we remove the abstract class, even if that means duplicating the test code?", "author": "Azquelt", "createdAt": "2020-01-27T11:53:11Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/UseConfiguredTopicServlet.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import javax.servlet.annotation.WebServlet;\n+\n+import org.junit.Test;\n+\n+@WebServlet(\"/useConfiguredTopicTest\")\n+public class UseConfiguredTopicServlet extends AbstractTopicServlet {\n+\n+    @Test\n+    public void testConfiguredTopic() {\n+        testTopic(ConfiguredTopicBean.CHANNEL_IN, ConfiguredTopicBean.CONFIGURED_TOPIC, ConfiguredTopicBean.PRODUCER_RECORD_TOPIC, ConfiguredTopicBean.PRODUCER_RECORD_KEY,\n+                  ConfiguredTopicBean.PRODUCER_RECORD_VALUE);\n+    }", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTU1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871550", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5ODU1MA=="}], "type": "inlineReview"}, {"oid": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "url": "https://github.com/OpenLiberty/open-liberty/commit/4b7820d0549ae3d98766fdd3e99601ad8728d280", "message": "Refactor KafkaReader and KafkaWriter", "committedDate": "2020-01-28T18:13:11Z", "type": "forcePushed"}, {"oid": "f7ac08ee1d5e0c07afb040f6b482389bed6952d2", "url": "https://github.com/OpenLiberty/open-liberty/commit/f7ac08ee1d5e0c07afb040f6b482389bed6952d2", "message": "dependabot update", "committedDate": "2020-01-29T11:55:23Z", "type": "forcePushed"}, {"oid": "e76a10f140b618fa9d486b6f6aaef7ca568e2fdf", "url": "https://github.com/OpenLiberty/open-liberty/commit/e76a10f140b618fa9d486b6f6aaef7ca568e2fdf", "message": "dependabot update", "committedDate": "2020-01-29T11:59:03Z", "type": "forcePushed"}, {"oid": "5f66f823f12fd5d579df5f6e61a23b04af23d149", "url": "https://github.com/OpenLiberty/open-liberty/commit/5f66f823f12fd5d579df5f6e61a23b04af23d149", "message": "dependabot update", "committedDate": "2020-01-29T11:59:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg4NzQyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372887424", "bodyText": "Exception messages need NLS before final release.", "author": "Azquelt", "createdAt": "2020-01-30T11:07:02Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/IncomingKafkaMessage.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.BetaUtils;\n+import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.ConsumerRecord;\n+\n+/**\n+ *\n+ */\n+public class IncomingKafkaMessage<T> implements Message<T> {\n+\n+    private final ConsumerRecord<?, T> consumerRecord;\n+    private final Supplier<CompletionStage<Void>> ack;\n+\n+    public IncomingKafkaMessage(ConsumerRecord<?, T> consumerRecord, Supplier<CompletionStage<Void>> ack) {\n+        this.consumerRecord = consumerRecord;\n+        this.ack = ack;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getPayload() {\n+        return this.consumerRecord.value();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public CompletionStage<Void> ack() {\n+        if (this.ack != null) {\n+            return this.ack.get();\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    @Override\n+    public <C> C unwrap(Class<C> unwrapType) {\n+        if (unwrapType == null) {\n+            throw new IllegalArgumentException(\"The target class must not be `null`\");\n+        }\n+        if (BetaUtils.USE_KAFKA_PRODUCER_RECORD) { //TODO remove guard before GA\n+            if (org.apache.kafka.clients.consumer.ConsumerRecord.class.equals(unwrapType)) {\n+                return unwrapType.cast(this.consumerRecord.getDelegate());\n+            }\n+        }\n+        try {\n+            return unwrapType.cast(this);\n+        } catch (ClassCastException e) {\n+            throw new IllegalArgumentException(\"Cannot unwrap an instance of \" + this.getClass().getName()\n+                                               + \" to \" + unwrapType.getName(), e);", "originalCommit": "5f66f823f12fd5d579df5f6e61a23b04af23d149", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwODQxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372908419", "bodyText": "Technically, the type variables don't match up here.\nYou can pass in a ProducerRecord<String, String> as the value (i.e. V = ProducerRecord<String, String>) and you'll get back a ProducerRecord<String, String> (i.e. V = String).\nIt might be clearer to make value an Object to acknowledge that there's no type safety here. It might even make sense to return ProducerRecord<?, ?> if we don't actually need to know K and V.", "author": "Azquelt", "createdAt": "2020-01-30T11:57:40Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.BetaUtils;\n+\n+public class ProducerRecordFactory {\n+\n+    private static final String CLAZZ = ProducerRecordFactory.class.getName();\n+    private static final Logger LOGGER = Logger.getLogger(CLAZZ);\n+\n+    public static <K, V> org.apache.kafka.clients.producer.ProducerRecord<K, V> newDelegateProducerRecord(String configuredTopic, String channelName, V value) {", "originalCommit": "5f66f823f12fd5d579df5f6e61a23b04af23d149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkxMDI5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372910294", "bodyText": "yeah, also a good point", "author": "tevans78", "createdAt": "2020-01-30T12:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwODQxOQ=="}], "type": "inlineReview"}, {"oid": "73e228406ffea758a7541ca0059d3e2cdc4a9c34", "url": "https://github.com/OpenLiberty/open-liberty/commit/73e228406ffea758a7541ca0059d3e2cdc4a9c34", "message": "Expose Producer and ConsumerRecord", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "f4c23bd228e1da55b9d8d86ca0050347096d7ae1", "url": "https://github.com/OpenLiberty/open-liberty/commit/f4c23bd228e1da55b9d8d86ca0050347096d7ae1", "message": "Kafka Producer Record - review updates 1", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "8fb2735635b256b54ca474f85802b2254299f528", "url": "https://github.com/OpenLiberty/open-liberty/commit/8fb2735635b256b54ca474f85802b2254299f528", "message": "Refactor KafkaReader and KafkaWriter", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "82030408bb5552e80e85dbd7c254c08a50c15674", "url": "https://github.com/OpenLiberty/open-liberty/commit/82030408bb5552e80e85dbd7c254c08a50c15674", "message": "Clarify test assertions, javadoc and tweak timeouts", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "5586b731457b538be19d15ff14388b7af2172cb0", "url": "https://github.com/OpenLiberty/open-liberty/commit/5586b731457b538be19d15ff14388b7af2172cb0", "message": "Final review updates", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "5586b731457b538be19d15ff14388b7af2172cb0", "url": "https://github.com/OpenLiberty/open-liberty/commit/5586b731457b538be19d15ff14388b7af2172cb0", "message": "Final review updates", "committedDate": "2020-01-30T17:16:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA5MTU2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r373091569", "bodyText": "if (configuredTopic == null || configuredTopic.equals(userProducerRecord.topic())) { might be clearer here", "author": "Azquelt", "createdAt": "2020-01-30T17:34:43Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java", "diffHunk": "@@ -61,4 +61,39 @@\n \n         return delegateRecord;\n     }\n+\n+    /**\n+     * Extract a suitable delegate ProducerRecord from a user provided one.\n+     * It will be a brand new ProducerRecord if the configuredTopic does not match the one in the user ProducerRecord.\n+     * If the topic is the same then this method will just return the user's ProducerRecord as-is\n+     *\n+     * @param <K> key type\n+     * @param <V> value type\n+     * @param configuredTopic The configured topic\n+     * @param userProducerRecord The user's producer record\n+     * @return\n+     */\n+    public static <K, V> org.apache.kafka.clients.producer.ProducerRecord<K, V> extractUserProducerRecord(String configuredTopic,\n+                                                                                                          org.apache.kafka.clients.producer.ProducerRecord<K, V> userProducerRecord) {\n+\n+        org.apache.kafka.clients.producer.ProducerRecord<K, V> delegateRecord;\n+\n+        String userTopic = userProducerRecord.topic();\n+\n+        //if a topic was not configured, use the one in the user provided ProducerRecord\n+        String topic = configuredTopic == null ? userTopic : configuredTopic;\n+        if (topic.contentEquals(userTopic)) {", "originalCommit": "5586b731457b538be19d15ff14388b7af2172cb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}