{"pr_number": 10968, "pr_title": "Properly handle removal of REST stat metrics when an application is unloaded", "pr_createdAt": "2020-02-19T20:56:36Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/10968", "timeline": [{"oid": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "url": "https://github.com/OpenLiberty/open-liberty/commit/033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "message": "Properly handle removal of REST stat metrics when an application is unloaded", "committedDate": "2020-02-19T20:56:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTU2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381539565", "bodyText": "This method has been modified.", "author": "Channyboy", "createdAt": "2020-02-19T20:57:02Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tsharedMetricRegistry.associateMetricIDToApplication(metricID, appName, metricRegistry);\n+\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else {\n+\t\t\t\tTr.debug(tc, \"Failed to register \" + metricName + \" because of invalid type \" + type);\n+\t\t\t}\n+\n+\t\t\t// reset\n+\t\t\tmetricRegistry = null;\n+\t\t}\n \t}\n \n \tprotected String[] getRESTMBeanStatsTags() {\n-\t\tString[] Tags = new String[3];\n+\t\tString[] mbeanProperties = new String[3];", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTY1NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381539654", "bodyText": "This method has been modified.", "author": "Channyboy", "createdAt": "2020-02-19T20:57:12Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tsharedMetricRegistry.associateMetricIDToApplication(metricID, appName, metricRegistry);\n+\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else {\n+\t\t\t\tTr.debug(tc, \"Failed to register \" + metricName + \" because of invalid type \" + type);\n+\t\t\t}\n+\n+\t\t\t// reset\n+\t\t\tmetricRegistry = null;\n+\t\t}\n \t}\n \n \tprotected String[] getRESTMBeanStatsTags() {\n-\t\tString[] Tags = new String[3];\n+\t\tString[] mbeanProperties = new String[3];\n \t\tfor (String subString : objectName.split(\",\")) {\n \t\t\tsubString = subString.trim();\n-            if (subString.contains(\"name=\")) {\n-            \tTags = subString.split(\"/\");\n-            \t//blank method\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\\\\)\", \"\");\n-            \t//otherwise first bracket becomes underscores\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\", \"_\");\n-            \t//second bracket is removed\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\)\", \"\");\n-            \tbreak;\n-            }\n+\n+\t\t\tif (subString.contains(\"name=\")) {\n+\t\t\t\tmbeanProperties = subString.split(\"/\");\n+\n+\t\t\t\tmbeanProperties[0] = mbeanProperties[0].substring(mbeanProperties[0].indexOf(\"=\") + 1,\n+\t\t\t\t\t\tmbeanProperties[0].length());\n+\n+\t\t\t\t// blank method\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\(\\\\)\", \"\");\n+\t\t\t\t// otherwise first bracket becomes underscores\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\(\", \"_\");\n+\t\t\t\t// second bracket is removed\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\)\", \"\");\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n-\t\treturn Tags;\n+\t\treturn mbeanProperties;\n \t}\n-\t\n-\t\n+\n \tprotected String getMBeanStatsString() {\n-    \tif (mbeanStatsName == null) {\n-    \t\tString serviceName = null;\n-    \t\tString serviceURL = null;\n-    \t\tString portName = null;\n-    \t\tString mbeanObjName = null;\n-    \t\tStringBuffer sb = new StringBuffer();\n-            for (String subString : objectName.split(\",\")) {\n-                subString = subString.trim();\n-                if (subString.contains(\"service=\")) {\t\n-                \tserviceName = getMBeanStatsServiceName(subString);\n-                \tserviceURL = getMBeanStatsServiceURL(subString);\n-                \tcontinue;\n-                }\n-                if (subString.contains(\"port=\")) {\n-                \tportName = getMBeanStatsPortName(subString);\n-                \tcontinue;\n-                }\n-                if (subString.contains(\"name=\")) {\n-                \tmbeanObjName = getMBeanStatsName(subString);\n-                \tbreak;\n-                }\n-            }\n-            if (serviceURL != null && serviceName != null && portName != null) {\n-            \tsb.append(serviceURL);\n-            \tsb.append(\".\");\n-            \tsb.append(serviceName);\n-            \tsb.append(\".\");\n-            \tsb.append(portName);\n-            }\n-            else if (mbeanObjName != null) {\n-            \tsb.append(mbeanObjName);\n-            }\n-            else {\n-            \tsb.append(\"unknown\");\n-            }\n-            \n-            mbeanStatsName = sb.toString();\n-    \t}\n-        return mbeanStatsName;\n+\t\tif (mbeanStatsName == null) {\n+\t\t\tString serviceName = null;\n+\t\t\tString serviceURL = null;\n+\t\t\tString portName = null;\n+\t\t\tString mbeanObjName = null;\n+\t\t\tStringBuffer sb = new StringBuffer();\n+\t\t\tfor (String subString : objectName.split(\",\")) {\n+\t\t\t\tsubString = subString.trim();\n+\t\t\t\tif (subString.contains(\"service=\")) {\n+\t\t\t\t\tserviceName = getMBeanStatsServiceName(subString);\n+\t\t\t\t\tserviceURL = getMBeanStatsServiceURL(subString);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subString.contains(\"port=\")) {\n+\t\t\t\t\tportName = getMBeanStatsPortName(subString);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subString.contains(\"name=\")) {\n+\t\t\t\t\tmbeanObjName = getMBeanStatsName(subString);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (serviceURL != null && serviceName != null && portName != null) {\n+\t\t\t\tsb.append(serviceURL);\n+\t\t\t\tsb.append(\".\");\n+\t\t\t\tsb.append(serviceName);\n+\t\t\t\tsb.append(\".\");\n+\t\t\t\tsb.append(portName);\n+\t\t\t} else if (mbeanObjName != null) {\n+\t\t\t\tsb.append(mbeanObjName);\n+\t\t\t} else {\n+\t\t\t\tsb.append(\"unknown\");\n+\t\t\t}\n+\n+\t\t\tmbeanStatsName = sb.toString();\n+\t\t}\n+\t\treturn mbeanStatsName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsName(String nameStr) {\n \t\tString mbeanName = nameStr.split(\"=\")[1];\n-\t\tmbeanName = mbeanName.replaceAll(\" \", \"_\"); \n+\t\tmbeanName = mbeanName.replaceAll(\" \", \"_\");\n \t\tmbeanName = mbeanName.replaceAll(\"/\", \"_\");\n \t\tmbeanName = mbeanName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n-    \treturn mbeanName;\n+\t\treturn mbeanName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsServiceName(String serviceStr) {\n-    \tserviceStr = serviceStr.split(\"=\")[1];\n-    \tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n-    \tString serviceName = serviceStr.substring(serviceStr.indexOf(\"}\") + 1);\n-    \treturn serviceName;\n+\t\tserviceStr = serviceStr.split(\"=\")[1];\n+\t\tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n+\t\tString serviceName = serviceStr.substring(serviceStr.indexOf(\"}\") + 1);\n+\t\treturn serviceName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsServiceURL(String serviceStr) {\n-    \tserviceStr = serviceStr.split(\"=\")[1];\n-    \tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n-    \tString serviceURL = serviceStr.substring(serviceStr.indexOf(\"{\") + 1, serviceStr.indexOf(\"}\"));\n-    \tserviceURL = serviceURL.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \".\");\n-    \treturn serviceURL;\n+\t\tserviceStr = serviceStr.split(\"=\")[1];\n+\t\tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n+\t\tString serviceURL = serviceStr.substring(serviceStr.indexOf(\"{\") + 1, serviceStr.indexOf(\"}\"));\n+\t\tserviceURL = serviceURL.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \".\");\n+\t\treturn serviceURL;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsPortName(String portStr) {\n \t\tportStr = portStr.split(\"=\")[1];\n-    \tString portName = portStr.replaceAll(\"\\\"\", \"\");\t\n-    \treturn portName;\n+\t\tString portName = portStr.replaceAll(\"\\\"\", \"\");\n+\t\treturn portName;\n \t}\n \n \tpublic void unregisterMetrics(SharedMetricRegistries sharedMetricRegistry) {\n-\t\tMetricRegistry registry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MDAxOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381540018", "bodyText": "These four lines were modified  118-120", "author": "Channyboy", "createdAt": "2020-02-19T20:57:56Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MDUyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381540524", "bodyText": "modifed/new", "author": "Channyboy", "createdAt": "2020-02-19T20:58:54Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDM2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381594363", "bodyText": "Put debug statement inside if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()){ }", "author": "fmhwong", "createdAt": "2020-02-19T22:53:38Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tsharedMetricRegistry.associateMetricIDToApplication(metricID, appName, metricRegistry);\n+\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else {\n+\t\t\t\tTr.debug(tc, \"Failed to register \" + metricName + \" because of invalid type \" + type);\n+\t\t\t}\n+\n+\t\t\t// reset\n+\t\t\tmetricRegistry = null;\n+\t\t}\n \t}\n \n \tprotected String[] getRESTMBeanStatsTags() {\n-\t\tString[] Tags = new String[3];\n+\t\tString[] mbeanProperties = new String[3];\n \t\tfor (String subString : objectName.split(\",\")) {\n \t\t\tsubString = subString.trim();\n-            if (subString.contains(\"name=\")) {\n-            \tTags = subString.split(\"/\");\n-            \t//blank method\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\\\\)\", \"\");\n-            \t//otherwise first bracket becomes underscores\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\", \"_\");\n-            \t//second bracket is removed\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\)\", \"\");\n-            \tbreak;\n-            }\n+\n+\t\t\tif (subString.contains(\"name=\")) {\n+\t\t\t\tmbeanProperties = subString.split(\"/\");\n+\n+\t\t\t\tmbeanProperties[0] = mbeanProperties[0].substring(mbeanProperties[0].indexOf(\"=\") + 1,\n+\t\t\t\t\t\tmbeanProperties[0].length());\n+\n+\t\t\t\t// blank method\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\(\\\\)\", \"\");\n+\t\t\t\t// otherwise first bracket becomes underscores\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\(\", \"_\");\n+\t\t\t\t// second bracket is removed\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\)\", \"\");\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n-\t\treturn Tags;\n+\t\treturn mbeanProperties;\n \t}\n-\t\n-\t\n+\n \tprotected String getMBeanStatsString() {\n-    \tif (mbeanStatsName == null) {\n-    \t\tString serviceName = null;\n-    \t\tString serviceURL = null;\n-    \t\tString portName = null;\n-    \t\tString mbeanObjName = null;\n-    \t\tStringBuffer sb = new StringBuffer();\n-            for (String subString : objectName.split(\",\")) {\n-                subString = subString.trim();\n-                if (subString.contains(\"service=\")) {\t\n-                \tserviceName = getMBeanStatsServiceName(subString);\n-                \tserviceURL = getMBeanStatsServiceURL(subString);\n-                \tcontinue;\n-                }\n-                if (subString.contains(\"port=\")) {\n-                \tportName = getMBeanStatsPortName(subString);\n-                \tcontinue;\n-                }\n-                if (subString.contains(\"name=\")) {\n-                \tmbeanObjName = getMBeanStatsName(subString);\n-                \tbreak;\n-                }\n-            }\n-            if (serviceURL != null && serviceName != null && portName != null) {\n-            \tsb.append(serviceURL);\n-            \tsb.append(\".\");\n-            \tsb.append(serviceName);\n-            \tsb.append(\".\");\n-            \tsb.append(portName);\n-            }\n-            else if (mbeanObjName != null) {\n-            \tsb.append(mbeanObjName);\n-            }\n-            else {\n-            \tsb.append(\"unknown\");\n-            }\n-            \n-            mbeanStatsName = sb.toString();\n-    \t}\n-        return mbeanStatsName;\n+\t\tif (mbeanStatsName == null) {\n+\t\t\tString serviceName = null;\n+\t\t\tString serviceURL = null;\n+\t\t\tString portName = null;\n+\t\t\tString mbeanObjName = null;\n+\t\t\tStringBuffer sb = new StringBuffer();\n+\t\t\tfor (String subString : objectName.split(\",\")) {\n+\t\t\t\tsubString = subString.trim();\n+\t\t\t\tif (subString.contains(\"service=\")) {\n+\t\t\t\t\tserviceName = getMBeanStatsServiceName(subString);\n+\t\t\t\t\tserviceURL = getMBeanStatsServiceURL(subString);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subString.contains(\"port=\")) {\n+\t\t\t\t\tportName = getMBeanStatsPortName(subString);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subString.contains(\"name=\")) {\n+\t\t\t\t\tmbeanObjName = getMBeanStatsName(subString);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (serviceURL != null && serviceName != null && portName != null) {\n+\t\t\t\tsb.append(serviceURL);\n+\t\t\t\tsb.append(\".\");\n+\t\t\t\tsb.append(serviceName);\n+\t\t\t\tsb.append(\".\");\n+\t\t\t\tsb.append(portName);\n+\t\t\t} else if (mbeanObjName != null) {\n+\t\t\t\tsb.append(mbeanObjName);\n+\t\t\t} else {\n+\t\t\t\tsb.append(\"unknown\");\n+\t\t\t}\n+\n+\t\t\tmbeanStatsName = sb.toString();\n+\t\t}\n+\t\treturn mbeanStatsName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsName(String nameStr) {\n \t\tString mbeanName = nameStr.split(\"=\")[1];\n-\t\tmbeanName = mbeanName.replaceAll(\" \", \"_\"); \n+\t\tmbeanName = mbeanName.replaceAll(\" \", \"_\");\n \t\tmbeanName = mbeanName.replaceAll(\"/\", \"_\");\n \t\tmbeanName = mbeanName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n-    \treturn mbeanName;\n+\t\treturn mbeanName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsServiceName(String serviceStr) {\n-    \tserviceStr = serviceStr.split(\"=\")[1];\n-    \tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n-    \tString serviceName = serviceStr.substring(serviceStr.indexOf(\"}\") + 1);\n-    \treturn serviceName;\n+\t\tserviceStr = serviceStr.split(\"=\")[1];\n+\t\tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n+\t\tString serviceName = serviceStr.substring(serviceStr.indexOf(\"}\") + 1);\n+\t\treturn serviceName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsServiceURL(String serviceStr) {\n-    \tserviceStr = serviceStr.split(\"=\")[1];\n-    \tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n-    \tString serviceURL = serviceStr.substring(serviceStr.indexOf(\"{\") + 1, serviceStr.indexOf(\"}\"));\n-    \tserviceURL = serviceURL.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \".\");\n-    \treturn serviceURL;\n+\t\tserviceStr = serviceStr.split(\"=\")[1];\n+\t\tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n+\t\tString serviceURL = serviceStr.substring(serviceStr.indexOf(\"{\") + 1, serviceStr.indexOf(\"}\"));\n+\t\tserviceURL = serviceURL.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \".\");\n+\t\treturn serviceURL;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsPortName(String portStr) {\n \t\tportStr = portStr.split(\"=\")[1];\n-    \tString portName = portStr.replaceAll(\"\\\"\", \"\");\t\n-    \treturn portName;\n+\t\tString portName = portStr.replaceAll(\"\\\"\", \"\");\n+\t\treturn portName;\n \t}\n \n \tpublic void unregisterMetrics(SharedMetricRegistries sharedMetricRegistry) {\n-\t\tMetricRegistry registry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-\t\tfor (MetricID metricID : metricIDs) {\n-\t\t\tboolean rc = registry.remove(metricID);\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\t\n+\t\tfor (MetricID metricID : vendorMetricIDs) {\n+\t\t\tboolean rc = vendorRegistry.remove(metricID);\n+\t\t\tTr.debug(tc, \"Unregistered \" + metricID.toString() + \" \" + (rc ? \"successfully\" : \"unsuccessfully\"));", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDQyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381594429", "bodyText": "Put debug statement inside if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()){ }", "author": "fmhwong", "createdAt": "2020-02-19T22:53:48Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tsharedMetricRegistry.associateMetricIDToApplication(metricID, appName, metricRegistry);\n+\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else {\n+\t\t\t\tTr.debug(tc, \"Failed to register \" + metricName + \" because of invalid type \" + type);\n+\t\t\t}\n+\n+\t\t\t// reset\n+\t\t\tmetricRegistry = null;\n+\t\t}\n \t}\n \n \tprotected String[] getRESTMBeanStatsTags() {\n-\t\tString[] Tags = new String[3];\n+\t\tString[] mbeanProperties = new String[3];\n \t\tfor (String subString : objectName.split(\",\")) {\n \t\t\tsubString = subString.trim();\n-            if (subString.contains(\"name=\")) {\n-            \tTags = subString.split(\"/\");\n-            \t//blank method\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\\\\)\", \"\");\n-            \t//otherwise first bracket becomes underscores\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\", \"_\");\n-            \t//second bracket is removed\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\)\", \"\");\n-            \tbreak;\n-            }\n+\n+\t\t\tif (subString.contains(\"name=\")) {\n+\t\t\t\tmbeanProperties = subString.split(\"/\");\n+\n+\t\t\t\tmbeanProperties[0] = mbeanProperties[0].substring(mbeanProperties[0].indexOf(\"=\") + 1,\n+\t\t\t\t\t\tmbeanProperties[0].length());\n+\n+\t\t\t\t// blank method\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\(\\\\)\", \"\");\n+\t\t\t\t// otherwise first bracket becomes underscores\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\(\", \"_\");\n+\t\t\t\t// second bracket is removed\n+\t\t\t\tmbeanProperties[2] = mbeanProperties[2].replaceAll(\"\\\\)\", \"\");\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n-\t\treturn Tags;\n+\t\treturn mbeanProperties;\n \t}\n-\t\n-\t\n+\n \tprotected String getMBeanStatsString() {\n-    \tif (mbeanStatsName == null) {\n-    \t\tString serviceName = null;\n-    \t\tString serviceURL = null;\n-    \t\tString portName = null;\n-    \t\tString mbeanObjName = null;\n-    \t\tStringBuffer sb = new StringBuffer();\n-            for (String subString : objectName.split(\",\")) {\n-                subString = subString.trim();\n-                if (subString.contains(\"service=\")) {\t\n-                \tserviceName = getMBeanStatsServiceName(subString);\n-                \tserviceURL = getMBeanStatsServiceURL(subString);\n-                \tcontinue;\n-                }\n-                if (subString.contains(\"port=\")) {\n-                \tportName = getMBeanStatsPortName(subString);\n-                \tcontinue;\n-                }\n-                if (subString.contains(\"name=\")) {\n-                \tmbeanObjName = getMBeanStatsName(subString);\n-                \tbreak;\n-                }\n-            }\n-            if (serviceURL != null && serviceName != null && portName != null) {\n-            \tsb.append(serviceURL);\n-            \tsb.append(\".\");\n-            \tsb.append(serviceName);\n-            \tsb.append(\".\");\n-            \tsb.append(portName);\n-            }\n-            else if (mbeanObjName != null) {\n-            \tsb.append(mbeanObjName);\n-            }\n-            else {\n-            \tsb.append(\"unknown\");\n-            }\n-            \n-            mbeanStatsName = sb.toString();\n-    \t}\n-        return mbeanStatsName;\n+\t\tif (mbeanStatsName == null) {\n+\t\t\tString serviceName = null;\n+\t\t\tString serviceURL = null;\n+\t\t\tString portName = null;\n+\t\t\tString mbeanObjName = null;\n+\t\t\tStringBuffer sb = new StringBuffer();\n+\t\t\tfor (String subString : objectName.split(\",\")) {\n+\t\t\t\tsubString = subString.trim();\n+\t\t\t\tif (subString.contains(\"service=\")) {\n+\t\t\t\t\tserviceName = getMBeanStatsServiceName(subString);\n+\t\t\t\t\tserviceURL = getMBeanStatsServiceURL(subString);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subString.contains(\"port=\")) {\n+\t\t\t\t\tportName = getMBeanStatsPortName(subString);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subString.contains(\"name=\")) {\n+\t\t\t\t\tmbeanObjName = getMBeanStatsName(subString);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (serviceURL != null && serviceName != null && portName != null) {\n+\t\t\t\tsb.append(serviceURL);\n+\t\t\t\tsb.append(\".\");\n+\t\t\t\tsb.append(serviceName);\n+\t\t\t\tsb.append(\".\");\n+\t\t\t\tsb.append(portName);\n+\t\t\t} else if (mbeanObjName != null) {\n+\t\t\t\tsb.append(mbeanObjName);\n+\t\t\t} else {\n+\t\t\t\tsb.append(\"unknown\");\n+\t\t\t}\n+\n+\t\t\tmbeanStatsName = sb.toString();\n+\t\t}\n+\t\treturn mbeanStatsName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsName(String nameStr) {\n \t\tString mbeanName = nameStr.split(\"=\")[1];\n-\t\tmbeanName = mbeanName.replaceAll(\" \", \"_\"); \n+\t\tmbeanName = mbeanName.replaceAll(\" \", \"_\");\n \t\tmbeanName = mbeanName.replaceAll(\"/\", \"_\");\n \t\tmbeanName = mbeanName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n-    \treturn mbeanName;\n+\t\treturn mbeanName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsServiceName(String serviceStr) {\n-    \tserviceStr = serviceStr.split(\"=\")[1];\n-    \tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n-    \tString serviceName = serviceStr.substring(serviceStr.indexOf(\"}\") + 1);\n-    \treturn serviceName;\n+\t\tserviceStr = serviceStr.split(\"=\")[1];\n+\t\tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n+\t\tString serviceName = serviceStr.substring(serviceStr.indexOf(\"}\") + 1);\n+\t\treturn serviceName;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsServiceURL(String serviceStr) {\n-    \tserviceStr = serviceStr.split(\"=\")[1];\n-    \tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n-    \tString serviceURL = serviceStr.substring(serviceStr.indexOf(\"{\") + 1, serviceStr.indexOf(\"}\"));\n-    \tserviceURL = serviceURL.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \".\");\n-    \treturn serviceURL;\n+\t\tserviceStr = serviceStr.split(\"=\")[1];\n+\t\tserviceStr = serviceStr.replaceAll(\"\\\"\", \"\");\n+\t\tString serviceURL = serviceStr.substring(serviceStr.indexOf(\"{\") + 1, serviceStr.indexOf(\"}\"));\n+\t\tserviceURL = serviceURL.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \".\");\n+\t\treturn serviceURL;\n \t}\n-\t\n+\n \tprivate String getMBeanStatsPortName(String portStr) {\n \t\tportStr = portStr.split(\"=\")[1];\n-    \tString portName = portStr.replaceAll(\"\\\"\", \"\");\t\n-    \treturn portName;\n+\t\tString portName = portStr.replaceAll(\"\\\"\", \"\");\n+\t\treturn portName;\n \t}\n \n \tpublic void unregisterMetrics(SharedMetricRegistries sharedMetricRegistry) {\n-\t\tMetricRegistry registry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-\t\tfor (MetricID metricID : metricIDs) {\n-\t\t\tboolean rc = registry.remove(metricID);\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\t\n+\t\tfor (MetricID metricID : vendorMetricIDs) {\n+\t\t\tboolean rc = vendorRegistry.remove(metricID);\n+\t\t\tTr.debug(tc, \"Unregistered \" + metricID.toString() + \" \" + (rc ? \"successfully\" : \"unsuccessfully\"));\n+\t\t}\n+\t\t\n+\t\tfor (MetricID metricID : baseMetricIDs) {\n+\t\t\tboolean rc = baseRegistry.remove(metricID);\n \t\t\tTr.debug(tc, \"Unregistered \" + metricID.toString() + \" \" + (rc ? \"successfully\" : \"unsuccessfully\"));", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDYyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381594625", "bodyText": "Put debug statement inside if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()){ }", "author": "fmhwong", "createdAt": "2020-02-19T22:54:20Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDcxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381594716", "bodyText": "Put debug statement inside if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()){ }", "author": "fmhwong", "createdAt": "2020-02-19T22:54:33Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDg1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381594855", "bodyText": "Put debug statement inside if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()){ }", "author": "fmhwong", "createdAt": "2020-02-19T22:54:58Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tsharedMetricRegistry.associateMetricIDToApplication(metricID, appName, metricRegistry);\n+\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDg5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381594898", "bodyText": "Put debug statement inside if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()){ }", "author": "fmhwong", "createdAt": "2020-02-19T22:55:04Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tsharedMetricRegistry.associateMetricIDToApplication(metricID, appName, metricRegistry);\n+\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else {\n+\t\t\t\tTr.debug(tc, \"Failed to register \" + metricName + \" because of invalid type \" + type);", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "82e3d564baf9d4a72b7a3d0813d592fe9256b082", "url": "https://github.com/OpenLiberty/open-liberty/commit/82e3d564baf9d4a72b7a3d0813d592fe9256b082", "message": "If statements around debug statements", "committedDate": "2020-02-19T22:58:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NjQ0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381596448", "bodyText": "Not sure the format is.  Is it safe to assume you will always have 3 elements?", "author": "fmhwong", "createdAt": "2020-02-19T22:59:04Z", "path": "dev/com.ibm.ws.microprofile.metrics.2.3.monitor/src/com/ibm/ws/microprofile/metrics/monitor/MonitorMetrics.java", "diffHunk": "@@ -29,187 +29,213 @@\n public class MonitorMetrics {\n \n \tprivate static final TraceComponent tc = Tr.register(MonitorMetrics.class);\n-\t\n+\n \tprotected String objectName;\n \tprotected String mbeanStatsName;\n \tprotected MBeanServer mbs;\n-\tprotected Set<MetricID> metricIDs;\n+\tprotected Set<MetricID> vendorMetricIDs;\n+\tprotected Set<MetricID> baseMetricIDs;\n \n \tpublic MonitorMetrics(String objectName) {\n \t\tthis.mbs = ManagementFactory.getPlatformMBeanServer();\n \t\tthis.objectName = objectName;\n-\t\tthis.metricIDs = new HashSet<MetricID>();\n-\t\t\n+\t\tthis.vendorMetricIDs = new HashSet<MetricID>();\n+\t\tthis.baseMetricIDs = new HashSet<MetricID>();\n \t}\n \n \tpublic void createMetrics(SharedMetricRegistries sharedMetricRegistry, String[][] data) {\n-\t\t\n-        MetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n-        MetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n-        MetricRegistry metricRegistry = null;\n-        \n-        for (String[] metricData : data) {\n-        \t\n-            String metricName = metricData[MappingTable.METRIC_NAME];\n-            String metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n-            \n-            Tag metricTag = null;\n-            if (metricTagName != null) {\n-            \tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n-            }\n-            MetricID metricID = new MetricID(metricName, metricTag);\n-            MetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n-            \n-            /*\n-             * New for the REST metrics (which are registered under base)\n-             * Will there be future optional base metrics?\n-             */\n-            metricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\") ) ? vendorRegistry : baseRegistry;\n-            \n-            if (MetricType.COUNTER.equals(type)) {\n-                MonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ? \n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-                        new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-                \n-                        metricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(), \n-        \t\t\tmc, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} else if (MetricType.GAUGE.equals(type)) {\n-            \tMonitorGauge<Number> mg =  metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null ?\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE]) :\n-            \t\tnew MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n-            \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmg, metricTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-        \t} \n-        \t// Only REST_Stats is using SIMPLETIMER at the moment\n-            else if (MetricType.SIMPLE_TIMER.equals(type)) {\n-\t        \t\t\n-        \t\t/*\n-        \t\t * Since only REST Stats is the only one using SIMPLETIMER\n-        \t\t * we're leveraging the sub-attribute at the moment as the second attribute to retreive\n-        \t\t */\n-        \t\t\n-        \t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_ATTRIBUTE], metricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n-        \t\tString[] objName_rest = getRESTMBeanStatsTags();\n-        \t\t\n-        \t\tTag classTag = new Tag(\"class\" , objName_rest[1]);\n-        \t\tTag methodTag= new Tag(\"method\" , objName_rest[2]);\n-        \t\t\n-        \t\tmetricRegistry.register(\n-        \t\t\t\tMetadata.builder().withName(metricName).withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME]).withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type).withUnit(metricData[MappingTable.METRIC_UNIT]).build(),\n-        \t\t\tmst, classTag, methodTag);\n-        \t\tmetricIDs.add(metricID);\n-        \t\tTr.debug(tc, \"Registered \" + metricID.toString());\n-            } else {\n-            \tTr.debug(tc, \"Falied to register \" + metricName + \" because of invalid type \" + type);\n-            }\n-            \n-            //reset\n-            metricRegistry = null;\n-        }\t\t\n+\n+\t\tMetricRegistry vendorRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.VENDOR.getName());\n+\t\tMetricRegistry baseRegistry = sharedMetricRegistry.getOrCreate(MetricRegistry.Type.BASE.getName());\n+\t\tMetricRegistry metricRegistry = null;\n+\t\tSet<MetricID> metricIDSet = null;\n+\n+\t\tfor (String[] metricData : data) {\n+\n+\t\t\tString metricName = metricData[MappingTable.METRIC_NAME];\n+\t\t\tString metricTagName = metricData[MappingTable.MBEAN_STATS_NAME];\n+\n+\t\t\tTag metricTag = null;\n+\t\t\tif (metricTagName != null) {\n+\t\t\t\tmetricTag = new Tag(metricTagName, getMBeanStatsString());\n+\t\t\t}\n+\t\t\tMetricID metricID = new MetricID(metricName, metricTag);\n+\t\t\tMetricType type = MetricType.valueOf(metricData[MappingTable.METRIC_TYPE]);\n+\n+\t\t\t/*\n+\t\t\t * New for the REST metrics (which are registered under base) Will there be\n+\t\t\t * future optional base metrics?\n+\t\t\t */\n+\t\t\tmetricRegistry = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorRegistry\n+\t\t\t\t\t: baseRegistry;\n+\t\t\tmetricIDSet = (metricData[MappingTable.METRIC_REGISTRY_TYPE].equalsIgnoreCase(\"vendor\")) ? vendorMetricIDs\n+\t\t\t\t\t: baseMetricIDs;\n+\n+\t\t\tif (MetricType.COUNTER.equals(type)) {\n+\t\t\t\tMonitorCounter mc = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorCounter(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mc, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else if (MetricType.GAUGE.equals(type)) {\n+\t\t\t\tMonitorGauge<Number> mg = metricData[MappingTable.MBEAN_SUBATTRIBUTE] == null\n+\t\t\t\t\t\t? new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE])\n+\t\t\t\t\t\t: new MonitorGauge<Number>(mbs, objectName, metricData[MappingTable.MBEAN_ATTRIBUTE],\n+\t\t\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SUBATTRIBUTE]);\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mg, metricTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t}\n+\t\t\t// Only REST_Stats is using SIMPLETIMER at the moment\n+\t\t\telse if (MetricType.SIMPLE_TIMER.equals(type)) {\n+\n+\t\t\t\tMonitorSimpleTimer mst = new MonitorSimpleTimer(mbs, objectName,\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_ATTRIBUTE], metricData[MappingTable.MBEAN_SUBATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_ATTRIBUTE],\n+\t\t\t\t\t\tmetricData[MappingTable.MBEAN_SECOND_SUBATTRIBUTE]);\n+\t\t\t\tString[] objName_rest = getRESTMBeanStatsTags();\n+\n+\t\t\t\t// Only REST STAT metric is using SIMPLE TIMER.. explicitly creating the tags\n+\t\t\t\t// necessary.\n+\t\t\t\tString appName = objName_rest[0];\n+\t\t\t\tTag classTag = new Tag(\"class\", objName_rest[1]);\n+\t\t\t\tTag methodTag = new Tag(\"method\", objName_rest[2]);\n+\n+\t\t\t\tmetricRegistry.register(Metadata.builder().withName(metricName)\n+\t\t\t\t\t\t.withDisplayName(metricData[MappingTable.METRIC_DISPLAYNAME])\n+\t\t\t\t\t\t.withDescription(metricData[MappingTable.METRIC_DESCRIPTION]).withType(type)\n+\t\t\t\t\t\t.withUnit(metricData[MappingTable.METRIC_UNIT]).build(), mst, classTag, methodTag);\n+\n+\t\t\t\tmetricID = new MetricID(metricName, classTag, methodTag);\n+\t\t\t\tmetricIDSet.add(metricID);\n+\t\t\t\tsharedMetricRegistry.associateMetricIDToApplication(metricID, appName, metricRegistry);\n+\n+\t\t\t\tTr.debug(tc, \"Registered \" + metricID.toString());\n+\t\t\t} else {\n+\t\t\t\tTr.debug(tc, \"Failed to register \" + metricName + \" because of invalid type \" + type);\n+\t\t\t}\n+\n+\t\t\t// reset\n+\t\t\tmetricRegistry = null;\n+\t\t}\n \t}\n \n \tprotected String[] getRESTMBeanStatsTags() {\n-\t\tString[] Tags = new String[3];\n+\t\tString[] mbeanProperties = new String[3];\n \t\tfor (String subString : objectName.split(\",\")) {\n \t\t\tsubString = subString.trim();\n-            if (subString.contains(\"name=\")) {\n-            \tTags = subString.split(\"/\");\n-            \t//blank method\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\\\\)\", \"\");\n-            \t//otherwise first bracket becomes underscores\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\(\", \"_\");\n-            \t//second bracket is removed\n-            \tTags[2] = Tags[2].replaceAll(\"\\\\)\", \"\");\n-            \tbreak;\n-            }\n+\n+\t\t\tif (subString.contains(\"name=\")) {\n+\t\t\t\tmbeanProperties = subString.split(\"/\");", "originalCommit": "033141e7ed9f3cbb14dd9d994bc6de1805c00e09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5ODkxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10968#discussion_r381598912", "bodyText": "Yes, it's expected to be:\nname=ApplicationName/fully.qualified.class.name/methodSignature(java.lang.String)\nThis is the Mbean property constructed from the JAXRS filter.\nHave made a commit with a comment, and renamed the the variable.", "author": "Channyboy", "createdAt": "2020-02-19T23:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NjQ0OA=="}], "type": "inlineReview"}, {"oid": "a3863d5d5b7fda0aa42574b17ab6d999d5bfb046", "url": "https://github.com/OpenLiberty/open-liberty/commit/a3863d5d5b7fda0aa42574b17ab6d999d5bfb046", "message": "Clarify Mbean property usage in Monitor Metrics regarding REST Stat mbean", "committedDate": "2020-02-19T23:04:00Z", "type": "commit"}]}