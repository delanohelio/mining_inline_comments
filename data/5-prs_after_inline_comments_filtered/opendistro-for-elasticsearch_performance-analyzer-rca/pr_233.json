{"pr_number": 233, "pr_title": "Add queue rejection RCA and UT", "pr_createdAt": "2020-06-12T00:50:54Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233", "timeline": [{"oid": "b21b3db256f711364d413fdb79a7afdfd4bbb45d", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/b21b3db256f711364d413fdb79a7afdfd4bbb45d", "message": "Add queue rejection RCA and UT", "committedDate": "2020-06-12T00:36:34Z", "type": "commit"}, {"oid": "bd48936ded36a2d960bc9212ac5592cb49f81cb0", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/bd48936ded36a2d960bc9212ac5592cb49f81cb0", "message": "Fix a bug in protobuf", "committedDate": "2020-06-12T00:49:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIxNTc2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233#discussion_r439215765", "bodyText": "IIUC, we consider the threadpool contended if we repeatedly see rejections for the last rejectionTimePeriodThreshold duration.\n\nWe can add a doc string to make this clear (can modify the comment in RCA)\nDo you think we should make it less aggressive - rather than demanding that each data point be a rejection, we say threadpool is contended if 80% data points in the window have rejections?", "author": "vigyasharma", "createdAt": "2020-06-12T05:35:20Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/threadpool/QueueRejectionRca.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.threadpool;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolDimension.THREAD_POOL_TYPE;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ThreadPoolEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.persist.SQLParsingUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * This RCA reads ThreadPool_RejectionReqs from upstream metrics and it keeps track of\n+ * the amount of the time period(tp) when requests in the queues are continuously being rejected.\n+ * This RCA is marked as unhealthy if tp we find in write/search queue is above the threshold.\n+ */\n+public class QueueRejectionRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+  private static final Logger LOG = LogManager.getLogger(QueueRejectionRca.class);\n+  private static final long REJECTION_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+  private final int rcaPeriod;\n+  private final List<QueueRejectionCollector> queueRejectionCollectors;\n+  private int counter;\n+  protected Clock clock;\n+\n+  public <M extends Metric> QueueRejectionRca(final int rcaPeriod, M threadPool_RejectedReqs) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    counter = 0;\n+    clock = Clock.systemUTC();\n+    queueRejectionCollectors = Collections.unmodifiableList(Arrays.asList(\n+        new QueueRejectionCollector(ThreadPoolEnum.WRITE_QUEUE, ThreadPoolType.WRITE,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND),\n+        new QueueRejectionCollector(ThreadPoolEnum.SEARCH_QUEUE, ThreadPoolType.SEARCH,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND)\n+    ));\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @Override\n+  public ResourceFlowUnit<HotNodeSummary> operate() {\n+    counter += 1;\n+    long currTimestamp = clock.millis();\n+    if (counter == rcaPeriod) {\n+      counter = 0;\n+      ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor\n+          .getCurrentNodeDetails();\n+      HotNodeSummary nodeSummary = null;\n+      for (QueueRejectionCollector collector : queueRejectionCollectors) {\n+        collector.collect(currTimestamp);\n+        // if we've see thread pool rejection in the last 5 mins, the thread pool is considered as contended\n+        if (collector.isUnhealthy(currTimestamp)) {\n+          if (nodeSummary == null) {\n+            nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+          }\n+          nodeSummary.addNestedSummaryList(collector.generateSummary(currTimestamp));\n+        }\n+      }\n+      ResourceContext context;\n+      if (nodeSummary == null) {\n+        context = new ResourceContext(Resources.State.HEALTHY);\n+      }\n+      else {\n+        context = new ResourceContext(Resources.State.UNHEALTHY);\n+      }\n+      boolean isDataNode = !currentNode.getIsMasterNode();\n+      return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, isDataNode);\n+    }\n+    else {\n+      return new ResourceFlowUnit<>(currTimestamp);\n+    }\n+  }\n+\n+  //TODO: move this method back into the Rca base class\n+  @Override\n+  public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+    final List<FlowUnitMessage> flowUnitMessages =\n+        args.getWireHopper().readFromWire(args.getNode());\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+    LOG.debug(\"rca: Executing fromWire: {}\", this.getClass().getSimpleName());\n+    for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+      flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+    }\n+    setFlowUnits(flowUnitList);\n+  }\n+\n+  /**\n+   * A collector class to collect rejection from each queue type\n+   */\n+  private static class QueueRejectionCollector {\n+    private final ResourceType threadPool;\n+    private final ThreadPoolType threadPoolMetric;\n+    private final Metric threadPool_RejectedReqs;\n+    private boolean hasRejection;\n+    private long rejectionTimestamp;\n+    private long rejectionTimePeriodThreshold;\n+\n+    public QueueRejectionCollector(final ThreadPoolEnum threadPool, final ThreadPoolType threadPoolMetric,\n+        final Metric threadPool_RejectedReqs, final long threshold) {\n+      this.threadPool = ResourceType.newBuilder().setThreadPool(threadPool).build();\n+      this.threadPoolMetric = threadPoolMetric;\n+      this.threadPool_RejectedReqs = threadPool_RejectedReqs;\n+      this.hasRejection = false;\n+      this.rejectionTimestamp = 0;\n+      this.rejectionTimePeriodThreshold = threshold;\n+    }\n+\n+    public void collect(final long currTimestamp) {\n+      for (MetricFlowUnit flowUnit : threadPool_RejectedReqs.getFlowUnits()) {\n+        if (flowUnit.isEmpty()) {\n+          continue;\n+        }\n+        double rejectCnt = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n+            THREAD_POOL_TYPE.getField(), threadPoolMetric.toString(), MetricsDB.MAX);\n+        if (!Double.isNaN(rejectCnt)) {\n+          if (rejectCnt > 0) {\n+            if (!hasRejection) {\n+              rejectionTimestamp = currTimestamp;\n+            }\n+            hasRejection = true;\n+          }\n+          else {\n+            hasRejection = false;\n+          }\n+        }\n+        else {\n+          LOG.error(\"Failed to parse metric from threadpool {}\", threadPool.toString());\n+        }\n+      }\n+    }\n+\n+    public boolean isUnhealthy(final long currTimestamp) {\n+      return hasRejection && (currTimestamp - rejectionTimestamp) >= rejectionTimePeriodThreshold;", "originalCommit": "bd48936ded36a2d960bc9212ac5592cb49f81cb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTI4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233#discussion_r439681280", "bodyText": "Let me add a doc for this RCA. And as per our discussion, we will go with this approach without sliding window to keep this RCA light weighted.", "author": "rguo-aws", "createdAt": "2020-06-12T23:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIxNTc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjExOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233#discussion_r439682118", "bodyText": "Just a doc string for the RCA would suffice. Thanks", "author": "vigyasharma", "createdAt": "2020-06-12T23:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIxNTc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzOTA5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233#discussion_r440339092", "bodyText": "done", "author": "rguo-aws", "createdAt": "2020-06-15T17:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIxNTc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIxNjE4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233#discussion_r439216183", "bodyText": "So this effectively resets the hasRejection status if any data point does not have rejections. Threadpool is contended only if it rejects for all data points, right?", "author": "vigyasharma", "createdAt": "2020-06-12T05:37:01Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/threadpool/QueueRejectionRca.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.threadpool;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolDimension.THREAD_POOL_TYPE;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ThreadPoolEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.persist.SQLParsingUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * This RCA reads ThreadPool_RejectionReqs from upstream metrics and it keeps track of\n+ * the amount of the time period(tp) when requests in the queues are continuously being rejected.\n+ * This RCA is marked as unhealthy if tp we find in write/search queue is above the threshold.\n+ */\n+public class QueueRejectionRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+  private static final Logger LOG = LogManager.getLogger(QueueRejectionRca.class);\n+  private static final long REJECTION_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+  private final int rcaPeriod;\n+  private final List<QueueRejectionCollector> queueRejectionCollectors;\n+  private int counter;\n+  protected Clock clock;\n+\n+  public <M extends Metric> QueueRejectionRca(final int rcaPeriod, M threadPool_RejectedReqs) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    counter = 0;\n+    clock = Clock.systemUTC();\n+    queueRejectionCollectors = Collections.unmodifiableList(Arrays.asList(\n+        new QueueRejectionCollector(ThreadPoolEnum.WRITE_QUEUE, ThreadPoolType.WRITE,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND),\n+        new QueueRejectionCollector(ThreadPoolEnum.SEARCH_QUEUE, ThreadPoolType.SEARCH,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND)\n+    ));\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @Override\n+  public ResourceFlowUnit<HotNodeSummary> operate() {\n+    counter += 1;\n+    long currTimestamp = clock.millis();\n+    if (counter == rcaPeriod) {\n+      counter = 0;\n+      ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor\n+          .getCurrentNodeDetails();\n+      HotNodeSummary nodeSummary = null;\n+      for (QueueRejectionCollector collector : queueRejectionCollectors) {\n+        collector.collect(currTimestamp);\n+        // if we've see thread pool rejection in the last 5 mins, the thread pool is considered as contended\n+        if (collector.isUnhealthy(currTimestamp)) {\n+          if (nodeSummary == null) {\n+            nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+          }\n+          nodeSummary.addNestedSummaryList(collector.generateSummary(currTimestamp));\n+        }\n+      }\n+      ResourceContext context;\n+      if (nodeSummary == null) {\n+        context = new ResourceContext(Resources.State.HEALTHY);\n+      }\n+      else {\n+        context = new ResourceContext(Resources.State.UNHEALTHY);\n+      }\n+      boolean isDataNode = !currentNode.getIsMasterNode();\n+      return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, isDataNode);\n+    }\n+    else {\n+      return new ResourceFlowUnit<>(currTimestamp);\n+    }\n+  }\n+\n+  //TODO: move this method back into the Rca base class\n+  @Override\n+  public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+    final List<FlowUnitMessage> flowUnitMessages =\n+        args.getWireHopper().readFromWire(args.getNode());\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+    LOG.debug(\"rca: Executing fromWire: {}\", this.getClass().getSimpleName());\n+    for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+      flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+    }\n+    setFlowUnits(flowUnitList);\n+  }\n+\n+  /**\n+   * A collector class to collect rejection from each queue type\n+   */\n+  private static class QueueRejectionCollector {\n+    private final ResourceType threadPool;\n+    private final ThreadPoolType threadPoolMetric;\n+    private final Metric threadPool_RejectedReqs;\n+    private boolean hasRejection;\n+    private long rejectionTimestamp;\n+    private long rejectionTimePeriodThreshold;\n+\n+    public QueueRejectionCollector(final ThreadPoolEnum threadPool, final ThreadPoolType threadPoolMetric,\n+        final Metric threadPool_RejectedReqs, final long threshold) {\n+      this.threadPool = ResourceType.newBuilder().setThreadPool(threadPool).build();\n+      this.threadPoolMetric = threadPoolMetric;\n+      this.threadPool_RejectedReqs = threadPool_RejectedReqs;\n+      this.hasRejection = false;\n+      this.rejectionTimestamp = 0;\n+      this.rejectionTimePeriodThreshold = threshold;\n+    }\n+\n+    public void collect(final long currTimestamp) {\n+      for (MetricFlowUnit flowUnit : threadPool_RejectedReqs.getFlowUnits()) {\n+        if (flowUnit.isEmpty()) {\n+          continue;\n+        }\n+        double rejectCnt = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n+            THREAD_POOL_TYPE.getField(), threadPoolMetric.toString(), MetricsDB.MAX);\n+        if (!Double.isNaN(rejectCnt)) {\n+          if (rejectCnt > 0) {\n+            if (!hasRejection) {\n+              rejectionTimestamp = currTimestamp;\n+            }\n+            hasRejection = true;\n+          }\n+          else {\n+            hasRejection = false;\n+          }", "originalCommit": "bd48936ded36a2d960bc9212ac5592cb49f81cb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cb46a9dc064683617e2d1e2ecfcfae04f9e1b7f6", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/cb46a9dc064683617e2d1e2ecfcfae04f9e1b7f6", "message": "Address PR comments", "committedDate": "2020-06-12T20:51:59Z", "type": "commit"}, {"oid": "3aa228bbb0f50f8cf207d208ce9753c7a0f80b24", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/3aa228bbb0f50f8cf207d208ce9753c7a0f80b24", "message": "Merge remote-tracking branch 'origin' into rguo-queue", "committedDate": "2020-06-15T17:14:56Z", "type": "commit"}, {"oid": "7cb1034da3c0ccc5b413c3e00794d807748bf528", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/7cb1034da3c0ccc5b413c3e00794d807748bf528", "message": "Address PR comments", "committedDate": "2020-06-15T17:39:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NDgzMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233#discussion_r482594832", "bodyText": "In a dedicated master cluster, if something is not master, it maybe a standby master or a datatnode. If we are interested in data nodes only, then we should check for getRole() == NodeRole.DATA.", "author": "yojs", "createdAt": "2020-09-02T23:22:48Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/threadpool/QueueRejectionRca.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.threadpool;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolDimension.THREAD_POOL_TYPE;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ThreadPoolEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.persist.SQLParsingUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * This RCA reads ThreadPool_RejectionReqs from upstream metrics and maintain collectors for each\n+ * thread pool queue type(currently we only support write/search queue). Each collector keeps track of\n+ * the time window period(tp) where we repeatedly see rejections for the last tp duration.\n+ * This RCA is marked as unhealthy if tp we find tp is above the threshold(300 seconds).\n+ */\n+public class QueueRejectionRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+  private static final Logger LOG = LogManager.getLogger(QueueRejectionRca.class);\n+  private static final long REJECTION_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+  private final int rcaPeriod;\n+  private final List<QueueRejectionCollector> queueRejectionCollectors;\n+  private int counter;\n+  protected Clock clock;\n+\n+  public <M extends Metric> QueueRejectionRca(final int rcaPeriod, M threadPool_RejectedReqs) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    counter = 0;\n+    clock = Clock.systemUTC();\n+    queueRejectionCollectors = Collections.unmodifiableList(Arrays.asList(\n+        new QueueRejectionCollector(ThreadPoolEnum.WRITE_QUEUE, ThreadPoolType.WRITE,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND),\n+        new QueueRejectionCollector(ThreadPoolEnum.SEARCH_QUEUE, ThreadPoolType.SEARCH,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND)\n+    ));\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @Override\n+  public ResourceFlowUnit<HotNodeSummary> operate() {\n+    counter += 1;\n+    long currTimestamp = clock.millis();\n+    // collect rejection metrics\n+    for (QueueRejectionCollector collector : queueRejectionCollectors) {\n+      collector.collect(currTimestamp);\n+    }\n+    if (counter == rcaPeriod) {\n+      counter = 0;\n+      ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor\n+          .getCurrentNodeDetails();\n+      HotNodeSummary nodeSummary = null;\n+      for (QueueRejectionCollector collector : queueRejectionCollectors) {\n+        // if we've see thread pool rejection in the last 5 mins, the thread pool is considered as contended\n+        if (collector.isUnhealthy(currTimestamp)) {\n+          if (nodeSummary == null) {\n+            nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+          }\n+          nodeSummary.appendNestedSummary(collector.generateSummary(currTimestamp));\n+        }\n+      }\n+      ResourceContext context;\n+      if (nodeSummary == null) {\n+        context = new ResourceContext(Resources.State.HEALTHY);\n+      }\n+      else {\n+        context = new ResourceContext(Resources.State.UNHEALTHY);\n+      }\n+      boolean isDataNode = !currentNode.getIsMasterNode();", "originalCommit": "7cb1034da3c0ccc5b413c3e00794d807748bf528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMDI4MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/233#discussion_r482600281", "bodyText": "If we fail to parse metrics from the threadpool, should we be safe and reset hasrejection ? Or else, in case, if the rejection was reported and then all subsequent values are Nan for the rest of the 5 minutes, we will still change the queue size.", "author": "yojs", "createdAt": "2020-09-02T23:35:54Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/threadpool/QueueRejectionRca.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.threadpool;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolDimension.THREAD_POOL_TYPE;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ThreadPoolEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.ThreadPoolType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.persist.SQLParsingUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * This RCA reads ThreadPool_RejectionReqs from upstream metrics and maintain collectors for each\n+ * thread pool queue type(currently we only support write/search queue). Each collector keeps track of\n+ * the time window period(tp) where we repeatedly see rejections for the last tp duration.\n+ * This RCA is marked as unhealthy if tp we find tp is above the threshold(300 seconds).\n+ */\n+public class QueueRejectionRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+  private static final Logger LOG = LogManager.getLogger(QueueRejectionRca.class);\n+  private static final long REJECTION_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+  private final int rcaPeriod;\n+  private final List<QueueRejectionCollector> queueRejectionCollectors;\n+  private int counter;\n+  protected Clock clock;\n+\n+  public <M extends Metric> QueueRejectionRca(final int rcaPeriod, M threadPool_RejectedReqs) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    counter = 0;\n+    clock = Clock.systemUTC();\n+    queueRejectionCollectors = Collections.unmodifiableList(Arrays.asList(\n+        new QueueRejectionCollector(ThreadPoolEnum.WRITE_QUEUE, ThreadPoolType.WRITE,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND),\n+        new QueueRejectionCollector(ThreadPoolEnum.SEARCH_QUEUE, ThreadPoolType.SEARCH,\n+            threadPool_RejectedReqs, REJECTION_TIME_PERIOD_IN_MILLISECOND)\n+    ));\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @Override\n+  public ResourceFlowUnit<HotNodeSummary> operate() {\n+    counter += 1;\n+    long currTimestamp = clock.millis();\n+    // collect rejection metrics\n+    for (QueueRejectionCollector collector : queueRejectionCollectors) {\n+      collector.collect(currTimestamp);\n+    }\n+    if (counter == rcaPeriod) {\n+      counter = 0;\n+      ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor\n+          .getCurrentNodeDetails();\n+      HotNodeSummary nodeSummary = null;\n+      for (QueueRejectionCollector collector : queueRejectionCollectors) {\n+        // if we've see thread pool rejection in the last 5 mins, the thread pool is considered as contended\n+        if (collector.isUnhealthy(currTimestamp)) {\n+          if (nodeSummary == null) {\n+            nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+          }\n+          nodeSummary.appendNestedSummary(collector.generateSummary(currTimestamp));\n+        }\n+      }\n+      ResourceContext context;\n+      if (nodeSummary == null) {\n+        context = new ResourceContext(Resources.State.HEALTHY);\n+      }\n+      else {\n+        context = new ResourceContext(Resources.State.UNHEALTHY);\n+      }\n+      boolean isDataNode = !currentNode.getIsMasterNode();\n+      return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, isDataNode);\n+    }\n+    else {\n+      return new ResourceFlowUnit<>(currTimestamp);\n+    }\n+  }\n+\n+  // TODO: move this method back into the Rca base class\n+  @Override\n+  public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+    final List<FlowUnitMessage> flowUnitMessages =\n+        args.getWireHopper().readFromWire(args.getNode());\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+    LOG.debug(\"rca: Executing fromWire: {}\", this.getClass().getSimpleName());\n+    for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+      flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+    }\n+    setFlowUnits(flowUnitList);\n+  }\n+\n+  /**\n+   * A collector class to collect rejection from each queue type\n+   */\n+  private static class QueueRejectionCollector {\n+    private final ResourceType threadPool;\n+    private final ThreadPoolType threadPoolMetric;\n+    private final Metric threadPool_RejectedReqs;\n+    private boolean hasRejection;\n+    private long rejectionTimestamp;\n+    private long rejectionTimePeriodThreshold;\n+\n+    public QueueRejectionCollector(final ThreadPoolEnum threadPool, final ThreadPoolType threadPoolMetric,\n+        final Metric threadPool_RejectedReqs, final long threshold) {\n+      this.threadPool = ResourceType.newBuilder().setThreadPool(threadPool).build();\n+      this.threadPoolMetric = threadPoolMetric;\n+      this.threadPool_RejectedReqs = threadPool_RejectedReqs;\n+      this.hasRejection = false;\n+      this.rejectionTimestamp = 0;\n+      this.rejectionTimePeriodThreshold = threshold;\n+    }\n+\n+    public void collect(final long currTimestamp) {\n+      for (MetricFlowUnit flowUnit : threadPool_RejectedReqs.getFlowUnits()) {\n+        if (flowUnit.isEmpty()) {\n+          continue;\n+        }\n+        double rejectCnt = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n+            THREAD_POOL_TYPE.getField(), threadPoolMetric.toString(), MetricsDB.MAX);\n+        if (!Double.isNaN(rejectCnt)) {\n+          if (rejectCnt > 0) {\n+            if (!hasRejection) {\n+              rejectionTimestamp = currTimestamp;\n+            }\n+            hasRejection = true;\n+          }\n+          else {\n+            hasRejection = false;\n+          }\n+        }\n+        else {\n+          LOG.error(\"Failed to parse metric from threadpool {}\", threadPool.toString());", "originalCommit": "7cb1034da3c0ccc5b413c3e00794d807748bf528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}