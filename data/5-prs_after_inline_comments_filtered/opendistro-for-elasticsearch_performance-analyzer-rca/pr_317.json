{"pr_number": 317, "pr_title": "Add upperbound for cache decider, Consume from NodeConfigurationRca and tune only one resource at a time", "pr_createdAt": "2020-07-29T02:17:50Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317", "timeline": [{"oid": "dbfacd6abe93a8dda76658ecf66f623fdf91256c", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/dbfacd6abe93a8dda76658ecf66f623fdf91256c", "message": "Add upperbound for cache decider", "committedDate": "2020-07-29T02:10:01Z", "type": "commit"}, {"oid": "5f57a3d1a4f4e0a2bf52ab4d4835e888424c52c2", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5f57a3d1a4f4e0a2bf52ab4d4835e888424c52c2", "message": "Resolve merge conflict", "committedDate": "2020-07-29T16:39:00Z", "type": "commit"}, {"oid": "9785e45b9bfbc23d57f090e421e0200015ac1f66", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9785e45b9bfbc23d57f090e421e0200015ac1f66", "message": "Consume upperbound from rcaConf", "committedDate": "2020-07-29T17:54:52Z", "type": "commit"}, {"oid": "983ca1e8a6a10630bdd259ab6ac684d355ea9444", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/983ca1e8a6a10630bdd259ab6ac684d355ea9444", "message": "Fix cache health decider unit test", "committedDate": "2020-07-29T18:20:23Z", "type": "commit"}, {"oid": "56db08b6095c8b38d9a525cb6361e039df802590", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/56db08b6095c8b38d9a525cb6361e039df802590", "message": "Modify cache decider to tune only one resource at a time", "committedDate": "2020-07-29T21:55:20Z", "type": "commit"}, {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/989e99f151cbe5578daa0acad29a77c04337e11e", "message": "Format issues", "committedDate": "2020-07-29T22:00:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzQxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462627411", "bodyText": "should we also have lower bound for each cache ?", "author": "rguo-aws", "createdAt": "2020-07-29T22:30:56Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {\n+    private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n     public static final String NAME = \"modifyCacheCapacity\";\n     public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n \n-    private long currentCapacityInBytes;\n-    private long desiredCapacityInBytes;\n+    private long currentCacheMaxSizeInBytes;\n+    private long desiredCacheMaxSizeInBytes;\n+    private long heapMaxSizeInBytes;\n+\n+    private double fieldDataCacheSizeUpperBound;\n+    private double shardRequestCacheSizeUpperBound;\n+\n     private ResourceEnum cacheType;\n     private NodeKey esNode;\n \n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n-    public ModifyCacheCapacityAction(\n+    public ModifyCacheMaxSizeAction(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentCacheMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n+            final double fieldDataCacheSizeUpperBound,\n+            final double shardRequestCacheSizeUpperBound,\n             final boolean increase) {\n-        // TODO: Also consume NodeConfigurationRca\n+        this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDE1OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462650159", "bodyText": "I will address them in subsequent PR.", "author": "sruti1312", "createdAt": "2020-07-29T23:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NjM4NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462656385", "bodyText": "You can move the lower bound addition to a TODO", "author": "khushbr", "createdAt": "2020-07-29T23:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1MjY4NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463152685", "bodyText": "Added a TODO", "author": "sruti1312", "createdAt": "2020-07-30T17:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzgwNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462627806", "bodyText": "can we also handle cache scaling down here ?", "author": "rguo-aws", "createdAt": "2020-07-29T22:31:47Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {\n+    private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n     public static final String NAME = \"modifyCacheCapacity\";\n     public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n \n-    private long currentCapacityInBytes;\n-    private long desiredCapacityInBytes;\n+    private long currentCacheMaxSizeInBytes;\n+    private long desiredCacheMaxSizeInBytes;\n+    private long heapMaxSizeInBytes;\n+\n+    private double fieldDataCacheSizeUpperBound;\n+    private double shardRequestCacheSizeUpperBound;\n+\n     private ResourceEnum cacheType;\n     private NodeKey esNode;\n \n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n-    public ModifyCacheCapacityAction(\n+    public ModifyCacheMaxSizeAction(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentCacheMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n+            final double fieldDataCacheSizeUpperBound,\n+            final double shardRequestCacheSizeUpperBound,\n             final boolean increase) {\n-        // TODO: Also consume NodeConfigurationRca\n+        this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;\n+        this.shardRequestCacheSizeUpperBound = shardRequestCacheSizeUpperBound;\n+        this.heapMaxSizeInBytes = heapMaxSizeInBytes;\n+\n         setBounds();\n         setStepSize();\n \n         this.esNode = esNode;\n         this.cacheType = cacheType;\n-        this.currentCapacityInBytes = currentCapacityInBytes;\n+        this.currentCacheMaxSizeInBytes = currentCacheMaxSizeInBytes;\n         long desiredCapacity =\n-                increase ? currentCapacityInBytes + getStepSize(cacheType) : currentCapacityInBytes;\n-        setDesiredCapacity(desiredCapacity);\n+                increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDA5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462650095", "bodyText": "Presently, cache decider only uses increasing the cache max size action.\nI do agree that we need scaling down option as well. I will address them in subsequent PR.", "author": "sruti1312", "createdAt": "2020-07-29T23:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NjY1Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462656657", "bodyText": "Same comment, add a TODO and address that when the JVMDecider is available.", "author": "khushbr", "createdAt": "2020-07-30T00:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1MzM3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463153376", "bodyText": "Added a TODO", "author": "sruti1312", "createdAt": "2020-07-30T17:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyOTI5OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462629298", "bodyText": "indent space is off. please make sure that you are using the google java code formatter in IDEA", "author": "rguo-aws", "createdAt": "2020-07-29T22:35:40Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,41 +16,52 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n+    private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n     public static final String NAME = \"cacheHealthDecider\";", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzOTQ3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462639475", "bodyText": "I do have google java code formatter plugin enabled. Maybe I might have missed the reformat. I will reformat and add the changes", "author": "sruti1312", "createdAt": "2020-07-29T23:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyOTI5OA=="}], "type": "inlineReview"}, {"oid": "73e3e402b4b1fff7a4acf3f727fe77affa28c619", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/73e3e402b4b1fff7a4acf3f727fe77affa28c619", "message": "Format cache decider", "committedDate": "2020-07-29T23:42:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTIwMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462655200", "bodyText": "Thank you for renaming this Action to ModifyCacheMaxSizeAction. Let's add some javadoc here around the purpose of this Action class.", "author": "khushbr", "createdAt": "2020-07-29T23:55:47Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE0OTAzNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463149034", "bodyText": "Added", "author": "sruti1312", "createdAt": "2020-07-30T17:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2Mjc4NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462662784", "bodyText": "Two things we also need to account before increasing/decreasing the cache size :\n\nField Data Cache Circuit Breaker -  The default value for field data circuit breaker is configured at 40% of the maximum JVM heap and is managed via static setting indices.breaker.fielddata.limit. If the circuit-breaker limit is lower than the cache size, no data will ever be evicted. In order for it to work properly, the circuit breaker limit must be higher than the cache size and we should assert for it when increasing the cache size.\nExplicit Cache size set by end user. - In case customer sets the explicit static value for cache size, how do we account for them in our actions ?", "author": "khushbr", "createdAt": "2020-07-30T00:22:23Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -76,9 +91,9 @@ public long coolOffPeriodInMillis() {\n     @Override\n     public Map<NodeKey, ImpactVector> impact() {\n         final ImpactVector impactVector = new ImpactVector();\n-        if (desiredCapacityInBytes > currentCapacityInBytes) {\n+        if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIwOTc5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463209795", "bodyText": "Issue to track this:\n#320", "author": "sruti1312", "createdAt": "2020-07-30T19:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2Mjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MzM5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462663391", "bodyText": "do we need any assertion for the heapMaxSizeInBytes value ? Maybe non-null, non-zero ?", "author": "khushbr", "createdAt": "2020-07-30T00:24:39Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -109,12 +124,11 @@ private void setBounds() {\n         // This is intentionally not made static because different nodes can\n         // have different bounds based on instance types\n \n-        // TODO: Read the upperBound from NodeConfigurationRca.\n         // Field data cache used when sorting on or computing aggregation on the field (in Bytes)\n-        upperBoundInBytes.put(ResourceEnum.FIELD_DATA_CACHE, 12000 * 1_000_000L);\n+        upperBoundInBytes.put(ResourceEnum.FIELD_DATA_CACHE, (long) (heapMaxSizeInBytes * fieldDataCacheSizeUpperBound));", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIxMzE3Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463213177", "bodyText": "Decider checks for non-null, I will add a check for non-zero in the decider.", "author": "sruti1312", "createdAt": "2020-07-30T19:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MzM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2OTA0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462669043", "bodyText": "Let's restrict this only to IlegalArgumentException .", "author": "khushbr", "createdAt": "2020-07-30T00:44:38Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -130,32 +149,80 @@ private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheT\n     private Action getAction(final String actionName,\n                              final NodeKey esNode,\n                              final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n+                             final Long currentMaxSizeInBytes,\n+                             final Long heapMaxSizeInBytes,\n                              final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n+        if (currentMaxSizeInBytes == null || heapMaxSizeInBytes == null) {\n+            return null;\n+        }\n+        if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+            return configureCacheMaxSize(esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n         }\n         return null;\n     }\n \n-    private ModifyCacheCapacityAction configureCacheCapacity(\n+    private ModifyCacheMaxSizeAction configureCacheMaxSize(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n             final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n+        final ModifyCacheMaxSizeAction action =\n+                new ModifyCacheMaxSizeAction(\n+                        esNode,\n+                        cacheType,\n+                        currentMaxSizeInBytes,\n+                        heapMaxSizeInBytes,\n+                        getFieldDataCacheUpperBound(),\n+                        getShardRequestCacheUpperBound(),\n+                        increase);\n         if (action.isActionable()) {\n             return action;\n         }\n         return null;\n     }\n \n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n+    private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n+        try {\n+            if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+                return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+            }\n+            return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+        } catch (final Exception e) {", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1MTE0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463151143", "bodyText": "Modified", "author": "sruti1312", "createdAt": "2020-07-30T17:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2OTA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2OTM5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462669395", "bodyText": "Same comment as above.", "author": "khushbr", "createdAt": "2020-07-30T00:45:54Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -130,32 +149,80 @@ private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheT\n     private Action getAction(final String actionName,\n                              final NodeKey esNode,\n                              final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n+                             final Long currentMaxSizeInBytes,\n+                             final Long heapMaxSizeInBytes,\n                              final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n+        if (currentMaxSizeInBytes == null || heapMaxSizeInBytes == null) {\n+            return null;\n+        }\n+        if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+            return configureCacheMaxSize(esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n         }\n         return null;\n     }\n \n-    private ModifyCacheCapacityAction configureCacheCapacity(\n+    private ModifyCacheMaxSizeAction configureCacheMaxSize(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n             final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n+        final ModifyCacheMaxSizeAction action =\n+                new ModifyCacheMaxSizeAction(\n+                        esNode,\n+                        cacheType,\n+                        currentMaxSizeInBytes,\n+                        heapMaxSizeInBytes,\n+                        getFieldDataCacheUpperBound(),\n+                        getShardRequestCacheUpperBound(),\n+                        increase);\n         if (action.isActionable()) {\n             return action;\n         }\n         return null;\n     }\n \n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n+    private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n+        try {\n+            if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+                return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+            }\n+            return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+        } catch (final Exception e) {\n+            LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n         }\n-        return 1000L;\n+        // No action if value not present in the cache.\n+        // No action will be triggered as this value was wiped out from the cache\n+        return null;\n+  }\n+\n+  private Long getHeapMaxSizeInBytes(final NodeKey esNode) {\n+      try {\n+          return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.HEAP_MAX_SIZE);\n+      } catch (final Exception e) {", "originalCommit": "989e99f151cbe5578daa0acad29a77c04337e11e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1MTIyOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463151229", "bodyText": "Modified", "author": "sruti1312", "createdAt": "2020-07-30T17:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2OTM5NQ=="}], "type": "inlineReview"}, {"oid": "6378a7448cdd15a882e635e16039e35515e38602", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/6378a7448cdd15a882e635e16039e35515e38602", "message": "Address PR comments", "committedDate": "2020-07-30T19:23:53Z", "type": "commit"}, {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5f1c5bf589ec092998867596092c947339fb7bc3", "message": "Add priorities for cache decider", "committedDate": "2020-07-30T20:00:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzQ5Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463323493", "bodyText": "This needs to be removed now, we've removed it from the interface.", "author": "vigyasharma", "createdAt": "2020-07-30T23:20:08Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  private ResourceEnum cacheType;\n+  private NodeKey esNode;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+  private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentCacheMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final double fieldDataCacheSizeUpperBound,\n+      final double shardRequestCacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;\n+    this.shardRequestCacheSizeUpperBound = shardRequestCacheSizeUpperBound;\n+    this.heapMaxSizeInBytes = heapMaxSizeInBytes;\n+\n+    setBounds();\n+    setStepSize();\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.currentCacheMaxSizeInBytes = currentCacheMaxSizeInBytes;\n+    // TODO: Address cache scaling down  when JVM decider is available\n+    long desiredCapacity =\n+        increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NTQzNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463345434", "bodyText": "Removed it.", "author": "sruti1312", "createdAt": "2020-07-31T00:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NTYwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463345609", "bodyText": "Removed it. Performed a merge from master and resolved the conflicts", "author": "sruti1312", "createdAt": "2020-07-31T00:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzkxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463323911", "bodyText": "Let us also provide a public setter for step size for different caches. Deciders may want to change step size to something more aggressive based on RCAs (like downsize aggressively when heap is extremely low)", "author": "vigyasharma", "createdAt": "2020-07-30T23:21:39Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  private ResourceEnum cacheType;\n+  private NodeKey esNode;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+  private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentCacheMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final double fieldDataCacheSizeUpperBound,\n+      final double shardRequestCacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;\n+    this.shardRequestCacheSizeUpperBound = shardRequestCacheSizeUpperBound;\n+    this.heapMaxSizeInBytes = heapMaxSizeInBytes;\n+\n+    setBounds();\n+    setStepSize();\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.currentCacheMaxSizeInBytes = currentCacheMaxSizeInBytes;\n+    // TODO: Address cache scaling down  when JVM decider is available\n+    long desiredCapacity =\n+        increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public void execute() {\n+    // Making this a no-op for now\n+    // TODO: Modify based on downstream CoS agent API calls\n+    assert true;\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  private void setBounds() {\n+    // This is intentionally not made static because different nodes can\n+    // have different bounds based on instance types\n+\n+    // Field data cache used when sorting on or computing aggregation on the field (in Bytes)\n+    upperBoundInBytes.put(\n+        ResourceEnum.FIELD_DATA_CACHE, (long) (heapMaxSizeInBytes * fieldDataCacheSizeUpperBound));\n+\n+    // Shard request cache (in Bytes)\n+    upperBoundInBytes.put(\n+        ResourceEnum.SHARD_REQUEST_CACHE,\n+        (long) (heapMaxSizeInBytes * shardRequestCacheSizeUpperBound));\n+  }\n+\n+  private void setStepSize() {", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMDg3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463820879", "bodyText": "Added a public setter for step size", "author": "sruti1312", "createdAt": "2020-07-31T20:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNzU5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463327591", "bodyText": "nit: i always find this code styling too vertical to read. is this enforced by our styling guide?", "author": "vigyasharma", "createdAt": "2020-07-30T23:34:39Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);\n     }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> void getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Decision decision,\n+      final List<InstanceDetails.Id> impactedNodes) {\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode =\n+              new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action =\n+                computeBestAction(esNode, resource.getResource().getResourceEnum());\n+            if (action != null) {\n+              decision.addAction(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n+          }\n         }\n+      }\n     }\n-\n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    Action action = null;\n+    action =\n+        getAction(", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NTkyMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463345922", "bodyText": "It was automatically refactored by the google java code style plugin. I will check if I can fix this", "author": "sruti1312", "createdAt": "2020-07-31T00:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNzU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyODg1OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463328858", "bodyText": "Can we reduce these params needed to create a cache action?\n\nAn action can only be for a particular type of cache, right? So it shouldn't need the upper bounds of all caches to initialize.\nWould be even better if these configs (upper bounds/heap size etc) can be read within this action itself, instead of passing from outside. IMHO, we want to keep the upper bound and lower bound fixed, and only vary cache size from deciders within these bounds.", "author": "vigyasharma", "createdAt": "2020-07-30T23:38:42Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  private ResourceEnum cacheType;\n+  private NodeKey esNode;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+  private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentCacheMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final double fieldDataCacheSizeUpperBound,\n+      final double shardRequestCacheSizeUpperBound,", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMTE1Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463821152", "bodyText": "Passing in the node config cache as discussed offline", "author": "sruti1312", "createdAt": "2020-07-31T20:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyODg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyOTI1MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463329250", "bodyText": "should we move this into the action instead of decider?", "author": "vigyasharma", "createdAt": "2020-07-30T23:39:55Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);\n     }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> void getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Decision decision,\n+      final List<InstanceDetails.Id> impactedNodes) {\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode =\n+              new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action =\n+                computeBestAction(esNode, resource.getResource().getResourceEnum());\n+            if (action != null) {\n+              decision.addAction(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n+          }\n         }\n+      }\n     }\n-\n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    Action action = null;\n+    action =\n+        getAction(\n+            ModifyCacheMaxSizeAction.NAME,\n+            esNode,\n+            cacheType,\n+            getNodeCacheMaxSizeInBytes(esNode, cacheType),\n+            getHeapMaxSizeInBytes(esNode),\n+            true);\n+    return action;\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final Long currentMaxSizeInBytes,\n+      final Long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    if (currentMaxSizeInBytes == null\n+        || currentMaxSizeInBytes == 0\n+        || heapMaxSizeInBytes == null\n+        || heapMaxSizeInBytes == 0) {\n+      return null;\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n-            if (action != null) {\n-                break;\n-            }\n-        }\n-        return action;\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    final ModifyCacheMaxSizeAction action =\n+        new ModifyCacheMaxSizeAction(\n+            esNode,\n+            cacheType,\n+            currentMaxSizeInBytes,\n+            heapMaxSizeInBytes,\n+            getFieldDataCacheUpperBound(),\n+            getShardRequestCacheUpperBound(),\n+            increase);\n+    if (action.isActionable()) {\n+      return action;\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMTIzMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463821230", "bodyText": "Moved", "author": "sruti1312", "createdAt": "2020-07-31T20:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyOTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyOTc3MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463329771", "bodyText": "Minor: how about we create a util class to read these common node configs?", "author": "vigyasharma", "createdAt": "2020-07-30T23:41:32Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);\n     }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> void getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Decision decision,\n+      final List<InstanceDetails.Id> impactedNodes) {\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode =\n+              new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action =\n+                computeBestAction(esNode, resource.getResource().getResourceEnum());\n+            if (action != null) {\n+              decision.addAction(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n+          }\n         }\n+      }\n     }\n-\n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    Action action = null;\n+    action =\n+        getAction(\n+            ModifyCacheMaxSizeAction.NAME,\n+            esNode,\n+            cacheType,\n+            getNodeCacheMaxSizeInBytes(esNode, cacheType),\n+            getHeapMaxSizeInBytes(esNode),\n+            true);\n+    return action;\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final Long currentMaxSizeInBytes,\n+      final Long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    if (currentMaxSizeInBytes == null\n+        || currentMaxSizeInBytes == 0\n+        || heapMaxSizeInBytes == null\n+        || heapMaxSizeInBytes == 0) {\n+      return null;\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n-            if (action != null) {\n-                break;\n-            }\n-        }\n-        return action;\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    final ModifyCacheMaxSizeAction action =\n+        new ModifyCacheMaxSizeAction(\n+            esNode,\n+            cacheType,\n+            currentMaxSizeInBytes,\n+            heapMaxSizeInBytes,\n+            getFieldDataCacheUpperBound(),\n+            getShardRequestCacheUpperBound(),\n+            increase);\n+    if (action.isActionable()) {\n+      return action;\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n+    try {\n+      if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+        return (long)\n+            getAppContext()\n+                .getNodeConfigCache()\n+                .get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+      }\n+      return (long)\n+          getAppContext()\n+              .getNodeConfigCache()\n+              .get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n     }\n-\n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n-        }\n-        return 1000L;\n+    // No action if value not present in the cache.\n+    // No action will be triggered as this value was wiped out from the cache\n+    return null;\n+  }\n+\n+  private Long getHeapMaxSizeInBytes(final NodeKey esNode) {", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMDc0OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463820748", "bodyText": "Created a util for reading config from node collector", "author": "sruti1312", "createdAt": "2020-07-31T20:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyOTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDI3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463330273", "bodyText": "why are we tracking impactedNodes here? how is this used?", "author": "vigyasharma", "createdAt": "2020-07-30T23:43:20Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTkwOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463331908", "bodyText": "Was this to ensure we only publish 1 action per node from this decider? I dont see it being used that way, am I missing something? Also, if that is the use case, would it make more sense to use a set instead of a list?", "author": "vigyasharma", "createdAt": "2020-07-30T23:48:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjMzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463346335", "bodyText": "Yes, it is used to ensure that we publish only 1 action per node. Modified to Set.", "author": "sruti1312", "createdAt": "2020-07-31T00:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTEwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463331109", "bodyText": "Instead of passing decision object reference and modifying it in the method, can we return an action and add it to the decision? It's more java oriented and readable", "author": "vigyasharma", "createdAt": "2020-07-30T23:46:09Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0OTQ4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463349482", "bodyText": "Right. Modified.", "author": "sruti1312", "createdAt": "2020-07-31T00:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzODYxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463338611", "bodyText": "Do you want to consider old gen heap size or total heap size for your configurations? I think jvm has some issues  with honoring the young-old split, we should just use total heap size.", "author": "vigyasharma", "createdAt": "2020-07-31T00:12:45Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/framework/api/summaries/ResourceUtil.java", "diffHunk": "@@ -31,8 +31,10 @@\n  * such as TOTAL_THROUGHPUT and SYS_CALL_RATE\n  */\n public class ResourceUtil {\n-\n   // JVM resource\n+  public static final Resource HEAP_MAX_SIZE = Resource.newBuilder()", "originalCommit": "5f1c5bf589ec092998867596092c947339fb7bc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMTM2MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463821360", "bodyText": "Created a new ResourceEnum called heap.", "author": "sruti1312", "createdAt": "2020-07-31T20:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzODYxMQ=="}], "type": "inlineReview"}, {"oid": "04c2d3f6904109e4a4cd36440c18b6f33a83af84", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/04c2d3f6904109e4a4cd36440c18b6f33a83af84", "message": "Merge from master", "committedDate": "2020-07-31T00:37:26Z", "type": "commit"}, {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/3cdc28dd04693904533fc0a32f21df19a2336b8c", "message": "Address PR comments", "committedDate": "2020-07-31T20:29:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODg0NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463878844", "bodyText": "let's follow the same naming convention that Queue action uses ?", "author": "rguo-aws", "createdAt": "2020-07-31T22:56:03Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTY2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463889666", "bodyText": "I think there was a naming change required on the queue decider side to use camelCase", "author": "sruti1312", "createdAt": "2020-07-31T23:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODk4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463878983", "bodyText": "remove empty line ?", "author": "rguo-aws", "createdAt": "2020-07-31T22:56:32Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTUzNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463889537", "bodyText": "Done", "author": "sruti1312", "createdAt": "2020-07-31T23:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3OTg3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463879875", "bodyText": "1_000_000L does not equal to 1024*1024", "author": "rguo-aws", "createdAt": "2020-07-31T23:00:45Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);\n+    Long heapMaxSize = NodeConfigReaderUtil.getHeapMaxSizeInBytes(nodeConfigCache, esNode);\n+\n+    if (cacheMaxSize == null || cacheMaxSize == 0 || heapMaxSize == null || heapMaxSize == 0) {\n+      return false;\n+    } else {\n+      currentCacheMaxSizeInBytes = cacheMaxSize;\n+      heapMaxSizeInBytes = heapMaxSize;\n+      return true;\n+    }\n+  }\n+\n+  private void setBounds() {\n+    // This is intentionally not made static because different nodes can\n+    // have different bounds based on instance types\n+    cacheUpperBoundInBytes = (long) (heapMaxSizeInBytes * cacheSizeUpperBound);\n+  }\n+\n+  private void setStepSize() {\n+    // TODO: Update the step size to also include percentage of heap size along with absolute value\n+    // Field data cache having step size of 512MB\n+    stepSizeInBytes.put(ResourceEnum.FIELD_DATA_CACHE, 512 * 1_000_000L);", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTM2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463889367", "bodyText": "Right, fixed this", "author": "sruti1312", "createdAt": "2020-07-31T23:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3OTg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MDMzNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463880337", "bodyText": "should we decouple this reading from cache operation from the Action class and let decider to read and pass them in as inputs args? Any thought ?", "author": "rguo-aws", "createdAt": "2020-07-31T23:03:01Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTgxNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463889814", "bodyText": "Had an offline discussion with vigya, this option was chosen as\nPassing the node config cache reduces params.\nHowever decider cannot overrode the bounds then. Which we anyway don\u2019t want it to.", "author": "sruti1312", "createdAt": "2020-07-31T23:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MDMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MTYzNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463891637", "bodyText": "@rguo-aws That was the previous version of this PR. I suggested this model so as to enforce the upper and lower bounds defined in configs and not let deciders override these bounds. Do you think deciders should reserve the right to override upper/lower bounds? It kind of fails the purpose of defining them in configs.\nIf not, then deciders reading and passing these configs is only adding extra params to the constructor and also leaving us vulnerable to someone ignoring config values in future.\nInstead, I think we should accept stepSize as a param (or settable via a getter), to allow deciders to aggresively downsize in extreme situations.", "author": "vigyasharma", "createdAt": "2020-08-01T00:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MDMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMzM2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463903365", "bodyText": "Actually there is confusion with naming. We dont want to pass upper/lower bounds from deciders. It may be okay to pass currentCapacity if needed (similar to queues). However, since configs come from rca.conf which is read in Node objects, deciders have access to them.\nWe should create separate ActionConfig objects for these action configs. decider configs should hold decider related settings like enable/disable deciders or deciderPeriod. These action configs can then be passed to each action while initializing it. Also we can split the cache action into separate actions since their RCAs are already separate. (It's ok to do this in a separate PR).", "author": "vigyasharma", "createdAt": "2020-08-01T01:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MDMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MTY4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463881683", "bodyText": "same as above", "author": "rguo-aws", "createdAt": "2020-07-31T23:09:35Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4ODA3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463888073", "bodyText": "does that mean that cache decider will always pick shard request cache to scale up?", "author": "rguo-aws", "createdAt": "2020-07-31T23:40:43Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<ResourceEnum, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<ResourceEnum> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<ResourceEnum, BaseClusterRca>builder()\n+            .put(ResourceEnum.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(ResourceEnum.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    Set<InstanceDetails.Id> impactedNodes = new HashSet<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+    for (final ResourceEnum cacheType : modifyCacheActionPriorityList) {", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTEzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463889135", "bodyText": "Yes, presently always shard request cache is given higher priority in modify decider.\nBased on performance testing, we can change this.", "author": "sruti1312", "createdAt": "2020-07-31T23:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4ODA3Mw=="}], "type": "inlineReview"}, {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "message": "Address PR comments", "committedDate": "2020-07-31T23:51:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MTkxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463891911", "bodyText": "Should we enforce this with a check inside the action itself? I was thinking deciders should be careful to not set it to 0. Can we have cases later where disabling the cache entirely makes sense? We may need to set it to 0 then.", "author": "vigyasharma", "createdAt": "2020-08-01T00:02:56Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5MDU0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463990549", "bodyText": "Removed this check.", "author": "sruti1312", "createdAt": "2020-08-01T19:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MjA3MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463892070", "bodyText": "an action instance has just one cacheType right? then we dont need cacheType in this param.", "author": "vigyasharma", "createdAt": "2020-08-01T00:03:58Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {", "originalCommit": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5MDU1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463990556", "bodyText": "Right. Modified", "author": "sruti1312", "createdAt": "2020-08-01T19:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MjA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mjc4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463892782", "bodyText": "Instead of this, for clarity, we can explicitly make isActionable return false if we cannot read nodeConfigCache, i.e. currentCacheMaxSizeInBytes is set to null.", "author": "vigyasharma", "createdAt": "2020-08-01T00:08:13Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;", "originalCommit": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MzQ0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463893445", "bodyText": "I also dont understand how this if-else helps. If validateAndSetNodeConfigValues returns false, then currentCacheMaxSizeInBytes is uninitialized.", "author": "vigyasharma", "createdAt": "2020-08-01T00:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mjc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5MTg5NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463991894", "bodyText": "Modified isActionable method and added a check for currentCacheMaxSize. This simplifies the if-else loop.\nIf validateAndSet is true, we set the desiredCapacity.", "author": "sruti1312", "createdAt": "2020-08-01T19:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mjc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mzc4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463893786", "bodyText": "setBounds and validateAndSetNodeConfigValues can be merged into a single function", "author": "vigyasharma", "createdAt": "2020-08-01T00:13:41Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);\n+    Long heapMaxSize = NodeConfigReaderUtil.getHeapMaxSizeInBytes(nodeConfigCache, esNode);\n+\n+    if (cacheMaxSize == null || cacheMaxSize == 0 || heapMaxSize == null || heapMaxSize == 0) {\n+      return false;\n+    } else {\n+      currentCacheMaxSizeInBytes = cacheMaxSize;\n+      heapMaxSizeInBytes = heapMaxSize;\n+      return true;\n+    }\n+  }\n+\n+  private void setBounds() {", "originalCommit": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4OTE2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463989161", "bodyText": "Done", "author": "sruti1312", "createdAt": "2020-08-01T18:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mzc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mzk0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463893945", "bodyText": "will this throw an NPE is validateAndSetNodeConfigValues fails and currentCacheMaxSizeInBytes is null", "author": "vigyasharma", "createdAt": "2020-08-01T00:14:45Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);", "originalCommit": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5MTkyNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463991925", "bodyText": "Removed this", "author": "sruti1312", "createdAt": "2020-08-01T19:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mzk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NjkxMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463896910", "bodyText": "Are these reversed?!", "author": "vigyasharma", "createdAt": "2020-08-01T00:34:10Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<ResourceEnum, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<ResourceEnum> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<ResourceEnum, BaseClusterRca>builder()\n+            .put(ResourceEnum.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(ResourceEnum.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    Set<InstanceDetails.Id> impactedNodes = new HashSet<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+    for (final ResourceEnum cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), impactedNodes)\n+          .forEach(decision::addAction);\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> List<Action> getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Set<InstanceDetails.Id> impactedNodes) {\n+    List<Action> actions = new ArrayList<>();\n+\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return actions;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode = new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action = computeBestAction(esNode, resource.getResource().getResourceEnum());\n             if (action != null) {\n-                break;\n+              actions.add(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n+          }\n         }\n-        return action;\n+      }\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return actions;\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    return getAction(ModifyCacheMaxSizeAction.NAME, esNode, cacheType, true);\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, increase);\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    final double cacheUpperBound = getCacheUpperBound(cacheType);\n+    if (cacheUpperBound != -1) {\n+      final ModifyCacheMaxSizeAction action =\n+          new ModifyCacheMaxSizeAction(\n+              esNode,\n+              cacheType,\n+              getAppContext().getNodeConfigCache(),\n+              cacheUpperBound,\n+              increase);\n+      if (action.isActionable()) {\n+        return action;\n+      }\n     }\n-\n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n-        }\n-        return 1000L;\n+    return null;\n+  }\n+\n+  private double getCacheUpperBound(final ResourceEnum cacheType) {\n+    if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+      return getFieldDataCacheUpperBound();\n+    } else if (cacheType.equals(ResourceEnum.SHARD_REQUEST_CACHE)) {\n+      return getShardRequestCacheUpperBound();\n     }\n+    return -1;\n+  }\n+\n+  private double getShardRequestCacheUpperBound() {\n+    return fieldDataCacheSizeUpperBound;\n+  }\n+\n+  private double getFieldDataCacheUpperBound() {\n+    return shardRequestCacheSizeUpperBound;\n+  }", "originalCommit": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4OTI1Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463989253", "bodyText": "Yes. Modified", "author": "sruti1312", "createdAt": "2020-08-01T18:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NjkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMzk1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463903955", "bodyText": "When will we hit this? We should throw exceptions instead of overloading return values. How about an IllegalArgumentException ?", "author": "vigyasharma", "createdAt": "2020-08-01T01:32:11Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<ResourceEnum, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<ResourceEnum> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<ResourceEnum, BaseClusterRca>builder()\n+            .put(ResourceEnum.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(ResourceEnum.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    Set<InstanceDetails.Id> impactedNodes = new HashSet<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+    for (final ResourceEnum cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), impactedNodes)\n+          .forEach(decision::addAction);\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> List<Action> getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Set<InstanceDetails.Id> impactedNodes) {\n+    List<Action> actions = new ArrayList<>();\n+\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return actions;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode = new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action = computeBestAction(esNode, resource.getResource().getResourceEnum());\n             if (action != null) {\n-                break;\n+              actions.add(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n+          }\n         }\n-        return action;\n+      }\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return actions;\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    return getAction(ModifyCacheMaxSizeAction.NAME, esNode, cacheType, true);\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, increase);\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    final double cacheUpperBound = getCacheUpperBound(cacheType);\n+    if (cacheUpperBound != -1) {\n+      final ModifyCacheMaxSizeAction action =\n+          new ModifyCacheMaxSizeAction(\n+              esNode,\n+              cacheType,\n+              getAppContext().getNodeConfigCache(),\n+              cacheUpperBound,\n+              increase);\n+      if (action.isActionable()) {\n+        return action;\n+      }\n     }\n-\n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n-        }\n-        return 1000L;\n+    return null;\n+  }\n+\n+  private double getCacheUpperBound(final ResourceEnum cacheType) {\n+    if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+      return getFieldDataCacheUpperBound();\n+    } else if (cacheType.equals(ResourceEnum.SHARD_REQUEST_CACHE)) {\n+      return getShardRequestCacheUpperBound();\n     }\n+    return -1;", "originalCommit": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5MDM2NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463990364", "bodyText": "Throwing IllegalArgumentException", "author": "sruti1312", "createdAt": "2020-08-01T19:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMzk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNDE0NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463904144", "bodyText": "These comments are out of context here as the util class has no relation to actions. lets remove them", "author": "vigyasharma", "createdAt": "2020-08-01T01:33:39Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/util/NodeConfigReaderUtil.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+public class NodeConfigReaderUtil {\n+  private static final Logger LOG = LogManager.getLogger(NodeConfigReaderUtil.class);\n+\n+  public static Long getCacheMaxSizeInBytes(\n+      final NodeConfigCache nodeConfigCache, final NodeKey esNode, final ResourceEnum cacheType) {\n+    try {\n+      if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+        return (long) nodeConfigCache.get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+      }\n+      return (long) nodeConfigCache.get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n+    }\n+    // No action if value not present in the cache.\n+    // No action will be triggered as this value was wiped out from the cache", "originalCommit": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4OTMzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463989335", "bodyText": "Removed them", "author": "sruti1312", "createdAt": "2020-08-01T18:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNDE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNDE1Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463904152", "bodyText": "same as above", "author": "vigyasharma", "createdAt": "2020-08-01T01:33:45Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/util/NodeConfigReaderUtil.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+public class NodeConfigReaderUtil {\n+  private static final Logger LOG = LogManager.getLogger(NodeConfigReaderUtil.class);\n+\n+  public static Long getCacheMaxSizeInBytes(\n+      final NodeConfigCache nodeConfigCache, final NodeKey esNode, final ResourceEnum cacheType) {\n+    try {\n+      if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+        return (long) nodeConfigCache.get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+      }\n+      return (long) nodeConfigCache.get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n+    }\n+    // No action if value not present in the cache.\n+    // No action will be triggered as this value was wiped out from the cache\n+    return null;\n+  }\n+\n+  public static Long getHeapMaxSizeInBytes(final NodeConfigCache nodeConfigCache, final NodeKey esNode) {\n+    try {\n+      return (long) nodeConfigCache.get(esNode, ResourceUtil.HEAP_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading heap max size from Node Config Cache\", e);\n+    }\n+    // No action if value not present in the cache.", "originalCommit": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4OTMyNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463989327", "bodyText": "Removed them", "author": "sruti1312", "createdAt": "2020-08-01T18:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNDE1Mg=="}], "type": "inlineReview"}, {"oid": "1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72", "message": "Address PR comments", "committedDate": "2020-08-01T19:37:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwODk3OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r464008978", "bodyText": "Rename param to stepSizeInBytes to make callers aware of expected units.", "author": "vigyasharma", "createdAt": "2020-08-01T23:05:02Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+\n+// TODO: Split the cache action into separate actions for different caches.\n+\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeKey esNode;\n+  private final ResourceEnum cacheType;\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+\n+  private Long currentCacheMaxSizeInBytes;\n+  private Long heapMaxSizeInBytes;\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    if (validateAndSetConfigValues()) {\n+      long desiredCapacity =\n+              increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+      setDesiredCacheMaxSize(desiredCapacity);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    if (currentCacheMaxSizeInBytes == null) {\n+      return false;\n+    }\n+    return desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (currentCacheMaxSizeInBytes != null) {\n+      if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+        impactVector.increasesPressure(HEAP);\n+      } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+        impactVector.decreasesPressure(HEAP);\n+      }\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final long stepSize) {", "originalCommit": "1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxMTAyNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r464011025", "bodyText": "Done", "author": "sruti1312", "createdAt": "2020-08-01T23:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwODk3OA=="}], "type": "inlineReview"}, {"oid": "7a69dedf75bc374631e11d17ac0d7daaae05f8f1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/7a69dedf75bc374631e11d17ac0d7daaae05f8f1", "message": "Fixed changes to protobuf", "committedDate": "2020-08-01T23:33:16Z", "type": "commit"}, {"oid": "d3578eb2dc42bad31ce4669d78b9825c8357da1c", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d3578eb2dc42bad31ce4669d78b9825c8357da1c", "message": "Address PR comments", "committedDate": "2020-08-01T23:38:45Z", "type": "commit"}]}