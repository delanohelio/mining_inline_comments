{"pr_number": 332, "pr_title": "Polarize actions based on impact vectors", "pr_createdAt": "2020-08-03T18:33:11Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332", "timeline": [{"oid": "8ff25668212726e0d0934f59d634e3e3a9ab1e3f", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/8ff25668212726e0d0934f59d634e3e3a9ab1e3f", "message": "Polarize actions based on impact vectors", "committedDate": "2020-08-03T18:31:40Z", "type": "commit"}, {"oid": "5e5840319e6e19cfdd3b456e38819fabffe8fe97", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5e5840319e6e19cfdd3b456e38819fabffe8fe97", "message": "Merge from master", "committedDate": "2020-08-03T21:11:21Z", "type": "commit"}, {"oid": "7649d14d7c0deef355a1047be5e2fc8c046c853e", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/7649d14d7c0deef355a1047be5e2fc8c046c853e", "message": "Merge from master", "committedDate": "2020-08-06T03:25:21Z", "type": "commit"}, {"oid": "95f958d74e974c41a53258d88eb5e6f28d84079b", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/95f958d74e974c41a53258d88eb5e6f28d84079b", "message": "Fix import order", "committedDate": "2020-08-06T03:27:01Z", "type": "commit"}, {"oid": "490d7f219fcb59da0cc677e241a14c529d756ec4", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/490d7f219fcb59da0cc677e241a14c529d756ec4", "message": "Use InstanceDetails.Id and Ip instead of String", "committedDate": "2020-08-06T04:00:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMDI5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466610291", "bodyText": "There can only be one collator node in a graph right ? Can we add that to the comments ?", "author": "yojs", "createdAt": "2020-08-06T18:36:44Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyOTAwOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466729008", "bodyText": "Done.", "author": "ktkrg", "createdAt": "2020-08-06T22:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMDI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMDYwNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466610605", "bodyText": "maybe we can make actions final as well ?", "author": "yojs", "createdAt": "2020-08-06T18:37:20Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(long evalIntervalSeconds, Decider... deciders) {\n+    this(evalIntervalSeconds, new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(long evalIntervalSeconds, ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<Action> proposedActions = getAllProposedActions();\n+    Map<NodeKey, List<Action>> actionsByNode = actionGrouper.groupByNodeId(proposedActions);\n+    List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((k, v) -> prunedActions.addAll(polarize(k, v)));\n+\n+    Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    finalDecision.addAllActions(prunedActions);\n+    return finalDecision;\n+  }\n+\n+  @NonNull private List<Action> getAllProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        if (decisions != null) {\n+          decisions.forEach(decision -> proposedActions.addAll(decision.getActions()));\n+        }\n+      }\n+    }\n+    return proposedActions;\n+  }\n+\n+  private List<Action> polarize(final NodeKey nodeKey, List<Action> actions) {", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyOTAzMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466729030", "bodyText": "done. Took care of the other parameters as well.", "author": "ktkrg", "createdAt": "2020-08-06T22:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMDYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMjA3OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466612078", "bodyText": "Functional programming !! yay !", "author": "yojs", "createdAt": "2020-08-06T18:40:05Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(long evalIntervalSeconds, Decider... deciders) {\n+    this(evalIntervalSeconds, new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(long evalIntervalSeconds, ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<Action> proposedActions = getAllProposedActions();\n+    Map<NodeKey, List<Action>> actionsByNode = actionGrouper.groupByNodeId(proposedActions);\n+    List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((k, v) -> prunedActions.addAll(polarize(k, v)));\n+\n+    Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    finalDecision.addAllActions(prunedActions);\n+    return finalDecision;\n+  }\n+\n+  @NonNull private List<Action> getAllProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        if (decisions != null) {\n+          decisions.forEach(decision -> proposedActions.addAll(decision.getActions()));\n+        }\n+      }\n+    }\n+    return proposedActions;\n+  }\n+\n+  private List<Action> polarize(final NodeKey nodeKey, List<Action> actions) {\n+    List<Action> pressureIncreasingActions = new ArrayList<>();\n+    List<Action> pressureNonIncreasingActions = new ArrayList<>();\n+\n+    for (final Action action : actions) {\n+      ImpactVector impactVector = action.impact().getOrDefault(nodeKey, new ImpactVector());\n+\n+      // Classify the action as pressure increasing action if the impact for any dimension is\n+      // increasing pressure.\n+      if (impactVector.getImpact()\n+                      .values()\n+                      .stream()\n+                      .anyMatch(impact -> impact == Impact.INCREASES_PRESSURE)) {", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTIxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466621211", "bodyText": "Do we need to turn on some checkstyle rukes, this should have caused an error ?", "author": "yojs", "createdAt": "2020-08-06T18:57:07Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/SingleNodeImpactActionGrouper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+public class SingleNodeImpactActionGrouper implements ActionGrouper {\n+\n+  @Override\n+  @NonNull public Map<NodeKey, List<Action>> groupByNodeId(@NonNull List<Action> actions) {\n+    final Map<NodeKey, List<Action>> actionsByNodeId = new HashMap<>();\n+    actions.stream()\n+           .filter(action -> action.impactedNodes().size() == 1)\n+           .forEach(action -> actionsByNodeId.computeIfAbsent(action.impactedNodes()\n+                                                                    .get(0), k -> new ArrayList<>())\n+                                             .add(action));\n+    return actionsByNodeId;", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MzcwMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466683702", "bodyText": "the .get(0) is aligned with .impactedNodes() because they're chained calls, and similarly, .add(action) is aligned with .computeIfAbsent() because they're chained calls.\nThis is what the formatter did and I thought it was helpful \ud83d\ude05 I'm using the GoogleStyle scheme. Let me know if I should use another formatter.", "author": "ktkrg", "createdAt": "2020-08-06T21:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTcyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466621721", "bodyText": "A new line in the end ?", "author": "yojs", "createdAt": "2020-08-06T18:58:01Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/SingleNodeImpactActionGrouperTest.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.MockitoAnnotations.initMocks;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails.Id;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails.Ip;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.google.common.collect.ImmutableList;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+\n+public class SingleNodeImpactActionGrouperTest {\n+  private ActionGrouper testActionGrouper;\n+\n+  private NodeKey nodeKey1;\n+  private NodeKey nodeKey2;\n+\n+  @Mock\n+  private Action singleNodeImpactAction1;\n+\n+  @Mock\n+  private Action singleNodeImpactAction2;\n+\n+  @Mock\n+  private Action multiNodeImpactAction1;\n+\n+  @Before\n+  public void setup() {\n+    initMocks(this);\n+    this.nodeKey1 = new NodeKey(new Id(\"node1\"), new Ip(\"5.6.7.8\"));\n+    this.nodeKey2 = new NodeKey(new Id(\"node2\"), new Ip(\"5.6.7.9\"));\n+    when(singleNodeImpactAction1.impactedNodes()).thenReturn(ImmutableList.of(nodeKey1));\n+    when(singleNodeImpactAction2.impactedNodes()).thenReturn(ImmutableList.of(nodeKey2));\n+    when(multiNodeImpactAction1.impactedNodes()).thenReturn(ImmutableList.of(nodeKey1, nodeKey2));\n+    this.testActionGrouper = new SingleNodeImpactActionGrouper();\n+  }\n+\n+  @Test\n+  public void testAllSingleNodeImpactActions() {\n+    Map<NodeKey, List<Action>> groupedActions =\n+        testActionGrouper\n+            .groupByNodeId(ImmutableList.of(singleNodeImpactAction1, singleNodeImpactAction2));\n+\n+    assertEquals(2, groupedActions.keySet().size());\n+    assertTrue(groupedActions.containsKey(nodeKey1));\n+    assertEquals(1, groupedActions.get(nodeKey1).size());\n+    assertEquals(singleNodeImpactAction1, groupedActions.get(nodeKey1).get(0));\n+    assertTrue(groupedActions.containsKey(nodeKey2));\n+    assertEquals(1, groupedActions.get(nodeKey2).size());\n+    assertEquals(singleNodeImpactAction2, groupedActions.get(nodeKey2).get(0));\n+  }\n+\n+  @Test\n+  public void testSingleAndMultiNodeImpactActions() {\n+    Map<NodeKey, List<Action>> groupedActions =\n+        testActionGrouper\n+            .groupByNodeId(ImmutableList.of(singleNodeImpactAction1, multiNodeImpactAction1));\n+\n+    assertEquals(1, groupedActions.keySet().size());\n+    assertTrue(groupedActions.containsKey(nodeKey1));\n+    assertFalse(groupedActions.containsKey(nodeKey2));\n+    assertEquals(1, groupedActions.get(nodeKey1).size());\n+    assertEquals(singleNodeImpactAction1, groupedActions.get(nodeKey1).get(0));\n+  }\n+}", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MzcxOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466683719", "bodyText": "Added.", "author": "ktkrg", "createdAt": "2020-08-06T21:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDQxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466614415", "bodyText": "nit: Extra full stop at the end.", "author": "khushbr", "createdAt": "2020-08-06T18:44:42Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/ActionGrouper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * A grouping interface to provide different ways to group actions as needed by the {@link\n+ * Collator}\n+ */\n+public interface ActionGrouper {\n+\n+  /**\n+   * Groups the given list of actions by the nodes they impact..", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4Mzc1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466683755", "bodyText": "Done.", "author": "ktkrg", "createdAt": "2020-08-06T21:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxOTYyOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466619628", "bodyText": "Can decision.getActions() return null or empty value ? Do we want to filter for them?", "author": "khushbr", "createdAt": "2020-08-06T18:54:22Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(long evalIntervalSeconds, Decider... deciders) {\n+    this(evalIntervalSeconds, new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(long evalIntervalSeconds, ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<Action> proposedActions = getAllProposedActions();\n+    Map<NodeKey, List<Action>> actionsByNode = actionGrouper.groupByNodeId(proposedActions);\n+    List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((k, v) -> prunedActions.addAll(polarize(k, v)));\n+\n+    Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    finalDecision.addAllActions(prunedActions);\n+    return finalDecision;\n+  }\n+\n+  @NonNull private List<Action> getAllProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        if (decisions != null) {\n+          decisions.forEach(decision -> proposedActions.addAll(decision.getActions()));", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4Mzc5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466683795", "bodyText": "not sure if any actions return null values, but added a null check any way.", "author": "ktkrg", "createdAt": "2020-08-06T21:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxOTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTU1NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466621554", "bodyText": "can we rename the variables k, v here to be more expressive of the purpose.", "author": "khushbr", "createdAt": "2020-08-06T18:57:40Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(long evalIntervalSeconds, Decider... deciders) {\n+    this(evalIntervalSeconds, new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(long evalIntervalSeconds, ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<Action> proposedActions = getAllProposedActions();\n+    Map<NodeKey, List<Action>> actionsByNode = actionGrouper.groupByNodeId(proposedActions);\n+    List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((k, v) -> prunedActions.addAll(polarize(k, v)));", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MzgxMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466683810", "bodyText": "Done.", "author": "ktkrg", "createdAt": "2020-08-06T21:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMjgzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466622835", "bodyText": "given \"If there are any actions that decrease pressure for a node, prefer that over list of actions that increase pressure.\", should we break here when we find a pressureNonIncreasingActions ?", "author": "khushbr", "createdAt": "2020-08-06T19:00:07Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(long evalIntervalSeconds, Decider... deciders) {\n+    this(evalIntervalSeconds, new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(long evalIntervalSeconds, ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<Action> proposedActions = getAllProposedActions();\n+    Map<NodeKey, List<Action>> actionsByNode = actionGrouper.groupByNodeId(proposedActions);\n+    List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((k, v) -> prunedActions.addAll(polarize(k, v)));\n+\n+    Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    finalDecision.addAllActions(prunedActions);\n+    return finalDecision;\n+  }\n+\n+  @NonNull private List<Action> getAllProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        if (decisions != null) {\n+          decisions.forEach(decision -> proposedActions.addAll(decision.getActions()));\n+        }\n+      }\n+    }\n+    return proposedActions;\n+  }\n+\n+  private List<Action> polarize(final NodeKey nodeKey, List<Action> actions) {\n+    List<Action> pressureIncreasingActions = new ArrayList<>();\n+    List<Action> pressureNonIncreasingActions = new ArrayList<>();\n+\n+    for (final Action action : actions) {\n+      ImpactVector impactVector = action.impact().getOrDefault(nodeKey, new ImpactVector());\n+\n+      // Classify the action as pressure increasing action if the impact for any dimension is\n+      // increasing pressure.\n+      if (impactVector.getImpact()\n+                      .values()\n+                      .stream()\n+                      .anyMatch(impact -> impact == Impact.INCREASES_PRESSURE)) {\n+        pressureIncreasingActions.add(action);\n+      } else {\n+        pressureNonIncreasingActions.add(action);", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4Mzg1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466683855", "bodyText": "there might be other pressure decreasing actions beyond the one that increases it, we need to add that as well, so we can't break early.", "author": "ktkrg", "createdAt": "2020-08-06T21:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMjgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDg0OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466624848", "bodyText": "so, each action can be associated with 1 or 0 impacted Nodes ? Just wanted to clarify this.", "author": "khushbr", "createdAt": "2020-08-06T19:03:57Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/SingleNodeImpactActionGrouper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+public class SingleNodeImpactActionGrouper implements ActionGrouper {\n+\n+  @Override\n+  @NonNull public Map<NodeKey, List<Action>> groupByNodeId(@NonNull List<Action> actions) {\n+    final Map<NodeKey, List<Action>> actionsByNodeId = new HashMap<>();\n+    actions.stream()\n+           .filter(action -> action.impactedNodes().size() == 1)", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MzUxOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466683519", "bodyText": "Yeah, is that not the understanding today? This class only considers those actions that impact exactly one node. The multi node impact action grouping will be done in the next PR.\n@yojs brought up a similar point, do we create a single action with multiple nodes in the impacted nodes when we want to say decrease cache size for node1, node2, node3 or do we create multiple actions for each node we want to decrease the cache size for?", "author": "ktkrg", "createdAt": "2020-08-06T21:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc0NjA3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466746073", "bodyText": "I clarified this with others and we will have actions which impact a single node and then another set of action which are for multiple nodes.\nTaking the above example, cache increase action will be per node but for cache decrease, we will have 1 action with multiple nodes in the impactedNodes.", "author": "khushbr", "createdAt": "2020-08-06T23:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI2ODE2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r470268163", "bodyText": "Actions can impact a single node or multiple nodes - this depends on the type of action. For a given action type (a class implementing Action interface), this stays fixed.\n@khushbr's example above is slightly incorrect. ModifyCacheAction impacts only a single node. If we want to increase or decrease caches across multiple nodes, the decider will have to create multiple such actions.\nThere will be other types of actions in future, like MoveShard, which can impact multiple nodes (src node and dest node) or SplitShard which impacts even more nodes. For those actions, impactedNodes will contain all the nodes impacted and impact() will return the impactVector for each node - e.g. for MoveShard impact() will indicate that pressure gets reduced on src node and increased on the destination node.", "author": "vigyasharma", "createdAt": "2020-08-13T21:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNTAyMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466625020", "bodyText": "Can we rename the method name to include InstanceName ?", "author": "yojs", "createdAt": "2020-08-06T19:04:18Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/ActionGrouper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * A grouping interface to provide different ways to group actions as needed by the {@link\n+ * Collator}\n+ */\n+public interface ActionGrouper {\n+\n+  /**\n+   * Groups the given list of actions by the nodes they impact..\n+   *\n+   * @param actions The list of actions that need to be grouped.\n+   * @return A map of actions grouped by nodes they impact.\n+   */\n+  @NonNull Map<NodeKey, List<Action>> groupByNodeId(@NonNull final List<Action> actions);", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MDQ1OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466680458", "bodyText": "yup, renamed it to groupByInstanceId.", "author": "ktkrg", "createdAt": "2020-08-06T20:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNzA5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466627099", "bodyText": "We plan to remove the evalIntervalSeconds as we wanted the scheduler to be simple - it would call each graphNode at every tick and then the node should decide how to handle if this is before the periodicity. In that vein, can we add a constant in Node class and use that and not even take evalIntervalSeconds as a constructor parameter ?", "author": "yojs", "createdAt": "2020-08-06T19:08:28Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(long evalIntervalSeconds, Decider... deciders) {\n+    this(evalIntervalSeconds, new SingleNodeImpactActionGrouper(), deciders);", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDA3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466700079", "bodyText": "Removed evalIntervalSeconds ctor parameter in Collator. It should be one less graph node to worry about when we remove the parameter permanently :)", "author": "ktkrg", "createdAt": "2020-08-06T21:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNzA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyODc5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466628791", "bodyText": "I think it might be a good idea to add a javadoc comment for the operate() as this is the center piece of the RCAGraph node ?", "author": "yojs", "createdAt": "2020-08-06T19:11:38Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(long evalIntervalSeconds, Decider... deciders) {\n+    this(evalIntervalSeconds, new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(long evalIntervalSeconds, ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MDI3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466680276", "bodyText": "Added.", "author": "ktkrg", "createdAt": "2020-08-06T20:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyODc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMTk2Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466631962", "bodyText": "So, we want the collator to come up with one action per node or one action per resource per node ?", "author": "yojs", "createdAt": "2020-08-06T19:17:38Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/SingleNodeImpactActionGrouper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+public class SingleNodeImpactActionGrouper implements ActionGrouper {\n+\n+  @Override\n+  @NonNull public Map<NodeKey, List<Action>> groupByNodeId(@NonNull List<Action> actions) {", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MDI0MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466680241", "bodyText": "Collator does not filter beyond polarizing the actions. It will return as many as possible after making sure that they align in terms of the impact on the instance so that the publisher and other components can filter based on other parameters.", "author": "ktkrg", "createdAt": "2020-08-06T20:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMTk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MDIxMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466640210", "bodyText": "Can we add a comment why are we filtering out the actions that ask for the same action to be performed on multiple nodes ? Is that rationale that we do it only one node per iteration ?", "author": "yojs", "createdAt": "2020-08-06T19:33:52Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/SingleNodeImpactActionGrouper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+public class SingleNodeImpactActionGrouper implements ActionGrouper {\n+\n+  @Override\n+  @NonNull public Map<NodeKey, List<Action>> groupByNodeId(@NonNull List<Action> actions) {\n+    final Map<NodeKey, List<Action>> actionsByNodeId = new HashMap<>();\n+    actions.stream()\n+           .filter(action -> action.impactedNodes().size() == 1)", "originalCommit": "490d7f219fcb59da0cc677e241a14c529d756ec4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MDAzOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466680038", "bodyText": "Interesting point, don't we create multiple actions in such cases?", "author": "ktkrg", "createdAt": "2020-08-06T20:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDI1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r466780255", "bodyText": "Looks like we are creating one action per node even if its the same action for multiple nodes, added a comment.", "author": "ktkrg", "createdAt": "2020-08-07T02:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MDIxMA=="}], "type": "inlineReview"}, {"oid": "3dcd77c727a8b6d8a303f09f285f9c930a57e94a", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/3dcd77c727a8b6d8a303f09f285f9c930a57e94a", "message": "Address PR comments", "committedDate": "2020-08-06T20:50:59Z", "type": "commit"}, {"oid": "19d6f2ca93e93d8224f450bf2c4629557be47d61", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/19d6f2ca93e93d8224f450bf2c4629557be47d61", "message": "Refactor collator constructor to not take evalInterval", "committedDate": "2020-08-06T21:36:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI2NTU0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r470265547", "bodyText": "We should use decision.isEmpty() here", "author": "vigyasharma", "createdAt": "2020-08-13T21:42:18Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.AnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned.\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance. In\n+ * order for the above guarantee to work, there should be only one collator instance in an {@link\n+ * AnalysisGraph}.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private static final int evalIntervalSeconds = 5;\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(Decider... deciders) {\n+    this(new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  /**\n+   * The collator uses an action grouping strategy to first group actions by instanceIds. Then, the\n+   * collator polarizes the list of actions per instance to be in the same direction of pressure,\n+   * i.e. all the polarized actions either increase pressure on a node, or decrease pressure on a\n+   * node.\n+   *\n+   * <p>When there are conflicting actions suggested by the deciders for an instance, the\n+   * polarization logic prefers pruning actions that decrease stability retaining only those that\n+   * increase stability. </p>\n+   *\n+   * @return A {@link Decision} instance that contains the list of polarized actions.\n+   */\n+  @Override\n+  public Decision operate() {\n+    final List<Action> proposedActions = getAllProposedActions();\n+    final Map<NodeKey, List<Action>> actionsByNode = actionGrouper\n+        .groupByInstanceId(proposedActions);\n+    final List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((nodeKey, actions) -> prunedActions.addAll(polarize(nodeKey, actions)));\n+\n+    final Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    finalDecision.addAllActions(prunedActions);\n+    return finalDecision;\n+  }\n+\n+  @NonNull\n+  private List<Action> getAllProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        if (decisions != null) {\n+          decisions.forEach(decision -> {\n+            if (decision.getActions() != null) {", "originalCommit": "19d6f2ca93e93d8224f450bf2c4629557be47d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3NDU4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r471874580", "bodyText": "will change in the next rev", "author": "ktkrg", "createdAt": "2020-08-18T02:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI2NTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzM0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r470273349", "bodyText": "This classifies an increase across any dimension as increasing pressure. Shouldn't we check on a per dimension basis? Otherwise there is no value in having different dimensions in the impact vector.\nSuppose you have an action to offload some data from heap to a file on disk. This would reduce heap but increase disk pressure. If there is no other action trying to decrease disk pressure, then the overall disk on the node is not under contention and we should let this action go through.", "author": "vigyasharma", "createdAt": "2020-08-13T22:01:27Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.AnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned.\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance. In\n+ * order for the above guarantee to work, there should be only one collator instance in an {@link\n+ * AnalysisGraph}.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private static final int evalIntervalSeconds = 5;\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(Decider... deciders) {\n+    this(new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  /**\n+   * The collator uses an action grouping strategy to first group actions by instanceIds. Then, the\n+   * collator polarizes the list of actions per instance to be in the same direction of pressure,\n+   * i.e. all the polarized actions either increase pressure on a node, or decrease pressure on a\n+   * node.\n+   *\n+   * <p>When there are conflicting actions suggested by the deciders for an instance, the\n+   * polarization logic prefers pruning actions that decrease stability retaining only those that\n+   * increase stability. </p>\n+   *\n+   * @return A {@link Decision} instance that contains the list of polarized actions.\n+   */\n+  @Override\n+  public Decision operate() {\n+    final List<Action> proposedActions = getAllProposedActions();\n+    final Map<NodeKey, List<Action>> actionsByNode = actionGrouper\n+        .groupByInstanceId(proposedActions);\n+    final List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((nodeKey, actions) -> prunedActions.addAll(polarize(nodeKey, actions)));\n+\n+    final Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    finalDecision.addAllActions(prunedActions);\n+    return finalDecision;\n+  }\n+\n+  @NonNull\n+  private List<Action> getAllProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        if (decisions != null) {\n+          decisions.forEach(decision -> {\n+            if (decision.getActions() != null) {\n+              proposedActions.addAll(decision.getActions());\n+            }\n+          });\n+        }\n+      }\n+    }\n+    return proposedActions;\n+  }\n+\n+  private List<Action> polarize(final NodeKey nodeKey, final List<Action> actions) {\n+    final List<Action> pressureIncreasingActions = new ArrayList<>();\n+    final List<Action> pressureNonIncreasingActions = new ArrayList<>();\n+\n+    for (final Action action : actions) {\n+      ImpactVector impactVector = action.impact().getOrDefault(nodeKey, new ImpactVector());\n+\n+      // Classify the action as pressure increasing action if the impact for any dimension is\n+      // increasing pressure.\n+      if (impactVector.getImpact()", "originalCommit": "19d6f2ca93e93d8224f450bf2c4629557be47d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3NDkxMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r471874912", "bodyText": "Makes sense, I assumed for the first iteration we would not have such actions and had not thought of polarizing at a dimension level. I will change it.", "author": "ktkrg", "createdAt": "2020-08-18T02:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4ODk0NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r470288944", "bodyText": "It seems to me that this will need non-trivial changes when we have actions impacting multiple nodes. If an action is purged because of pressure conflict on one of the nodes, it must be removed from the list of all of the nodes.\nShould polarize() then move to ActionGrouper? Is the overall above structure right for future use cases?\n\nMy ideas for solving this were more around compiling all impact vectors into a matrix and doing a second pass through it to accept or prune actions. Something on these lines:\nSuppose the collator received 2 actions, moveShard from node A to node B, and moveShard from node B to node C\nactions = [MoveShard: A -> B, MoveShard: B -> C]\nImpact vectors:\n\tactions[0] :: MoveShard: A -> B\n\timpactedNodes = [A, B]\n\tA: [CPU:dec, Heap: dec, RAM: dec, NW: dec, Disk: dec]\n\tB: [CPU:inc, Heap: inc, RAM: inc, NW: inc, Disk: inc]\n\n\tactions[1] :: MoveShard: B -> C\n\timpactedNodes = [B, C]\n\tB: [CPU:dec, Heap: dec, RAM: dec, NW: dec, Disk: dec]\n\tC: [CPU:inc, Heap: inc, RAM: inc, NW: inc, Disk: inc]\nFirst we create an impact matrix for the cluster:\n\nnode A has only decrease across each dim\nB has 1 inc and 1 dec action,\nC has 1 inc action for each dim\n\n\t       A \tB \t      C\ncpu \t  i=0,d=1     i=1,d=1     i=1,d=0\nheap \t  i=0,d=1     i=1,d=1     i=1,d=0\nram       i=0,d=1     i=1,d=1     i=1,d=0\nnw        i=0,d=1     i=1,d=1     i=1,d=0\ndisk      i=0,d=1     i=1,d=1     i=1,d=0\nNow we run the actions through this matrix again.\n\nIf an action is increasing pressure on a dim on a node, it is only allowed\nif there is no other action trying to dec that dim on the node. i.e. d=0 for that node,dim.\n\nWhen an action gets purged in this second pass, we remove it from the matrix by reducing the node,dim counters.\nIn above e.g. we process MoveShard(A->B) -\n\nIt cannot go through because d=1 for some dims on node B\nWe purge MoveShard(A->B)\nCounters on A and B are updated. All counters in A become i=0, d=0. B becomes i=0,d=1\n\nNow we process MoveShard(B->C) -\n\nIt increases pressure on C but there is no one decreasing pressure (d=0 for all dims on C), so it can go through\nOn B it is dec pressure anyway so it has a clear pass.\n\nHence MoveShard(B->C) gets picked.\nThis will also resolve cycles like A->B, B->C, C->A by picking either one or two of the actions (depending on order of 2nd pass).\n\nIt is okay if we handle multi-node actions in a separate PR later. You may also use different/better algorithms for polarizing impact vectors. Just wanted to check if the current Collator::polarize() and ActionGrouper::groupByInstanceId() is the right approach for future use cases, like the moveShard, splitShard etc..\nIt will also be good to at least handle the dimension level comparisons right away, as they help establish a structure for all use cases.", "author": "vigyasharma", "createdAt": "2020-08-13T22:44:04Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.AnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned.\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node. To resolve conflicts, we prefer stability over performance. In\n+ * order for the above guarantee to work, there should be only one collator instance in an {@link\n+ * AnalysisGraph}.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private static final int evalIntervalSeconds = 5;\n+\n+  private final List<Decider> deciders;\n+\n+  private final ActionGrouper actionGrouper;\n+\n+  public Collator(Decider... deciders) {\n+    this(new SingleNodeImpactActionGrouper(), deciders);\n+  }\n+\n+  public Collator(ActionGrouper actionGrouper, Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionGrouper = actionGrouper;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  /**\n+   * The collator uses an action grouping strategy to first group actions by instanceIds. Then, the\n+   * collator polarizes the list of actions per instance to be in the same direction of pressure,\n+   * i.e. all the polarized actions either increase pressure on a node, or decrease pressure on a\n+   * node.\n+   *\n+   * <p>When there are conflicting actions suggested by the deciders for an instance, the\n+   * polarization logic prefers pruning actions that decrease stability retaining only those that\n+   * increase stability. </p>\n+   *\n+   * @return A {@link Decision} instance that contains the list of polarized actions.\n+   */\n+  @Override\n+  public Decision operate() {\n+    final List<Action> proposedActions = getAllProposedActions();\n+    final Map<NodeKey, List<Action>> actionsByNode = actionGrouper\n+        .groupByInstanceId(proposedActions);\n+    final List<Action> prunedActions = new ArrayList<>();\n+    actionsByNode.forEach((nodeKey, actions) -> prunedActions.addAll(polarize(nodeKey, actions)));\n+\n+    final Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    finalDecision.addAllActions(prunedActions);\n+    return finalDecision;\n+  }\n+\n+  @NonNull\n+  private List<Action> getAllProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        if (decisions != null) {\n+          decisions.forEach(decision -> {\n+            if (decision.getActions() != null) {\n+              proposedActions.addAll(decision.getActions());\n+            }\n+          });\n+        }\n+      }\n+    }\n+    return proposedActions;\n+  }\n+\n+  private List<Action> polarize(final NodeKey nodeKey, final List<Action> actions) {", "originalCommit": "19d6f2ca93e93d8224f450bf2c4629557be47d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwMDU4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474200589", "bodyText": "Thanks for this sage advice, I had an unnecessarily complex system and I was able to rip it out until I got to something similar to what you've proposed here :) I've updated the PR to reflect these changes.", "author": "ktkrg", "createdAt": "2020-08-20T18:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4ODk0NA=="}], "type": "inlineReview"}, {"oid": "9ce128c51eca69310732d3048fb81d2881bcb43d", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9ce128c51eca69310732d3048fb81d2881bcb43d", "message": "Merge from master", "committedDate": "2020-08-17T21:24:10Z", "type": "commit"}, {"oid": "002179c4eb0ebc53926b01d3ac0c91d28e49898a", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/002179c4eb0ebc53926b01d3ac0c91d28e49898a", "message": "Handle multi node impacting actions in the collator", "committedDate": "2020-08-20T08:46:19Z", "type": "commit"}, {"oid": "7d9484a187064cc1681f32819432b7428d69b77f", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/7d9484a187064cc1681f32819432b7428d69b77f", "message": "Merge from master", "committedDate": "2020-08-20T08:47:53Z", "type": "commit"}, {"oid": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/89192203ccbf5de8e465f9d95983bc2b54a991f3", "message": "Add missing javadoc", "committedDate": "2020-08-20T09:03:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzODQxNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474438416", "bodyText": "Interesting implementation.", "author": "vigyasharma", "createdAt": "2020-08-21T06:40:22Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/Collator.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.AnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * Collator collects and prunes the candidate decisions from each decider so that their impacts are\n+ * aligned.\n+ *\n+ * <p>Decisions can increase or decrease pressure on different key resources on an Elasticsearch\n+ * node. This is encapsulated in each Action via the {@link ImpactVector}. Since each decider\n+ * independently evaluates its decision, it is possible to have conflicting ImpactVectors from\n+ * actions across deciders.\n+ *\n+ * <p>The collator prunes them to ensure we only take actions that either increase, or decrease\n+ * pressure on a particular node's resources. To resolve conflicts, we prefer stability over\n+ * performance. In order for the above guarantee to work, there should be only one collator instance\n+ * in an {@link AnalysisGraph}.\n+ */\n+public class Collator extends Decider {\n+\n+  public static final String NAME = \"collator\";\n+\n+  /* Deciders can choose to publish decisions at different frequencies based on the\n+   * type of resources monitored and rca signals. The collator should however, not introduce any\n+   * unnecessary delays. As soon as a decision is taken, it should be evaluated and published downstream.\n+   */\n+  private static final int collatorFrequency = 1; // Measured in terms of number of evaluationIntervalPeriods\n+\n+  private static final int evalIntervalSeconds = 5;\n+\n+  private final ImpactAssessor impactAssessor;\n+\n+  private final List<Decider> deciders;\n+\n+  private final Comparator<Action> actionComparator;\n+\n+  public Collator(Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionComparator = new ImpactBasedActionComparator();\n+    this.impactAssessor = new ImpactAssessor();\n+  }\n+\n+  /**\n+   * Constructor used for unit testing purposes only.\n+   *\n+   * @param impactAssessor   the impact assessor.\n+   * @param actionComparator comparator for sorting actions.\n+   * @param deciders         The participating deciders.\n+   */\n+  @VisibleForTesting\n+  public Collator(final ImpactAssessor impactAssessor, final Comparator<Action> actionComparator,\n+      Decider... deciders) {\n+    super(evalIntervalSeconds, collatorFrequency);\n+    this.deciders = Arrays.asList(deciders);\n+    this.actionComparator = actionComparator;\n+    this.impactAssessor = impactAssessor;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  /**\n+   * Process all the actions proposed by the deciders and prune them based on their impact vectors.\n+   *\n+   * @return A {@link Decision} instance that contains the list of polarized actions.\n+   */\n+  @Override\n+  public Decision operate() {\n+    Decision finalDecision = new Decision(System.currentTimeMillis(), NAME);\n+    List<Action> allowedActions = new ArrayList<>();\n+\n+    // First get all the actions proposed by the deciders and assess the overall impact all\n+    // actions combined have on all the affected nodes.\n+\n+    List<Action> allActions = getProposedActions();\n+    Map<NodeKey, ImpactAssessment> overallImpactAssessment =\n+        impactAssessor.assessOverallImpact(allActions);\n+\n+    // We need to identify and prune conflicting actions based on the overall impact. In order to\n+    // do that, we re-assess each of the proposed actions with the overall impact assessment in\n+    // mind. In each such assessment, we ensure the impact of an action aligns with the instance's\n+    // current pressure heading(increasing/decreasing). Actions that don't align are pruned and\n+    // their effects on the overall impact are undone. As the order in which we reassess matters\n+    // as to what actions get picked and what don't, we sort the list of actions based on a\n+    // simple heuristic where actions that reduce pressure the most are re-assessed later\n+    // thereby decreasing the chance of them getting pruned because of another action.\n+\n+    allActions.sort(actionComparator);\n+    allActions.forEach(action -> {\n+      if (impactAssessor.isImpactAligned(action, overallImpactAssessment)) {\n+        allowedActions.add(action);\n+      } else {\n+        impactAssessor.undoActionImpactOnOverallAssessment(action, overallImpactAssessment);\n+      }\n+    });\n+\n+    finalDecision.addAllActions(allowedActions);\n+    return finalDecision;\n+  }\n+\n+  /**\n+   * Combines all actions proposed by the deciders into a list.\n+   *\n+   * @return A list of actions.\n+   */\n+  @NonNull\n+  private List<Action> getProposedActions() {\n+    final List<Action> proposedActions = new ArrayList<>();\n+    if (deciders != null) {\n+      for (final Decider decider : deciders) {\n+        List<Decision> decisions = decider.getFlowUnits();\n+        decisions.forEach(decision -> {\n+          if (!decision.getActions().isEmpty()) {\n+            proposedActions.addAll(decision.getActions());\n+          }\n+        });\n+      }\n+    }\n+    return proposedActions;\n+  }\n+\n+  /**\n+   * A comparator for actions to sort them based on their impact from least pressure decreasing\n+   * to most.\n+   */\n+  @VisibleForTesting\n+  static final class ImpactBasedActionComparator implements Comparator<Action>, Serializable {", "originalCommit": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0MjUzOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474442539", "bodyText": "This is a useful comment, thanks for adding", "author": "vigyasharma", "createdAt": "2020-08-21T06:51:40Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/ImpactAssessment.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * ImpactAssessment maintains and helps with updating impacts of actions on a node.\n+ */\n+public class ImpactAssessment {\n+\n+  private static final Logger LOG = LogManager.getLogger(ImpactAssessment.class);\n+  private final NodeKey nodeKey;\n+\n+  private final Map<Dimension, List<String>> perDimensionPressureDecreasingActions;\n+  private final Map<Dimension, List<String>> perDimensionPressureIncreasingActions;\n+\n+  public ImpactAssessment(final NodeKey nodeKey) {\n+    this.nodeKey = nodeKey;\n+    this.perDimensionPressureDecreasingActions = new HashMap<>();\n+    this.perDimensionPressureIncreasingActions = new HashMap<>();\n+  }\n+\n+  /**\n+   * Adds the action's impact to the current overall impact of all proposed actions for this node\n+   * so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void addActionImpact(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while adding action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Removes an action's impact from the current overall impact of all proposed actions for this\n+   * node so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void removeActionImpact(@NonNull final String actionName,\n+      @NonNull ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while removing action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Checks if the given impact vector aligns with the current overall impact for this node.\n+   * Alignment is checked when reassessing the actions where all impacts are replayed.\n+   *\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   * @return true if the impact vector aligns with the overall impact, false otherwise.\n+   */\n+  public boolean checkAlignmentAcrossDimensions(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    boolean isAligned = true;\n+\n+    // If this is an action that increases pressure along some dimension for this node, and the", "originalCommit": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0MjY4OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474442688", "bodyText": "nit: move to after the comment string?", "author": "vigyasharma", "createdAt": "2020-08-21T06:52:06Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/ImpactAssessment.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * ImpactAssessment maintains and helps with updating impacts of actions on a node.\n+ */\n+public class ImpactAssessment {\n+\n+  private static final Logger LOG = LogManager.getLogger(ImpactAssessment.class);\n+  private final NodeKey nodeKey;\n+\n+  private final Map<Dimension, List<String>> perDimensionPressureDecreasingActions;\n+  private final Map<Dimension, List<String>> perDimensionPressureIncreasingActions;\n+\n+  public ImpactAssessment(final NodeKey nodeKey) {\n+    this.nodeKey = nodeKey;\n+    this.perDimensionPressureDecreasingActions = new HashMap<>();\n+    this.perDimensionPressureIncreasingActions = new HashMap<>();\n+  }\n+\n+  /**\n+   * Adds the action's impact to the current overall impact of all proposed actions for this node\n+   * so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void addActionImpact(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while adding action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Removes an action's impact from the current overall impact of all proposed actions for this\n+   * node so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void removeActionImpact(@NonNull final String actionName,\n+      @NonNull ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while removing action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Checks if the given impact vector aligns with the current overall impact for this node.\n+   * Alignment is checked when reassessing the actions where all impacts are replayed.\n+   *\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   * @return true if the impact vector aligns with the overall impact, false otherwise.\n+   */\n+  public boolean checkAlignmentAcrossDimensions(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    boolean isAligned = true;", "originalCommit": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyODMzMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r475928332", "bodyText": "Done.", "author": "ktkrg", "createdAt": "2020-08-24T22:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0MjY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0Mzg4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474443889", "bodyText": "can we use impactMap.foreach(dimension, impact) {...} ?", "author": "vigyasharma", "createdAt": "2020-08-21T06:54:52Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/ImpactAssessment.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * ImpactAssessment maintains and helps with updating impacts of actions on a node.\n+ */\n+public class ImpactAssessment {\n+\n+  private static final Logger LOG = LogManager.getLogger(ImpactAssessment.class);\n+  private final NodeKey nodeKey;\n+\n+  private final Map<Dimension, List<String>> perDimensionPressureDecreasingActions;\n+  private final Map<Dimension, List<String>> perDimensionPressureIncreasingActions;\n+\n+  public ImpactAssessment(final NodeKey nodeKey) {\n+    this.nodeKey = nodeKey;\n+    this.perDimensionPressureDecreasingActions = new HashMap<>();\n+    this.perDimensionPressureIncreasingActions = new HashMap<>();\n+  }\n+\n+  /**\n+   * Adds the action's impact to the current overall impact of all proposed actions for this node\n+   * so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void addActionImpact(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while adding action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Removes an action's impact from the current overall impact of all proposed actions for this\n+   * node so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void removeActionImpact(@NonNull final String actionName,\n+      @NonNull ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while removing action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Checks if the given impact vector aligns with the current overall impact for this node.\n+   * Alignment is checked when reassessing the actions where all impacts are replayed.\n+   *\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   * @return true if the impact vector aligns with the overall impact, false otherwise.\n+   */\n+  public boolean checkAlignmentAcrossDimensions(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    boolean isAligned = true;\n+\n+    // If this is an action that increases pressure along some dimension for this node, and the\n+    // overall assessment says there are actions that decrease pressure along those same\n+    // dimensions, then this action is not aligned with the other proposed actions where the\n+    // deciders are trying to reduce pressure for those dimensions.\n+\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+    for (final Map.Entry<Dimension, Impact> entry : impactMap.entrySet()) {\n+      final Impact impactOnDimension = entry.getValue();", "originalCommit": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMDE4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r475930180", "bodyText": "We can't use forEach here because we will be updating a local variable inside the body of the lambda and it needs the isAligned value to be effectively final. Since local variables are not effectively final, we'll need to declare an array or a list of size=1 to hold the isAligned value.\nI chose the verbose way to avoid some confusion there.", "author": "ktkrg", "createdAt": "2020-08-24T22:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0Mzg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NDcwMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474444703", "bodyText": "How about:\nisAligned = !pressureDecreasingActions.contains(dimension);", "author": "vigyasharma", "createdAt": "2020-08-21T06:56:45Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/ImpactAssessment.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * ImpactAssessment maintains and helps with updating impacts of actions on a node.\n+ */\n+public class ImpactAssessment {\n+\n+  private static final Logger LOG = LogManager.getLogger(ImpactAssessment.class);\n+  private final NodeKey nodeKey;\n+\n+  private final Map<Dimension, List<String>> perDimensionPressureDecreasingActions;\n+  private final Map<Dimension, List<String>> perDimensionPressureIncreasingActions;\n+\n+  public ImpactAssessment(final NodeKey nodeKey) {\n+    this.nodeKey = nodeKey;\n+    this.perDimensionPressureDecreasingActions = new HashMap<>();\n+    this.perDimensionPressureIncreasingActions = new HashMap<>();\n+  }\n+\n+  /**\n+   * Adds the action's impact to the current overall impact of all proposed actions for this node\n+   * so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void addActionImpact(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while adding action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Removes an action's impact from the current overall impact of all proposed actions for this\n+   * node so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void removeActionImpact(@NonNull final String actionName,\n+      @NonNull ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while removing action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Checks if the given impact vector aligns with the current overall impact for this node.\n+   * Alignment is checked when reassessing the actions where all impacts are replayed.\n+   *\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   * @return true if the impact vector aligns with the overall impact, false otherwise.\n+   */\n+  public boolean checkAlignmentAcrossDimensions(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    boolean isAligned = true;\n+\n+    // If this is an action that increases pressure along some dimension for this node, and the\n+    // overall assessment says there are actions that decrease pressure along those same\n+    // dimensions, then this action is not aligned with the other proposed actions where the\n+    // deciders are trying to reduce pressure for those dimensions.\n+\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+    for (final Map.Entry<Dimension, Impact> entry : impactMap.entrySet()) {\n+      final Impact impactOnDimension = entry.getValue();\n+      if (isAligned && impactOnDimension.equals(Impact.INCREASES_PRESSURE)) {\n+        List<String> pressureDecreasingActions = perDimensionPressureDecreasingActions\n+            .getOrDefault(entry.getKey(), Collections.emptyList());\n+        isAligned = pressureDecreasingActions.isEmpty();", "originalCommit": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMDE5NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r475930194", "bodyText": "Done.", "author": "ktkrg", "createdAt": "2020-08-24T22:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NDcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NDk3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474444979", "bodyText": "nit: single line?", "author": "vigyasharma", "createdAt": "2020-08-21T06:57:19Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/ImpactAssessment.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Impact;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/**\n+ * ImpactAssessment maintains and helps with updating impacts of actions on a node.\n+ */\n+public class ImpactAssessment {\n+\n+  private static final Logger LOG = LogManager.getLogger(ImpactAssessment.class);\n+  private final NodeKey nodeKey;\n+\n+  private final Map<Dimension, List<String>> perDimensionPressureDecreasingActions;\n+  private final Map<Dimension, List<String>> perDimensionPressureIncreasingActions;\n+\n+  public ImpactAssessment(final NodeKey nodeKey) {\n+    this.nodeKey = nodeKey;\n+    this.perDimensionPressureDecreasingActions = new HashMap<>();\n+    this.perDimensionPressureIncreasingActions = new HashMap<>();\n+  }\n+\n+  /**\n+   * Adds the action's impact to the current overall impact of all proposed actions for this node\n+   * so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void addActionImpact(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          addActionToMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while adding action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Removes an action's impact from the current overall impact of all proposed actions for this\n+   * node so far.\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   */\n+  public void removeActionImpact(@NonNull final String actionName,\n+      @NonNull ImpactVector impactVector) {\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+\n+    impactMap.forEach((dimension, impact) -> {\n+      switch (impact) {\n+        case INCREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureIncreasingActions, actionName, dimension);\n+          break;\n+        case DECREASES_PRESSURE:\n+          removeActionFromMap(perDimensionPressureDecreasingActions, actionName, dimension);\n+          break;\n+        case NO_IMPACT:\n+          break;\n+        default:\n+          LOG.warn(\"Unknown impact value: {} encountered while removing action: {}'s impact\",\n+              impact, actionName);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Checks if the given impact vector aligns with the current overall impact for this node.\n+   * Alignment is checked when reassessing the actions where all impacts are replayed.\n+   *\n+   * @param actionName The name of the action.\n+   * @param impactVector The impact vector which gives a pressure heading for various resources\n+   *                     impacted by taking this action.\n+   * @return true if the impact vector aligns with the overall impact, false otherwise.\n+   */\n+  public boolean checkAlignmentAcrossDimensions(@NonNull final String actionName,\n+      @NonNull final ImpactVector impactVector) {\n+    boolean isAligned = true;\n+\n+    // If this is an action that increases pressure along some dimension for this node, and the\n+    // overall assessment says there are actions that decrease pressure along those same\n+    // dimensions, then this action is not aligned with the other proposed actions where the\n+    // deciders are trying to reduce pressure for those dimensions.\n+\n+    final Map<Dimension, Impact> impactMap = impactVector.getImpact();\n+    for (final Map.Entry<Dimension, Impact> entry : impactMap.entrySet()) {\n+      final Impact impactOnDimension = entry.getValue();\n+      if (isAligned && impactOnDimension.equals(Impact.INCREASES_PRESSURE)) {\n+        List<String> pressureDecreasingActions = perDimensionPressureDecreasingActions\n+            .getOrDefault(entry.getKey(), Collections.emptyList());\n+        isAligned = pressureDecreasingActions.isEmpty();\n+\n+        if (!isAligned) {\n+          LOG.info(\"action: {}'s impact is not aligned with node: {}'s overall impact for \"\n+                  + \"dimension: {}. Found pressure decreasing actions: {}\", actionName, nodeKey,\n+              entry.getKey(), pressureDecreasingActions);\n+        }\n+      }\n+    }\n+\n+    return isAligned;\n+  }\n+\n+  private void addActionToMap(@NonNull final Map<Dimension, List<String>> map,\n+      @NonNull final String actionName, @NonNull final Dimension dimension) {\n+    map.computeIfAbsent(dimension,\n+        dim -> new ArrayList<>()).add(actionName);", "originalCommit": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMDIxNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r475930214", "bodyText": "Done.", "author": "ktkrg", "createdAt": "2020-08-24T22:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NDk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NjA0Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r474446046", "bodyText": "nit: add newline", "author": "vigyasharma", "createdAt": "2020-08-21T06:59:28Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/collator/CollatorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.MockitoAnnotations.initMocks;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.Decision;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.collator.Collator.ImpactBasedActionComparator;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails.Id;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails.Ip;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+\n+public class CollatorTest {\n+\n+  private Collator testCollator;\n+\n+  @Mock\n+  private Decider mockDecider1;\n+\n+  @Mock\n+  private Decider mockDecider2;\n+\n+  @Mock\n+  private Comparator<Action> mockComparator;\n+\n+  @Mock\n+  private Decision decision1;\n+\n+  @Mock\n+  private Decision decision2;\n+\n+  @Mock\n+  private Action moveShardAction1;\n+\n+  @Mock\n+  private Action moveShardAction2;\n+\n+  @Mock\n+  private Action moveShardAction3;\n+\n+  private final ImpactAssessor impactAssessor = new ImpactAssessor();\n+\n+  private final NodeKey nodeA = new NodeKey(new Id(\"node A\"), new Ip(\"1.2.3.4\"));\n+  private final NodeKey nodeB = new NodeKey(new Id(\"node B\"), new Ip(\"5.6.7.8\"));\n+  private final NodeKey nodeC = new NodeKey(new Id(\"node C\"), new Ip(\"9.10.11.12\"));\n+\n+  private String moveShardActionName = \"MoveShard\";\n+  \n+  private Map<NodeKey, ImpactVector> moveShardImpact1 = ImmutableMap.of(\n+      nodeA, buildShardMoveOutImpactVector(),\n+      nodeB, buildShardMoveInImpactVector()\n+  );\n+\n+  private Map<NodeKey, ImpactVector> moveShardImpact2 = ImmutableMap.of(\n+      nodeB, buildShardMoveOutImpactVector(),\n+      nodeC, buildShardMoveInImpactVector()\n+  );\n+\n+  private Map<NodeKey, ImpactVector> moveShardImpact3 = ImmutableMap.of(\n+      nodeC, buildShardMoveOutImpactVector(),\n+      nodeA, buildShardMoveInImpactVector()\n+  );\n+\n+  @Before\n+  public void setup() {\n+    initMocks(this);\n+    this.testCollator = new Collator(impactAssessor, mockComparator, mockDecider1,\n+        mockDecider2);\n+    setupActions();\n+    setupDecisions();\n+  }\n+\n+  @Test\n+  public void testCollatorAcyclicImpactDecisions() {\n+    when(mockDecider1.getFlowUnits()).thenReturn(Collections.singletonList(decision1));\n+    when(mockDecider2.getFlowUnits()).thenReturn(Collections.singletonList(decision2));\n+    // fix some order for the test.\n+    when(mockComparator.compare(eq(moveShardAction1), eq(moveShardAction2))).thenReturn(-1);\n+\n+    Decision decision = testCollator.operate();\n+\n+    assertEquals(1, decision.getActions().size());\n+    assertEquals(moveShardAction2, decision.getActions().get(0));\n+  }\n+\n+  @Test\n+  public void testCollatorCyclicImpactDecisions() {\n+    when(decision1.getActions()).thenReturn(Arrays.asList(moveShardAction1, moveShardAction3));\n+    when(mockDecider1.getFlowUnits()).thenReturn(Collections.singletonList(decision1));\n+    when(mockDecider2.getFlowUnits()).thenReturn(Collections.singletonList(decision2));\n+    when(mockComparator.compare(any(Action.class), any(Action.class))).thenReturn(0);\n+    this.testCollator = new Collator(impactAssessor, new ImpactBasedActionComparator(),\n+        mockDecider1, mockDecider2);\n+\n+    Decision decision = testCollator.operate();\n+\n+    assertEquals(1, decision.getActions().size());\n+    assertEquals(moveShardAction3, decision.getActions().get(0));\n+  }\n+\n+  @Test\n+  public void testCollatorEmptyActions() {\n+    when(decision1.getActions()).thenReturn(Collections.emptyList());\n+    when(decision2.getActions()).thenReturn(Collections.emptyList());\n+    when(mockDecider1.getFlowUnits()).thenReturn(Collections.singletonList(decision1));\n+    when(mockDecider2.getFlowUnits()).thenReturn(Collections.singletonList(decision2));\n+    this.testCollator = new Collator(impactAssessor, new ImpactBasedActionComparator(),\n+        mockDecider1, mockDecider2);\n+\n+    Decision decision = testCollator.operate();\n+\n+    assertTrue(decision.getActions().isEmpty());\n+  }\n+\n+  @Test\n+  public void testNoDeciders() {\n+    testCollator = new Collator(impactAssessor, mockComparator);\n+\n+    final Decision decision = testCollator.operate();\n+\n+    assertTrue(decision.getActions().isEmpty());\n+  }\n+\n+  public void setupDecisions() {\n+    when(decision1.getActions())\n+        .thenReturn(Collections.singletonList(moveShardAction1));\n+    when(decision2.getActions())\n+        .thenReturn(Collections.singletonList(moveShardAction2));\n+  }\n+\n+  public void setupActions() {\n+    when(moveShardAction1.name()).thenReturn(moveShardActionName);\n+    when(moveShardAction1.impact()).thenReturn(moveShardImpact1);\n+    when(moveShardAction1.impactedNodes()).thenReturn(new ArrayList<>(moveShardImpact1.keySet()));\n+\n+    when(moveShardAction2.name()).thenReturn(moveShardActionName);\n+    when(moveShardAction2.impact()).thenReturn(moveShardImpact2);\n+    when(moveShardAction2.impactedNodes()).thenReturn(new ArrayList<>(moveShardImpact2.keySet()));\n+\n+    when(moveShardAction3.name()).thenReturn(moveShardActionName);\n+    when(moveShardAction3.impact()).thenReturn(moveShardImpact3);\n+    when(moveShardAction3.impactedNodes()).thenReturn(new ArrayList<>(moveShardImpact3.keySet()));\n+  }\n+\n+  public ImpactVector buildShardMoveOutImpactVector() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    impactVector.decreasesPressure(Dimension.CPU);\n+    impactVector.decreasesPressure(Dimension.HEAP);\n+\n+    return impactVector;\n+  }\n+\n+  public ImpactVector buildShardMoveInImpactVector() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    impactVector.increasesPressure(Dimension.CPU);\n+    impactVector.increasesPressure(Dimension.HEAP);\n+\n+    return impactVector;\n+  }\n+}", "originalCommit": "89192203ccbf5de8e465f9d95983bc2b54a991f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMDIzMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/332#discussion_r475930231", "bodyText": "Done.", "author": "ktkrg", "createdAt": "2020-08-24T22:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NjA0Ng=="}], "type": "inlineReview"}, {"oid": "a4fbb59871b67f761b04c16a3e80220c5524cb17", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/a4fbb59871b67f761b04c16a3e80220c5524cb17", "message": "Address review comments", "committedDate": "2020-08-24T21:46:08Z", "type": "commit"}]}