{"pr_number": 284, "pr_title": "[MOB-2046] - Setting up database", "pr_createdAt": "2020-11-12T01:53:24Z", "pr_url": "https://github.com/Iterable/iterable-android-sdk/pull/284", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MTk5Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r524471993", "bodyText": "I think this class has various levels of abstraction. It manages/create a database (low level), but also manages tasks. Tasks seem to be a higher level abstraction that may be better placed in its own class, especially if we're planning to use the database for other things in the future.", "author": "vbabenkoru", "createdAt": "2020-11-16T18:09:20Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableDataManager.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+public class IterableDataManager {\n+\n+    private static IterableDataManager sharedInstance;\n+\n+    private static final String TAG = \"IterableDataManager\";\n+    private static final String DATABASE_NAME = \"iterable_sdk.db\";\n+    private static final int DATABASE_VERSION = 1;\n+    private static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+\n+    private static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableDataManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableDataManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableDataManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    void createTask(String name) {", "originalCommit": "784ce12393d904547be5c4216a52a5eeefa11d76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "446e7d66f080c0b6fa4869bef7fd372d551c0dd2", "url": "https://github.com/Iterable/iterable-android-sdk/commit/446e7d66f080c0b6fa4869bef7fd372d551c0dd2", "message": "[MOB-2046] - Setting up database\n\n1. Created Datamanager\n2. Created DatabaseManager\n3. Created IterableTask class acting as dao for offline events", "committedDate": "2020-11-20T17:18:00Z", "type": "commit"}, {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "url": "https://github.com/Iterable/iterable-android-sdk/commit/2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "message": "Revision 1\n\n1. Renamed `IterableDataManager` to `IterableTaskManager`. Also renamed `IterableDatabaseManager` to `IterableTaskDatabaseManager`. For new modules needing database access, they can always use the SQLiteOpenHelper like `IterableTaskDatabaseManager`.\n2. Added more methods to IterableTaskManager to update the database entries for tasks.", "committedDate": "2020-11-20T17:19:09Z", "type": "commit"}, {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "url": "https://github.com/Iterable/iterable-android-sdk/commit/2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "message": "Revision 1\n\n1. Renamed `IterableDataManager` to `IterableTaskManager`. Also renamed `IterableDatabaseManager` to `IterableTaskDatabaseManager`. For new modules needing database access, they can always use the SQLiteOpenHelper like `IterableTaskDatabaseManager`.\n2. Added more methods to IterableTaskManager to update the database entries for tasks.", "committedDate": "2020-11-20T17:19:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjI4NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042284", "bodyText": "Remove", "author": "vbabenkoru", "createdAt": "2020-11-21T00:53:00Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -35,6 +38,7 @@\n      * {@link IterableApi} singleton instance\n      */\n     static volatile IterableApi sharedInstance = new IterableApi();\n+    private static IterableTaskManager dataManager;", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjMwNg==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042306", "bodyText": "Remove", "author": "vbabenkoru", "createdAt": "2020-11-21T00:53:06Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -307,6 +311,24 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n         IterablePushActionReceiver.processPendingAction(context);\n+\n+        //TODO: Temporary code to test. Datamanger would eventually either go to IterableRequest or apiInternal as architecture concretes.", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjU0Ng==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042546", "bodyText": "How/when is this going to be used?", "author": "vbabenkoru", "createdAt": "2020-11-21T00:54:25Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.iterable.iterableapi;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+class IterableTask {\n+\n+    //String columns as stored in DB\n+    static final String TASK_ID = \"task_id\";\n+    static final String NAME = \"name\";\n+    static final String VERSION = \"version\";\n+    static final String CREATED_AT = \"created\";\n+    static final String MODIFIED_AT = \"modified\";\n+    static final String LAST_ATTEMPTED_AT = \"last_attempt\";\n+    static final String SCHEDULED_AT = \"scheduled\";\n+    static final String REQUESTED_AT = \"requested\";\n+    static final String PROCESSING = \"processing\";\n+    static final String FAILED = \"failed\";\n+    static final String BLOCKING = \"blocking\";\n+    static final String DATA = \"data\";\n+    static final String ERROR = \"error\";\n+    static final String TYPE = \"type\";\n+    static final String ATTEMPTS = \"attempts\";\n+\n+    int currentVersion = 1;\n+\n+    String id; //uuid generated for each task when getting created\n+    String name;//name of the api\n+    int version;//version for the task? Not sure. replicating as on iOS\n+    Date createdAt;\n+    Date modifiedAt;\n+    Date lastAttemptedAt;\n+    Date scheduledAt;\n+    Date requestedAt;\n+\n+    Boolean processing;\n+    Boolean failed;\n+    Boolean blocking;\n+\n+    //TODO: Confirm if data and failure data would be String converted from JSONObjects.\n+    Object data;\n+    Object taskFailureData;\n+    IterableTaskType taskType;\n+    int attempts;\n+\n+    //To be used when creating IterableTask from database\n+    public IterableTask(String id, @NonNull String name, @NonNull int version, @NonNull Date createdAt, Date modifiedAt, Date lastAttemptedAt, Date scheduledAt, Date requestedAt, Boolean processing, Boolean failed, Boolean blocking, Object data, Object taskFailureData, IterableTaskType taskType, int attempts) {\n+\n+        this.id = id;\n+        this.name = name;\n+        this.version = version;\n+        this.createdAt = createdAt;\n+        this.modifiedAt = modifiedAt;\n+        this.lastAttemptedAt = lastAttemptedAt;\n+        this.scheduledAt = scheduledAt;\n+        this.requestedAt = requestedAt;\n+        this.processing = processing;\n+        this.failed = failed;\n+        this.blocking = blocking;\n+        this.data = data;\n+        this.taskFailureData = taskFailureData;\n+        this.taskType = taskType;\n+        this.attempts = attempts;\n+    }\n+\n+    //Bare minimum one to be used when creating the Task\n+    public IterableTask(String name, IterableTaskType taskType) {\n+\n+        this.id = UUID.randomUUID().toString();\n+        this.name = name;\n+        this.createdAt = new Date();\n+        this.scheduledAt = new Date();\n+        this.requestedAt = new Date();\n+        this.taskType = taskType;\n+\n+    }\n+\n+    IterableTask updateTask(int attempts, Date lastAttemptedAt, Boolean processing, Date scheduledAt, Object data, Object taskFailureData) {", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTY2Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491663", "bodyText": "Not gonna be used. Deleting.", "author": "Ayyanchira", "createdAt": "2020-11-23T06:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjcyMQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042721", "bodyText": "Is this designed just for the tasks? If we need to store something else, are we going to create a separate db or reuse this one?", "author": "vbabenkoru", "createdAt": "2020-11-21T00:55:10Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTM1Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491357", "bodyText": "Made it generic.. Creation of all the tables can go here in its onCreate", "author": "Ayyanchira", "createdAt": "2020-11-23T06:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Mjc5Ng==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042796", "bodyText": "Depending on the answer to above, we probably need to scope the name to tasks only, or rename the class itself.", "author": "vbabenkoru", "createdAt": "2020-11-21T00:55:35Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {\n+    private static final String DATABASE_NAME = \"iterable_sdk.db\";", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTU4NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491584", "bodyText": "Not changing the Iterable_sdk. Will keep it like this assuming we will need only one db and tables could be added in this class as feature set requiring table grows", "author": "Ayyanchira", "createdAt": "2020-11-23T06:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Mjc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzI4Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528043287", "bodyText": "Why is it using a class field vs. local variable for contentValues?", "author": "vbabenkoru", "createdAt": "2020-11-21T00:58:23Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTAwMA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491000", "bodyText": "had it referenced from a website previously.. having it local is safe and prevent possible data leak. Thanks. Made them local", "author": "Ayyanchira", "createdAt": "2020-11-23T06:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzQwMQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528043401", "bodyText": "Do we need to check for task count before running queries? I think in that case it'll just return nothing, which should be a valid return value.", "author": "vbabenkoru", "createdAt": "2020-11-21T00:59:05Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.FAILED, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    private Boolean updateTaskWithContentValues(String id) {\n+        int result = database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id});\n+        contentValues.clear();\n+        if (result > 0) return true;\n+        else return false;\n+    }\n+\n+    private boolean precheck() {\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return false;\n+        }\n+        if (getTaskCount() == 0) {", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MDcxNw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528490717", "bodyText": "Removing.. unnecessary overhead", "author": "Ayyanchira", "createdAt": "2020-11-23T06:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzQwMQ=="}], "type": "inlineReview"}, {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "url": "https://github.com/Iterable/iterable-android-sdk/commit/a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "message": "Revision 2\n\nRemove datamanger code task from IterableAPI.\nMade public methods in IterableTask package private.\nRemoved updateTask as its use case is not fit for our requirement.\nContentvalues is not a global variable and is a local method variable instead.\nRemoved unused enum.\nChanged the data and error to String\nAdded update Error method\nAdded update Data method\nAdded docs to all the methods\nRemove getCount from precheck", "committedDate": "2020-11-23T06:26:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE1NzEzNQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529157135", "bodyText": "What are the required fields for createTask? Are type and data required? If so, they should be arguments for this function.", "author": "vbabenkoru", "createdAt": "2020-11-24T02:31:08Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE1Nzg1NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529157855", "bodyText": "Add nullability annotations to methods in this class", "author": "vbabenkoru", "createdAt": "2020-11-24T02:31:54Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NjY4Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529166683", "bodyText": "Is there a datetime type we can use?", "author": "vbabenkoru", "createdAt": "2020-11-24T02:51:04Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2NjY4Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529866683", "bodyText": "No it seems.\nhttps://sqlite.org/datatype3.html#date_and_time_datatype", "author": "Ayyanchira", "createdAt": "2020-11-24T20:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NjY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzMyNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167324", "bodyText": "Return an empty array if the check failed", "author": "vbabenkoru", "createdAt": "2020-11-24T02:53:08Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzUyNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167524", "bodyText": "What do we need this for?", "author": "vbabenkoru", "createdAt": "2020-11-24T02:53:48Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2Njc3MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529866770", "bodyText": "Just a left over method I thought could be useful. Will remove", "author": "Ayyanchira", "createdAt": "2020-11-24T20:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzgxMA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167810", "bodyText": "incrementAttempts?", "author": "vbabenkoru", "createdAt": "2020-11-24T02:54:35Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2Nzk2MQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167961", "bodyText": "Can we extract this line into a separate method? Looks like we're doing the same thing for every update method.", "author": "vbabenkoru", "createdAt": "2020-11-24T02:55:01Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529168398", "bodyText": "I think this should have a clearer name: isDatabaseReady/isDatabaseAvailable or something like that.", "author": "vbabenkoru", "createdAt": "2020-11-24T02:56:16Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    private boolean precheck() {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2NzM0NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529867344", "bodyText": "isOpen and inTransaction() can be a good check to have \ud83d\udc4d", "author": "Ayyanchira", "createdAt": "2020-11-24T20:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MTc1NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529971755", "bodyText": "Looks like it still has the same name. inTransaction I think is not a good name as it would imply it's in an SQL transaction, and this code doesn't use transactions.", "author": "vbabenkoru", "createdAt": "2020-11-24T22:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NDY1Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529974657", "bodyText": "Basically I don't know what precheck does without looking at its code. Ideally the name should tell what it checks for (in high level terms).", "author": "vbabenkoru", "createdAt": "2020-11-24T22:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MzM0MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529993340", "bodyText": "oh I misread the comment made. I thought you were suggesting of having additional checks inside the method precheck \ud83e\udd26\u200d\u2642\ufe0f .. my bad", "author": "Ayyanchira", "createdAt": "2020-11-24T23:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI0ODA3MQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529248071", "bodyText": "Ideally this should not have an implicit dependency on IterableApi.. One alternative is to just pass Context around in the constructor and in sharedInstance.", "author": "vbabenkoru", "createdAt": "2020-11-24T07:15:01Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTAzNw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529969037", "bodyText": "@NonNull", "author": "vbabenkoru", "createdAt": "2020-11-24T22:54:02Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {", "originalCommit": "42f6e0900fd0061b134ca93817fb444cfce78e07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTI5NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529969295", "bodyText": "Why Boolean and not boolean?", "author": "vbabenkoru", "createdAt": "2020-11-24T22:54:17Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (!precheck()) return taskIds;\n+\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {", "originalCommit": "42f6e0900fd0061b134ca93817fb444cfce78e07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNDYwOQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530004609", "bodyText": "No particular reason to choose Boolean. Changing it to primitive to keep it simple and consistent.", "author": "Ayyanchira", "createdAt": "2020-11-24T23:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MjY3MQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529972671", "bodyText": "Why is it calling a method (precheck) elsewhere and using a direct check here?", "author": "vbabenkoru", "createdAt": "2020-11-24T22:57:32Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {", "originalCommit": "42f6e0900fd0061b134ca93817fb444cfce78e07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b7b41d296afa01efb4989798b00a4ac98705661", "url": "https://github.com/Iterable/iterable-android-sdk/commit/7b7b41d296afa01efb4989798b00a4ac98705661", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean", "committedDate": "2020-11-24T23:34:29Z", "type": "forcePushed"}, {"oid": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "url": "https://github.com/Iterable/iterable-android-sdk/commit/473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean", "committedDate": "2020-11-24T23:46:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzODA3OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530038079", "bodyText": "type is not used anywhere. Is it needed?", "author": "vbabenkoru", "createdAt": "2020-11-25T00:51:18Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+        if (!isDatabaseReady()) return null;\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        if (!isDatabaseReady()) return null;\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));", "originalCommit": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzODI4Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530038283", "bodyText": "Catch Exception instead of Throwable\nSee CodeClimate: https://codeclimate.com/github/Iterable/iterable-android-sdk/pull/284#", "author": "vbabenkoru", "createdAt": "2020-11-25T00:51:59Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {", "originalCommit": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "76d84007dd3243326de0c20003e1951154527a42", "url": "https://github.com/Iterable/iterable-android-sdk/commit/76d84007dd3243326de0c20003e1951154527a42", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean\n9. inlcude type in constructor instead of hardcoded API type.\n10. Handle SQLException instead of just throwable t when getting writeable database.", "committedDate": "2020-11-25T16:43:49Z", "type": "commit"}, {"oid": "76d84007dd3243326de0c20003e1951154527a42", "url": "https://github.com/Iterable/iterable-android-sdk/commit/76d84007dd3243326de0c20003e1951154527a42", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean\n9. inlcude type in constructor instead of hardcoded API type.\n10. Handle SQLException instead of just throwable t when getting writeable database.", "committedDate": "2020-11-25T16:43:49Z", "type": "forcePushed"}]}