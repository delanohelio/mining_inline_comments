{"pr_number": 4659, "pr_title": "DB-10719 add unit tests for foreign key dependency checker.", "pr_createdAt": "2020-11-19T19:29:30Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4659", "timeline": [{"oid": "4352fc8ecd16198ae0f6132db4dc08e46c09a2ce", "url": "https://github.com/splicemachine/spliceengine/commit/4352fc8ecd16198ae0f6132db4dc08e46c09a2ce", "message": "DB-10719 add unit tests for foreign key dependency checker.", "committedDate": "2020-11-19T19:24:26Z", "type": "commit"}, {"oid": "fff2e24638b39ab79fbfa6c7491ca5218b9eb339", "url": "https://github.com/splicemachine/spliceengine/commit/fff2e24638b39ab79fbfa6c7491ca5218b9eb339", "message": "DB-10719 small refactoring.", "committedDate": "2020-11-19T19:36:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1NzY4NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4659#discussion_r527157685", "bodyText": "Is this a legitimate issue on the current version? What kind of failures would it cause if so?", "author": "dgomezferro", "createdAt": "2020-11-19T19:52:49Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/foreignkey/Graph.java", "diffHunk": "@@ -208,6 +208,7 @@ public void removeEdge(int from, int to) {\n                     edgeNode.next = null; // bye, GC.\n                     return;\n                 }\n+                previous = edgeNode;", "originalCommit": "fff2e24638b39ab79fbfa6c7491ca5218b9eb339", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3MzQxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4659#discussion_r527173413", "bodyText": "Yes it is, it causes the graph to miss some edges (which leads to incorrect conclusions about the validity of the graph). Since we're not updating previous correctly, we end up removing the wrong edge (line 207). Here is an example that exposes this bug:\ndigraph {\n  C -> A[label=\"Restrict\"];\n  A -> B[label=\"Cascade\"];\n  C -> A[label=\"SetNull\"];\n  B -> C[label=\"Cascade\"];\n}\n\nIn this graph, adding the final edge B -> C causes two cycles to appear:\n\nA -Cascade-> B -Cascade-> C -SetNull-> A\nA -Cascade-> B -Cascade-> C -Restrict-> A\n\nWe remove the first cycle by rerouting C-SetNull->A to surrogate node C-SetNull->S_A_0. At this point, the edge list for node C looks something like this:\n'C' -> 'S_A_0 (setnull)' -> 'A (restrict)'.\nNow, we try check again if we have a cycle (line 124), and we find that we have another one: A -Cascade-> B -Cascade-> C -Restrict-> A. So now we reroute C -Restrict-> A to a new surrogate node C -Restrict->S_A_1. (at this point, the edge list for node C will be 'C' -> 'S_A_1 (restrict)' -> 'S_A_0 (setnull)' -> 'A (restrict)') And we attempt to remove the edge between C and A (line 122).\nHere is where we hit the problem, when removeEdge is called we set the previous to edge 'S_A_1 (restrict)', and we don't update it anymore, so when we find the edge to remove, we end removing this edge instead of the edge 'A (restrict)', therefore we end up building a different graph which happens to be OK.", "author": "hatyo", "createdAt": "2020-11-19T20:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1NzY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NDEzNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4659#discussion_r527174136", "bodyText": "The failure it causes is accepting invalid graphs, I think this is unlikely to happen with customers who are migrating schemas from other DBMS to SpliceMachine because these schemas are most of the time valid.", "author": "hatyo", "createdAt": "2020-11-19T20:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1NzY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1Mjc1Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4659#discussion_r528952757", "bodyText": "Maybe use LANG_DELETE_RULE_VIOLATION instead of 42915.", "author": "msirek", "createdAt": "2020-11-23T19:43:01Z", "path": "db-engine/src/test/java/com/splicemachine/db/iapi/sql/dictionary/foreignkey/GraphTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.foreignkey;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import splice.com.google.common.collect.Lists;\n+\n+import java.util.*;\n+import java.util.stream.IntStream;\n+\n+@RunWith(Enclosed.class)\n+public class GraphTest {\n+\n+    interface PermuteClosure {\n+        void call(List<String> permutation) throws StandardException;\n+    }\n+\n+    static void permute(List<String> input, int k, PermuteClosure action) throws StandardException {\n+        if (k == 1) {\n+            action.call(input);\n+        }\n+        for (int i = 0; i < k; ++i) {\n+            permute(input, k - 1, action);\n+            if (i < k - 1) {\n+                if (k % 2 == 0) {\n+                    Collections.swap(input, i, k - 1);\n+                } else {\n+                    Collections.swap(input, 0, input.size() - 1);\n+                }\n+            }\n+        }\n+    }\n+\n+    static List<String> permute(String graphviz) throws StandardException {\n+        final List<String> edges = Lists.newArrayList(graphviz.split(\"\\n\"));\n+        final String header = edges.remove(0);\n+        final String footer = edges.remove(edges.size() - 1);\n+        final List<String> result = new ArrayList<>(IntStream.rangeClosed(1, edges.size()).reduce(1, (int x, int y) -> x * y));\n+        result.add(graphviz);\n+        permute(edges, edges.size(), permutation -> {\n+            StringBuilder permutedGraph = new StringBuilder(header);\n+            for (String edge : permutation) {\n+                permutedGraph.append(edge);\n+            }\n+            permutedGraph.append(footer);\n+            result.add(permutedGraph.toString());\n+        });\n+        return result;\n+    }\n+\n+    static class NegativeTestCase {\n+        final String graph;\n+        final String pathA;\n+        final String pathB;\n+        final String deleteActionA;\n+        final String deleteActionB;\n+        final String table;\n+\n+        NegativeTestCase(String graph, String table, String pathA, String deleteActionA, String pathB, String deleteActionB) {\n+            this.graph = graph;\n+            this.pathA = pathA;\n+            this.pathB = pathB;\n+            this.deleteActionA = deleteActionA;\n+            this.deleteActionB = deleteActionB;\n+            this.table = table;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return graph;\n+        }\n+    }\n+\n+    @RunWith(Parameterized.class)\n+    public static class NegativeTests {\n+\n+        private static Collection<Object[]> parameters = Lists.newArrayListWithCapacity(100);\n+\n+        private static void addCase(String graph, String table, String pathA, String deleteActionA, String pathB, String deleteActionB) throws StandardException {\n+            parameters.add(new Object[]{new NegativeTestCase(graph, table, pathA, deleteActionA, pathB, deleteActionB)});\n+            List<String> invalidGraph1Permutations = permute(graph);\n+            for (String permutedGraph : invalidGraph1Permutations) {\n+                parameters.add(new Object[]{new NegativeTestCase(permutedGraph, table, pathA, deleteActionA, pathB, deleteActionB)});\n+            }\n+        }\n+\n+        @Parameterized.Parameters(name = \"negative case --- {0}\")\n+        public static Collection<Object[]> data() throws StandardException {\n+            addCase(\"digraph {\\n\" +\n+                            \"A -> B[label=\\\"Cascade\\\"];\\n\" +\n+                            \"B -> C[label=\\\"Cascade\\\"];\\n\" +\n+                            \"C -> A[label=\\\"SetNull\\\"];\\n\" +\n+                            \"C -> A[label=\\\"Restrict\\\"];\\n\" +\n+                            \"}\", \"C\", \"A\", \"SetNull\", \"A\", \"Restrict\");\n+            addCase(\"digraph {\\n\" +\n+                            \"T2 -> T1[label=\\\"Cascade\\\"];\\n\" +\n+                            \"T3 -> T1[label=\\\"Cascade\\\"];\\n\" +\n+                            \"T6 -> T2[label=\\\"Cascade\\\"];\\n\" +\n+                            \"T7 -> T6[label=\\\"Cascade\\\"];\\n\" +\n+                            \"T7 -> T4[label=\\\"SetNull\\\"];\\n\" +\n+                            \"T4 -> T3[label=\\\"Cascade\\\"];\\n\" +\n+                            \"}\", \"T7\", \"T1 T2 T6\", \"Cascade\", \"T1 T3 T4\", \"SetNull\");\n+            addCase(\"digraph {\\n\" +\n+                            \"B -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"C -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"D -> B[label=\\\"Cascade\\\"];\\n\" +\n+                            \"D -> C[label=\\\"SetNull\\\"];\\n\" +\n+                            \"}\", \"D\", \"A C\", \"SetNull\", \"A B\", \"Cascade\");\n+            addCase(\"digraph {\\n\" +\n+                            \"A -> B[label=\\\"Cascade\\\"];\\n\" +\n+                            \"A -> B[label=\\\"SetNull\\\"];\\n\" +\n+                            \"}\", \"A\", \"B\", \"SetNull\", \"B\", \"Cascade\");\n+            addCase(\"digraph {\\n\" +\n+                            \"B -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"C -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"D -> B[label=\\\"Cascade\\\"];\\n\" +\n+                            \"D -> C[label=\\\"SetNull\\\"];\\n\" +\n+                            \"}\", \"D\", \"A C\", \"SetNull\", \"A B\", \"Cascade\");\n+            return parameters;\n+        }\n+\n+        public NegativeTests(NegativeTestCase negativeTestCase) {\n+            this.negativeTestCase = negativeTestCase;\n+        }\n+\n+        NegativeTestCase negativeTestCase;\n+\n+        @Test\n+        public void testcase() throws Exception {\n+            Graph graph = new GraphvizParser\n+                    (negativeTestCase.graph).generateGraph(\"something\");\n+\n+            GraphAnnotator annotater = new GraphAnnotator(\"something\", graph);\n+            annotater.annotate();\n+            try {\n+                annotater.analyzeAnnotations();\n+                Assert.fail(\"the annotator should have failed with error containing: adding this foreign key leads to the conflicting delete actions on the table ...\");\n+            } catch (Exception e) {\n+                Assert.assertTrue(e instanceof StandardException);\n+                StandardException sqlException = (StandardException) e;\n+                Assert.assertEquals(\"42915\", sqlException.getSQLState());\n+                Assert.assertTrue(sqlException.getMessage().contains(\"adding this foreign key leads to the conflicting delete actions on the table '\" + negativeTestCase.table + \"'\"));\n+                Assert.assertTrue(sqlException.getMessage().contains(negativeTestCase.pathA + \" (delete action: \" + negativeTestCase.deleteActionA + \")\"));\n+                Assert.assertTrue(sqlException.getMessage().contains(negativeTestCase.pathB + \" (delete action: \" + negativeTestCase.deleteActionB + \")\"));\n+            }\n+        }\n+    }\n+\n+    @RunWith(Parameterized.class)\n+    public static class PositiveTests {\n+\n+        private static Collection<Object[]> parameters = Lists.newArrayListWithCapacity(100);\n+\n+        private static void addCase(String graph) throws StandardException {\n+            parameters.add(new Object[]{graph});\n+            List<String> validGraphPermutations = permute(graph);\n+            for (String permutedGraph : validGraphPermutations) {\n+                parameters.add(new Object[]{permutedGraph});\n+            }\n+        }\n+\n+        @Parameterized.Parameters(name = \"positive case --- {0}\")\n+        public static Collection<Object[]> data() throws StandardException {\n+            addCase(\"digraph {\\n\" +\n+                            \"A -> B[label=\\\"Cascade\\\"];\\n\" +\n+                            \"A -> B[label=\\\"Cascade\\\"];\\n\" +\n+                            \"}\");\n+            addCase(\"digraph {\\n\" +\n+                            \"B -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"C -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"D -> B[label=\\\"Cascade\\\"];\\n\" +\n+                            \"D -> C[label=\\\"Cascade\\\"];\\n\" +\n+                            \"}\");\n+            addCase(\"digraph {\\n\" +\n+                            \"A -> B[label=\\\"SetNull\\\"];\\n\" +\n+                            \"C -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"B -> C[label=\\\"NoAction\\\"];\\n\" +\n+                            \"}\");\n+            addCase(\"digraph {\\n\" +\n+                            \"D -> A[label=\\\"SetNull\\\"];\\n\" +\n+                            \"D -> C[label=\\\"Cascade\\\"];\\n\" +\n+                            \"C -> B[label=\\\"Restrict\\\"];\\n\" +\n+                            \"B -> A[label=\\\"Cascade\\\"];\\n\" +\n+                            \"}\");\n+            return parameters;\n+        }\n+\n+        public PositiveTests(String graph) {\n+            this.graph = graph;\n+        }\n+\n+        String graph;\n+\n+        @Test\n+        public void testcase() throws Exception {\n+            Graph g = new GraphvizParser(graph).generateGraph(\"something\");\n+            GraphAnnotator annotator = new GraphAnnotator(\"something\", g);\n+            annotator.annotate();\n+            annotator.analyzeAnnotations();\n+        }\n+    }\n+\n+    public static class NonParameterizedTests {\n+        @Test\n+        public void invalidGraphIsDetectedProperlyCase5() { // invalid cascade cycle\n+            try {\n+                new GraphvizParser\n+                        (\"digraph {\\n\" +\n+                                 \"A -> B[label=\\\"Cascade\\\"];\\n\" +\n+                                 \"B -> C[label=\\\"Cascade\\\"];\\n\" +\n+                                 \"C -> A[label=\\\"Cascade\\\"];\\n\" +\n+                                 \"}\").generateGraph(\"something\");\n+                Assert.fail(\"expected graph creation to fail with error message: adding the constraint between A and C would cause the following \" +\n+                                    \"illegal delete action cascade cycle A B C\");\n+            } catch (Exception e) {\n+                Assert.assertTrue(e instanceof StandardException);\n+                StandardException sqlException = (StandardException) e;\n+                Assert.assertEquals(\"42915\", sqlException.getSQLState());", "originalCommit": "fff2e24638b39ab79fbfa6c7491ca5218b9eb339", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMDY5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4659#discussion_r529710693", "bodyText": "Thanks! will keep that in mind when adding more fixes to FKs.", "author": "hatyo", "createdAt": "2020-11-24T16:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1Mjc1Nw=="}], "type": "inlineReview"}]}