{"pr_number": 3905, "pr_title": "DB-9883 spliceck - HBase/Splice Support Tool", "pr_createdAt": "2020-07-29T16:33:13Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3905", "timeline": [{"oid": "25b19eb749abb437cec1f2019da636430ede2794", "url": "https://github.com/splicemachine/spliceengine/commit/25b19eb749abb437cec1f2019da636430ede2794", "message": "DB-9883 implement API for print HBase row.", "committedDate": "2020-07-22T15:55:01Z", "type": "commit"}, {"oid": "31e93781e170139cc9e1f906325012cf9aa72406", "url": "https://github.com/splicemachine/spliceengine/commit/31e93781e170139cc9e1f906325012cf9aa72406", "message": "Merge remote-tracking branch 'origin/master' into DB-9883", "committedDate": "2020-07-24T17:06:19Z", "type": "commit"}, {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "url": "https://github.com/splicemachine/spliceengine/commit/a1b39e822872ffbab0c544cb9c20ab3fe9926536", "message": "DB-9883 first version of spliceck.\n\n- tlist, rget, tschema, tableof, regionof commands are implemented.", "committedDate": "2020-07-29T18:00:47Z", "type": "commit"}, {"oid": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "url": "https://github.com/splicemachine/spliceengine/commit/a1b39e822872ffbab0c544cb9c20ab3fe9926536", "message": "DB-9883 first version of spliceck.\n\n- tlist, rget, tschema, tableof, regionof commands are implemented.", "committedDate": "2020-07-29T18:00:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDkwOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462584908", "bodyText": "note: mostly whitespace changes", "author": "martinrupp", "createdAt": "2020-07-29T20:58:58Z", "path": "db-tools-ij/src/main/java/com/splicemachine/db/impl/tools/ij/Main.java", "diffHunk": "@@ -55,220 +49,192 @@\n  * If it is not an ij command, it is treated as a JSQL\n  * statement and executed against the current connection.\n  * ijParser controls the current connection, and so contains\n- * all of the state information for executing JSQL statements.\n+ * all the state information for executing JSQL statements.\n  * <p>\n  * This was written to facilitate a test harness for language\n  * functionality tests.\n- *\n- *\n  */\n public class Main {\n-\tprivate utilMain utilInstance;\n-\n-\t/**\n-\t * ij can be used directly on a shell command line through\n-\t * its main program.\n-\t * @param args allows 1 file name to be specified, from which\n-\t *    input will be read; if not specified, stdin is used.\n-\t */\n-\tpublic static void main(String[] args)\t\n-\t\tthrows IOException \n-\t{\n-\t\tmainCore(args, new Main(true));\n-\t}\n+    private utilMain utilInstance;\n \n-\tpublic static void mainCore(String[] args, Main main)\n-\t\tthrows IOException \n-\t{\n-\t\tLocalizedInput in = null;\n-\t\tInputStream in1 = null;\n-\t\tMain me;\n-\t\tString file;\n-\t\tString inputResourceName;\n-\n-\t\tLocalizedResource langUtil = LocalizedResource.getInstance();\n-\t\tLocalizedOutput out = langUtil.getNewOutput(System.out);\n-\n-                // Validate arguments, check for --help.\n-\t\tif (util.invalidArgs(args)) {\n-\t\t\tutil.Usage(out);\n-      \t\treturn;\n-\t\t}\n-\n-\t\t// load the property file if specified\n-\t\tutil.getPropertyArg(args);\n-\n-\t\t// readjust output to db.ui.locale and db.ui.codeset if\n-                // they were loaded from a property file.\n-\t\tlangUtil.init();\n-\t\tout = langUtil.getNewOutput(System.out);\n-                main.initAppUI();\n-\n-\t\tfile = util.getFileArg(args);\n-\t\tinputResourceName = util.getInputResourceNameArg(args);\n-\t\tif (inputResourceName != null) {\n-\t\t\tin = langUtil.getNewInput(util.getResourceAsStream(inputResourceName));\n-\t\t\tif (in == null) {\n-\t\t\t\tout.println(langUtil.getTextMessage(\"IJ_IjErroResoNo\",inputResourceName));\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t} else if (file == null) {\n-\t\t\tin = langUtil.getNewInput(System.in);\n-                        out.flush();\n-    \t        } else {\n+    /**\n+     * ij can be used directly on a shell command line through\n+     * its main program.\n+     *\n+     * @param args allows 1 file name to be specified, from which\n+     *  input will be read; if not specified, stdin is used.\n+     */\n+    public static void main(String[] args)\n+            throws IOException {\n+        mainCore(args, new Main(true));\n+    }\n+\n+    public static void mainCore(String[] args, Main main)\n+            throws IOException {\n+        LocalizedResource langUtil = LocalizedResource.getInstance();\n+        LocalizedOutput out = langUtil.getNewOutput(System.out);\n+        // Validate arguments, check for --help.\n+        if (util.invalidArgs(args)) {\n+            util.Usage(out);\n+            return;\n+        }\n+\n+        // load the property file if specified\n+        util.getPropertyArg(args);\n+\n+        // readjust output to db.ui.locale and db.ui.codeset if\n+        // they were loaded from a property file.\n+        langUtil.init();\n+        out = langUtil.getNewOutput(System.out);\n+        main.initAppUI();", "originalCommit": "25b19eb749abb437cec1f2019da636430ede2794", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzNTcyMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464535723", "bodyText": "I reverted the changes done to this file since it is not relevant to this PR.", "author": "hatyo", "createdAt": "2020-08-03T16:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjE0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462586146", "bodyText": "(minor comment) tab/space alignment looks off", "author": "martinrupp", "createdAt": "2020-07-29T21:01:16Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSCOLUMNSRowFactory.java", "diffHunk": "@@ -60,17 +60,17 @@\n public class SYSCOLUMNSRowFactory extends CatalogRowFactory {\n     public static final String\t\tTABLENAME_STRING = \"SYSCOLUMNS\";\n \n-    protected static final int\t\tSYSCOLUMNS_COLUMN_COUNT = 13;\n+    public static final int\t\tSYSCOLUMNS_COLUMN_COUNT = 13;\n \t/* Column #s for syscolumns (1 based) */\n \n     //TABLEID is an obsolete name, it is better to use\n     //REFERENCEID, but to make life easier you can use either\n     protected static final int\t\tSYSCOLUMNS_TABLEID = 1;\n-    protected static final int\t\tSYSCOLUMNS_REFERENCEID = 1;\n-    protected static final int\t\tSYSCOLUMNS_COLUMNNAME = 2;\n-    protected static final int\t\tSYSCOLUMNS_COLUMNNUMBER = 3;\n+    public static final int\t\tSYSCOLUMNS_REFERENCEID = 1;\n+    public static final int\t\tSYSCOLUMNS_COLUMNNAME = 2;\n+    public static final int\t\tSYSCOLUMNS_COLUMNNUMBER = 3;\n     protected static final int\t\tSYSCOLUMNS_STORAGECOLUMNNUMBER = 4;\n-    protected static final int\t\tSYSCOLUMNS_COLUMNDATATYPE = 5;\n+    public static final int\t\tSYSCOLUMNS_COLUMNDATATYPE = 5;", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzNjIzOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464536239", "bodyText": "I wouldn't fix it here since it would make this change even bigger, I can do it later in a more focused refactoring change.", "author": "hatyo", "createdAt": "2020-08-03T16:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjU3OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462586578", "bodyText": "please use line breaks (80-100 columns max i would say)", "author": "martinrupp", "createdAt": "2020-07-29T21:02:03Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSCOLUMNSRowFactory.java", "diffHunk": "@@ -208,27 +208,33 @@ public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent) throws Standa\n \n \t\t    /* Build the row to insert  */\n         row = getExecutionFactory().getValueRow(SYSCOLUMNS_COLUMN_COUNT);\n+        setRowColumns(row, colName, defaultID, tabID, colID, storageNumber, typeDesc, defaultSerializable, autoincStart,\n+                autoincInc, autoincValue, partitionPosition, autoinc_create_or_modify_Start_Increment, collectStats, useExtrapolation);\n \n-\t\t    /* 1st column is REFERENCEID (UUID - char(36)) */\n+        return row;\n+    }\n+\n+    public static void setRowColumns(ExecRow row, String colName, String defaultID, String tabID, Integer colID, Integer storageNumber, TypeDescriptor typeDesc, Object defaultSerializable, long autoincStart, long autoincInc, long autoincValue, int partitionPosition, long autoinc_create_or_modify_Start_Increment, boolean collectStats, byte useExtrapolation) {", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzNjgyNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464536825", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-03T16:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NzYxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462587613", "bodyText": "are these... tabs? ;-)", "author": "martinrupp", "createdAt": "2020-07-29T21:03:54Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java", "diffHunk": "@@ -257,6 +257,27 @@ public ExecRow makeRow(TupleDescriptor td,\n \t\t/* Build the row to insert  */\n \t\trow = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n \n+\t\tsetRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n+\t\t\t\tdelimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows);\n+\t\treturn row;\n+\t}\n+\n+\tpublic static void setRowColumns(ExecRow row,\n+\t\t\t\t\t\t\t\t\t String tableID,", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0MDIwMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464540203", "bodyText": ":) yeah, the whole file uses tabs and my IDE is smart enough to follow whatever whitespace convention the file has, I would leave it as-is for now. Should do a major refactoring to all these files to follow a consistent style.", "author": "hatyo", "createdAt": "2020-08-03T16:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NzYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MjAzMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462592031", "bodyText": "maybe \"\"\" + value + \"\"\", to differentiate the string \"NULL\" from NULL ?\nAnd maybe also escape strings? Not sure how \"pro\" this needs to be\nif( value == null )\n  return \"NULL\";\n\nreturn \"\\\"\" + value.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\";", "author": "martinrupp", "createdAt": "2020-07-29T21:12:06Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NzIwNA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464557204", "bodyText": "that could get more complicated for its purpose, also we could easily make things more confusing if we tamper with the original values therefore I wouldn't do any escaping myself. Instead maybe we can give the user the option to tell us how nulls should look like. I would rather leave it as is at the moment.", "author": "hatyo", "createdAt": "2020-08-03T17:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MjAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDIxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594213", "bodyText": "tableName", "author": "martinrupp", "createdAt": "2020-07-29T21:16:29Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NzgwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464557802", "bodyText": "done. I use instead of index number a properly named integer constant.\npublic String regionOf(String tableName) throws Exception {\n        Utils.Tabular results = getListTables();\n        Utils.Tabular.Row row = results.rows.stream().filter(result -> result.cols.get(TBL_TABLES_NAME_IDX).equals(tableName)\n                && result.cols.get(TBL_TABLES_INDEX_IDX).equals(NULL)).min((l, r) -> Long.compare(Long.parseLong(r.cols.get(TBL_TABLES_CREATE_TXN_IDX)),\n                Long.parseLong(l.cols.get(TBL_TABLES_CREATE_TXN_IDX)))).orElseThrow(TableNotFoundException::new);\n        assert row.cols.size() > 0;\n        return row.cols.get(TBL_TABLES_HBASE_NAME_IDX);\n    }", "author": "hatyo", "createdAt": "2020-08-03T17:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDcyNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594725", "bodyText": "index? isn't that transactionId?", "author": "martinrupp", "createdAt": "2020-07-29T21:17:25Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1ODY0Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464558643", "bodyText": "Actually yes, it is the index, in hbase one could find many tables sharing the same table name (as far as I understand, base table and its indices share the same name), one way to tell which one is the base table is by checking that it doesn't have an index name.", "author": "hatyo", "createdAt": "2020-08-03T17:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDgxNA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594814", "bodyText": "schemaName?", "author": "martinrupp", "createdAt": "2020-07-29T21:17:39Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);\n+        if (r == null) {\n+            throw new TableNotFoundException();\n+        } else {\n+            return r.cols.get(0);\n+        }\n+    }\n+\n+    public String getSpliceTableNameOf(String regionName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(0 /*name*/).equals(regionName)", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1ODkwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464558909", "bodyText": "dito.\n    public String tableOf(String regionName) throws Exception {\n        Utils.Tabular tables = getListTables();\n        Utils.Tabular.Row r = tables.rows.stream().filter(result -> result.cols.get(TBL_TABLES_HBASE_NAME_IDX).equals(regionName)\n                && result.cols.get(TBL_TABLES_INDEX_IDX).equals(NULL)).findAny().orElseThrow(TableNotFoundException::new);\n        return r.cols.get(TBL_TABLES_NAME_IDX);\n    }", "author": "hatyo", "createdAt": "2020-08-03T17:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDg5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462594891", "bodyText": "transactionId?", "author": "martinrupp", "createdAt": "2020-07-29T21:17:50Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/HBaseInspector.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.ck.decoder.SysColsDataDecoder;\n+import com.splicemachine.ck.decoder.SysTableDataDecoder;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.ck.decoder.UserDefinedDataDecoder;\n+import com.splicemachine.ck.visitor.CellPrinter;\n+import com.splicemachine.ck.visitor.ICellVisitor;\n+import com.splicemachine.db.catalog.types.TypeDescriptorImpl;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.catalog.SYSCOLUMNSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.SYSTABLESRowFactory;\n+import com.splicemachine.si.constants.SIConstants;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.*;\n+import org.apache.hadoop.hbase.client.*;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class HBaseInspector {\n+\n+    private Configuration config;\n+\n+    public HBaseInspector(Configuration config) {\n+        this.config = config;\n+    }\n+\n+    public static class ScanPrinter implements AutoCloseable {\n+        @Override\n+        public void close() {\n+        }\n+\n+        public void ProcessRow(Result r, ICellVisitor visitor) throws Exception {\n+            CellScanner scanner = r.cellScanner();\n+            while (scanner.advance()) {\n+                Cell cell = scanner.current();\n+                visitor.visit(cell);\n+            }\n+        }\n+    }\n+\n+    public String scanRow(String region, String rowKey, Utils.SQLType[] schema) throws Exception {\n+        StringBuilder result = new StringBuilder();\n+        try {\n+            try (Connection conn = ConnectionFactory.createConnection(config)) {\n+                Table table = conn.getTable(TableName.valueOf(region));\n+                Scan scan = new Scan();\n+                scan.withStartRow(Bytes.fromHex(rowKey)).setLimit(1).readAllVersions();\n+                try (ResultScanner results = table.getScanner(scan)) {\n+                    ScanPrinter scanner = new ScanPrinter();\n+                    CellPrinter cellPrinter = new CellPrinter(new UserDefinedDataDecoder(schema, 4));\n+                    for (Result r : results) {\n+                        scanner.ProcessRow(r, cellPrinter);\n+                        result.append(cellPrinter.getOutput());\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            return Utils.checkException(e, region);\n+        }\n+        return result.toString();\n+    }\n+\n+    private Utils.Tabular getListTables() throws Exception {\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            List<TableDescriptor> descriptors = conn.getAdmin().listTableDescriptors(Pattern.compile(\"splice.*\"));\n+\n+            Utils.Tabular tabular = new Utils.Tabular(\"hbase name\", \"schema\", \"table\", \"index\", \"create txn\");\n+            for (TableDescriptor td : descriptors) {\n+                tabular.addRow(CheckNull(td.getTableName().toString()),\n+                        CheckNull(td.getValue(SIConstants.SCHEMA_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TABLE_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.INDEX_DISPLAY_NAME_ATTR)),\n+                        CheckNull(td.getValue(SIConstants.TRANSACTION_ID_ATTR)));\n+            }\n+            return tabular;\n+        }\n+    }\n+\n+    private String CheckNull(String value) {\n+        return value == null ? \"NULL\" : value;\n+    }\n+\n+    public String listTables() throws Exception {\n+        return Utils.printTabularResults(getListTables());\n+    }\n+\n+    public Utils.Tabular schemaOf(String table) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSTABLESRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table hbaseTable = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = hbaseTable.getScanner(scan)) {\n+                final ValContainer<Pair<Long, String>> tableId = new ValContainer<>(null);\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysTableDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (table.equals(er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLENAME).getString())) {\n+                                if (tableId.get() == null || (tableId.get() != null && tableId.get().getFirst() < userData.getTimestamp())) {\n+                                    tableId.set(new Pair<>(userData.getTimestamp(), er.getColumn(SYSTABLESRowFactory.SYSTABLES_TABLEID).getString()));\n+                                }\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                if (tableId.get() == null) {\n+                    throw new TableNotFoundException();\n+                }\n+                return constructSchemaFromSysColsTable(tableId.get().getSecond());\n+            }\n+        }\n+    }\n+\n+    private Utils.Tabular constructSchemaFromSysColsTable(String tableId) throws Exception {\n+        String systableId = getHbaseRegionOf(SYSCOLUMNSRowFactory.TABLENAME_STRING);\n+        try (Connection conn = ConnectionFactory.createConnection(config)) {\n+            Table table = conn.getTable(TableName.valueOf(systableId));\n+            Scan scan = new Scan().addColumn(SIConstants.DEFAULT_FAMILY_BYTES, SIConstants.PACKED_COLUMN_BYTES);\n+            try (ResultScanner results = table.getScanner(scan)) {\n+                final ValContainer<Utils.Tabular> schema = new ValContainer<>(new Utils.Tabular(\"column index\", \"column name\", \"column type\"));\n+                for (Result r : results) {\n+                    ICellVisitor cellVisitor = new ICellVisitor() {\n+                        @Override\n+                        protected void visitUserData(Cell userData) throws StandardException {\n+                            UserDataDecoder decoder = new SysColsDataDecoder();\n+                            ExecRow er = decoder.decode(userData);\n+                            if (er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID) != null\n+                                    && tableId.equals(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_REFERENCEID).getString())) {\n+                                schema.get().addRow(Integer.toString(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNUMBER).getInt()),\n+                                        CheckNull(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNNAME).toString()),\n+                                        CheckNull(((TypeDescriptorImpl)(er.getColumn(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMNDATATYPE)).getObject()).getTypeName()));\n+                            }\n+                        }\n+                    };\n+                    for (Cell cell : r.listCells()) {\n+                        cellVisitor.visit(cell);\n+                    }\n+                }\n+                return schema.get();\n+            }\n+        }\n+    }\n+\n+    public String getHbaseRegionOf(String tableName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(2 /*name*/).equals(tableName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);\n+        if (r == null) {\n+            throw new TableNotFoundException();\n+        } else {\n+            return r.cols.get(0);\n+        }\n+    }\n+\n+    public String getSpliceTableNameOf(String regionName) throws Exception {\n+        Utils.Tabular results = getListTables();\n+        Utils.Tabular.Row r = results.rows.stream().filter(result -> result.cols.get(0 /*name*/).equals(regionName)\n+                && result.cols.get(3 /*index*/).equals(\"NULL\")).findAny().orElse(null);", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1ODk4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464558982", "bodyText": "dito", "author": "hatyo", "createdAt": "2020-08-03T17:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NTI5Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462595296", "bodyText": "make 5 a descriptive constant", "author": "martinrupp", "createdAt": "2020-07-29T21:18:36Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/Utils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.StoredFormatIds;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+\n+import java.io.UncheckedIOException;\n+import java.util.*;\n+\n+import static com.splicemachine.db.iapi.types.TypeId.BOOLEAN_NAME;\n+\n+public class Utils {\n+\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_QUORUM = \"hbase.zookeeper.quorum\";\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT = \"hbase.zookeeper.property.clientPort\";\n+\n+    public static Configuration constructConfig(String zkq, int port) {\n+        Configuration conf = HBaseConfiguration.create();\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_QUORUM, zkq);\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT, Integer.toString(port));\n+        return conf;\n+    }\n+\n+    public static class Tabular {\n+        public static class Row implements Comparable<Row> {\n+            public List<String> cols;\n+\n+            public Row(String... cols) {\n+                assert cols.length > 0;\n+                this.cols = Arrays.asList(cols);\n+            }\n+\n+            @Override\n+            public int compareTo(Row o) {\n+                return cols.get(0).compareTo(o.cols.get(0));\n+            }\n+        }\n+\n+        public Set<Row> rows;\n+        public List<String> headers;\n+\n+        public Tabular(String... headers) {\n+            assert headers.length > 0;\n+            this.headers = Arrays.asList(headers);\n+            rows = new TreeSet<>();\n+        }\n+\n+        public void addRow(String... cols) {\n+            assert cols.length == headers.size();\n+            rows.add(new Row(cols));\n+        }\n+\n+        public List<String> getCol(int index) {\n+            assert index >= 0 && index < headers.size();\n+            List<String> result = new ArrayList<>(rows.size());\n+            for(final Row row : rows) {\n+                result.add(row.cols.get(index));\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static String printTabularResults(Tabular tabular) {\n+        List<Integer> lengths = new ArrayList<>(tabular.headers.size());\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            lengths.add(tabular.headers.get(i).length());\n+        }\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                if(lengths.get(i) < row.cols.get(i).length()) {\n+                    lengths.set(i, row.cols.get(i).length());\n+                }\n+            }\n+        }\n+\n+        List<String> formats = new ArrayList<>(lengths.size());\n+        for(Integer length : lengths) {\n+            formats.add(\"%-\" + (length + 5) + \"s\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            stringBuilder.append(Colored.boldWhite(String.format(formats.get(i), tabular.headers.get(i))));\n+        }\n+        stringBuilder.append(\"\\n\");\n+        int totalLength = lengths.stream().reduce(0, Integer::sum);\n+        totalLength += 5 * lengths.size();", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU2MDY2Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464560666", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-03T17:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462596420", "bodyText": "woah these are some sweet util classes! i'm not sure maybe we would want a way to disable coloring for some weird terminals / file forwarding", "author": "martinrupp", "createdAt": "2020-07-29T21:20:51Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/Utils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package com.splicemachine.ck;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.StoredFormatIds;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.TypeId;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+\n+import java.io.UncheckedIOException;\n+import java.util.*;\n+\n+import static com.splicemachine.db.iapi.types.TypeId.BOOLEAN_NAME;\n+\n+public class Utils {\n+\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_QUORUM = \"hbase.zookeeper.quorum\";\n+    public static final String HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT = \"hbase.zookeeper.property.clientPort\";\n+\n+    public static Configuration constructConfig(String zkq, int port) {\n+        Configuration conf = HBaseConfiguration.create();\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_QUORUM, zkq);\n+        conf.set(HBASE_CONFIGURATION_ZOOKEEPER_CLIENTPORT, Integer.toString(port));\n+        return conf;\n+    }\n+\n+    public static class Tabular {\n+        public static class Row implements Comparable<Row> {\n+            public List<String> cols;\n+\n+            public Row(String... cols) {\n+                assert cols.length > 0;\n+                this.cols = Arrays.asList(cols);\n+            }\n+\n+            @Override\n+            public int compareTo(Row o) {\n+                return cols.get(0).compareTo(o.cols.get(0));\n+            }\n+        }\n+\n+        public Set<Row> rows;\n+        public List<String> headers;\n+\n+        public Tabular(String... headers) {\n+            assert headers.length > 0;\n+            this.headers = Arrays.asList(headers);\n+            rows = new TreeSet<>();\n+        }\n+\n+        public void addRow(String... cols) {\n+            assert cols.length == headers.size();\n+            rows.add(new Row(cols));\n+        }\n+\n+        public List<String> getCol(int index) {\n+            assert index >= 0 && index < headers.size();\n+            List<String> result = new ArrayList<>(rows.size());\n+            for(final Row row : rows) {\n+                result.add(row.cols.get(index));\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static String printTabularResults(Tabular tabular) {\n+        List<Integer> lengths = new ArrayList<>(tabular.headers.size());\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            lengths.add(tabular.headers.get(i).length());\n+        }\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                if(lengths.get(i) < row.cols.get(i).length()) {\n+                    lengths.set(i, row.cols.get(i).length());\n+                }\n+            }\n+        }\n+\n+        List<String> formats = new ArrayList<>(lengths.size());\n+        for(Integer length : lengths) {\n+            formats.add(\"%-\" + (length + 5) + \"s\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for(int i = 0; i < tabular.headers.size(); ++i) {\n+            stringBuilder.append(Colored.boldWhite(String.format(formats.get(i), tabular.headers.get(i))));\n+        }\n+        stringBuilder.append(\"\\n\");\n+        int totalLength = lengths.stream().reduce(0, Integer::sum);\n+        totalLength += 5 * lengths.size();\n+        String separate = new String(new char[totalLength]).replace(\"\\0\", \"=\");\n+        stringBuilder.append(Colored.boldWhite(separate)).append(\"\\n\");\n+        for(Tabular.Row row : tabular.rows) {\n+            for(int i = 0; i < row.cols.size(); ++i) {\n+                stringBuilder.append(String.format(formats.get(i), row.cols.get(i)));\n+            }\n+            stringBuilder.append(\"\\n\");\n+        }\n+        return stringBuilder.toString();\n+    }\n+\n+    public static String toString(ExecRow er) throws StandardException {\n+        StringJoiner joiner = new StringJoiner(\",\");\n+        for(int i = 1; i <= er.nColumns(); ++i) {\n+            joiner.add(er.getColumn(i).toString());\n+        }\n+        return joiner.toString();\n+    }\n+\n+    public enum SQLType { BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, DOUBLE, REAL, NUMERIC,\n+        DECIMAL, CHAR, VARCHAR, REF, TIMESTAMP, DATE, TIME, LONG_VARCHAR, BLOB, CLOB, BIT,\n+        VARBIT, LONGVARBIT, XML, LIST, UNKNOWN }\n+\n+    private static Map<String, SQLType> typeMap;\n+    static {\n+        typeMap = new HashMap<>();\n+        typeMap.put(TypeId.BOOLEAN_NAME, SQLType.BOOLEAN);\n+        typeMap.put(TypeId.TINYINT_NAME, SQLType.TINYINT);\n+        typeMap.put(TypeId.SMALLINT_NAME, SQLType.SMALLINT);\n+        typeMap.put(TypeId.INTEGER_NAME, SQLType.INT);\n+        typeMap.put(TypeId.LONGINT_NAME, SQLType.BIGINT);\n+        typeMap.put(TypeId.DECIMAL_NAME, SQLType.DECIMAL);\n+        typeMap.put(TypeId.NUMERIC_NAME, SQLType.NUMERIC);\n+        typeMap.put(TypeId.DOUBLE_NAME, SQLType.DOUBLE);\n+        typeMap.put(TypeId.REAL_NAME, SQLType.REAL);\n+        typeMap.put(TypeId.CHAR_NAME, SQLType.CHAR);\n+        typeMap.put(TypeId.VARCHAR_NAME, SQLType.VARCHAR);\n+        typeMap.put(TypeId.REF_NAME, SQLType.REF);\n+        typeMap.put(TypeId.LONGVARCHAR_NAME, SQLType.LONG_VARCHAR);\n+        typeMap.put(TypeId.BLOB_NAME, SQLType.BLOB);\n+        typeMap.put(TypeId.CLOB_NAME, SQLType.CLOB);\n+        typeMap.put(TypeId.DATE_NAME, SQLType.DATE);\n+        typeMap.put(TypeId.TIME_NAME, SQLType.TIME);\n+        typeMap.put(TypeId.TIMESTAMP_NAME, SQLType.TIMESTAMP);\n+        typeMap.put(TypeId.BIT_NAME, SQLType.BIT);\n+        typeMap.put(TypeId.VARBIT_NAME, SQLType.VARBIT);\n+        typeMap.put(TypeId.LONGVARBIT_NAME, SQLType.LONGVARBIT);\n+        typeMap.put(TypeId.XML_NAME, SQLType.XML);\n+        typeMap.put(TypeId.LIST_NAME, SQLType.LIST);\n+    }\n+\n+    public static SQLType[] toSQLTypeArray(List<String> values) {\n+        SQLType[] result = new SQLType[values.size()];\n+        int cnt = 0;\n+        for(String value : values) {\n+            result[cnt++] = typeMap.get(value);\n+        }\n+        return result;\n+    }\n+\n+    public static class Colored {", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU2MTcxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464561719", "bodyText": "done, check more recent commits, there is a new option: \"-l\" resp. \"--colors\" which enables/disables coloring.", "author": "hatyo", "createdAt": "2020-08-03T17:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMDU2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464900567", "bodyText": "The helper message lets the user believe that -l prints coloured output whereas it disabled colours on my side.", "author": "arnaud-splice", "createdAt": "2020-08-04T08:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMTg4NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464901884", "bodyText": "The same goes for verbose. It seems enabled by default and -v disables it.\nI'd suggest to have colours enabled, verbose disabled, and the respective options to toggle that.", "author": "arnaud-splice", "createdAt": "2020-08-04T08:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzQ5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464913497", "bodyText": "Yes! thanks, I was messing around with these parameters locally to test some stuff, I will set them properly.", "author": "hatyo", "createdAt": "2020-08-04T09:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNjk1OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464926958", "bodyText": "Now the default values are also printed to the output making it easier to know the default behavior.", "author": "hatyo", "createdAt": "2020-08-04T09:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMDk3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464930974", "bodyText": "The helper message lets the user believe that -l prints coloured output whereas it disabled colours on my side.\n\nthe default \"fallback\" values for boolean flags is false by default, I flipped it so now it is more what we expect from setting -l or -v.", "author": "hatyo", "createdAt": "2020-08-04T09:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODM2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r462598367", "bodyText": "too long line", "author": "martinrupp", "createdAt": "2020-07-29T21:24:56Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/visitor/CellPrinter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.ck.visitor;\n+\n+import com.splicemachine.ck.Utils;\n+import com.splicemachine.ck.decoder.UserDataDecoder;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import org.apache.hadoop.hbase.Cell;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+public class CellPrinter extends ICellVisitor {\n+\n+    private final UserDataDecoder decoder;\n+    StringBuilder stringBuilder;\n+    SortedMap<Long, List<String>> events;\n+\n+    public CellPrinter(UserDataDecoder decoder) {\n+        this.decoder = decoder;\n+        this.stringBuilder = new StringBuilder();\n+        events = new TreeMap<>();\n+    }\n+\n+    public String getOutput() {\n+        StringBuilder sb = new StringBuilder();\n+        for (long event : events.keySet()) {\n+            sb.append(Utils.Colored.boldWhite(\"at: \")).append(Utils.Colored.boldWhite(Long.toString(event))).append(\"\\n\");\n+            for(String eventResult : events.get(event)) {\n+                sb.append(\"\\t\").append(eventResult).append(\"\\n\");\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void preVisit(Cell cell) {\n+        stringBuilder.setLength(0);\n+    }\n+\n+    @Override\n+    protected void postVisit(Cell cell) {\n+        Long key = cell.getTimestamp();\n+        events.computeIfAbsent(key, k -> new ArrayList<>());\n+        events.get(key).add(stringBuilder.toString());\n+    }\n+\n+    @Override\n+    public void visitCommitTimestamp(Cell cell) {\n+        stringBuilder.append(Utils.Colored.green(\"commit timestamp \"));\n+        stringBuilder.append(Utils.Colored.green(Long.toString(com.splicemachine.primitives.Bytes.toLong(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength()))));", "originalCommit": "a1b39e822872ffbab0c544cb9c20ab3fe9926536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU2MjM5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464562397", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-03T17:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODM2Nw=="}], "type": "inlineReview"}, {"oid": "1535b5f8017fca7821722ca99a83d14deb779ee8", "url": "https://github.com/splicemachine/spliceengine/commit/1535b5f8017fca7821722ca99a83d14deb779ee8", "message": "DB-9883 add more commands, fixes, refactoring.\n\n- add txlist command which prints the splice_txn table.\n- add rput command which allows the user to modify a hbase row.\n- refatoring, bug fixes, code simplifications.", "committedDate": "2020-07-31T17:23:40Z", "type": "commit"}, {"oid": "1535b5f8017fca7821722ca99a83d14deb779ee8", "url": "https://github.com/splicemachine/spliceengine/commit/1535b5f8017fca7821722ca99a83d14deb779ee8", "message": "DB-9883 add more commands, fixes, refactoring.\n\n- add txlist command which prints the splice_txn table.\n- add rput command which allows the user to modify a hbase row.\n- refatoring, bug fixes, code simplifications.", "committedDate": "2020-07-31T17:23:40Z", "type": "forcePushed"}, {"oid": "f1b61c9d8cbdeaa6afd96d26f5a149b94cd71b69", "url": "https://github.com/splicemachine/spliceengine/commit/f1b61c9d8cbdeaa6afd96d26f5a149b94cd71b69", "message": "DB-9883 use decoder bitset to check if values are set.\n\n- rget now distinguishes between non-set values and NULL-set\n  values.\n- this is relevant when printing partial row updates where some\n  values are not set, previously they were printed as NULL, now\n  '[]' is printed instead.", "committedDate": "2020-08-03T11:22:32Z", "type": "commit"}, {"oid": "0e01c74f568173c80576e7a5e88b99addab34aeb", "url": "https://github.com/splicemachine/spliceengine/commit/0e01c74f568173c80576e7a5e88b99addab34aeb", "message": "DB-9883 refactoring.", "committedDate": "2020-08-03T14:44:40Z", "type": "commit"}, {"oid": "1e2da4888d5981cd0761d1c696f4391a108abb20", "url": "https://github.com/splicemachine/spliceengine/commit/1e2da4888d5981cd0761d1c696f4391a108abb20", "message": "DB-9883 Add license note to files.", "committedDate": "2020-08-03T16:18:51Z", "type": "commit"}, {"oid": "8aa7b907a91949a0c486004594af9d35e9072548", "url": "https://github.com/splicemachine/spliceengine/commit/8aa7b907a91949a0c486004594af9d35e9072548", "message": "DB-9883 addressed spotbug issues and comments.", "committedDate": "2020-08-03T17:39:46Z", "type": "commit"}, {"oid": "1bc6336b91a5f9a92a9560abde935b75528bb099", "url": "https://github.com/splicemachine/spliceengine/commit/1bc6336b91a5f9a92a9560abde935b75528bb099", "message": "Merge remote-tracking branch 'origin/master' into DB-9883", "committedDate": "2020-08-03T17:50:42Z", "type": "commit"}, {"oid": "1c02f63af6d765e9e2077578b2769a938d9af111", "url": "https://github.com/splicemachine/spliceengine/commit/1c02f63af6d765e9e2077578b2769a938d9af111", "message": "DB-9883 manually update the parent version in splice-ck pom.xml.", "committedDate": "2020-08-03T18:00:24Z", "type": "commit"}, {"oid": "11b2e022c227cf0c2c32453c78f69c1935cf24bd", "url": "https://github.com/splicemachine/spliceengine/commit/11b2e022c227cf0c2c32453c78f69c1935cf24bd", "message": "DB-9883 move splice-ck from core to cdh*, hdp* and dbaas profiles.", "committedDate": "2020-08-03T18:13:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3ODg4NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464878885", "bodyText": "Remove", "author": "arnaud-splice", "createdAt": "2020-08-04T08:15:04Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/marshall/EntryDataDecoder.java", "diffHunk": "@@ -26,6 +26,7 @@\n import com.splicemachine.db.iapi.error.StandardException;\n import com.splicemachine.db.iapi.sql.execute.ExecRow;\n import com.splicemachine.db.iapi.types.DataValueDescriptor;\n+import org.apache.spark.sql.Row;", "originalCommit": "11b2e022c227cf0c2c32453c78f69c1935cf24bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMzY5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464923695", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-04T09:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3ODg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NTA0Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464895043", "bodyText": "I would add quite the disclaimer here, informing that doing so may compromise data integrity, break our MVCC model, etc.", "author": "arnaud-splice", "createdAt": "2020-08-04T08:42:29Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/command/RPutCommand.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.ck.command;\n+\n+import com.splicemachine.ck.HBaseInspector;\n+import com.splicemachine.ck.Utils;\n+import com.splicemachine.ck.encoder.RPutConfigBuilder;\n+import org.apache.commons.lang3.StringUtils;\n+import picocli.CommandLine;\n+\n+import java.util.concurrent.Callable;\n+\n+\n+@CommandLine.Command(name = \"rput\",\n+        description = \"modify HBase row\",", "originalCommit": "11b2e022c227cf0c2c32453c78f69c1935cf24bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNDMwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464914301", "bodyText": "Good idea, I will do that.", "author": "hatyo", "createdAt": "2020-08-04T09:15:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NTA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NzMyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464897326", "bodyText": "If a table exists in multiple schemas, this will always select the latest one. It'd be nice to be able to specify the schema. We'd need to find a way to distinguish between the schema in which the table resides and the schema you already use here (boolean, int, etc.)\nAlso, table names and schema names should be normalised (EngineUtils.validateTable, EngineUtils.validateSchema) so that the end user can write t2 instead of T2 for example.", "author": "arnaud-splice", "createdAt": "2020-08-04T08:46:11Z", "path": "splice_ck/src/main/java/com/splicemachine/ck/command/RGetCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*", "originalCommit": "11b2e022c227cf0c2c32453c78f69c1935cf24bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNDY4NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3905#discussion_r464914685", "bodyText": "Good point(s) :)", "author": "hatyo", "createdAt": "2020-08-04T09:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NzMyNg=="}], "type": "inlineReview"}, {"oid": "64cc90a205b4762565cbeec216c329eb39e111d8", "url": "https://github.com/splicemachine/spliceengine/commit/64cc90a205b4762565cbeec216c329eb39e111d8", "message": "DB-9883 address spotbugs issues.", "committedDate": "2020-08-04T08:55:53Z", "type": "commit"}, {"oid": "1ea4ecf571c50534d2ea48fd4585075500d92efb", "url": "https://github.com/splicemachine/spliceengine/commit/1ea4ecf571c50534d2ea48fd4585075500d92efb", "message": "DB-9883 Addressed comments, refactoring.\n\n- new command: slist, which views schemas is added.", "committedDate": "2020-08-04T14:40:57Z", "type": "commit"}, {"oid": "11d67acbde137eeb50f3a81e4ac1476165c301ba", "url": "https://github.com/splicemachine/spliceengine/commit/11d67acbde137eeb50f3a81e4ac1476165c301ba", "message": "Merge remote-tracking branch 'origin/master' into DB-9883", "committedDate": "2020-08-11T09:21:38Z", "type": "commit"}, {"oid": "420dff4f42926399e485d30e644e3ab6337fb337", "url": "https://github.com/splicemachine/spliceengine/commit/420dff4f42926399e485d30e644e3ab6337fb337", "message": "DB-9883 update parent version in splice_ck pom.", "committedDate": "2020-08-11T10:59:57Z", "type": "commit"}, {"oid": "1cc78ae6350c310f4aaf96a219fcc49419a9bd7d", "url": "https://github.com/splicemachine/spliceengine/commit/1cc78ae6350c310f4aaf96a219fcc49419a9bd7d", "message": "DB-9883 change license to GNU Affero.", "committedDate": "2020-08-14T08:56:16Z", "type": "commit"}, {"oid": "13dfd114056dfe48fc900aa63f895e1d5894cfd0", "url": "https://github.com/splicemachine/spliceengine/commit/13dfd114056dfe48fc900aa63f895e1d5894cfd0", "message": "Merge remote-tracking branch 'origin/master' into DB-9883", "committedDate": "2020-08-14T10:03:15Z", "type": "commit"}]}