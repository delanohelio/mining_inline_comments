{"pr_number": 3771, "pr_title": "DB-9715 AS OF should also accept a timestamp expression", "pr_createdAt": "2020-07-06T15:45:26Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3771", "timeline": [{"oid": "49ecb0fde526b1f6baf19453462a6e2760dbe7bd", "url": "https://github.com/splicemachine/spliceengine/commit/49ecb0fde526b1f6baf19453462a6e2760dbe7bd", "message": "Support time travel SELECT statements with tx id.\n\n- add parser extensions to support AS OF clause.\n- only the tx id is supported.\n- propagate the transaction id down the execution tree to\n  TableScanOperation.\n- adapt code generation to pass the tx id to TableScanOperation\n  at runtime.\n- add tests", "committedDate": "2020-06-17T20:40:01Z", "type": "commit"}, {"oid": "69c5064cfb517f637292c9a9198520b0667c49ff", "url": "https://github.com/splicemachine/spliceengine/commit/69c5064cfb517f637292c9a9198520b0667c49ff", "message": "Addressed comments.", "committedDate": "2020-07-06T18:46:41Z", "type": "commit"}, {"oid": "ebae97a79a00a8a55d4c12047bc338909c2e06ec", "url": "https://github.com/splicemachine/spliceengine/commit/ebae97a79a00a8a55d4c12047bc338909c2e06ec", "message": "Merge remote-tracking branch 'origin/master' into DB-9714", "committedDate": "2020-07-06T18:47:54Z", "type": "commit"}, {"oid": "d9c4480364623cc4fb382a64183e0d2ec70f18d0", "url": "https://github.com/splicemachine/spliceengine/commit/d9c4480364623cc4fb382a64183e0d2ec70f18d0", "message": "Disallow time travel clause on external tables and views.\n\n- Add tests.", "committedDate": "2020-07-06T20:14:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NDY1OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450764658", "bodyText": "@yxia92 @jyuanca do we need to do something here regarding upgrades?", "author": "dgomezferro", "createdAt": "2020-07-07T10:27:06Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java", "diffHunk": "@@ -1012,7 +1013,8 @@ NoPutResultSet getTableScanResultSet(\n \t\t\t\t\t\t\t\tString location,\n \t\t\t\t\t\t\t\tint partitionByRefItem,\n \t\t\t\t\t\t\t\tGeneratedMethod defaultRowFunc,\n-\t\t\t\t\t\t\t\tint defaultValueMapItem\n+\t\t\t\t\t\t\t\tint defaultValueMapItem,\n+\t\t\t\t\t\t\t\tGeneratedMethod pastTxFunctor", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTA3Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765072", "bodyText": "I'm not a fan of the isBulkDeleteOrTxId parameter, would it be possible to add an extra parameter for the transaction id ?", "author": "dgomezferro", "createdAt": "2020-07-07T10:27:54Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -196,36 +196,30 @@\n     private AggregateNode aggrForSpecialMaxScan;\n \n     private boolean isBulkDelete = false;\n+\n+    private ValueNode pastTxIdExpression = null;\n+\n     @Override\n     public boolean isParallelizable(){\n         return false;\n     }\n \n     /**\n-     * Initializer for a table in a FROM list. Parameters are as follows:\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * <li>tableProperties    The Properties list associated with the table.</li>\n-     * </ul>\n-     * <p/>\n-     * <p>\n-     * - OR -\n-     * </p>\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>updateOrDelete    Table is being updated/deleted from. </li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * </ul>\n+     * Initializer for a table in a FROM list.\n+     * @param tableName The name of the table\n+     * @param correlationName The correlation name\n+     * @param rclOrUD update/delete flag or result column list\n+     * @param propsOrRcl properties or result column list\n+     * @param isBulkDeleteOrTxId bulk delete flag or past tx id expression.\n      */\n     @Override\n-    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete){\n+    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDeleteOrTxId){\n+        if(isBulkDeleteOrTxId instanceof Boolean) {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2MzAyNA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454463024", "bodyText": "Right, I did it in the base change (DB-9714). The new signature looks like this:\npublic void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete, Object pastTxIdExpr)", "author": "hatyo", "createdAt": "2020-07-14T15:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTU2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765565", "bodyText": "Remove comments", "author": "dgomezferro", "createdAt": "2020-07-07T10:28:56Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -3410,7 +3431,11 @@ private String getClassName(String niceIndexName) throws StandardException {\n         if(niceIndexName!=null){\n             cName = \"IndexScan[\"+niceIndexName+\"]\";\n         }else{\n-            cName = \"TableScan[\"+getPrettyTableName()+\"]\";\n+            cName = \"TableScan[\"+getPrettyTableName();\n+//            if(pastTxIdExpression >= 0){", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2MzUxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454463513", "bodyText": "Done", "author": "hatyo", "createdAt": "2020-07-14T15:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770046", "bodyText": "If I'm understanding this correctly, this is mapping the Txn begin timestamp to the instant when the transaction was last updated. This would be wrong for long running transactions:\n\ntxn1 is created at instant1\na long time passes\ntxn1 is committed at instant500\nthis function maps txnId 1 to instant 500 (it should map txnId 1 to instant 1)", "author": "dgomezferro", "createdAt": "2020-07-07T10:37:55Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4MTMwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454481309", "bodyText": "You're right, what's a better way to correlate? maybe parse and check the timestamp of COMMIT_QUALIFIER_BYTES or STATE_QUALIFIER_BYTES (sorry maybe we already went through this once, but I just want to make sure).", "author": "hatyo", "createdAt": "2020-07-14T16:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MzUyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456343527", "bodyText": "I think the best option would be to scan for STATE_QUALIFIER_BYTES with ACTIVE value (0x00), since that's what's written when the transaction is first created. In principle there should only be 2 states at most (ACTIVE, superseded by COMMITTED or ROLLEDBACK) but I think I saw some cases where ROLLEDBACK was written multiple times. If there's such a case and the ACTIVE keyvalue is not available I'd ignore that row.", "author": "dgomezferro", "createdAt": "2020-07-17T09:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5Mzc0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459393746", "bodyText": "Done, we're reading now the STATE_QUALIFIER_BYTES qualifier (all versions), iterate over the results and pick the timestamp of ACTIVE state if found, if not found, we simply ignore the row and proceed further.", "author": "hatyo", "createdAt": "2020-07-23T11:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDY4Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770687", "bodyText": "You can specify the column you are interested in directly in the scan, so you don't have to check for the right KV.", "author": "dgomezferro", "createdAt": "2020-07-07T10:39:16Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());\n+            return new Pair<>(txnId, ts);\n+        }\n+\n+\n+        public ScanTimestampIterator(RegionScanner scanner){\n+            this.regionScanner=scanner;\n+        }\n+\n+        @Override\n+        public boolean hasNext() throws IOException{\n+            if(next!=null) return true;\n+            if(currentResults==null)\n+                currentResults=new ArrayList<>(10);\n+            boolean shouldContinue;\n+            do{\n+                shouldContinue=regionScanner.next(currentResults);\n+                if(currentResults.size()<=0) return false;\n+\n+                this.next = decode(currentResults);\n+                currentResults.clear();\n+            }while(next==null && shouldContinue);\n+\n+            return next!=null;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> next() throws IOException{\n+            if(!hasNext()) throw new NoSuchElementException();\n+            Pair<Long, Long> n=next;\n+            next=null;\n+            return n;\n+        }\n+\n+        @Override\n+        public void close() throws IOException{\n+            regionScanner.close();\n+        }\n+    }\n+\n+    @Override\n+    public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+        Scan s = new Scan();", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5MzgwMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459393800", "bodyText": "Thanks, done, now we're reading only STATE_QUALIFIER_BYTES column qualifier (all versions).\nhbaseScan.addColumn(V2TxnDecoder.FAMILY, V2TxnDecoder.STATE_QUALIFIER_BYTES)\n         .setReversed(reverse)\n         .readAllVersions()\n         .setFilter(new PrefixFilter(new byte[]{bucket})); // todo get one row only", "author": "hatyo", "createdAt": "2020-07-23T11:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NTY5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450775697", "bodyText": "Txn id 0 is used for the ROOT_TRANSACTION, which is a special transaction parent of all user level transactions. I don't think this is going to be problematic but I'd rather use a different transaction id other than 0, in case we think at some point this is actually the root transaction.", "author": "dgomezferro", "createdAt": "2020-07-07T10:49:31Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1MzA5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459453095", "bodyText": "Done. I created a constant: public static final long OLDEST_TIME_TRAVEL_TX = TRASANCTION_INCREMENT; and I am using it here instead of simply using zero.", "author": "hatyo", "createdAt": "2020-07-23T13:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NTY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776001", "bodyText": "Method names should start with lowercase", "author": "dgomezferro", "createdAt": "2020-07-07T10:50:05Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n+            }\n+        } else {\n+            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n+        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n+    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDk5MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456294990", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776851", "bodyText": "Method names start lowercase", "author": "dgomezferro", "createdAt": "2020-07-07T10:51:40Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU5OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295598", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776968", "bodyText": "ditto", "author": "dgomezferro", "createdAt": "2020-07-07T10:51:53Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTY3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295675", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450777470", "bodyText": "Remove", "author": "dgomezferro", "createdAt": "2020-07-07T10:52:50Z", "path": "splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java", "diffHunk": "@@ -30,10 +30,23 @@ private TxnUtils(){}\n \t\tlong beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK;\n \t\tbyte[] rowKey = new byte[9];\n \t\trowKey[0] = (byte)((beginTS / SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1));\n+\t\trowKey[0] = (byte)(2);", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5ODQ0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456298449", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA=="}], "type": "inlineReview"}, {"oid": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "url": "https://github.com/splicemachine/spliceengine/commit/16e8ee799170ab2ef72aba0f4c7084085e8514e2", "message": "Fix SpotBug issues.", "committedDate": "2020-07-07T12:31:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451297626", "bodyText": "we don't really have a code convention, but i think this could use a bit more spaces, e.g.\n} catch(Throwable throwable) {\n(same for other lines)\nI don't really need the spaces after (, but like around operators e.g. if(keyValues.size()<=0) -> if(keyValues.size() <= 0).", "author": "martinrupp", "createdAt": "2020-07-08T05:48:50Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java", "diffHunk": "@@ -268,6 +268,17 @@ public int compare(TxnView o1,TxnView o2){\n         }\n     }\n \n+    @Override\n+    public long getTxnAt(long ts) throws IOException {\n+        final TxnMessage.TxnAtRequest request=TxnMessage.TxnAtRequest.newBuilder().setTs(ts).build();\n+        try(TxnNetworkLayer table = tableFactory.accessTxnNetwork()){\n+            TxnMessage.TxnAtResponse result = table.getTxnAt(request);\n+            return result.getTxnId();\n+        }catch(Throwable throwable){", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzk0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317949", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T09:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299344", "bodyText": "really LOG level, not TRACE? i'm not even sure we should have this here at all, even in trace level.", "author": "martinrupp", "createdAt": "2020-07-08T05:53:52Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzQzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317434", "bodyText": "Yeah, I changed all of them back to DEBUG.", "author": "hatyo", "createdAt": "2020-07-17T09:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299873", "bodyText": "TRACE or DEBUG?", "author": "martinrupp", "createdAt": "2020-07-08T05:55:22Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;\n+    }\n+\n+    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n+        long closestTS = Long.MAX_VALUE, closestTx = -1;\n+        Pair<Long, Long> before, after;\n+        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+            before = first(i);\n+            if(before == null /*|| before.getBeginTs() > ts*/) {\n+                continue; // region is empty, or the earliest tx in there happened after 'ts'\n+            }\n+            if(before.getSecond() > ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n+                            (int)i,\n+                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n+                            new Timestamp(before.getSecond()).toString(),\n+                            before.getFirst().toString(),\n+                            new Timestamp(ts).toString());\n+                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n+            }\n+            after = last(i);\n+            if(after.getSecond() < ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNjM3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456316370", "bodyText": "Right, I don't know why I chose TRACE and not DEBUG, I will change it on DEBUG level then.", "author": "hatyo", "createdAt": "2020-07-17T09:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451303330", "bodyText": "SortedMap<Long, Long> m = txnTimeline.get(bucket); and if(m.size() == 0) { return null\ncan be done independent of if(begin == null) and if(reverse).\nI think you can add at the beginning of this function\nSortedMap<Long, Long> m = txnTimeline.get(bucket);\nif(m.size() == 0) {\n    return null;\n}\n\nand remove in other lines.", "author": "martinrupp", "createdAt": "2020-07-08T06:05:57Z", "path": "hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.splicemachine.si.impl;\n+\n+import com.splicemachine.primitives.Bytes;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.region.TxnFinder;\n+import com.splicemachine.si.impl.region.TxnTimeTraveler;\n+import com.splicemachine.utils.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+public class TimeTravelTest {\n+\n+    private static Long toTs(String s) throws ParseException {\n+        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\");\n+        Date parsedDate = dateFormat.parse(s);\n+        Timestamp timestamp = new java.sql.Timestamp(parsedDate.getTime());\n+        return timestamp.getTime();\n+    }\n+\n+    class MockTxnFinder implements TxnFinder {\n+\n+\n+        List<SortedMap<Long, Long>> txnTimeline = new ArrayList<>();\n+\n+        MockTxnFinder() {\n+            for(int i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+                txnTimeline.add(new TreeMap<>());\n+            }\n+        }\n+\n+        MockTxnFinder AddTxn(int bucket, long txnId, String ts) throws ParseException {\n+            assert bucket >= 0 && bucket < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT;\n+            txnTimeline.get(bucket).put(txnId, toTs(ts));\n+            return this;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+            if(begin == null) {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNDYyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456314620", "bodyText": "You're absolutely right! Thank you \ud83d\udc4d I fixed it.", "author": "hatyo", "createdAt": "2020-07-17T08:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451306646", "bodyText": "do we really need this? maybe sth like \"testTimeTravelWorksT\" would be more intuitive? the SpliceWatcher will drop these tables automatically, so you can run the test multiple times.", "author": "martinrupp", "createdAt": "2020-07-08T06:15:45Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {\n+        return \"T\" + counter++;\n+    }\n+\n+    @Test\n+    public void testTimeTravelWorks() throws Exception {\n+        String tbl = GenerateTableName();", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NzkxOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456297918", "bodyText": "I actually find this more elegant, I am already using a SpliceWatcher for the schema so I can repeat my tests since the schema (which is the same for all tests in this class) will be dropped and created again in the next run.\nI don't use a watcher for each table because it is just too cumbersome and unnecessary.", "author": "hatyo", "createdAt": "2020-07-17T08:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng=="}], "type": "inlineReview"}, {"oid": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "url": "https://github.com/splicemachine/spliceengine/commit/20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "message": "Add upgrade script to invalidate stored statements.", "committedDate": "2020-07-10T15:07:15Z", "type": "commit"}, {"oid": "2f544c86289748608ac77934e5bc1250f7fdfbae", "url": "https://github.com/splicemachine/spliceengine/commit/2f544c86289748608ac77934e5bc1250f7fdfbae", "message": "Merge remote-tracking branch 'origin/master' into DB-9714", "committedDate": "2020-07-10T15:12:03Z", "type": "commit"}, {"oid": "a84933d44be77758a4b1603cd9ce7b2e841f569c", "url": "https://github.com/splicemachine/spliceengine/commit/a84933d44be77758a4b1603cd9ce7b2e841f569c", "message": "Addressed further comments.", "committedDate": "2020-07-14T15:14:29Z", "type": "commit"}, {"oid": "2405dcb59774fecad245895185f80c6170108e7e", "url": "https://github.com/splicemachine/spliceengine/commit/2405dcb59774fecad245895185f80c6170108e7e", "message": "Merge remote-tracking branch 'origin/master' into DB-9714", "committedDate": "2020-07-14T15:15:31Z", "type": "commit"}, {"oid": "15aac492587e0e6b8aae0d2339332dcb9dcc16dd", "url": "https://github.com/splicemachine/spliceengine/commit/15aac492587e0e6b8aae0d2339332dcb9dcc16dd", "message": "DB-9715 allow timestamp in AS OF clause.\n\n- accept a general expression which must evaluate to either\n  * numeric value that corresponds to txid\n  * timestamp value that corresponds to approximate time of\n    committing a transaction.\n- TODO: implement mapping function that maps timestamp to txid.", "committedDate": "2020-07-14T15:28:50Z", "type": "commit"}, {"oid": "361a907cd1bc01f845619e3e4ac6b7f0f595ae1d", "url": "https://github.com/splicemachine/spliceengine/commit/361a907cd1bc01f845619e3e4ac6b7f0f595ae1d", "message": "DB-9715 Implement algorithm to map timestamp to nearest transaction.\n\n- implement a special version of binary search that efficiently\n  scans a bucket of txn in SPLICE_TXN looking for the nearest\n  transaction to a given timestamp.\n- implement a new endpoint API call to retrieven nearest tx of\n  a given timestamp.\n- add tests.", "committedDate": "2020-07-14T15:28:50Z", "type": "commit"}, {"oid": "a028264376428e88eecb8ff963ff4f6dba222fd7", "url": "https://github.com/splicemachine/spliceengine/commit/a028264376428e88eecb8ff963ff4f6dba222fd7", "message": "DB-9715 Address comments", "committedDate": "2020-07-23T12:48:54Z", "type": "commit"}, {"oid": "1df95cc586347e02f45c22577b9c2a72e759ce38", "url": "https://github.com/splicemachine/spliceengine/commit/1df95cc586347e02f45c22577b9c2a72e759ce38", "message": "Merge remote-tracking branch 'origin' into DB-9715", "committedDate": "2020-07-23T13:17:58Z", "type": "commit"}, {"oid": "1df95cc586347e02f45c22577b9c2a72e759ce38", "url": "https://github.com/splicemachine/spliceengine/commit/1df95cc586347e02f45c22577b9c2a72e759ce38", "message": "Merge remote-tracking branch 'origin' into DB-9715", "committedDate": "2020-07-23T13:17:58Z", "type": "forcePushed"}, {"oid": "2716a5e98c6d1f16f3bfa68c6f2e6e91620712e8", "url": "https://github.com/splicemachine/spliceengine/commit/2716a5e98c6d1f16f3bfa68c6f2e6e91620712e8", "message": "Merge remote-tracking branch 'origin/master' into DB-9715", "committedDate": "2020-07-24T17:00:12Z", "type": "commit"}, {"oid": "625377de5f60745e7f8697f90fba10017d287380", "url": "https://github.com/splicemachine/spliceengine/commit/625377de5f60745e7f8697f90fba10017d287380", "message": "Merge remote-tracking branch 'origin/master' into DB-9715", "committedDate": "2020-08-04T14:45:09Z", "type": "commit"}, {"oid": "8070e6b063e11c0dfa62e0caf86365de8548d5cb", "url": "https://github.com/splicemachine/spliceengine/commit/8070e6b063e11c0dfa62e0caf86365de8548d5cb", "message": "DB-9715 address spotbugs issues.", "committedDate": "2020-08-04T15:03:13Z", "type": "commit"}, {"oid": "af035906997bb6ffdeec0468b1ba102d84741011", "url": "https://github.com/splicemachine/spliceengine/commit/af035906997bb6ffdeec0468b1ba102d84741011", "message": "Merge remote-tracking branch 'origin/master' into DB-9715", "committedDate": "2020-08-06T10:54:12Z", "type": "commit"}, {"oid": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "url": "https://github.com/splicemachine/spliceengine/commit/eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "message": "DB-9715 fix exception message.", "committedDate": "2020-08-06T10:54:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NTMwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r466575301", "bodyText": "While  misspellings generally aren't noteworthy and this isn't a blocker for merging today, the literal here is spelled wrong. Could make searching for it harder in the future, so can we fix this in a future release?", "author": "carolp-503", "createdAt": "2020-08-06T17:33:24Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isDebugEnabled())\n+            SpliceLogUtils.debug(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isDebugEnabled())\n+                SpliceLogUtils.debug(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;", "originalCommit": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}