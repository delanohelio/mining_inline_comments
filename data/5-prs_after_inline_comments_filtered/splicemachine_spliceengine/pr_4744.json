{"pr_number": 4744, "pr_title": "DB-10895 Complete DB2 varchar compatibility for MultiProbeScan.", "pr_createdAt": "2020-12-01T02:15:49Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4744", "timeline": [{"oid": "027aab4dd95161dbc54a75ee14be0d9a78283045", "url": "https://github.com/splicemachine/spliceengine/commit/027aab4dd95161dbc54a75ee14be0d9a78283045", "message": "DB-10895 Complete DB2 varchar compatibility for MultiProbeScan.", "committedDate": "2020-12-01T02:07:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0ODMwNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533248306", "bodyText": "same code as 347-361. i think we should combine those in a function", "author": "martinrupp", "createdAt": "2020-12-01T09:52:22Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/MultiProbeDerbyScanInformation.java", "diffHunk": "@@ -293,39 +301,64 @@ public void readExternal(ObjectInput in) throws IOException, ClassNotFoundExcept\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint maxSize = dtd.getMaximumWidth();\n+\t\t\t\tDataValueDescriptor targetDesc = templateRow.getColumn(keyTablePositionMap[keyDecodingMap[position]] + 1);\n+\t\t\t\tboolean targetIsSQLVarcharDB2Compatible = targetDesc instanceof SQLVarcharDB2Compatible;\n \t\t\t\tfor (int index = 0; index < probingVals.length; index++) {\n \t\t\t\t\t DataValueDescriptor dvd = probingVals[index];\n \t\t\t\t\t if (dvd instanceof ListDataType) {\n \t\t\t\t\t\t ListDataType listData = (ListDataType) dvd;\n \t\t\t\t\t\t DataValueDescriptor dvd1 = listData.getDVD(position);\n-\t\t\t\t\t\t if (dvd1 instanceof SQLChar) {\n+\t\t\t\t\t\t boolean isSQLVarcharDB2Compatible = dvd1 instanceof SQLVarcharDB2Compatible;\n+\t\t\t\t\t\t if (isSQLVarcharDB2Compatible) {\n+\t\t\t\t\t\t\tDataValueDescriptor newDVD =\n+\t\t\t\t\t\t\t\tQualifierUtils.convertChar((SQLChar) dvd1, dvd1.getLength(),\n+\t\t\t\t\t\t\t\t                           inlistDataTypes[position].getMaximumWidth());\n+\t\t\t\t\t\t\tlistData.setDVD(position, newDVD);\n+\t\t\t\t\t\t }\n+\t\t\t\t\t\t else if (dvd1 instanceof SQLChar) {\n \t\t\t\t\t\t \t// we may prune some probe value based on the string length\n-\t\t\t\t\t\t \tif (isFixedCharType && dvd1.getLength() != maxSize) {\n-\t\t\t\t\t\t\t\ttoRemove[index] = true;\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t} else if (isVarCharType && dvd1.getLength() > maxSize) {\n+\t\t\t\t\t\t \tif (isVarCharType && dvd1.getLength() > maxSize &&\n+\t\t\t\t\t\t\t    !targetIsSQLVarcharDB2Compatible) {\n \t\t\t\t\t\t\t\ttoRemove[index] = true;\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t // if column is of varchar type, we need to change the probe values from SQLChar to SQLVarchar,\n-\t\t\t\t\t\t\t // so that duplicate removal won't ignore the trailing spaces\n-\t\t\t\t\t\t\t if (isVarCharType && !(dvd1 instanceof SQLVarchar))\n-\t\t\t\t\t\t\t\t listData.setDVD(position, new SQLVarchar(dvd1.getString()));\n+\t\t\t\t\t\t\t // so that duplicate removal won't ignore the trailing spaces,\n+\t\t\t\t\t\t\t // unless we're in DB2 varchar compatibility mode.\n+\t\t\t\t\t\t\t if (isVarCharType) {\n+\t\t\t\t\t\t\t \tif (targetIsSQLVarcharDB2Compatible) {\n+\t\t\t\t\t\t\t \t\tif (dvd1.getClass().equals(SQLVarchar.class))\n+\t\t\t\t\t\t\t \t\t\tlistData.setDVD(position,\n+\t\t\t\t\t\t\t\t\t\t                new SQLVarcharDB2Compatible(dvd1.getString()));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t \telse if (!(dvd1 instanceof SQLVarchar))\n+\t\t\t\t\t\t\t\t     listData.setDVD(position, new SQLVarchar(dvd1.getString()));\n+\t\t\t\t\t\t\t }", "originalCommit": "027aab4dd95161dbc54a75ee14be0d9a78283045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzNjQ3OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533336478", "bodyText": "+1 for this", "author": "ascend1", "createdAt": "2020-12-01T11:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0ODMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczMzQyOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533733429", "bodyText": "OK, I've refactored this into a function.", "author": "msirek", "createdAt": "2020-12-01T21:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0ODMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MjMxNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533252317", "bodyText": "this strings are weirdly intended. i think we should intend multi-line commands like e.g.\nString sqlTemplate = \"select * from t a --splice-properties useSpark=\" + useSpark.toString() +\n        \", index=%s\\n\" +\n        \"where v in ('SBVGCCC    ', 'G')\\n\" +\n        \"and c in ( ' ', CAST('A' AS CHAR(2)))\";", "author": "martinrupp", "createdAt": "2020-12-01T09:55:24Z", "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/DB2VarcharCompatibilityIT.java", "diffHunk": "@@ -325,4 +340,140 @@ public void testInvalidateStoredStatements() throws Exception {\n         // Restore the flag setting to the value when this test started.\n         methodWatcher.executeUpdate(\"call syscs_util.syscs_set_global_database_property('splice.db2.varchar.compatible', true)\");\n     }\n+\n+    @Test\n+    public void testMultiProbeScan() throws Exception {\n+        String sqlTemplate = \"select * from t a --splice-properties useSpark=\" + useSpark.toString() +\n+        \", index=%s\\n\" +\n+        \"where v in ('SBVGCCC    ', 'G')\\n\" +\n+        \"and c in ( ' ', CAST('A' AS CHAR(2)))\";", "originalCommit": "027aab4dd95161dbc54a75ee14be0d9a78283045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczNDUzNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533734537", "bodyText": "OK, I've fixed the indentation.", "author": "msirek", "createdAt": "2020-12-01T21:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MjMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMTY1Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533331652", "bodyText": "It feels dangerous to change usefulCount to 1 here because usefulCount is used not only for multi-probe scan construction but also later to determine start/stop keys. Suppose we have several other predicates together with one in-list on a varchar column so we enter this code path. Setting usefulCount to 1 would prevent all other predicates to be scan start/stop keys. Or am I missing anything?\nIf we don't want to build a MultiProbe...Scan for this in-list, is it sufficient to remove it from inlistPreds and clean up its states in other data structures (e.g., usefulPredicates[], usefulCount--, isEquality[], etc.) ?", "author": "ascend1", "createdAt": "2020-12-01T11:18:00Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -1111,15 +1116,28 @@ private void orderUsefulPredicates(Optimizable optTable,\n         ArrayList<Predicate> predsForNewInList = null;\n     \n         if (inlistQualified) {\n-          // Only combine multiple IN lists if not using Spark.\n-          // Adding extra RDDs and unioning them together hinders performance.\n-          if (inlistPreds.size() > 1) {\n+          // In DB2 mode, probe keys can be overlapping with eachother.\n+          // On HBase the overlapping keys are merged together, but on\n+          // mem they aren't causing duplicate rows.  So here we avoid\n+          // constructing the overlapping keys on mem.\n+          boolean varcharDB2CompatibilityMode = getCompilerContext().getVarcharDB2CompatibilityMode();\n+          if (varcharDB2CompatibilityMode && isMemPlatform()) {\n+              BinaryRelationalOperatorNode bron =\n+                  (BinaryRelationalOperatorNode) usefulPredicates[0].getRelop();\n+              boolean isVarChar =\n+                  bron.getLeftOperand().getTypeServices().\n+                         getTypeName().equals(TypeId.VARCHAR_NAME);\n+              if (isVarChar)\n+                  usefulCount = 1;", "originalCommit": "027aab4dd95161dbc54a75ee14be0d9a78283045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MzA1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533463054", "bodyText": "This is a good point you bring up.  The intent of this code is to disallow any IN list predicates to be used for multiprobing after the first usefulPredicate which is or type varchar, whether it be in an equality predicate or an in list predicate.  However, usefulCount is not the right position to use.\nJust for clarity, let's look at a test case.  Suppose we have this test case:\n\ncreate table t (v varchar(14), c char(2));\ninsert into t values ('SBVGCCC','  ');\ninsert into t values ('SBVGCCC c ','  ');\ninsert into t values ('SBVGCCC','A ');\ncreate index ti on t (v,c);\nselect * from t a --splice-properties index=ti\nwhere v in ('SBVGCCC    ', 'G')\nand c in ( ' ', CAST('A' AS CHAR(2)));\n\nWe will build 4 probe keys for this.  Two of these are:\n\nProbe Number________________Start Key___________________________Stop Key\n\n      1                     'SBVGCCC', '  '                           'SBVGCCC       ', '  '\n      2                     'SBVGCCC', 'A '                           'SBVGCCC       ', 'A  '\n\n\nSince the first probe value is a varchar, its start and stop keys must cover a range of values, the start key having zero trailing spaces, and the stop key having the maximum number of trailing spaces to fit the field width.  That means that for all other matching values in between (e.g., 'SBVGCCC ','SBVGCCC  ', 'SBVGCCC   ' ...), for those we also match all values for column c.  The same is true whether we use 'v =' or 'v in'.  However, we could have a third column, i, and have an index:  create index ti2 on t (v,c,i);  with predicates v = 'SBVGCCC    ' and c = 'A ' and i in (1,2,3).  In this case we don't want to disallow use of the column c predicate in the IndexScan because equality predicates are marked as qualifiers, so even if more values than c = 'A ' could initially be scanned, applying the qualifier filters those values out, and this predicate could still be useful as a start key.  Multiprobe IN list predicates don't currently use qualifiers.  I will fix up the code to make the correct usefulCount adjustment and see what other adjustments are appropriate.  Keep in mind, this only affects the mem platform, so isn't something that should affect customers.", "author": "msirek", "createdAt": "2020-12-01T14:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMTY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc0OTM1Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533749353", "bodyText": "@ascend1 I've reworked the logic to simply avoid adding the problematic IN list predicates to usefulPredicates, so the adjustment on usefulCount is removed.  I found problem cases on HBase too, so I've removed the distinction between mem platform and non-mem.", "author": "msirek", "createdAt": "2020-12-01T22:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NjkwOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533456908", "bodyText": "Is it possible to avoid this?", "author": "dgomezferro", "createdAt": "2020-12-01T14:39:43Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -847,6 +848,10 @@ private void saveOriginalInListPreds(Predicate newPred, List<Predicate> predsFor\n         newPred.setOriginalInListPredList(origList);\n     }\n \n+    private boolean isMemPlatform() {", "originalCommit": "027aab4dd95161dbc54a75ee14be0d9a78283045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4NTYxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533485619", "bodyText": "See my comment below.", "author": "msirek", "createdAt": "2020-12-01T15:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NjkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MDUyOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533460528", "bodyText": "Can we fix this on Mem by merging those keys? I dislike introducing knowledge of the platform in the engine itself.", "author": "dgomezferro", "createdAt": "2020-12-01T14:42:19Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -1111,15 +1116,28 @@ private void orderUsefulPredicates(Optimizable optTable,\n         ArrayList<Predicate> predsForNewInList = null;\n     \n         if (inlistQualified) {\n-          // Only combine multiple IN lists if not using Spark.\n-          // Adding extra RDDs and unioning them together hinders performance.\n-          if (inlistPreds.size() > 1) {\n+          // In DB2 mode, probe keys can be overlapping with eachother.\n+          // On HBase the overlapping keys are merged together, but on\n+          // mem they aren't causing duplicate rows.  So here we avoid", "originalCommit": "027aab4dd95161dbc54a75ee14be0d9a78283045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4NTE5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533485193", "bodyText": "It's possible, but may take a bit of effort for not much performance benefit.  It's not actually merging that could be done on mem, but expansion, since each probe value is applied independently.  For example, if we have t1 (a varchar(101), b int);  create index ix1 on t1 (a, b);  select * from t1 where a in ('a', 'b', 'c') and b in (1,2,3);  Each probe value for column a would have to be chopped up into 100 probe values to cover each possible number of trailing spaces.  For this case that would be 900 total probe values.  It would likely be more efficient to just use keys from column a resulting in 3 start/stop keys, and apply the column b predicate as a filter.  There really is a difference in how mem does probing vs. HBase.  HBase does a straight scan through rows in a single pass, while mem does actual probing where each probe is done independently.  If we don't want the optimizer to be aware of the platform, we would either have to limit which predicates we use on HBase to match mem, or we could change mem to do a straight scan through in a single thread.  Keep in mind that this is only for DB2 compatibility mode and only mem platform that customers never see, which we are talking about optimizing.  I would argue that the implementation effort compared to possible benefit isn't worth it.", "author": "msirek", "createdAt": "2020-12-01T15:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MDUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMDUwMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r533630500", "bodyText": "After a discussion with @msirek we thought it better to open a JIRA to address this at a later time and keep this optimization here for now.", "author": "dgomezferro", "createdAt": "2020-12-01T18:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MDUyOA=="}], "type": "inlineReview"}, {"oid": "3876bc431b564b7521b33940ae7cfe3d26068c9b", "url": "https://github.com/splicemachine/spliceengine/commit/3876bc431b564b7521b33940ae7cfe3d26068c9b", "message": "DB-10895 Address review comments", "committedDate": "2020-12-01T21:56:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3Nzc1MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r534277751", "bodyText": "Remove this since we don't rely on it anymore.", "author": "dgomezferro", "createdAt": "2020-12-02T15:53:54Z", "path": "mem_sql/src/main/java/com/splicemachine/derby/lifecycle/MemDatabase.java", "diffHunk": "@@ -59,6 +59,7 @@ public static void main(String...args) throws Exception{\n             System.setProperty(\"com.splicemachine.enableLegacyAsserts\",Boolean.TRUE.toString());\n             SanityManager.DEBUG_SET(\"DumpOptimizedTree\");\n         }\n+        System.setProperty(\"com.splicemachine.isMemPlatform\",Boolean.TRUE.toString());", "originalCommit": "3876bc431b564b7521b33940ae7cfe3d26068c9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4OTE1OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4744#discussion_r534289159", "bodyText": "Thanks @dgomezferro , I've removed the line.", "author": "msirek", "createdAt": "2020-12-02T16:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3Nzc1MQ=="}], "type": "inlineReview"}, {"oid": "b5838bd2e31f166387edd3863eec6872cfe38498", "url": "https://github.com/splicemachine/spliceengine/commit/b5838bd2e31f166387edd3863eec6872cfe38498", "message": "DB-10895 Address review comments, part 2.", "committedDate": "2020-12-02T16:06:08Z", "type": "commit"}, {"oid": "0788ccd252009467a71cc06108ac301557751bd9", "url": "https://github.com/splicemachine/spliceengine/commit/0788ccd252009467a71cc06108ac301557751bd9", "message": "DB-10895 Fix InListMultiprobeIT", "committedDate": "2020-12-02T20:31:20Z", "type": "commit"}]}