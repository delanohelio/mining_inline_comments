{"pr_number": 4476, "pr_title": "DB-10484 Support new DECFLOAT data type ", "pr_createdAt": "2020-11-04T22:57:50Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4476", "timeline": [{"oid": "d4f32eacbc567621cfe4e7afe7e7753598926f21", "url": "https://github.com/splicemachine/spliceengine/commit/d4f32eacbc567621cfe4e7afe7e7753598926f21", "message": "DB-10484 Support new DECFLOAT type", "committedDate": "2020-11-04T22:53:19Z", "type": "commit"}, {"oid": "6d0c5334408d990432bf0ec34d3d3b246681f3ca", "url": "https://github.com/splicemachine/spliceengine/commit/6d0c5334408d990432bf0ec34d3d3b246681f3ca", "message": "Merge remote-tracking branch 'origin/master' into DB-10484", "committedDate": "2020-11-04T22:56:57Z", "type": "commit"}, {"oid": "d63cdfe6997cb62e00341a2c8e06ccf1a49a2d89", "url": "https://github.com/splicemachine/spliceengine/commit/d63cdfe6997cb62e00341a2c8e06ccf1a49a2d89", "message": "DB-10484 Fix spotbugs", "committedDate": "2020-11-05T00:05:25Z", "type": "commit"}, {"oid": "c4d8712ac9a639ff3864ef57aedc89903093b81e", "url": "https://github.com/splicemachine/spliceengine/commit/c4d8712ac9a639ff3864ef57aedc89903093b81e", "message": "DB-10484 Address comment", "committedDate": "2020-11-05T00:07:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNTU2Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4476#discussion_r517735562", "bodyText": "It may be not right to use DataTypes.BinaryType here. For native spark execution path, the use of defloat type will fail for the following case:\ncreate table t1 (a1 decfloat, b1 int);\ncreate table t2 (a2 decfloat, b2 int);\ninsert into t1 values (3,3);\ninsert into t2 values (3,3);\n\nselect * from t1, t2 --splice-properties useSpark=true, joinStrategy=broadcast\n> where a1=a2;\nERROR SE001: Splice Engine exception: unexpected exception\nERROR XJ001: Java exception: 'java.lang.RuntimeException: java.math.BigDecimal is not a valid external type for schema of binary: java.io.IOException'.\nERROR XJ001: Java exception: 'java.math.BigDecimal is not a valid external type for schema of binary: java.lang.RuntimeException'.", "author": "yxia92", "createdAt": "2020-11-05T01:52:44Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLDecfloat.java", "diffHunk": "@@ -0,0 +1,995 @@\n+/*\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ * Some parts of this source code are based on Apache Derby, and the following notices apply to\n+ * Apache Derby:\n+ *\n+ * Apache Derby is a subproject of the Apache DB project, and is licensed under\n+ * the Apache License, Version 2.0 (the \"License\"); you may not use these files\n+ * except in compliance with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed\n+ * under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * Splice Machine, Inc. has modified the Apache Derby code in this file.\n+ *\n+ * All such Splice Machine modifications are Copyright 2012 - 2020 Splice Machine, Inc.,\n+ * and are licensed to you under the GNU Affero General Public License.\n+ */\n+\n+package com.splicemachine.db.iapi.types;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import com.splicemachine.db.iapi.services.cache.ClassSize;\n+import com.splicemachine.db.iapi.services.io.ArrayInputStream;\n+import com.splicemachine.db.iapi.services.io.Storable;\n+import com.splicemachine.db.iapi.services.io.StoredFormatIds;\n+import com.splicemachine.db.iapi.services.sanity.SanityManager;\n+import com.splicemachine.db.iapi.types.DataValueFactoryImpl.Format;\n+import com.yahoo.sketches.theta.UpdateSketch;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.StructField;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Objects;\n+\n+/**\n+ * SQLDecfloat satisfies the DataValueDescriptor\n+ * interfaces (i.e., OrderableDataType). It implements a numeric/decimal column,\n+ * e.g. for * storing a column value; it can be specified\n+ * when constructed to not allow nulls. Nullability cannot be changed\n+ * after construction, as it affects the storage size and mechanism.\n+ * <p>\n+ * Because OrderableDataType is a subtype of DataType,\n+ * SQLDecfloat can play a role in either a DataType/Row\n+ * or a OrderableDataType/Row, interchangeably.\n+ * <p>\n+ * We assume the store has a flag for nullness of the value,\n+ * and simply return a 0-length array for the stored form\n+ * when the value is null.\n+ *\n+ */\n+public final class SQLDecfloat extends NumberDataType\n+{\n+    /**\n+     * object state.  Note that scale and precision are\n+     * always determined dynamically from value when\n+     * it is not null.\n+\n+       The field value can be null without the data value being null.\n+       In this case the value is stored in rawData and rawScale. This\n+       is to allow the minimal amount of work to read a SQLDecimal from disk.\n+       Creating the BigDecimal is expensive as it requires allocating\n+       three objects, the last two are a waste in the case the row does\n+       not qualify or the row will be written out by the sorter before being\n+       returned to the application.\n+        <P>\n+        This means that this field must be accessed for read indirectly through\n+        the getBigDecimal() method, and when setting it the rawData field must\n+        be set to null.\n+\n+     */\n+    private BigDecimal value;\n+\n+    /**\n+        See comments for value\n+    */\n+    private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLDecfloat.class);\n+    private static final int BIG_DECIMAL_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( BigDecimal.class);\n+\n+    public int estimateMemoryUsage()\n+    {\n+        int sz = BASE_MEMORY_USAGE;\n+        if( null != value)\n+            sz += BIG_DECIMAL_MEMORY_USAGE;\n+        return sz;\n+    }\n+\n+\n+    ////////////////////////////////////////////////////////////////////\n+    //\n+    // CLASS INTERFACE\n+    //\n+    ////////////////////////////////////////////////////////////////////\n+    /** no-arg constructor, required by Formattable */\n+    public SQLDecfloat() {\n+\n+    }\n+\n+    public SQLDecfloat(BigDecimal val)\n+    {\n+        setValue(val);\n+    }\n+\n+    public SQLDecfloat(String val)\n+    {\n+        setValue(new BigDecimal(val, MathContext.DECIMAL128));\n+    }\n+\n+    /*\n+     * DataValueDescriptor interface\n+     * (mostly implemented in DataType)\n+     *\n+     */\n+\n+\n+    /**\n+     * @exception StandardException thrown on failure to convert\n+     */\n+    public int    getInt() throws StandardException\n+    {\n+        if (isNull())\n+            return 0;\n+\n+        try {\n+            long lv = getLong();\n+\n+            if ((lv >= Integer.MIN_VALUE) && (lv <= Integer.MAX_VALUE))\n+                return (int) lv;\n+\n+        } catch (StandardException ignored) {\n+        }\n+\n+        throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, \"INTEGER\");\n+    }\n+\n+    /**\n+     * @exception StandardException thrown on failure to convert\n+     */\n+    public byte    getByte() throws StandardException\n+    {\n+        if (isNull())\n+            return (byte)0;\n+\n+        try {\n+            long lv = getLong();\n+\n+            if ((lv >= Byte.MIN_VALUE) && (lv <= Byte.MAX_VALUE))\n+                return (byte) lv;\n+\n+        } catch (StandardException ignored) {\n+        }\n+\n+        throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, \"TINYINT\");\n+    }\n+\n+    /**\n+     * @exception StandardException thrown on failure to convert\n+     */\n+    public short    getShort() throws StandardException\n+    {\n+        if (isNull())\n+            return (short)0;\n+\n+        try {\n+            long lv = getLong();\n+\n+            if ((lv >= Short.MIN_VALUE) && (lv <= Short.MAX_VALUE))\n+                return (short) lv;\n+\n+        } catch (StandardException ignored) {\n+        }\n+\n+        throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, \"SMALLINT\");\n+    }\n+\n+    /**\n+     * @exception StandardException thrown on failure to convert\n+     */\n+    public long    getLong() throws StandardException\n+    {\n+        BigDecimal localValue = getBigDecimal();\n+        if (localValue == null)\n+            return 0;\n+\n+        // Valid range for long is\n+        //   greater than Long.MIN_VALUE - 1\n+        // *and*\n+        //   less than Long.MAX_VALUE + 1\n+        //\n+        // This ensures that DECIMAL values with an integral value\n+        // equal to the Long.MIN/MAX_VALUE round correctly to those values.\n+        // e.g. 9223372036854775807.1  converts to 9223372036854775807\n+        // this matches DB2 UDB behaviour\n+\n+        if (   (localValue.compareTo(MINLONG_MINUS_ONE) > 0)\n+            && (localValue.compareTo(MAXLONG_PLUS_ONE) < 0)) {\n+\n+            return localValue.longValue();\n+        }\n+\n+        throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, \"BIGINT\");\n+    }\n+\n+    /**\n+     * @exception StandardException thrown on failure to convert\n+     */\n+    public float getFloat() throws StandardException\n+    {\n+        BigDecimal localValue = getBigDecimal();\n+        if (localValue == null)\n+            return (float)0;\n+\n+        // If the BigDecimal is out of range for the float\n+        // then positive or negative infinity is returned.\n+\n+        return NumberDataType.normalizeREAL(localValue.floatValue());\n+    }\n+\n+    /**\n+     *\n+     * If we have a value that is greater than the maximum double,\n+     * exception is thrown.  Otherwise, ok.  If the value is less\n+     * than can be represented by a double, ti will get set to\n+     * the smallest double value.\n+     *\n+     * @exception StandardException thrown on failure to convert\n+     */\n+    public double getDouble() throws StandardException\n+    {\n+        BigDecimal localValue = getBigDecimal();\n+        if (localValue == null)\n+            return 0;\n+\n+        // If the BigDecimal is out of range for double\n+        // then positive or negative infinity is returned.\n+        return NumberDataType.normalizeDOUBLE(localValue.doubleValue());\n+    }\n+\n+    public BigDecimal getBigDecimal()\n+    {\n+        if (isNull())\n+            return null;\n+\n+        return value;\n+    }\n+\n+    /**\n+     * DECIMAL implementation. Convert to a BigDecimal using getObject\n+     * which will return a BigDecimal\n+     */\n+    public int typeToBigDecimal() {\n+        return com.splicemachine.db.iapi.reference.Types.DECFLOAT;\n+    }\n+\n+    // 0 or null is false, all else is true\n+    public boolean    getBoolean() {\n+        BigDecimal localValue = getBigDecimal();\n+        return localValue != null && localValue.compareTo(ZERO) != 0;\n+    }\n+\n+    public String    getString() {\n+        BigDecimal localValue = getBigDecimal();\n+        if (localValue == null)\n+            return null;\n+        else\n+            return localValue.toPlainString();\n+    }\n+\n+    public Object getSparkObject() {\n+        return getObject();\n+    }\n+\n+    @Override\n+    public Object getObject() {\n+        return getBigDecimal();\n+    }\n+\n+    /* This is constructor used fo PyStoredProcedureResultSetFactory */\n+    public void setValue(Double theValue) throws StandardException{\n+        if(theValue==null){\n+            restoreToNull();\n+            return;\n+        }\n+        setValue(theValue.doubleValue());\n+    }\n+\n+    /**\n+     * Set the value from a correctly typed BigDecimal object.\n+     * @throws StandardException\n+     */\n+    void setObject(Object theValue) throws StandardException {\n+        setValue((BigDecimal) theValue);\n+    }\n+\n+    protected void setFrom(DataValueDescriptor theValue) throws StandardException {\n+        setCoreValue(SQLDecfloat.getBigDecimal(theValue));\n+    }\n+\n+    public int    getLength()\n+    {\n+        return getDecimalValuePrecision();\n+    }\n+\n+    // this is for DataType's error generator\n+    public String getTypeName() {\n+        return TypeId.DECFLOAT_NAME;\n+    }\n+\n+    /*\n+     * Storable interface, implies Externalizable, TypedFormat\n+     */\n+\n+    /**\n+        Return my format identifier.\n+\n+        @see com.splicemachine.db.iapi.services.io.TypedFormat#getTypeFormatId\n+    */\n+    public int getTypeFormatId()\n+    {\n+        return StoredFormatIds.SQL_DECFLOAT_ID;\n+    }\n+\n+    /*\n+     * see if the decimal value is null.\n+     */\n+    /* @see Storable#isNull\n+     */\n+    private boolean evaluateNull()\n+    {\n+        return (value == null);\n+    }\n+\n+    /**\n+     *\n+     */\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeBoolean(isNull);\n+        if (isNull)\n+            return;\n+        out.writeObject(value);\n+    }\n+\n+    /**\n+     * Note the use of rawData: we reuse the array if the\n+     * incoming array is the same length or smaller than\n+     * the array length.\n+     *\n+     * @see java.io.Externalizable#readExternal\n+     */\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\n+        if (in.readBoolean()) {\n+            setCoreValue(null);\n+            return;\n+        }\n+\n+        value = ((BigDecimal) in.readObject()).round(MathContext.DECIMAL128);\n+\n+        isNull = evaluateNull();\n+    }\n+    public void readExternalFromArray(ArrayInputStream in) throws IOException, ClassNotFoundException {\n+        value = ((BigDecimal) in.readObject()).round(MathContext.DECIMAL128);\n+        isNull = evaluateNull();\n+    }\n+\n+    /**\n+     * @see Storable#restoreToNull\n+     *\n+     */\n+    public void restoreToNull()\n+    {\n+        value = null;\n+        isNull = true;\n+    }\n+\n+\n+    /** @exception StandardException        Thrown on error */\n+    protected int typeCompare(DataValueDescriptor arg) throws StandardException\n+    {\n+        BigDecimal otherValue = SQLDecfloat.getBigDecimal(arg);\n+        return getBigDecimal().compareTo(otherValue);\n+    }\n+\n+    /*\n+     * DataValueDescriptor interface\n+     */\n+\n+    /**\n+     * @see DataValueDescriptor#cloneValue\n+     */\n+    public DataValueDescriptor cloneValue(boolean forceMaterialization)\n+    {\n+        try {\n+            return new SQLDecfloat(getBigDecimal());\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * @see DataValueDescriptor#getNewNull\n+     */\n+    public DataValueDescriptor getNewNull() {\n+        try {\n+            return new SQLDecfloat();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * @see DataValueDescriptor#setValueFromResultSet\n+     *\n+     * @exception SQLException        Thrown on error\n+     */\n+    public void setValueFromResultSet(ResultSet resultSet, int colNumber,\n+                                      boolean isNullable)\n+        throws SQLException\n+    {\n+            setValue(resultSet.getBigDecimal(colNumber));\n+    }\n+    /**\n+        Set the value into a PreparedStatement.\n+\n+        @exception SQLException Error setting value in PreparedStatement\n+    */\n+    public final void setInto(PreparedStatement ps, int position) throws SQLException {\n+\n+        if (isNull()) {\n+            ps.setNull(position, com.splicemachine.db.iapi.reference.Types.DECFLOAT);\n+            return;\n+        }\n+\n+        ps.setBigDecimal(position, getBigDecimal());\n+    }\n+\n+    /**\n+     *\n+     * <B> WARNING </B> there is no checking to make sure\n+     * that theValue doesn't exceed the precision/scale of\n+     * the current SQLDecimal.  It is just assumed that the\n+     * SQLDecimal is supposed to take the precision/scale of\n+     * the BigDecimalized String.\n+     *\n+     * @exception StandardException throws NumberFormatException\n+     *        when the String format is not recognized.\n+     */\n+    public void setValue(String theValue) throws StandardException\n+    {\n+        if (theValue == null)\n+        {\n+            restoreToNull();\n+        }\n+        else\n+        {\n+            try\n+            {\n+                theValue = theValue.trim();\n+                setValue(new BigDecimal(theValue, MathContext.DECIMAL128));\n+            } catch (NumberFormatException nfe)\n+            {\n+                throw invalidFormat();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @see NumberDataValue#setValue\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public void setValue(double theValue) throws StandardException\n+    {\n+        setCoreValue(NumberDataType.normalizeDOUBLE(theValue));\n+        isNull = evaluateNull();\n+    }\n+\n+    /**\n+     * @see NumberDataValue#setValue\n+     *\n+     */\n+    public void setValue(float theValue)\n+        throws StandardException\n+    {\n+        setCoreValue((double)NumberDataType.normalizeREAL(theValue));\n+        isNull = evaluateNull();\n+    }\n+\n+    /**\n+     * @see NumberDataValue#setValue\n+     *\n+     */\n+    public void setValue(long theValue)\n+    {\n+        value = new BigDecimal(theValue, MathContext.DECIMAL128);\n+        isNull = false;\n+    }\n+\n+    /**\n+     * @see NumberDataValue#setValue\n+     *\n+     */\n+    public void setValue(int theValue)\n+    {\n+        setValue((long)theValue);\n+        isNull = evaluateNull();\n+    }\n+\n+    public void setValue(BigDecimal theValue)\n+    {\n+        setCoreValue(theValue);\n+    }\n+\n+    /**\n+        Only to be called when the application sets a value using BigDecimal\n+        through setBigDecimal calls.\n+    */\n+    public void setBigDecimal(Number theValue) throws StandardException\n+    {\n+        setCoreValue((BigDecimal) theValue);\n+    }\n+\n+    /**\n+        Called when setting a DECIMAL value internally or from\n+        through a procedure or function.\n+        Handles long in addition to BigDecimal to handle\n+        identity being stored as a long but returned as a DECIMAL.\n+    */\n+    public void setValue(Number theValue) throws StandardException\n+    {\n+        if (SanityManager.ASSERT)\n+        {\n+            if (theValue != null &&\n+                !(theValue instanceof BigDecimal) &&\n+                !(theValue instanceof Long))\n+                SanityManager.THROWASSERT(\"SQLDecimal.setValue(Number) passed a \" + theValue.getClass());\n+        }\n+\n+        if (theValue instanceof BigDecimal || theValue == null)\n+            setCoreValue((BigDecimal) theValue);\n+        else\n+            setValue(theValue.longValue());\n+    }\n+\n+    /**\n+     * @see NumberDataValue#setValue\n+     *\n+     */\n+    public void setValue(boolean theValue)\n+    {\n+        setCoreValue(theValue ? ONE : ZERO);\n+    }\n+\n+    /*\n+     * DataValueDescriptor interface\n+     */\n+\n+    /** @see DataValueDescriptor#typePrecedence */\n+    public int typePrecedence()\n+    {\n+        return TypeId.DECFLOAT_PRECEDENCE;\n+    }\n+    // END DataValueDescriptor interface\n+\n+    private void setCoreValue(BigDecimal theValue)\n+    {\n+        if (theValue == null) {\n+            value = null;\n+        } else {\n+            value = theValue.round(MathContext.DECIMAL128);\n+        }\n+        isNull = evaluateNull();\n+    }\n+\n+    private void setCoreValue(double theValue) {\n+        value = new BigDecimal(Double.toString(theValue), MathContext.DECIMAL128);\n+        isNull = false;\n+    }\n+\n+    /**\n+     * Normalization method - this method may be called when putting\n+     * a value into a SQLDecimal, for example, when inserting into a SQLDecimal\n+     * column.  See NormalizeResultSet in execution.\n+     * <p>\n+     * Note that truncation is allowed on the decimal portion\n+     * of a numeric only.\n+     *\n+     * @param desiredType    The type to normalize the source column to\n+     * @param source        The value to normalize\n+     *\n+     * @throws StandardException                Thrown for null into\n+     *                                            non-nullable column, and for\n+     *                                            truncation error\n+     */\n+    public void normalize(\n+                DataTypeDescriptor desiredType,\n+                DataValueDescriptor source)\n+                        throws StandardException\n+    {\n+        setFrom(source);\n+    }\n+\n+\n+    /*\n+    ** SQL Operators\n+    */\n+\n+\n+    /**\n+     * This method implements the + operator for DECIMAL.\n+     *\n+     * @param addend1    One of the addends\n+     * @param addend2    The other addend\n+     * @param result    The result of a previous call to this method, null\n+     *                    if not called yet\n+     *\n+     * @return    A SQLDecimal containing the result of the addition\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public NumberDataValue plus(NumberDataValue addend1,\n+                            NumberDataValue addend2,\n+                            NumberDataValue result)\n+                throws StandardException\n+    {\n+        if (result == null)\n+        {\n+            result = new SQLDecfloat();\n+        }\n+\n+        if (addend1.isNull() || addend2.isNull())\n+        {\n+            result.setToNull();\n+            return result;\n+        }\n+\n+        result.setBigDecimal(Objects.requireNonNull(SQLDecfloat.getBigDecimal(addend1)).add(SQLDecfloat.getBigDecimal(addend2), MathContext.DECIMAL128));\n+        return result;\n+    }\n+\n+    /**\n+     * This method implements the - operator for \"decimal - decimal\".\n+     *\n+     * @param left    The value to be subtracted from\n+     * @param right    The value to be subtracted\n+     * @param result    The result of a previous call to this method, null\n+     *                    if not called yet\n+     *\n+     * @return    A SQLDecimal containing the result of the subtraction\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public NumberDataValue minus(NumberDataValue left,\n+                            NumberDataValue right,\n+                            NumberDataValue result)\n+                throws StandardException\n+    {\n+        if (result == null)\n+        {\n+            result = new SQLDecfloat();\n+        }\n+\n+        if (left.isNull() || right.isNull())\n+        {\n+            result.setToNull();\n+            return result;\n+        }\n+\n+        result.setBigDecimal(Objects.requireNonNull(SQLDecfloat.getBigDecimal(left)).subtract(SQLDecfloat.getBigDecimal(right), MathContext.DECIMAL128));\n+        return result;\n+    }\n+\n+    /**\n+     * This method implements the * operator for \"double * double\".\n+     *\n+     * @param left    The first value to be multiplied\n+     * @param right    The second value to be multiplied\n+     * @param result    The result of a previous call to this method, null\n+     *                    if not called yet\n+     *\n+     * @return    A SQLDecimal containing the result of the multiplication\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public NumberDataValue times(NumberDataValue left,\n+                            NumberDataValue right,\n+                            NumberDataValue result)\n+                throws StandardException\n+    {\n+        if (result == null)\n+        {\n+            result = new SQLDecfloat();\n+        }\n+\n+        if (left.isNull() || right.isNull())\n+        {\n+            result.setToNull();\n+            return result;\n+        }\n+\n+        result.setBigDecimal(Objects.requireNonNull(SQLDecfloat.getBigDecimal(left)).multiply(SQLDecfloat.getBigDecimal(right), MathContext.DECIMAL128));\n+        return result;\n+    }\n+\n+    /**\n+     * This method implements the / operator for BigDecimal/BigDecimal\n+     *\n+     * @param dividend    The numerator\n+     * @param divisor    The denominator\n+     * @param result    The result of a previous call to this method, null\n+     *                    if not called yet\n+     *\n+     * @return    A SQLDecimal containing the result of the division\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public NumberDataValue divide(NumberDataValue dividend,\n+                             NumberDataValue divisor,\n+                             NumberDataValue result)\n+                throws StandardException\n+    {\n+        return divide(dividend, divisor, result, -1);\n+    }\n+\n+    /**\n+     * This method implements the / operator for BigDecimal/BigDecimal\n+     *\n+     * @param dividend    The numerator\n+     * @param divisor    The denominator\n+     * @param result    The result of a previous call to this method, null\n+     *                    if not called yet\n+     * @param scale        The result scale, if < 0, calculate the scale according\n+     *                    to the actual values' sizes\n+     *\n+     * @return    A SQLDecimal containing the result of the division\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public NumberDataValue divide(NumberDataValue dividend,\n+                             NumberDataValue divisor,\n+                             NumberDataValue result,\n+                             int scale)\n+                throws StandardException\n+    {\n+        if (result == null)\n+        {\n+            result = new SQLDecfloat();\n+        }\n+\n+        if (dividend.isNull() || divisor.isNull())\n+        {\n+            result.setToNull();\n+            return result;\n+        }\n+\n+        BigDecimal divisorBigDecimal = SQLDecfloat.getBigDecimal(divisor);\n+\n+        if (divisorBigDecimal.compareTo(ZERO) == 0)\n+        {\n+            throw  StandardException.newException(SQLState.LANG_DIVIDE_BY_ZERO);\n+        }\n+        BigDecimal dividendBigDecimal = SQLDecfloat.getBigDecimal(dividend);\n+\n+        /*\n+        ** Set the result scale to be either the passed in scale, whcih was\n+        ** calculated at bind time to be max(ls+rp-rs+1, 4), where ls,rp,rs\n+        ** are static data types' sizes, which are predictable and stable\n+        ** (for the whole result set column, eg.); otherwise dynamically\n+        ** calculates the scale according to actual values.  Beetle 3901\n+        */\n+        assert dividendBigDecimal != null;\n+        result.setBigDecimal(dividendBigDecimal.divide(\n+                                    divisorBigDecimal,\n+                                    MathContext.DECIMAL128));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * This method implements the unary minus operator for double.\n+     *\n+     * @param result    The result of a previous call to this method, null\n+     *                    if not called yet\n+     *\n+     * @return    A SQLDecimal containing the result of the division\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public NumberDataValue minus(NumberDataValue result)\n+                                    throws StandardException\n+    {\n+        if (result == null)\n+        {\n+            result = new SQLDecfloat();\n+        }\n+\n+        if (this.isNull())\n+        {\n+            result.setToNull();\n+            return result;\n+        }\n+\n+        result.setBigDecimal(Objects.requireNonNull(getBigDecimal()).negate(MathContext.DECIMAL128));\n+        return result;\n+    }\n+\n+    /**\n+     * This method implements the isNegative method.\n+     *\n+     * @return  A boolean.  If this.value is negative, return true.\n+     *          For positive values or null, return false.\n+     */\n+\n+    protected boolean isNegative()\n+    {\n+        return !isNull() && (Objects.requireNonNull(getBigDecimal()).compareTo(ZERO) < 0);\n+    }\n+\n+    /*\n+     * String display of value\n+     */\n+    public String toString()\n+    {\n+        if (isNull())\n+            return \"NULL\";\n+        else\n+            return getString();\n+    }\n+\n+    /*\n+     * Hash code\n+     */\n+    public int hashCode()\n+    {\n+        long longVal;\n+        BigDecimal localValue = getBigDecimal();\n+\n+        double doubleVal = (localValue != null) ? localValue.doubleValue() : 0;\n+\n+        if (Double.isInfinite(doubleVal))\n+        {\n+            /*\n+             ** This loses the fractional part, but it probably doesn't\n+             ** matter for numbers that are big enough to overflow a double -\n+             ** it's probably rare for numbers this big to be different only in\n+             ** their fractional parts.\n+             */\n+            longVal = localValue.longValue();\n+        }\n+        else\n+        {\n+            longVal = (long) doubleVal;\n+            if (longVal != doubleVal)\n+            {\n+                longVal = Double.doubleToLongBits(doubleVal);\n+            }\n+        }\n+\n+        return (int) (longVal ^ (longVal >> 32));\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////\n+    //\n+    // VariableSizeDataValue interface\n+    //\n+    ///////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Return the SQL scale of this value, number of digits after the\n+     * decimal point, or zero for a whole number. This does not match the\n+     * return from BigDecimal.scale() since in J2SE 5.0 onwards that can return\n+     * negative scales.\n+     */\n+    public int getDecimalValuePrecision()\n+    {\n+        if (isNull())\n+            return 0;\n+\n+        BigDecimal localValue = getBigDecimal();\n+\n+        return SQLDecfloat.getWholeDigits(localValue) + getDecimalValueScale();\n+    }\n+\n+    /**\n+     * Get a BigDecimal representing the value of a DataValueDescriptor\n+     * @param value Non-null value to be converted\n+     * @return BigDecimal value\n+     * @throws StandardException Invalid conversion or out of range.\n+     */\n+    public static BigDecimal getBigDecimal(DataValueDescriptor value) throws StandardException\n+    {\n+        if (SanityManager.DEBUG)\n+        {\n+            if (value.isNull())\n+                SanityManager.THROWASSERT(\"NULL value passed to SQLDecimal.getBigDecimal\");\n+        }\n+\n+        switch (value.typeToBigDecimal())\n+        {\n+        case com.splicemachine.db.iapi.reference.Types.DECFLOAT:\n+        case Types.DECIMAL:\n+            return ((BigDecimal) value.getObject()).round(MathContext.DECIMAL128);\n+        case Types.CHAR:\n+            try {\n+                return new BigDecimal(value.getString().trim(), MathContext.DECIMAL128);\n+            } catch (NumberFormatException nfe) {\n+                throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, \"java.math.BigDecimal\");\n+            }\n+        case Types.BIGINT:\n+            return BigDecimal.valueOf(value.getLong());\n+        default:\n+            if (SanityManager.DEBUG)\n+                SanityManager.THROWASSERT(\"invalid return from \" + value.getClass() + \".typeToBigDecimal() \" + value.typeToBigDecimal());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Calculate the number of digits to the left of the decimal point\n+     * of the passed in value.\n+     * @param decimalValue Value to get whole digits from, never null.\n+     * @return number of whole digits.\n+     */\n+    private static int getWholeDigits(BigDecimal decimalValue) {\n+        /**\n+         * if ONE > abs(value) then the number of whole digits is 0\n+         */\n+        decimalValue = decimalValue.abs();\n+        if (ONE.compareTo(decimalValue) > 0)\n+            return 0;\n+        return decimalValue.precision() - decimalValue.scale();\n+    }\n+\n+    public Format getFormat() {\n+        return Format.DECFLOAT;\n+    }\n+\n+    @Override\n+    public void read(Row row, int ordinal) throws StandardException {\n+        if (row.isNullAt(ordinal))\n+            setToNull();\n+        else {\n+            isNull = false;\n+            value = row.getDecimal(ordinal).round(MathContext.DECIMAL128);\n+        }\n+    }\n+\n+    @Override\n+    public StructField getStructField(String columnName) {\n+        return DataTypes.createStructField(columnName, DataTypes.BinaryType, true);", "originalCommit": "c4d8712ac9a639ff3864ef57aedc89903093b81e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI0MTI4OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4476#discussion_r518241289", "bodyText": "Good point,\nSQLDecfloat.getSparkObject / setSparkObject now work with Strings.\nUntil we define a proper native spark sql type for decfloat, ordering will not be possible", "author": "arnaud-splice", "createdAt": "2020-11-05T17:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNTU2Mg=="}], "type": "inlineReview"}, {"oid": "b7698a52a062353d5e7a0867ae9dd0d1a9bb00ea", "url": "https://github.com/splicemachine/spliceengine/commit/b7698a52a062353d5e7a0867ae9dd0d1a9bb00ea", "message": "DB-10484 Fix native spark usage (as string) and disable order by", "committedDate": "2020-11-05T17:36:03Z", "type": "commit"}, {"oid": "44b8f0dc74a1a47ed3438d92c421459b454de0bb", "url": "https://github.com/splicemachine/spliceengine/commit/44b8f0dc74a1a47ed3438d92c421459b454de0bb", "message": "Merge remote-tracking branch 'origin/master' into DB-10484", "committedDate": "2020-11-05T17:37:33Z", "type": "commit"}, {"oid": "d1ec9883ecfe7ccc76100111cc91d6910c3cf19a", "url": "https://github.com/splicemachine/spliceengine/commit/d1ec9883ecfe7ccc76100111cc91d6910c3cf19a", "message": "DB-10484 Fix weird error in unit test", "committedDate": "2020-11-05T18:28:50Z", "type": "commit"}]}