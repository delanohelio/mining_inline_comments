{"pr_number": 4734, "pr_title": "DB-10455 add LIST_DIRECTORY and ANALYZE_EXTERNAL_TABLE", "pr_createdAt": "2020-11-30T12:08:26Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4734", "timeline": [{"oid": "903bd7776a930812807d7172d5dbe3c429cb88a0", "url": "https://github.com/splicemachine/spliceengine/commit/903bd7776a930812807d7172d5dbe3c429cb88a0", "message": "DB-10455 fix path varchar too short", "committedDate": "2020-12-09T07:40:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0MDE0Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543240147", "bodyText": "better to use interface List in the variable definition, like rows, private\nList<Column> columns = new ArrayList<>();'", "author": "ipraznik-splice", "createdAt": "2020-12-15T10:50:22Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/ResultHelper.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.utils;\n+\n+import com.splicemachine.db.iapi.error.PublicAPI;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.Activation;\n+import com.splicemachine.db.iapi.sql.ResultColumnDescriptor;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.DataTypeDescriptor;\n+import com.splicemachine.db.iapi.types.SQLLongint;\n+import com.splicemachine.db.iapi.types.SQLTimestamp;\n+import com.splicemachine.db.iapi.types.SQLVarchar;\n+import com.splicemachine.db.impl.jdbc.EmbedConnection;\n+import com.splicemachine.db.impl.jdbc.EmbedResultSet40;\n+import com.splicemachine.db.impl.sql.GenericColumnDescriptor;\n+import com.splicemachine.db.impl.sql.execute.IteratorNoPutResultSet;\n+import com.splicemachine.db.impl.sql.execute.ValueRow;\n+import org.joda.time.DateTime;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A helper to create a ResultSet with columns\n+ * use e.g.\n+ *   ResultHelper resultHelper = new ResultHelper();\n+ *\n+ *   // order here determines order in column\n+ *   ResultHelper.VarcharColumn   colUser    = resultHelper.addVarchar(\"USER\", 10);\n+ *   ResultHelper.TimestampColumn colTime    = resultHelper.addTimestamp(\"TIME\", 30);\n+ *   ResultHelper.BigintColumn    colNumber  = resultHelper.addBigint(\"NUMBER\", 10);\n+ *\n+ *   for(...)\n+ *   {\n+ *       resultHelper.newRow();\n+ *       colTime.set( new DateTime(...) );\n+ *       colUser.set( userName );\n+ *       if( hasNumber ) // if not set, will be displayed as NULL\n+ *          colNumber.set( 23 );\n+ *   }\n+ *   ResultSet rs = resultHelper.getResultSet();\n+ *   resultSet[0] = rs;\n+ *\n+ */\n+class ResultHelper {\n+    public VarcharColumn addVarchar(String name, int length) {\n+        VarcharColumn c = new VarcharColumn();\n+        c.add(name, length);\n+        return c;\n+    }\n+\n+    public BigintColumn addBigint(String name, int length)\n+    {\n+        BigintColumn c = new BigintColumn();\n+        c.add(name, length);\n+        return c;\n+    }\n+\n+    public TimestampColumn addTimestamp(String name, int length)\n+    {\n+        TimestampColumn c = new TimestampColumn();\n+        c.add(name, length);\n+        return c;\n+    }\n+\n+    public int numColumns() {\n+        return columnDescriptors.size();\n+    }\n+\n+    public ResultColumnDescriptor[] getColumnDescriptorsArray() {\n+        return columnDescriptors.toArray(new ResultColumnDescriptor[columnDescriptors.size()]);\n+    }\n+\n+    void newRow()\n+    {\n+        finishRow();\n+        row = new ValueRow(numColumns());\n+    }\n+    void finishRow() {\n+        if( row == null ) return;\n+        for(Column c : columns) c.finishRow();\n+        rows.add(row);\n+        row = null;\n+    }\n+\n+    public ResultSet getResultSet() throws SQLException {\n+        finishRow();\n+\n+        EmbedConnection conn = (EmbedConnection) BaseAdminProcedures.getDefaultConn();\n+        Activation lastActivation = conn.getLanguageConnection().getLastActivation();\n+\n+        IteratorNoPutResultSet resultsToWrap = new IteratorNoPutResultSet(rows, getColumnDescriptorsArray(), lastActivation);\n+        try {\n+            resultsToWrap.openCore();\n+        } catch (StandardException se) {\n+            throw PublicAPI.wrapStandardException(se);\n+        }\n+        return new EmbedResultSet40(conn, resultsToWrap, false, null, true);\n+    }\n+\n+    class Column {\n+        public int index;\n+        boolean set = false;\n+\n+        public void finishRow() {\n+            if( !set ) init();\n+            set = false;\n+        }\n+\n+        void add(String name, int length)\n+        {\n+            columnDescriptors.add( new GenericColumnDescriptor(name, create(length)) );\n+            index = columnDescriptors.size();\n+            columns.add(this);\n+        }\n+\n+        void init() { throw new RuntimeException(\"not implemented\"); }\n+\n+        public DataTypeDescriptor create(int length) { throw new RuntimeException(\"not implemented\"); }\n+    }\n+\n+    class VarcharColumn extends Column {\n+        @Override\n+        public DataTypeDescriptor create(int length)\n+        {\n+            return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, length);\n+        }\n+        public void set(String value) {\n+            assert row != null;\n+            row.setColumn(index, new SQLVarchar(value));\n+            set = true;\n+        }\n+        @Override\n+        public void init() {\n+            set(\"\");\n+        }\n+    }\n+    class BigintColumn extends Column {\n+        @Override\n+        public DataTypeDescriptor create(int length)\n+        {\n+            return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT, length);\n+        }\n+        public void set(long value) {\n+            assert row != null;\n+            row.setColumn(index, new SQLLongint(value));\n+            set = true;\n+        }\n+        @Override\n+        public void init() {\n+            set(0);\n+        }\n+    }\n+\n+    class TimestampColumn extends Column {\n+        @Override\n+        public DataTypeDescriptor create(int length)\n+        {\n+            return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIMESTAMP, length);\n+        }\n+        public void set(org.joda.time.DateTime value) throws StandardException {\n+            assert row != null;\n+            row.setColumn(index, new SQLTimestamp(value));\n+            set = true;\n+        }\n+        @Override\n+        public void init() {\n+            try {\n+                set( new DateTime(0));\n+            } catch (StandardException e) {\n+            }\n+        }\n+    }\n+    private List<ExecRow> rows = new ArrayList<>();\n+    private ArrayList<Column> columns = new ArrayList<>();", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNjY3Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r544136676", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-12-16T09:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0MDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0MDU1Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543240556", "bodyText": "the same", "author": "ipraznik-splice", "createdAt": "2020-12-15T10:51:01Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/ResultHelper.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.utils;\n+\n+import com.splicemachine.db.iapi.error.PublicAPI;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.Activation;\n+import com.splicemachine.db.iapi.sql.ResultColumnDescriptor;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.DataTypeDescriptor;\n+import com.splicemachine.db.iapi.types.SQLLongint;\n+import com.splicemachine.db.iapi.types.SQLTimestamp;\n+import com.splicemachine.db.iapi.types.SQLVarchar;\n+import com.splicemachine.db.impl.jdbc.EmbedConnection;\n+import com.splicemachine.db.impl.jdbc.EmbedResultSet40;\n+import com.splicemachine.db.impl.sql.GenericColumnDescriptor;\n+import com.splicemachine.db.impl.sql.execute.IteratorNoPutResultSet;\n+import com.splicemachine.db.impl.sql.execute.ValueRow;\n+import org.joda.time.DateTime;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A helper to create a ResultSet with columns\n+ * use e.g.\n+ *   ResultHelper resultHelper = new ResultHelper();\n+ *\n+ *   // order here determines order in column\n+ *   ResultHelper.VarcharColumn   colUser    = resultHelper.addVarchar(\"USER\", 10);\n+ *   ResultHelper.TimestampColumn colTime    = resultHelper.addTimestamp(\"TIME\", 30);\n+ *   ResultHelper.BigintColumn    colNumber  = resultHelper.addBigint(\"NUMBER\", 10);\n+ *\n+ *   for(...)\n+ *   {\n+ *       resultHelper.newRow();\n+ *       colTime.set( new DateTime(...) );\n+ *       colUser.set( userName );\n+ *       if( hasNumber ) // if not set, will be displayed as NULL\n+ *          colNumber.set( 23 );\n+ *   }\n+ *   ResultSet rs = resultHelper.getResultSet();\n+ *   resultSet[0] = rs;\n+ *\n+ */\n+class ResultHelper {\n+    public VarcharColumn addVarchar(String name, int length) {\n+        VarcharColumn c = new VarcharColumn();\n+        c.add(name, length);\n+        return c;\n+    }\n+\n+    public BigintColumn addBigint(String name, int length)\n+    {\n+        BigintColumn c = new BigintColumn();\n+        c.add(name, length);\n+        return c;\n+    }\n+\n+    public TimestampColumn addTimestamp(String name, int length)\n+    {\n+        TimestampColumn c = new TimestampColumn();\n+        c.add(name, length);\n+        return c;\n+    }\n+\n+    public int numColumns() {\n+        return columnDescriptors.size();\n+    }\n+\n+    public ResultColumnDescriptor[] getColumnDescriptorsArray() {\n+        return columnDescriptors.toArray(new ResultColumnDescriptor[columnDescriptors.size()]);\n+    }\n+\n+    void newRow()\n+    {\n+        finishRow();\n+        row = new ValueRow(numColumns());\n+    }\n+    void finishRow() {\n+        if( row == null ) return;\n+        for(Column c : columns) c.finishRow();\n+        rows.add(row);\n+        row = null;\n+    }\n+\n+    public ResultSet getResultSet() throws SQLException {\n+        finishRow();\n+\n+        EmbedConnection conn = (EmbedConnection) BaseAdminProcedures.getDefaultConn();\n+        Activation lastActivation = conn.getLanguageConnection().getLastActivation();\n+\n+        IteratorNoPutResultSet resultsToWrap = new IteratorNoPutResultSet(rows, getColumnDescriptorsArray(), lastActivation);\n+        try {\n+            resultsToWrap.openCore();\n+        } catch (StandardException se) {\n+            throw PublicAPI.wrapStandardException(se);\n+        }\n+        return new EmbedResultSet40(conn, resultsToWrap, false, null, true);\n+    }\n+\n+    class Column {\n+        public int index;\n+        boolean set = false;\n+\n+        public void finishRow() {\n+            if( !set ) init();\n+            set = false;\n+        }\n+\n+        void add(String name, int length)\n+        {\n+            columnDescriptors.add( new GenericColumnDescriptor(name, create(length)) );\n+            index = columnDescriptors.size();\n+            columns.add(this);\n+        }\n+\n+        void init() { throw new RuntimeException(\"not implemented\"); }\n+\n+        public DataTypeDescriptor create(int length) { throw new RuntimeException(\"not implemented\"); }\n+    }\n+\n+    class VarcharColumn extends Column {\n+        @Override\n+        public DataTypeDescriptor create(int length)\n+        {\n+            return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, length);\n+        }\n+        public void set(String value) {\n+            assert row != null;\n+            row.setColumn(index, new SQLVarchar(value));\n+            set = true;\n+        }\n+        @Override\n+        public void init() {\n+            set(\"\");\n+        }\n+    }\n+    class BigintColumn extends Column {\n+        @Override\n+        public DataTypeDescriptor create(int length)\n+        {\n+            return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT, length);\n+        }\n+        public void set(long value) {\n+            assert row != null;\n+            row.setColumn(index, new SQLLongint(value));\n+            set = true;\n+        }\n+        @Override\n+        public void init() {\n+            set(0);\n+        }\n+    }\n+\n+    class TimestampColumn extends Column {\n+        @Override\n+        public DataTypeDescriptor create(int length)\n+        {\n+            return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIMESTAMP, length);\n+        }\n+        public void set(org.joda.time.DateTime value) throws StandardException {\n+            assert row != null;\n+            row.setColumn(index, new SQLTimestamp(value));\n+            set = true;\n+        }\n+        @Override\n+        public void init() {\n+            try {\n+                set( new DateTime(0));\n+            } catch (StandardException e) {\n+            }\n+        }\n+    }\n+    private List<ExecRow> rows = new ArrayList<>();\n+    private ArrayList<Column> columns = new ArrayList<>();\n+    private ArrayList<GenericColumnDescriptor> columnDescriptors = new ArrayList<>();", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0MzMzNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543243335", "bodyText": "fs is not closed on the end", "author": "ipraznik-splice", "createdAt": "2020-12-15T10:55:00Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -1926,6 +1930,77 @@ public static void SYSCS_GET_OLDEST_ACTIVE_TRANSACTION(ResultSet[] resultSet) th\n         return rows;\n     }\n \n+    public static String getCurrentUserId() throws SQLException {\n+        EmbedConnection conn = (EmbedConnection)getDefaultConn();\n+        Activation lastActivation = conn.getLanguageConnection().getLastActivation();\n+        return lastActivation.getLanguageConnectionContext().getCurrentUserId(lastActivation);\n+    }\n+\n+    public static void ANALYZE_EXTERNAL_TABLE(String location, final ResultSet[] resultSet) throws IOException, SQLException {\n+\n+        GetSchemaExternalResult result = DistributedGetSchemaExternalJob.execute(location, getCurrentUserId()+\"_analyze\",\n+                    null, false, new CsvOptions(), null, null);\n+\n+        String[] res = result.getSuggestedSchema(\"\\n\").split(\"\\n\");\n+        int maxLen = Arrays.stream(res).map(String::length).max(Integer::compareTo).get();\n+\n+        ResultHelper resultHelper = new ResultHelper();\n+        ResultHelper.VarcharColumn col1 = resultHelper.addVarchar(\"SCHEMA\", Math.max(maxLen, 20));\n+\n+        for(String s : res ) {\n+            resultHelper.newRow();\n+            col1.set(s);\n+        }\n+        resultSet[0] = resultHelper.getResultSet();\n+    }\n+\n+    public static void LIST_DIRECTORY(String location, final ResultSet[] resultSet) throws SQLException, IOException, URISyntaxException {\n+        DistributedFileSystem  fs = null;", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NDM5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543444393", "bodyText": "sorry, my mistake, I thought it's org.apache.hadoop.dfs.DistributedFileSystem, com.splicemachine.access.api.DistributedFileSystem has no close, please ignore my comment", "author": "ipraznik-splice", "createdAt": "2020-12-15T15:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0MzMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0NTg0NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543245845", "bodyText": "should be here also real timeout check, if for example the operation takes too long time? In another case could be an endless loop", "author": "ipraznik-splice", "createdAt": "2020-12-15T10:58:50Z", "path": "splice_machine/src/main/java/com/splicemachine/procedures/external/DistributedGetSchemaExternalJob.java", "diffHunk": "@@ -58,6 +61,38 @@ public DistributedGetSchemaExternalJob(String location,\n         this.partitionColumns = partitionColumns;\n     }\n \n+    public static GetSchemaExternalResult execute(String location,\n+                 String jobGroup,\n+                 String storedAs,\n+                 boolean mergeSchema,\n+                 CsvOptions csvOptions,\n+                 StructType nonPartitionColumns,\n+                 StructType partitionColumns) throws IOException {\n+        Future<GetSchemaExternalResult> futureResult = EngineDriver.driver().getOlapClient().\n+                submit(new DistributedGetSchemaExternalJob(location, jobGroup, storedAs, mergeSchema, csvOptions,\n+                        nonPartitionColumns, partitionColumns));\n+        GetSchemaExternalResult result = null;\n+        SConfiguration config = EngineDriver.driver().getConfiguration();\n+\n+        while (result == null) {\n+            try {", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNjU4MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r544136581", "bodyText": "this code was just moved, i didn't change or add it. however, you're still right and\nwe also have similar code in IndexConstantOperation and SpliceTableAdmin. i created a new JIRA item for this DB-11054 .", "author": "martinrupp", "createdAt": "2020-12-16T09:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0NTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1MDExNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543250114", "bodyText": "Shouldn't we at least log the exception (or re-throw it)? otherwise the user might think the directory was actually empty but in reality we e.g. couldn't connect.", "author": "hatyo", "createdAt": "2020-12-15T11:05:28Z", "path": "hbase_storage/src/main/java/com/splicemachine/storage/HNIOFileSystem.java", "diffHunk": "@@ -197,6 +194,24 @@ public HFileInfo(FileStatus fileStatus) {\n             return res;\n         }\n \n+        @Override\n+        public FileInfo[] listDir()\n+        {\n+            if( !exists() ) return new FileInfo[] {};\n+            if( !isDirectory() ) return new FileInfo[] { this };\n+            ArrayList<FileInfo> res = new ArrayList<>();\n+            try {\n+                RemoteIterator<LocatedFileStatus> iterator = fs.listLocatedStatus(path);\n+                while (iterator.hasNext()) {\n+                    res.add( new HFileInfo(iterator.next()) );\n+                }\n+\n+            } catch (IOException e) {\n+                return new FileInfo[0];", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzMTA2Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543431063", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-12-15T15:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1MDExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1MjM4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543252382", "bodyText": "This probably doesn't matter since it is a local variable, but I would normally declare a variable using the interface type java.util.List because it makes it easier to understand the intended usage of it later on (since you will be using standard List methods and not something special to ArrayList).", "author": "hatyo", "createdAt": "2020-12-15T11:09:04Z", "path": "hbase_storage/src/main/java/com/splicemachine/storage/HNIOFileSystem.java", "diffHunk": "@@ -197,6 +194,24 @@ public HFileInfo(FileStatus fileStatus) {\n             return res;\n         }\n \n+        @Override\n+        public FileInfo[] listDir()\n+        {\n+            if( !exists() ) return new FileInfo[] {};\n+            if( !isDirectory() ) return new FileInfo[] { this };\n+            ArrayList<FileInfo> res = new ArrayList<>();", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzMTAyMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543431023", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-12-15T15:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1MjM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1NTQyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543255427", "bodyText": "I wouldn't do that, instead I might throw a RuntimeException and/or use our logging mechanism to log the exception. IIRC printStackTrace writes to stderr which could be not inline with our logging framework.", "author": "hatyo", "createdAt": "2020-12-15T11:13:33Z", "path": "mem_storage/src/main/java/com/splicemachine/storage/MemFileSystem.java", "diffHunk": "@@ -257,8 +259,40 @@ public boolean exists(){\n         }\n \n         @Override\n-        public FileInfo[] listRecursive(){\n+        public FileInfo[] listFilesRecursive(){\n             throw new UnsupportedOperationException(\"IMPLEMENT\");\n         }\n+        @Override\n+        public FileInfo[] listDir(){\n+            try {\n+                return Files.list(p).map( path -> new PathInfo(path) ).toArray(PathInfo[]::new);\n+            } catch (IOException e) {\n+                e.printStackTrace();", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzMTgzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543431834", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-12-15T15:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1NTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1NTczOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543255739", "bodyText": "ditto", "author": "hatyo", "createdAt": "2020-12-15T11:14:05Z", "path": "mem_storage/src/main/java/com/splicemachine/storage/MemFileSystem.java", "diffHunk": "@@ -257,8 +259,40 @@ public boolean exists(){\n         }\n \n         @Override\n-        public FileInfo[] listRecursive(){\n+        public FileInfo[] listFilesRecursive(){\n             throw new UnsupportedOperationException(\"IMPLEMENT\");\n         }\n+        @Override\n+        public FileInfo[] listDir(){\n+            try {\n+                return Files.list(p).map( path -> new PathInfo(path) ).toArray(PathInfo[]::new);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public String getPermissionStr(){\n+             try {\n+                 Set<PosixFilePermission> s = Files.getPosixFilePermissions(p, LinkOption.NOFOLLOW_LINKS);\n+                 return PosixFilePermissions.toString(s);\n+            } catch (IOException e) {\n+                return \"err\";", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2NDMwNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543464304", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-12-15T15:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1NTczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NDg3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543264874", "bodyText": "Nice!", "author": "hatyo", "createdAt": "2020-12-15T11:29:23Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/ResultHelper.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.utils;\n+\n+import com.splicemachine.db.iapi.error.PublicAPI;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.Activation;\n+import com.splicemachine.db.iapi.sql.ResultColumnDescriptor;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.iapi.types.DataTypeDescriptor;\n+import com.splicemachine.db.iapi.types.SQLLongint;\n+import com.splicemachine.db.iapi.types.SQLTimestamp;\n+import com.splicemachine.db.iapi.types.SQLVarchar;\n+import com.splicemachine.db.impl.jdbc.EmbedConnection;\n+import com.splicemachine.db.impl.jdbc.EmbedResultSet40;\n+import com.splicemachine.db.impl.sql.GenericColumnDescriptor;\n+import com.splicemachine.db.impl.sql.execute.IteratorNoPutResultSet;\n+import com.splicemachine.db.impl.sql.execute.ValueRow;\n+import org.joda.time.DateTime;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A helper to create a ResultSet with columns\n+ * use e.g.\n+ *   ResultHelper resultHelper = new ResultHelper();\n+ *\n+ *   // order here determines order in column\n+ *   ResultHelper.VarcharColumn   colUser    = resultHelper.addVarchar(\"USER\", 10);\n+ *   ResultHelper.TimestampColumn colTime    = resultHelper.addTimestamp(\"TIME\", 30);\n+ *   ResultHelper.BigintColumn    colNumber  = resultHelper.addBigint(\"NUMBER\", 10);\n+ *\n+ *   for(...)\n+ *   {\n+ *       resultHelper.newRow();\n+ *       colTime.set( new DateTime(...) );\n+ *       colUser.set( userName );\n+ *       if( hasNumber ) // if not set, will be displayed as NULL\n+ *          colNumber.set( 23 );\n+ *   }\n+ *   ResultSet rs = resultHelper.getResultSet();\n+ *   resultSet[0] = rs;\n+ *\n+ */\n+class ResultHelper {", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NTcyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543265727", "bodyText": "ditto", "author": "hatyo", "createdAt": "2020-12-15T11:30:50Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -1386,10 +1391,9 @@ public static void SYSCS_EMPTY_GLOBAL_STORED_STATEMENT_CACHE() throws SQLExcepti\n         }\n \n         for (HostAndPort server : servers) {\n-            try (Connection connection = RemoteUser.getConnection(server.toString())) {\n-                try (PreparedStatement ps = connection.prepareStatement(\"call SYSCS_UTIL.SYSCS_EMPTY_STORED_STATEMENT_CACHE()\")) {\n-                    ps.execute();\n-                }\n+            try (Connection connection = RemoteUser.getConnection(server.toString());\n+                 Statement ps = connection.createStatement()) {", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2OTIxMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543469212", "bodyText": "ditto", "author": "martinrupp", "createdAt": "2020-12-15T15:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NTg4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543265888", "bodyText": "I think you should wrap the statement with try-with-resource", "author": "hatyo", "createdAt": "2020-12-15T11:31:08Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -1317,10 +1323,9 @@ public static void SYSCS_EMPTY_GLOBAL_STATEMENT_CACHE() throws SQLException{\n         }\n \n         for (HostAndPort server : servers) {\n-            try (Connection connection = RemoteUser.getConnection(server.toString())) {\n-                try (PreparedStatement ps = connection.prepareStatement(\"call SYSCS_UTIL.SYSCS_EMPTY_STATEMENT_CACHE()\")) {\n-                    ps.execute();\n-                }\n+            try (Connection connection = RemoteUser.getConnection(server.toString());\n+                 Statement s = connection.createStatement()) {", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2OTA3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543469074", "bodyText": "the statement IS wrapped in a try-with-resource, check the brackets, note that you can also have multiple statements in a try-with-resources, e.g.\ntry( MyClass1 c1 = new MyClass1();  MyClass2 = new MyClass2(c1); )\n{\n ...\n}", "author": "martinrupp", "createdAt": "2020-12-15T15:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NTg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk5MTM3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r544991370", "bodyText": "I didn't notice the semicolon, my bad.", "author": "hatyo", "createdAt": "2020-12-17T10:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NzI2NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543267264", "bodyText": "I would use a StringBuilder for this (probably IntelliJ can automatically do that for you)", "author": "hatyo", "createdAt": "2020-12-15T11:33:27Z", "path": "splice_machine/src/main/java/com/splicemachine/procedures/external/GetSchemaExternalResult.java", "diffHunk": "@@ -48,9 +52,14 @@ public boolean isSuccess(){\n         return true;\n     }\n \n-    public String getSuggestedSchema()\n+    public String getSuggestedSchema(String separator)\n     {\n-        return ExternalTableUtils.getSuggestedSchema(schema, partition_schema);\n+        String s = ExternalTableUtils.getSuggestedSchema(schema, partition_schema, separator);", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNjc1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r544136750", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-12-16T09:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2NzI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2ODAxNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543268014", "bodyText": "While you're at it, maybe you can try-with-resource this one as-well.", "author": "hatyo", "createdAt": "2020-12-15T11:34:38Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/utils/SpliceAdminIT.java", "diffHunk": "@@ -248,54 +249,59 @@ public void testGetExecInfo() throws Exception {\n         ResultSet rs = cs.executeQuery();\n         TestUtils.FormattedResult fr = TestUtils.FormattedResult.ResultFactory.convert(\"call SYSCS_UTIL.SYSCS_GET_EXEC_SERVICE_INFO()\", rs);\n         System.out.println(fr.toString());\n-        assertTrue(fr.size()>=1);\n+        assertTrue(fr.size() >= 1);\n         DbUtils.closeQuietly(rs);\n     }\n \n     @Test\n     public void testGetCacheInfo() throws Exception {\n-        CallableStatement cs = methodWatcher.prepareCall(\"call SYSCS_UTIL.SYSCS_GET_CACHE_INFO()\");\n-        ResultSet rs = cs.executeQuery();\n-        while(rs.next()){\n-            double hitRate = rs.getDouble(\"HitRate\");\n-            double missRate = rs.getDouble(\"MissRate\");\n-            assertTrue((hitRate >= 0.0) && (hitRate <= 1.0));\n-            assertTrue(missRate <= 1-hitRate + .0001 && missRate >= 1-hitRate - .0001);\n+        try( CallableStatement cs = methodWatcher.prepareCall(\"call SYSCS_UTIL.SYSCS_GET_CACHE_INFO()\") ) {\n+            ResultSet rs = cs.executeQuery();\n+            while (rs.next()) {\n+                double hitRate = rs.getDouble(\"HitRate\");\n+                double missRate = rs.getDouble(\"MissRate\");\n+                assertTrue((hitRate >= 0.0) && (hitRate <= 1.0));\n+                assertTrue(missRate <= 1 - hitRate + .0001 && missRate >= 1 - hitRate - .0001);\n+            }\n+            DbUtils.closeQuietly(rs);\n         }\n-        DbUtils.closeQuietly(rs);\n     }\n \n     @Test\n     public void testGetTotalCacheInfo() throws Exception {\n-        CallableStatement cs = methodWatcher.prepareCall(\"call SYSCS_UTIL.SYSCS_GET_TOTAL_CACHE_INFO()\");\n-        ResultSet rs = cs.executeQuery();\n-        rs.next();\n-        double hitRate = rs.getDouble(\"HitRate\");\n-        double missRate = rs.getDouble(\"MissRate\");\n-        assertTrue((hitRate >= 0.0) && (hitRate <= 1.0));\n-        assertTrue(missRate <= 1-hitRate + .0001 && missRate >= 1-hitRate - .0001);\n-        DbUtils.closeQuietly(rs);\n+        try(CallableStatement cs = methodWatcher.prepareCall(\"call SYSCS_UTIL.SYSCS_GET_TOTAL_CACHE_INFO()\");\n+            ResultSet rs = cs.executeQuery() ) {\n+            rs.next();\n+            double hitRate = rs.getDouble(\"HitRate\");\n+            double missRate = rs.getDouble(\"MissRate\");\n+            assertTrue((hitRate >= 0.0) && (hitRate <= 1.0));\n+            assertTrue(missRate <= 1 - hitRate + .0001 && missRate >= 1 - hitRate - .0001);\n+            DbUtils.closeQuietly(rs);\n+        }\n     }\n \n     @Test\n     public void testGetSessionInfo() throws Exception {\n-        CallableStatement cs = methodWatcher.prepareCall(\"call SYSCS_UTIL.SYSCS_GET_SESSION_INFO()\");\n-        ResultSet rs = cs.executeQuery();\n-        rs.next();\n-        String hostname = rs.getString(\"HOSTNAME\");\n-        int session = rs.getInt(\"SESSION\");\n-        DbUtils.closeQuietly(rs);\n+        String hostname = \"\"; int session = 0;\n+        try(CallableStatement cs = methodWatcher.prepareCall(\"call SYSCS_UTIL.SYSCS_GET_SESSION_INFO()\") ) {\n+            ResultSet rs = cs.executeQuery();", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0MDU2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r544140565", "bodyText": "yes sure", "author": "martinrupp", "createdAt": "2020-12-16T09:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2ODAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2ODU3Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r543268576", "bodyText": "remove if not used.", "author": "hatyo", "createdAt": "2020-12-15T11:35:29Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/utils/SpliceAdminIT.java", "diffHunk": "@@ -457,8 +463,8 @@ public void testDictionaryDeletes() throws Exception {\n                     \"s.schemaname = '%s' and t.tablename = '%s'\", spliceSchemaWatcher.schemaName.toUpperCase(), dictionaryDeletes.tableName.toUpperCase());\n             ResultSet rs = methodWatcher.executeQuery(query);\n             assertTrue(rs.next());\n-            String rowId  = rs.getString(1);\n-            String tableId = rs.getString(2);\n+            String rowId = rs.getString(1);\n+            //String tableId = rs.getString(2);", "originalCommit": "c08482a22fadf84ac05671c9a6829d83174faefd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0MDUyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4734#discussion_r544140526", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-12-16T09:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI2ODU3Ng=="}], "type": "inlineReview"}, {"oid": "0a75390657d9d3564af108edd5a2b15b666887a4", "url": "https://github.com/splicemachine/spliceengine/commit/0a75390657d9d3564af108edd5a2b15b666887a4", "message": "DB-10455 address code reviews", "committedDate": "2020-12-16T09:36:31Z", "type": "forcePushed"}, {"oid": "147f692f4e49fa159987fe0a88cb9f79b8e418dc", "url": "https://github.com/splicemachine/spliceengine/commit/147f692f4e49fa159987fe0a88cb9f79b8e418dc", "message": "DB-10455 fix some tests", "committedDate": "2020-12-16T11:58:00Z", "type": "forcePushed"}, {"oid": "5b43fb3682f6f6791a2df3b72a5fca8d84c4ac9a", "url": "https://github.com/splicemachine/spliceengine/commit/5b43fb3682f6f6791a2df3b72a5fca8d84c4ac9a", "message": "DB-10455 fix some tests", "committedDate": "2020-12-16T14:46:07Z", "type": "forcePushed"}, {"oid": "d1fcdbded639d6800d805478a4e7ebc7de3c73d2", "url": "https://github.com/splicemachine/spliceengine/commit/d1fcdbded639d6800d805478a4e7ebc7de3c73d2", "message": "DB-10455 add LIST_DIRECTORY function", "committedDate": "2020-12-17T10:58:32Z", "type": "commit"}, {"oid": "2048e588d7d2283972169da6f3e3fcac919c46ad", "url": "https://github.com/splicemachine/spliceengine/commit/2048e588d7d2283972169da6f3e3fcac919c46ad", "message": "DB-10455 fix SpotBugs", "committedDate": "2020-12-17T10:58:32Z", "type": "commit"}, {"oid": "84ad9874dde488f3f1ed7410e76d591520204f87", "url": "https://github.com/splicemachine/spliceengine/commit/84ad9874dde488f3f1ed7410e76d591520204f87", "message": "DB-10922 adding SYS_UTILS.ANALYZE_EXTERNAL_TABLE", "committedDate": "2020-12-17T10:58:59Z", "type": "commit"}, {"oid": "1e096ecd5c06e839c39ba1438594f7df7f93aa2b", "url": "https://github.com/splicemachine/spliceengine/commit/1e096ecd5c06e839c39ba1438594f7df7f93aa2b", "message": "DB-10455 fix mem", "committedDate": "2020-12-17T10:58:59Z", "type": "commit"}, {"oid": "f065b3f244f0236930904819fd992f58df4f14e3", "url": "https://github.com/splicemachine/spliceengine/commit/f065b3f244f0236930904819fd992f58df4f14e3", "message": "DB-10455 fix path varchar too short", "committedDate": "2020-12-17T11:00:14Z", "type": "commit"}, {"oid": "0c95646bbe5571266d3f17fc0adbfc160ca0771e", "url": "https://github.com/splicemachine/spliceengine/commit/0c95646bbe5571266d3f17fc0adbfc160ca0771e", "message": "DB-10455 fix mem", "committedDate": "2020-12-17T11:00:15Z", "type": "commit"}, {"oid": "c343a15473869c6324ca434e69d64fc0c15944a5", "url": "https://github.com/splicemachine/spliceengine/commit/c343a15473869c6324ca434e69d64fc0c15944a5", "message": "DB-10455 fix test different creation date", "committedDate": "2020-12-17T11:00:15Z", "type": "commit"}, {"oid": "03abcac3d25129593655222e77bd88bb6525c314", "url": "https://github.com/splicemachine/spliceengine/commit/03abcac3d25129593655222e77bd88bb6525c314", "message": "DB-10455 fix testListDirectory", "committedDate": "2020-12-17T11:00:15Z", "type": "commit"}, {"oid": "53bf5638d636c7feb28d7933cb7ac732f6423f8f", "url": "https://github.com/splicemachine/spliceengine/commit/53bf5638d636c7feb28d7933cb7ac732f6423f8f", "message": "DB-10455 address code reviews", "committedDate": "2020-12-17T11:00:15Z", "type": "commit"}, {"oid": "6d93231efcbe30278e65874db49b73a32f86e3f5", "url": "https://github.com/splicemachine/spliceengine/commit/6d93231efcbe30278e65874db49b73a32f86e3f5", "message": "DB-10455 fix some tests", "committedDate": "2020-12-17T11:00:15Z", "type": "commit"}, {"oid": "6d93231efcbe30278e65874db49b73a32f86e3f5", "url": "https://github.com/splicemachine/spliceengine/commit/6d93231efcbe30278e65874db49b73a32f86e3f5", "message": "DB-10455 fix some tests", "committedDate": "2020-12-17T11:00:15Z", "type": "forcePushed"}]}