{"pr_number": 4830, "pr_title": "DB-10420 Push down disjunction of index expressions when possible", "pr_createdAt": "2020-12-10T15:58:15Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4830", "timeline": [{"oid": "195eb64db67c54bed64a62a708d0b9572d790cbc", "url": "https://github.com/splicemachine/spliceengine/commit/195eb64db67c54bed64a62a708d0b9572d790cbc", "message": "DB-10420 Push down disjunction of index expressions when possible", "committedDate": "2020-12-10T14:19:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MTY3OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4830#discussion_r542441679", "bodyText": "pushPreds seems to be true when join planning is complete, and false in the middle of join planning.  If we use skipProbePreds as false while planning a hash join, then we might think an IN list predicate is useful, which may affect the cost of the join and lead us to pick it.  But then at the end of planning we would enter this code again, and see that we can't actually push the predicate, so the join is not as cheap as we thought.  Perhaps the code should be modified to detect during join planning whether the predicate can be pushed, something like:\n\nJoinStrategy joinStrategy = pushPreds ? optTable.getTrulyTheBestAccessPath().getJoinStrategy() :\n                                        optTable.getCurrentAccessPath().getJoinStrategy();\nboolean skipProbePreds = joinStrategy.isHashJoin();", "author": "msirek", "createdAt": "2020-12-14T14:48:38Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java", "diffHunk": "@@ -521,34 +522,64 @@ public final boolean isStoreQualifier(){\n      * @return true if the predicate is a pushable set of OR clauses.\n      * @throws StandardException Standard exception policy.\n      */\n-    public final boolean isPushableOrClause(Optimizable optTable) throws StandardException{\n+    public final boolean isPushableOrClause(Optimizable optTable, ConglomerateDescriptor cd,\n+                                            boolean pushPreds) throws StandardException{\n \n         if(andNode.getLeftOperand() instanceof OrNode){\n-            QueryTreeNode node=andNode.getLeftOperand();\n+            QueryTreeNode node = andNode.getLeftOperand();\n+            QueryTreeNode trueNode;\n+            AndNode tempAnd = null;\n+\n+            IndexRowGenerator irg = cd == null ? null : cd.getIndexDescriptor();\n+            boolean isOnExpression = irg != null && irg.isOnExpression();\n+            if (isOnExpression) {\n+                trueNode = (QueryTreeNode) getNodeFactory().getNode(\n+                        C_NodeTypes.BOOLEAN_CONSTANT_NODE,\n+                        Boolean.TRUE,\n+                        getContextManager());\n+                tempAnd = (AndNode) getNodeFactory().getNode(\n+                        C_NodeTypes.AND_NODE,\n+                        trueNode,  // to be replaced later\n+                        trueNode,\n+                        getContextManager());\n+            }\n \n             while(node instanceof OrNode){\n                 OrNode or_node=(OrNode)node;\n \n                 if(or_node.getLeftOperand() instanceof RelationalOperator){\n                     // if any term of the OR clause is not a qualifier, then\n                     // reject the entire OR clause.\n-                    if(!((RelationalOperator)or_node.getLeftOperand()).isQualifier(optTable,true)){\n-                        // one of the terms is not a pushable Qualifier.\n-                        return (false);\n+                    if (isOnExpression) {\n+                        tempAnd.setLeftOperand(or_node.getLeftOperand());\n+                        tempAnd.postBindFixup();\n+                        Predicate tempPred = (Predicate) getNodeFactory().getNode(\n+                                C_NodeTypes.PREDICATE,\n+                                tempAnd,\n+                                or_node.getLeftOperand().getTablesReferenced(),\n+                                getContextManager());\n+                        boolean skipProbePreds = pushPreds && optTable.getTrulyTheBestAccessPath().getJoinStrategy().isHashJoin();", "originalCommit": "195eb64db67c54bed64a62a708d0b9572d790cbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzMTIzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4830#discussion_r543431234", "bodyText": "That makes total sense! I didn't really check this logic before but simply copy-pasted. I improve it as you suggested with a bit modification mainly because when join planning is complete, this method can also get called with pushPreds = false. This happens in some helper functions, e.g. transferPredicates().", "author": "ascend1", "createdAt": "2020-12-15T15:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MTY3OQ=="}], "type": "inlineReview"}, {"oid": "39f70cb74639ba003002019f7784d86e8f8a23ac", "url": "https://github.com/splicemachine/spliceengine/commit/39f70cb74639ba003002019f7784d86e8f8a23ac", "message": "Merge branch 'master' into DB-10420", "committedDate": "2020-12-15T13:28:38Z", "type": "commit"}, {"oid": "8e64102ad5f8746aa1fa145574250c7ebed4fec9", "url": "https://github.com/splicemachine/spliceengine/commit/8e64102ad5f8746aa1fa145574250c7ebed4fec9", "message": "DB-10420 Address comment / improve cost estimation for in-list pred", "committedDate": "2020-12-15T15:06:39Z", "type": "commit"}]}