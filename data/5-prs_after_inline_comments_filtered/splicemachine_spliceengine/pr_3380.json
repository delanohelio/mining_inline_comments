{"pr_number": 3380, "pr_title": "DB-9336 Allow 'default null' in create table", "pr_createdAt": "2020-04-03T13:49:00Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3380", "timeline": [{"oid": "ab5971fdc8d30e52461089e32e3f044d640e9e67", "url": "https://github.com/splicemachine/spliceengine/commit/ab5971fdc8d30e52461089e32e3f044d640e9e67", "message": "DB-9336 Allow 'default null' in create table", "committedDate": "2020-04-03T13:42:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5MDAyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3380#discussion_r404490026", "bodyText": "With the lines added after this line to set the value, this line become redundant and can be removed.", "author": "yxia92", "createdAt": "2020-04-07T01:50:58Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UserTypeConstantNode.java", "diffHunk": "@@ -54,194 +54,199 @@\n import java.sql.Types;\n \n /**\n-\tUser type constants.  These are created by built-in types\n-\tthat use user types as their implementation. This could also\n-\tpotentially be used by an optimizer that wanted to store plans\n-\tfor frequently-used parameter values.\n+    User type constants.  These are created by built-in types\n+    that use user types as their implementation. This could also\n+    potentially be used by an optimizer that wanted to store plans\n+    for frequently-used parameter values.\n \n-\tThis is also used to represent nulls in user types, which occurs\n-\twhen NULL is inserted into or supplied as the update value for\n-\ta usertype column.\n+    This is also used to represent nulls in user types, which occurs\n+    when NULL is inserted into or supplied as the update value for\n+    a usertype column.\n \n  */\n public class UserTypeConstantNode extends ConstantNode {\n-\t/*\n-\t** This value field hides the value in the super-type.  It is here\n-\t** Because user-type constants work differently from built-in constants.\n-\t** User-type constant values are stored as Objects, while built-in\n-\t** constants are stored as StorableDataValues.\n-\t**\n-\t** RESOLVE: This is a bit of a mess, and should be fixed.  All constants\n-\t** should be represented the same way.\n-\t*/\n-\tObject\tvalue;\n-\n-\t/**\n-\t * Initializer for a typed null node\n-\t * or a date, time, or timestamp value. Parameters may be:\n-\t *\n-\t * <ul>\n-\t * <li>arg1\tThe TypeId for the type of the node</li>\n-\t * <li>arg2\tThe factory to get the TypeId and DataTypeServices factories from.</li>\n-\t * </ul>\n-\t *\n-\t * <p>\n-\t * - OR -\n-\t * </p>\n-\t *\n-\t * <ul>\n-\t * <li>arg1 the date, time, or timestamp value</li>\n-\t * </ul>\n-\t *\n-\t * @exception StandardException thrown on failure\n-\t */\n-\tpublic void init(Object arg1)\n-\t\t\tthrows StandardException {\n+    /*\n+    ** This value field hides the value in the super-type.  It is here\n+    ** Because user-type constants work differently from built-in constants.\n+    ** User-type constant values are stored as Objects, while built-in\n+    ** constants are stored as StorableDataValues.\n+    **\n+    ** RESOLVE: This is a bit of a mess, and should be fixed.  All constants\n+    ** should be represented the same way.\n+    */\n+    Object    value;\n+\n+    /**\n+     * Initializer for a typed null node\n+     * or a date, time, or timestamp value. Parameters may be:\n+     *\n+     * <ul>\n+     * <li>arg1    The TypeId for the type of the node</li>\n+     * <li>arg2    The factory to get the TypeId and DataTypeServices factories from.</li>\n+     * </ul>\n+     *\n+     * <p>\n+     * - OR -\n+     * </p>\n+     *\n+     * <ul>\n+     * <li>arg1 the date, time, or timestamp value</li>\n+     * </ul>\n+     *\n+     * @exception StandardException thrown on failure\n+     */\n+    public void init(Object arg1)\n+            throws StandardException {\n         DataValueDescriptor dvd = null;\n         \n-\t\tif (arg1 instanceof TypeId)\n-\t\t{\n-\t\t\tsuper.init(\n-\t\t\t\t\targ1,\n-\t\t\t\t\tBoolean.TRUE,\n-\t\t\t\t\tReuseFactory.getInteger(\n-\t\t\t\t\t\t\t\t\t\tTypeDescriptor.MAXIMUM_WIDTH_UNKNOWN));\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tInteger maxWidth = null;\n-\t\t\tTypeId\ttypeId = null;\n+        if (arg1 instanceof TypeId)\n+        {\n+            super.init(\n+                    arg1,\n+                    Boolean.TRUE,\n+                    ReuseFactory.getInteger(\n+                                        TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN));\n+        }\n+        else\n+        {\n+            Integer maxWidth = null;\n+            TypeId    typeId = null;\n \n             if( arg1 instanceof DataValueDescriptor)\n                 dvd = (DataValueDescriptor) arg1;\n-\t\t\tif (arg1 instanceof Date\n+            if (arg1 instanceof Date\n                 || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_DATE_ID))\n-\t\t\t{\n-\t\t\t\tmaxWidth = ReuseFactory.getInteger(TypeId.DATE_MAXWIDTH);\n-\t\t\t\ttypeId = TypeId.getBuiltInTypeId(Types.DATE);\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Time\n+            {\n+                maxWidth = ReuseFactory.getInteger(TypeId.DATE_MAXWIDTH);\n+                typeId = TypeId.getBuiltInTypeId(Types.DATE);\n+            }\n+            else if (arg1 instanceof Time\n                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIME_ID))\n-\t\t\t{\n-\t\t\t\tmaxWidth = ReuseFactory.getInteger(TypeId.TIME_MAXWIDTH);\n-\t\t\t\ttypeId = TypeId.getBuiltInTypeId(Types.TIME);\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Timestamp\n+            {\n+                maxWidth = ReuseFactory.getInteger(TypeId.TIME_MAXWIDTH);\n+                typeId = TypeId.getBuiltInTypeId(Types.TIME);\n+            }\n+            else if (arg1 instanceof Timestamp\n                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIMESTAMP_ID))\n-\t\t\t{\n-\t\t\t\tmaxWidth = ReuseFactory.getInteger(TypeId.TIMESTAMP_MAXWIDTH);\n-\t\t\t\ttypeId = TypeId.getBuiltInTypeId(Types.TIMESTAMP);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\t{\n-\t\t\t\t\tSanityManager.THROWASSERT(\n-\t\t\t\t\t\t\t\"Unexpected class \" + arg1.getClass().getName());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tsuper.init( \n-\t\t\t\ttypeId,\n-\t\t\t\t(arg1 == null) ? Boolean.TRUE : Boolean.FALSE,\n-\t\t\t\tmaxWidth);\n-\n-            if( dvd != null)\n-                setValue( dvd);\n-\t\t\telse if (arg1 instanceof Date)\n-\t\t\t{\n-\t\t\t\tsetValue(new SQLDate((Date) arg1));\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Time)\n-\t\t\t{\n-\t\t\t\tsetValue(new SQLTime((Time) arg1));\n-\t\t\t}\n-\t\t\telse if (arg1 instanceof Timestamp)\n-\t\t\t{\n-\t\t\t\tsetValue(new SQLTimestamp((Timestamp) arg1));\n-\t\t\t}\n-\n-\t\t\tvalue = arg1;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Return the object value of this user defined type.\n-\t *\n-\t * @return\tthe value of this constant. can't use getValue() for this.\n-\t *\t\t\tgetValue() returns the DataValueDescriptor for the built-in\n-\t *\t\t\ttypes that are implemented as user types (date, time, timestamp)\n-\t */\n-    public\tObject\tgetObjectValue() { return value; }\n-\n-\t/**\n-\t * Return whether or not this node represents a typed null constant.\n-\t *\n-\t */\n-\tpublic boolean isNull()\n-\t{\n-\t\treturn (value == null);\n-\t}\n-\n-\t/**\n-\t * Return an Object representing the bind time value of this\n-\t * expression tree.  If the expression tree does not evaluate to\n-\t * a constant at bind time then we return null.\n-\t * This is useful for bind time resolution of VTIs.\n-\t * RESOLVE: What do we do for primitives?\n-\t *\n-\t * @return\tAn Object representing the bind time value of this expression tree.\n-\t *\t\t\t(null if not a bind time constant.)\n-\t *\n-\t */\n-\tpublic Object getConstantValueAsObject()\n-\t{\n-\t\treturn value;\n-\t}\n-\n-\t/**\n-\t * For a UserTypeConstantNode, we have to store away the object somewhere\n-\t * and have a way to get it back at runtime.\n-\t * These objects are serializable.  This gives us at least two options:\n-\t * 1) serialize it out into a byte array field, and serialize\n-\t *\t  it back in when needed, from the field.\n-\t * 2) have an array of objects in the prepared statement and a #,\n-\t *\t  to find the object directly. Because it is serializable, it\n-\t *\t  will store with the rest of the executable just fine.\n-\t * Choice 2 gives better performance -- the ser/deser cost is paid\n-\t * on database access for the statement, not for each execution of it.\n-\t * However, it requires some infrastructure support from prepared\n-\t * statements.  For now, we take choice 3, and make some assumptions\n-\t * about available methods on the user type.  This choice has the\n-\t * shortcoming that it will not work for arbitrary user types.\n-\t * REVISIT and implement choice 2 when a general solution is needed.\n-\t * <p>\n-\t * A null is generated as a Null value cast to the type of\n-\t * the constant node.\n-\t *\n-\t * @param acb\tThe ExpressionClassBuilder for the class being built\n-\t * @param mb\tThe method the expression will go into\n-\t *\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic void generateExpression(ExpressionClassBuilder acb,\n-\t\t\t\t\t\t\t\t\t\t\tMethodBuilder mb)\n-\t\t\t\t\t\t\t\t\tthrows StandardException {\n-\n-\t\tTypeCompiler\t\ttc = getTypeCompiler();\n+            {\n+                maxWidth = ReuseFactory.getInteger(TypeId.TIMESTAMP_MAXWIDTH);\n+                typeId = TypeId.getBuiltInTypeId(Types.TIMESTAMP);\n+            }\n+            else\n+            {\n+                if (SanityManager.DEBUG)\n+                {\n+                    SanityManager.THROWASSERT(\n+                            \"Unexpected class \" + arg1.getClass().getName());\n+                }\n+            }\n+\n+            assert maxWidth != null;\n+\n+            super.init(\n+                typeId,\n+                (arg1 == null) ? Boolean.TRUE : Boolean.FALSE,\n+                maxWidth);\n+\n+            if( dvd != null) {\n+                setValue(dvd);", "originalCommit": "ab5971fdc8d30e52461089e32e3f044d640e9e67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc3MDk1OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3380#discussion_r404770959", "bodyText": "Weirdly enough, no. setValue sets the attribute of the base class, whereas value= sets the value of this derived class. The whole thing is a bit messy and explained in a comment above UserTypeConstantNode.value declaration:\n /* ** This value field hides the value in the super-type.  It is here ** Because user-type constants work differently from built-in constants. ** User-type constant values are stored as Objects, while built-in ** constants are stored as StorableDataValues. ** ** RESOLVE: This is a bit of a mess, and should be fixed.  All constants ** should be represented the same way. */", "author": "arnaud-splice", "createdAt": "2020-04-07T12:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5MDAyNg=="}], "type": "inlineReview"}]}