{"pr_number": 3706, "pr_title": "DB-9455 Refactor TimestampOracle to expose three distinct functions", "pr_createdAt": "2020-06-22T12:29:40Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3706", "timeline": [{"oid": "432812479b8304a747204ae41d20eb1c092d6d19", "url": "https://github.com/splicemachine/spliceengine/commit/432812479b8304a747204ae41d20eb1c092d6d19", "message": "DB-9455 Fix sync issue in TimestampOracle.getNextTimestamp", "committedDate": "2020-06-22T12:29:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNDE0OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444424148", "bodyText": "synchronized does not address the issue described in the bug.", "author": "OlegMazurov", "createdAt": "2020-06-23T18:28:28Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {", "originalCommit": "432812479b8304a747204ae41d20eb1c092d6d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyOTE5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444429193", "bodyText": "Recursion is not justified. A simple loop is clearer and can be used in the calling method:\nwhile (nextTimestamp  > _maxReservedTimestamp ) { reserveNextBlock(_maxReservedTimestamp); } \nI wouldn't worry about \"double volatile read\": it's not on the hot path and synchronization cost along with ZK read make its extra cost negligible.", "author": "OlegMazurov", "createdAt": "2020-06-23T18:38:04Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {\n+                _maxReservedTimestamp = timestampBlockManager.initialize();\n+                _timestampCounter.set(_maxReservedTimestamp);\n+            }\n+        }\n+\n+        long nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        reserveNextBlockIfNecessary(maxTS);\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private void reserveNextBlockIfNecessary(long nextTimestamp) throws TimestampIOException {\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTimestamp > maxTS) {\n+            reserveNextBlock(maxTS);\n+        }\n+        // Check if reserving next block was enough\n+        if (nextTimestamp > _maxReservedTimestamp) {\n+            reserveNextBlockIfNecessary(nextTimestamp);", "originalCommit": "432812479b8304a747204ae41d20eb1c092d6d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0Njk4Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r444546987", "bodyText": "nextTS ?", "author": "OlegMazurov", "createdAt": "2020-06-23T22:39:40Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,78 +29,89 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n+    public long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n+        if (refresh) {\n+            synchronized (this) {\n+                _maxReservedTimestamp = timestampBlockManager.initialize();\n+                _timestampCounter.set(_maxReservedTimestamp);\n+            }\n+        }\n+\n+        long nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        reserveNextBlockIfNecessary(maxTS);", "originalCommit": "432812479b8304a747204ae41d20eb1c092d6d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "110d9537b1ba0fdfe2e5af693c9ba1abfde580ed", "url": "https://github.com/splicemachine/spliceengine/commit/110d9537b1ba0fdfe2e5af693c9ba1abfde580ed", "message": "DB-9455 Refactor TimestampOracle to expose three distinct functions", "committedDate": "2020-07-01T15:57:49Z", "type": "commit"}, {"oid": "e5e06fc79aa972b2aceac374b55c3710e6ef787e", "url": "https://github.com/splicemachine/spliceengine/commit/e5e06fc79aa972b2aceac374b55c3710e6ef787e", "message": "Merge remote-tracking branch 'origin/master' into DB-9455", "committedDate": "2020-07-01T16:39:12Z", "type": "commit"}, {"oid": "46568d2120a3406063d0fd37f1831b7fda00d2b0", "url": "https://github.com/splicemachine/spliceengine/commit/46568d2120a3406063d0fd37f1831b7fda00d2b0", "message": "DB-9455 Update dependency", "committedDate": "2020-07-01T16:41:58Z", "type": "commit"}, {"oid": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "url": "https://github.com/splicemachine/spliceengine/commit/8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "message": "DB-9455 Fix spotbugs", "committedDate": "2020-07-01T17:48:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450422049", "bodyText": "If nextTS is larger than _maxReservedTimestamp by several blockSize, we'll go to ZK several times.\nWhy do that when we can do the right thing in one take?", "author": "OlegMazurov", "createdAt": "2020-07-06T19:02:04Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read\n+        if (nextTS > maxTS) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "originalCommit": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4MDY1Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453680652", "bodyText": "Fixed", "author": "arnaud-splice", "createdAt": "2020-07-13T14:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTQ0NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461109444", "bodyText": "blockCount is not computed right (can be zero or even negative).", "author": "OlegMazurov", "createdAt": "2020-07-27T19:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4ODE5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r466888195", "bodyText": "Fixed", "author": "arnaud-splice", "createdAt": "2020-08-07T08:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMjA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyNDU0OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450424548", "bodyText": "Double volatile read is gone. Can get rid of maxTS.", "author": "OlegMazurov", "createdAt": "2020-07-06T19:07:19Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        long maxTS = _maxReservedTimestamp; // avoid the double volatile read", "originalCommit": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3MzQ2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453673465", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-07-13T14:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyNDU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyOTk2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450429967", "bodyText": "By calling reserveNextBlock(timestamp) we have guaranteed that timestamp <= _maxReservedTimestamp. Reassigning _maxReservedTimestamp to  timestamp doesn't look right.", "author": "OlegMazurov", "createdAt": "2020-07-06T19:18:42Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;", "originalCommit": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMDk1OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453700958", "bodyText": "I'm not quite sure what else to put instead. @jyuanca, can you weigh in?", "author": "arnaud-splice", "createdAt": "2020-07-13T14:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyOTk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzMDk3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r450430975", "bodyText": "synchronized doesn't guard _timestampCounter . I'd still like to see compareAndSet here.", "author": "OlegMazurov", "createdAt": "2020-07-06T19:20:54Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,114 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long timestamp) throws TimestampIOException {\n+        if (timestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(timestamp);\n+            _maxReservedTimestamp = timestamp;\n+            _timestampCounter.set(timestamp);", "originalCommit": "8a72fbd8e03ba9df8cec0b50dc3b7a1c9edc3cad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMDYwMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r453700603", "bodyText": "done", "author": "arnaud-splice", "createdAt": "2020-07-13T14:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzMDk3NQ=="}], "type": "inlineReview"}, {"oid": "9734bf8368e69195b1028eb32f7cb59cac939749", "url": "https://github.com/splicemachine/spliceengine/commit/9734bf8368e69195b1028eb32f7cb59cac939749", "message": "DB-9455 Address first comments", "committedDate": "2020-07-13T14:42:56Z", "type": "commit"}, {"oid": "926df4339771cf4377e7b404fd5c58d11128eb2d", "url": "https://github.com/splicemachine/spliceengine/commit/926df4339771cf4377e7b404fd5c58d11128eb2d", "message": "Merge remote-tracking branch 'origin/master' into DB-9455", "committedDate": "2020-07-14T09:57:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTgxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461109813", "bodyText": "Use addAndGet()", "author": "OlegMazurov", "createdAt": "2020-07-27T19:11:49Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;\n+            long nextMax = _maxReservedTimestamp + blockSize * blockCount;\n             timestampBlockManager.reserveNextBlock(nextMax);\n             _maxReservedTimestamp = nextMax;\n-            _numBlocksReserved.incrementAndGet(); // JMX metric\n+            for (int i = 0; i < blockCount; ++i)", "originalCommit": "926df4339771cf4377e7b404fd5c58d11128eb2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4ODkwNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r466888905", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-08-07T08:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTU5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r461111593", "bodyText": "reserveNextBlock assigns a new value to _maxReservedTimestamp, here it's overwritten.\nupdateAndGet ensures assignment (it has a loop), which is more than needed here; a simple compareAndSet with the value from the initial _timestampCounter.get() would suffice.", "author": "OlegMazurov", "createdAt": "2020-07-27T19:15:14Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;", "originalCommit": "926df4339771cf4377e7b404fd5c58d11128eb2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwMDI0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473200246", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-08-19T17:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NjMxNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r471786316", "bodyText": "Change to nextTS  - _maxReservedTimestamp to make it positive? Just in case next Ts is much larger than _maxReservedTimestamp and blockCount becomes negative.", "author": "jyuanca", "createdAt": "2020-08-17T21:31:00Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,115 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        if (newTimestamp > _timestampCounter.get()) {\n+            timestampBlockManager.reserveNextBlock(newTimestamp);\n+            _maxReservedTimestamp = newTimestamp;\n+            _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, newTimestamp));\n+        }\n+    }\n+\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {\n+            long blockCount = (_maxReservedTimestamp - nextTS) / blockSize + 1;", "originalCommit": "926df4339771cf4377e7b404fd5c58d11128eb2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwMDE5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473200195", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-08-19T17:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NjMxNg=="}], "type": "inlineReview"}, {"oid": "7eadaa999062936bdf8cf6b15cf05511321cdd1b", "url": "https://github.com/splicemachine/spliceengine/commit/7eadaa999062936bdf8cf6b15cf05511321cdd1b", "message": "DB-9455 Address comments", "committedDate": "2020-08-19T17:18:01Z", "type": "commit"}, {"oid": "fd01c0d07609a5458fdf208f5f43cbce76949a4e", "url": "https://github.com/splicemachine/spliceengine/commit/fd01c0d07609a5458fdf208f5f43cbce76949a4e", "message": "Merge remote-tracking branch 'origin/master' into DB-9455", "committedDate": "2020-08-19T17:19:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzMzUwNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473333506", "bodyText": "\"while\" is redundant here, \"if\" would suffice", "author": "OlegMazurov", "createdAt": "2020-08-19T21:21:49Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);\n+            }\n+        }\n     }\n \n-\tpublic long getNextTimestamp(boolean refresh, boolean increment) throws TimestampIOException {\n-\t\tif (refresh) {\n-            _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t_timestampCounter.set(_maxReservedTimestamp);\n-\t\t}\n-\n-\t\tlong nextTS = increment ? _timestampCounter.addAndGet(TIMESTAMP_INCREMENT): _timestampCounter.get();\n-\t\tlong maxTS = _maxReservedTimestamp; // avoid the double volatile read\n-\t\tif (nextTS > maxTS) {\n-\t\t\treserveNextBlock(maxTS);\n-\t\t}\n-\t\t_numTimestampsCreated.incrementAndGet(); // JMX metric\n-\t\treturn nextTS;\n-\t}\n-\n-    private void reserveNextBlock(long priorMaxReservedTimestamp) throws TimestampIOException {\n-        synchronized(this)  {\n-            if (_maxReservedTimestamp > priorMaxReservedTimestamp) return; // some other thread got there first\n-            long nextMax = _maxReservedTimestamp + blockSize;\n-            timestampBlockManager.reserveNextBlock(nextMax);\n+    public long getNextTimestamp() throws TimestampIOException {\n+        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);\n+        if (nextTS > _maxReservedTimestamp) {\n+            reserveNextBlock(nextTS);\n+        }\n+        _numTimestampsCreated.incrementAndGet(); // JMX metric\n+        return nextTS;\n+    }\n+\n+    private synchronized void reserveNextBlock(long nextTS) throws TimestampIOException {\n+        while (nextTS > _maxReservedTimestamp) {", "originalCommit": "fd01c0d07609a5458fdf208f5f43cbce76949a4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgwNTc0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473805740", "bodyText": "done", "author": "arnaud-splice", "createdAt": "2020-08-20T09:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzMzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM0OTU5Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473349596", "bodyText": "compareAndSet returns true if successful, which also guarantees the condition is satisfied.\nConsider:\npublic synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n\tnewTimestamp = roundUp(newTimestamp);\n\tif (newTimestamp> _maxReservedTimestamp) {\n\t\treserveNextBlock(newTimestamp);\n\t}\n\tlong currentTimestampCounter;\n\twhile ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n\t\tif (_timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp)) break;\n\t}\n}", "author": "OlegMazurov", "createdAt": "2020-08-19T21:40:28Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampOracle.java", "diffHunk": "@@ -29,108 +29,128 @@\n import javax.management.ObjectName;\n \n public class TimestampOracle implements TimestampOracleStatistics{\n-\tprivate static final long TIMESTAMP_INCREMENT = 0x100l;\n+    private static final long TIMESTAMP_INCREMENT = 0x100l;\n \n     private static final Logger LOG = Logger.getLogger(TimestampOracle.class);\n \n-\t// Contains the next timestamp value to be returned to caller use\n-\tprivate final AtomicLong _timestampCounter = new AtomicLong(0l);\n-\t\n-\t// Maximum timestamp that we can feed before reserving another block\n-\tprivate volatile long _maxReservedTimestamp = -1l;\n-\n-\t// Singleton instance, used by TimestampServerHandler\n-\tprivate static volatile TimestampOracle _instance;\n-\t\n-\t// Metrics to expose via JMX. See TimestampOracleStatistics\n-\t// for solid definitions of each metric.\n+    // Contains the next timestamp value to be returned to caller use\n+    private final AtomicLong _timestampCounter = new AtomicLong(0l);\n+\n+    // Maximum timestamp that we can feed before reserving another block\n+    private volatile long _maxReservedTimestamp = -1l;\n+\n+    // Singleton instance, used by TimestampServerHandler\n+    private static volatile TimestampOracle _instance;\n+\n+    // Metrics to expose via JMX. See TimestampOracleStatistics\n+    // for solid definitions of each metric.\n     private AtomicLong _numBlocksReserved = new AtomicLong(0);\n     private AtomicLong _numTimestampsCreated = new AtomicLong(0);\n \n     private TimestampBlockManager timestampBlockManager;\n     private long blockSize;\n \n     public static TimestampOracle getInstance(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException{\n-\t\tTimestampOracle to = _instance;\n-\t\tif(to==null){\n-\t\t\tsynchronized(TimestampOracle.class){\n-\t\t\t\tto = _instance;\n-\t\t\t\tif(to==null){\n-\t\t\t\t\tSpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n-\t\t\t\t\tto=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn to;\n-\t}\n-\t\n-\tprivate TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n+        TimestampOracle to = _instance;\n+        if(to==null){\n+            synchronized(TimestampOracle.class){\n+                to = _instance;\n+                if(to==null){\n+                    SpliceLogUtils.info(LOG,\"Initializing TimestampOracle...\");\n+                    to=_instance=new TimestampOracle(timestampBlockManager,blockSize);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private TimestampOracle(TimestampBlockManager timestampBlockManager, int blockSize) throws TimestampIOException {\n         this.timestampBlockManager=timestampBlockManager;\n         this.blockSize = blockSize * TIMESTAMP_INCREMENT;\n-\t\tinitialize();\n-\t}\n+        initialize();\n+    }\n \n     /**\n      * Read the current state of the block from the timestampBlockManager\n      *\n      * @throws TimestampIOException\n      */\n-\tprivate void initialize() throws TimestampIOException {\n-\t\t\tsynchronized(this) {\n+    private void initialize() throws TimestampIOException {\n+            synchronized(this) {\n                 _maxReservedTimestamp = timestampBlockManager.initialize();\n-\t\t\t\t_timestampCounter.set(_maxReservedTimestamp + TIMESTAMP_INCREMENT);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tregisterJMX();\n-\t\t\t} catch (Exception e) {\n+                _timestampCounter.updateAndGet(oldTS -> Math.max(oldTS, _maxReservedTimestamp + TIMESTAMP_INCREMENT));\n+            }\n+            try {\n+                registerJMX();\n+            } catch (Exception e) {\n                 SpliceLogUtils.error(LOG, \"Unable to register Timestamp Generator with JMX. Service will function but metrics will not be available.\");\n-\t\t\t}\n+            }\n+    }\n+\n+    public long getCurrentTimestamp() {\n+        return _timestampCounter.get();\n+    }\n+\n+    private static long roundUp(long timestamp) {\n+        assert timestamp >= 0;\n+        long remainder = timestamp % TIMESTAMP_INCREMENT;\n+        if (remainder == 0) {\n+            return timestamp;\n+        }\n+        return timestamp - remainder + TIMESTAMP_INCREMENT;\n+    }\n+\n+    public synchronized void bumpTimestamp(long newTimestamp) throws TimestampIOException {\n+        newTimestamp = roundUp(newTimestamp);\n+        if (newTimestamp > _timestampCounter.get()) {\n+            if (newTimestamp> _maxReservedTimestamp) {\n+                reserveNextBlock(newTimestamp);\n+            }\n+            long currentTimestampCounter;\n+            while ((currentTimestampCounter = _timestampCounter.get()) < newTimestamp) {\n+                _timestampCounter.compareAndSet(currentTimestampCounter, newTimestamp);", "originalCommit": "fd01c0d07609a5458fdf208f5f43cbce76949a4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgwNTk2MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3706#discussion_r473805961", "bodyText": "done", "author": "arnaud-splice", "createdAt": "2020-08-20T09:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM0OTU5Ng=="}], "type": "inlineReview"}, {"oid": "5d340d4a2a7ac773c387d1910838c17fae07dd0b", "url": "https://github.com/splicemachine/spliceengine/commit/5d340d4a2a7ac773c387d1910838c17fae07dd0b", "message": "DB-9455 Address more comments", "committedDate": "2020-08-20T09:16:26Z", "type": "commit"}, {"oid": "a1f5dd028d24214ad5ca87f1ae3007c4a8fddd85", "url": "https://github.com/splicemachine/spliceengine/commit/a1f5dd028d24214ad5ca87f1ae3007c4a8fddd85", "message": "Merge remote-tracking branch 'origin/master' into DB-9455", "committedDate": "2020-08-20T22:19:59Z", "type": "commit"}]}