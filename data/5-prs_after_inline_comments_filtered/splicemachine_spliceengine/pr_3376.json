{"pr_number": 3376, "pr_title": "DB-6542: create missing index rows", "pr_createdAt": "2020-04-02T00:04:36Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3376", "timeline": [{"oid": "88b37a1300bf09be424eb5c565c5846473519262", "url": "https://github.com/splicemachine/spliceengine/commit/88b37a1300bf09be424eb5c565c5846473519262", "message": "DB-6542: create missing index rows", "committedDate": "2020-04-02T16:24:54Z", "type": "commit"}, {"oid": "88b37a1300bf09be424eb5c565c5846473519262", "url": "https://github.com/splicemachine/spliceengine/commit/88b37a1300bf09be424eb5c565c5846473519262", "message": "DB-6542: create missing index rows", "committedDate": "2020-04-02T16:24:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzNjM1Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3376#discussion_r404536356", "bodyText": "This line is not used and can be removed.", "author": "yxia92", "createdAt": "2020-04-07T05:02:04Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/storage/CheckTableJob.java", "diffHunk": "@@ -118,10 +119,12 @@ public Void call() throws Exception {\n         CheckTableResult checkTableResult = new CheckTableResult();\n         Map<String, List<String>> errors = new TreeMap<>();\n \n+        int[] baseColumnMap = getBaseColumnMap(tentativeIndexList);", "originalCommit": "88b37a1300bf09be424eb5c565c5846473519262", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1MjMyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3376#discussion_r405052320", "bodyText": "Should we return here? I thought we only want to suppress the messages in the report, but we want to continue to remove the invalidate indexes. If we want to stop fixing indexes when it reaches maxCheckTableErrors, maybe we should return in the result an explicit message that not all indexes have been fixed.", "author": "yxia92", "createdAt": "2020-04-07T19:17:15Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/control/ControlTableChecker.java", "diffHunk": "@@ -167,57 +188,150 @@ private void populateData(PairDataSet table, PairDataSet index) {\n             }\n         }\n \n-        int i = 0;\n         if (invalidIndexCount > 0) {\n-            messages.add(String.format(\"The following %d indexes are invalid:\", invalidIndexCount));\n+            if (fix) {\n+                return fixInvalidIndexes(result);\n+            } else {\n+                return reportInvalidIndexes(result);\n+            }\n+        }\n+        return new LinkedList<>();\n+    }\n+\n+    private List<String> reportInvalidIndexes(ArrayListMultimap<String, byte[]> result) throws StandardException {\n+        List<String> messages = new LinkedList<>();\n+        int i = 0;\n+        messages.add(String.format(\"The following %d indexes are invalid:\", invalidIndexCount));\n+        for (String baseRowId : result.keySet()) {\n+            List<byte[]> keys = result.get(baseRowId);\n+            for (byte[] key : keys) {\n+                if (i >= maxCheckTableErrors) {\n+                    messages.add(\"...\");\n+                    return messages;\n+                }\n+                indexKeyDecoder.set(key, 0, key.length);\n+                indexKeyDecoder.decode(indexKeyTemplate);\n+                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + baseRowId);\n+                i++;\n+            }\n+        }\n+        return  messages;\n+    }\n+\n+\n+    private List<String> fixInvalidIndexes(ArrayListMultimap<String, byte[]> result) throws StandardException {\n+        try {\n+            WriteCoordinator writeCoordinator = PipelineDriver.driver().writeCoordinator();\n+            WriteConfiguration writeConfiguration = writeCoordinator.defaultWriteConfiguration();\n+            Partition indexPartition = SIDriver.driver().getTableFactory().getTable(Long.toString(conglomerate));\n+            RecordingCallBuffer<KVPair> writeBuffer = writeCoordinator.writeBuffer(indexPartition, txn, null, writeConfiguration);\n+\n+            List<String> messages = new LinkedList<>();\n+            int i = 0;\n+            messages.add(String.format(\"The following %d indexes are deleted:\", invalidIndexCount));\n             for (String baseRowId : result.keySet()) {\n                 List<byte[]> keys = result.get(baseRowId);\n                 for (byte[] key : keys) {\n-                    if (i >= maxCheckTableErrors) {\n+                    if (i == maxCheckTableErrors) {\n                         messages.add(\"...\");\n                         return messages;", "originalCommit": "88b37a1300bf09be424eb5c565c5846473519262", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1NTg0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3376#discussion_r405055840", "bodyText": "Same question here, should we break out here without fixing the remaining rows?", "author": "yxia92", "createdAt": "2020-04-07T19:23:25Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/control/ControlTableChecker.java", "diffHunk": "@@ -167,57 +188,150 @@ private void populateData(PairDataSet table, PairDataSet index) {\n             }\n         }\n \n-        int i = 0;\n         if (invalidIndexCount > 0) {\n-            messages.add(String.format(\"The following %d indexes are invalid:\", invalidIndexCount));\n+            if (fix) {\n+                return fixInvalidIndexes(result);\n+            } else {\n+                return reportInvalidIndexes(result);\n+            }\n+        }\n+        return new LinkedList<>();\n+    }\n+\n+    private List<String> reportInvalidIndexes(ArrayListMultimap<String, byte[]> result) throws StandardException {\n+        List<String> messages = new LinkedList<>();\n+        int i = 0;\n+        messages.add(String.format(\"The following %d indexes are invalid:\", invalidIndexCount));\n+        for (String baseRowId : result.keySet()) {\n+            List<byte[]> keys = result.get(baseRowId);\n+            for (byte[] key : keys) {\n+                if (i >= maxCheckTableErrors) {\n+                    messages.add(\"...\");\n+                    return messages;\n+                }\n+                indexKeyDecoder.set(key, 0, key.length);\n+                indexKeyDecoder.decode(indexKeyTemplate);\n+                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + baseRowId);\n+                i++;\n+            }\n+        }\n+        return  messages;\n+    }\n+\n+\n+    private List<String> fixInvalidIndexes(ArrayListMultimap<String, byte[]> result) throws StandardException {\n+        try {\n+            WriteCoordinator writeCoordinator = PipelineDriver.driver().writeCoordinator();\n+            WriteConfiguration writeConfiguration = writeCoordinator.defaultWriteConfiguration();\n+            Partition indexPartition = SIDriver.driver().getTableFactory().getTable(Long.toString(conglomerate));\n+            RecordingCallBuffer<KVPair> writeBuffer = writeCoordinator.writeBuffer(indexPartition, txn, null, writeConfiguration);\n+\n+            List<String> messages = new LinkedList<>();\n+            int i = 0;\n+            messages.add(String.format(\"The following %d indexes are deleted:\", invalidIndexCount));\n             for (String baseRowId : result.keySet()) {\n                 List<byte[]> keys = result.get(baseRowId);\n                 for (byte[] key : keys) {\n-                    if (i >= maxCheckTableErrors) {\n+                    if (i == maxCheckTableErrors) {\n                         messages.add(\"...\");\n                         return messages;\n                     }\n+                    writeBuffer.add(new KVPair(key, new byte[0], KVPair.Type.DELETE));\n+                    if (i > maxCheckTableErrors) {\n+                        continue;\n+                    }\n                     indexKeyDecoder.set(key, 0, key.length);\n                     indexKeyDecoder.decode(indexKeyTemplate);\n                     messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + baseRowId);\n                     i++;\n                 }\n             }\n+            writeBuffer.flushBuffer();\n+            return messages;\n+        }\n+        catch (Exception e) {\n+            throw StandardException.plainWrapException(e);\n         }\n-        return  messages;\n     }\n \n     private List<String> checkMissingIndexes() throws StandardException {\n         List<String> messages = new LinkedList<>();\n         missingIndexCount = 0;\n-        Map<String, byte[]> result = new HashMap<>();\n+        Map<String, ExecRow> result = new HashMap<>();\n         for (String rowId : tableData.keySet()) {\n             if (!indexData.containsKey(rowId)) {\n                 missingIndexCount++;\n                 result.put(rowId, tableData.get(rowId));\n             }\n         }\n+        if (missingIndexCount > 0) {\n+            if (fix) {\n+                return fixMissingIndexes(result);\n+            } else {\n+                return reportMissingIndexes(result);\n+            }\n+        }\n+        return new LinkedList<>();\n+    }\n+\n+    private List<String> fixMissingIndexes(Map<String, ExecRow> result) throws StandardException {\n+        List<String> messages = new LinkedList<>();\n+\n+        DataSet<ExecRow> dataSet = new ControlDataSet<>(result.values().iterator());\n+        PairDataSet dsToWrite = dataSet\n+                .map(new IndexTransformFunction(tentativeIndex), null, false, true, \"Prepare Index\")\n+                .index(new KVPairFunction(), false, true, \"Add missing indexes\");\n+        DataSetWriter writer = dsToWrite.directWriteData()\n+                .destConglomerate(tentativeIndex.getIndex().getConglomerate())\n+                .txn(txn)\n+                .build();\n+        writer.write();\n \n         int i = 0;\n-        if (missingIndexCount > 0) {\n-            messages.add(String.format(\"The following %d rows from base table %s.%s are not indexed:\", result.size(), schemaName, tableName));\n-            for (Map.Entry<String, byte[]> entry : result.entrySet()) {\n-                if (i >= maxCheckTableErrors) {\n-                    messages.add(\"...\");\n-                    break;\n-                }\n-                byte[] key = entry.getValue();\n-                if (tableKeyTemplate.nColumns() > 0) {\n-                    tableKeyDecoder.set(key, 0, key.length);\n-                    tableKeyDecoder.decode(tableKeyTemplate);\n-                    messages.add(tableKeyTemplate.getClone().toString());\n-                }\n-                else {\n-                    messages.add(entry.getKey());\n-                }\n-                i++;\n+        messages.add(String.format(\"Create index for the following %d rows from base table %s.%s:\", result.size(), schemaName, tableName));\n+        for (Map.Entry<String, ExecRow> entry : result.entrySet()) {\n+            if (i >= maxCheckTableErrors) {\n+                messages.add(\"...\");\n+                break;", "originalCommit": "88b37a1300bf09be424eb5c565c5846473519262", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1ODU2OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3376#discussion_r405058568", "bodyText": "If we stop at the maxCheckTableErrors, why we have this check here?", "author": "yxia92", "createdAt": "2020-04-07T19:28:15Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/control/ControlTableChecker.java", "diffHunk": "@@ -167,57 +188,150 @@ private void populateData(PairDataSet table, PairDataSet index) {\n             }\n         }\n \n-        int i = 0;\n         if (invalidIndexCount > 0) {\n-            messages.add(String.format(\"The following %d indexes are invalid:\", invalidIndexCount));\n+            if (fix) {\n+                return fixInvalidIndexes(result);\n+            } else {\n+                return reportInvalidIndexes(result);\n+            }\n+        }\n+        return new LinkedList<>();\n+    }\n+\n+    private List<String> reportInvalidIndexes(ArrayListMultimap<String, byte[]> result) throws StandardException {\n+        List<String> messages = new LinkedList<>();\n+        int i = 0;\n+        messages.add(String.format(\"The following %d indexes are invalid:\", invalidIndexCount));\n+        for (String baseRowId : result.keySet()) {\n+            List<byte[]> keys = result.get(baseRowId);\n+            for (byte[] key : keys) {\n+                if (i >= maxCheckTableErrors) {\n+                    messages.add(\"...\");\n+                    return messages;\n+                }\n+                indexKeyDecoder.set(key, 0, key.length);\n+                indexKeyDecoder.decode(indexKeyTemplate);\n+                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + baseRowId);\n+                i++;\n+            }\n+        }\n+        return  messages;\n+    }\n+\n+\n+    private List<String> fixInvalidIndexes(ArrayListMultimap<String, byte[]> result) throws StandardException {\n+        try {\n+            WriteCoordinator writeCoordinator = PipelineDriver.driver().writeCoordinator();\n+            WriteConfiguration writeConfiguration = writeCoordinator.defaultWriteConfiguration();\n+            Partition indexPartition = SIDriver.driver().getTableFactory().getTable(Long.toString(conglomerate));\n+            RecordingCallBuffer<KVPair> writeBuffer = writeCoordinator.writeBuffer(indexPartition, txn, null, writeConfiguration);\n+\n+            List<String> messages = new LinkedList<>();\n+            int i = 0;\n+            messages.add(String.format(\"The following %d indexes are deleted:\", invalidIndexCount));\n             for (String baseRowId : result.keySet()) {\n                 List<byte[]> keys = result.get(baseRowId);\n                 for (byte[] key : keys) {\n-                    if (i >= maxCheckTableErrors) {\n+                    if (i == maxCheckTableErrors) {\n                         messages.add(\"...\");\n                         return messages;\n                     }\n+                    writeBuffer.add(new KVPair(key, new byte[0], KVPair.Type.DELETE));\n+                    if (i > maxCheckTableErrors) {", "originalCommit": "88b37a1300bf09be424eb5c565c5846473519262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1ODExMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3376#discussion_r405158113", "bodyText": "Let me restructure the code to make it more readable.", "author": "jyuanca", "createdAt": "2020-04-07T22:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1ODU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NDU4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3376#discussion_r405084588", "bodyText": "For checkDuplicateIndexes(), shouldn't we also handle the fix=true path, and remove duplicate indexes?", "author": "yxia92", "createdAt": "2020-04-07T20:15:35Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/control/ControlTableChecker.java", "diffHunk": "@@ -157,7 +178,7 @@ private void populateData(PairDataSet table, PairDataSet index) {\n \n     private List<String> checkInvalidIndexes() throws StandardException {", "originalCommit": "88b37a1300bf09be424eb5c565c5846473519262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1Nzk0Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3376#discussion_r405157942", "bodyText": "This does not happen for system tables. I'll file another Jira( DB-9361) to address this issue.", "author": "jyuanca", "createdAt": "2020-04-07T22:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NDU4OA=="}], "type": "inlineReview"}, {"oid": "507adaf87711048dc276f975f02dba50a702bf40", "url": "https://github.com/splicemachine/spliceengine/commit/507adaf87711048dc276f975f02dba50a702bf40", "message": "address review comments", "committedDate": "2020-04-07T23:07:02Z", "type": "commit"}]}